webpackJsonp([1],{

/***/ 131:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar platform_browser_dynamic_1 = __webpack_require__(132);\r\nvar app_module_1 = __webpack_require__(153);\r\nplatform_browser_dynamic_1.platformBrowserDynamic().bootstrapModule(app_module_1.AppModule);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL21haW4udHM/MDM0YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljJztcblxuaW1wb3J0IHsgQXBwTW9kdWxlIH0gZnJvbSAnLi9hcHAvYXBwLm1vZHVsZSc7XG5cbnBsYXRmb3JtQnJvd3NlckR5bmFtaWMoKS5ib290c3RyYXBNb2R1bGUoQXBwTW9kdWxlKTtcblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9hbmd1bGFyLXJvdXRlci1sb2FkZXIvc3JjIS4vbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwLWxvYWRlciEuL25vZGVfbW9kdWxlcy90c2xpbnQtbG9hZGVyIS4vc3JjL21haW4udHMiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFFQTtBQUVBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///131\n");

/***/ }),

/***/ 132:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n\n// CONCATENATED MODULE: ./node_modules/@angular/compiler/@angular/compiler.es5.js\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(40);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(9);\n\n/**\n * @license Angular v4.3.3\n * (c) 2010-2017 Google, Inc. https://angular.io/\n * License: MIT\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @module\n * @description\n * Entry point for all public APIs of the common package.\n */\n/**\n * \\@stable\n */\nvar VERSION = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Version\"]('4.3.3');\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A segment of text within the template.\n */\nvar TextAst = (function () {\n    /**\n     * @param {?} value\n     * @param {?} ngContentIndex\n     * @param {?} sourceSpan\n     */\n    function TextAst(value, ngContentIndex, sourceSpan) {\n        this.value = value;\n        this.ngContentIndex = ngContentIndex;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    TextAst.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };\n    return TextAst;\n}());\n/**\n * A bound expression within the text of a template.\n */\nvar BoundTextAst = (function () {\n    /**\n     * @param {?} value\n     * @param {?} ngContentIndex\n     * @param {?} sourceSpan\n     */\n    function BoundTextAst(value, ngContentIndex, sourceSpan) {\n        this.value = value;\n        this.ngContentIndex = ngContentIndex;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    BoundTextAst.prototype.visit = function (visitor, context) {\n        return visitor.visitBoundText(this, context);\n    };\n    return BoundTextAst;\n}());\n/**\n * A plain attribute on an element.\n */\nvar AttrAst = (function () {\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    function AttrAst(name, value, sourceSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    AttrAst.prototype.visit = function (visitor, context) { return visitor.visitAttr(this, context); };\n    return AttrAst;\n}());\n/**\n * A binding for an element property (e.g. `[property]=\"expression\"`) or an animation trigger (e.g.\n * `[\\@trigger]=\"stateExp\"`)\n */\nvar BoundElementPropertyAst = (function () {\n    /**\n     * @param {?} name\n     * @param {?} type\n     * @param {?} securityContext\n     * @param {?} value\n     * @param {?} unit\n     * @param {?} sourceSpan\n     */\n    function BoundElementPropertyAst(name, type, securityContext, value, unit, sourceSpan) {\n        this.name = name;\n        this.type = type;\n        this.securityContext = securityContext;\n        this.value = value;\n        this.unit = unit;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    BoundElementPropertyAst.prototype.visit = function (visitor, context) {\n        return visitor.visitElementProperty(this, context);\n    };\n    Object.defineProperty(BoundElementPropertyAst.prototype, \"isAnimation\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this.type === PropertyBindingType.Animation; },\n        enumerable: true,\n        configurable: true\n    });\n    return BoundElementPropertyAst;\n}());\n/**\n * A binding for an element event (e.g. `(event)=\"handler()\"`) or an animation trigger event (e.g.\n * `(\\@trigger.phase)=\"callback($event)\"`).\n */\nvar BoundEventAst = (function () {\n    /**\n     * @param {?} name\n     * @param {?} target\n     * @param {?} phase\n     * @param {?} handler\n     * @param {?} sourceSpan\n     */\n    function BoundEventAst(name, target, phase, handler, sourceSpan) {\n        this.name = name;\n        this.target = target;\n        this.phase = phase;\n        this.handler = handler;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} name\n     * @param {?} target\n     * @param {?} phase\n     * @return {?}\n     */\n    BoundEventAst.calcFullName = function (name, target, phase) {\n        if (target) {\n            return target + \":\" + name;\n        }\n        else if (phase) {\n            return \"@\" + name + \".\" + phase;\n        }\n        else {\n            return name;\n        }\n    };\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    BoundEventAst.prototype.visit = function (visitor, context) {\n        return visitor.visitEvent(this, context);\n    };\n    Object.defineProperty(BoundEventAst.prototype, \"fullName\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return BoundEventAst.calcFullName(this.name, this.target, this.phase); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BoundEventAst.prototype, \"isAnimation\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return !!this.phase; },\n        enumerable: true,\n        configurable: true\n    });\n    return BoundEventAst;\n}());\n/**\n * A reference declaration on an element (e.g. `let someName=\"expression\"`).\n */\nvar ReferenceAst = (function () {\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    function ReferenceAst(name, value, sourceSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ReferenceAst.prototype.visit = function (visitor, context) {\n        return visitor.visitReference(this, context);\n    };\n    return ReferenceAst;\n}());\n/**\n * A variable declaration on a <ng-template> (e.g. `var-someName=\"someLocalName\"`).\n */\nvar VariableAst = (function () {\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    function VariableAst(name, value, sourceSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    VariableAst.prototype.visit = function (visitor, context) {\n        return visitor.visitVariable(this, context);\n    };\n    return VariableAst;\n}());\n/**\n * An element declaration in a template.\n */\nvar ElementAst = (function () {\n    /**\n     * @param {?} name\n     * @param {?} attrs\n     * @param {?} inputs\n     * @param {?} outputs\n     * @param {?} references\n     * @param {?} directives\n     * @param {?} providers\n     * @param {?} hasViewContainer\n     * @param {?} queryMatches\n     * @param {?} children\n     * @param {?} ngContentIndex\n     * @param {?} sourceSpan\n     * @param {?} endSourceSpan\n     */\n    function ElementAst(name, attrs, inputs, outputs, references, directives, providers, hasViewContainer, queryMatches, children, ngContentIndex, sourceSpan, endSourceSpan) {\n        this.name = name;\n        this.attrs = attrs;\n        this.inputs = inputs;\n        this.outputs = outputs;\n        this.references = references;\n        this.directives = directives;\n        this.providers = providers;\n        this.hasViewContainer = hasViewContainer;\n        this.queryMatches = queryMatches;\n        this.children = children;\n        this.ngContentIndex = ngContentIndex;\n        this.sourceSpan = sourceSpan;\n        this.endSourceSpan = endSourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ElementAst.prototype.visit = function (visitor, context) {\n        return visitor.visitElement(this, context);\n    };\n    return ElementAst;\n}());\n/**\n * A `<ng-template>` element included in an Angular template.\n */\nvar EmbeddedTemplateAst = (function () {\n    /**\n     * @param {?} attrs\n     * @param {?} outputs\n     * @param {?} references\n     * @param {?} variables\n     * @param {?} directives\n     * @param {?} providers\n     * @param {?} hasViewContainer\n     * @param {?} queryMatches\n     * @param {?} children\n     * @param {?} ngContentIndex\n     * @param {?} sourceSpan\n     */\n    function EmbeddedTemplateAst(attrs, outputs, references, variables, directives, providers, hasViewContainer, queryMatches, children, ngContentIndex, sourceSpan) {\n        this.attrs = attrs;\n        this.outputs = outputs;\n        this.references = references;\n        this.variables = variables;\n        this.directives = directives;\n        this.providers = providers;\n        this.hasViewContainer = hasViewContainer;\n        this.queryMatches = queryMatches;\n        this.children = children;\n        this.ngContentIndex = ngContentIndex;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    EmbeddedTemplateAst.prototype.visit = function (visitor, context) {\n        return visitor.visitEmbeddedTemplate(this, context);\n    };\n    return EmbeddedTemplateAst;\n}());\n/**\n * A directive property with a bound value (e.g. `*ngIf=\"condition\").\n */\nvar BoundDirectivePropertyAst = (function () {\n    /**\n     * @param {?} directiveName\n     * @param {?} templateName\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    function BoundDirectivePropertyAst(directiveName, templateName, value, sourceSpan) {\n        this.directiveName = directiveName;\n        this.templateName = templateName;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    BoundDirectivePropertyAst.prototype.visit = function (visitor, context) {\n        return visitor.visitDirectiveProperty(this, context);\n    };\n    return BoundDirectivePropertyAst;\n}());\n/**\n * A directive declared on an element.\n */\nvar DirectiveAst = (function () {\n    /**\n     * @param {?} directive\n     * @param {?} inputs\n     * @param {?} hostProperties\n     * @param {?} hostEvents\n     * @param {?} contentQueryStartId\n     * @param {?} sourceSpan\n     */\n    function DirectiveAst(directive, inputs, hostProperties, hostEvents, contentQueryStartId, sourceSpan) {\n        this.directive = directive;\n        this.inputs = inputs;\n        this.hostProperties = hostProperties;\n        this.hostEvents = hostEvents;\n        this.contentQueryStartId = contentQueryStartId;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    DirectiveAst.prototype.visit = function (visitor, context) {\n        return visitor.visitDirective(this, context);\n    };\n    return DirectiveAst;\n}());\n/**\n * A provider declared on an element\n */\nvar ProviderAst = (function () {\n    /**\n     * @param {?} token\n     * @param {?} multiProvider\n     * @param {?} eager\n     * @param {?} providers\n     * @param {?} providerType\n     * @param {?} lifecycleHooks\n     * @param {?} sourceSpan\n     */\n    function ProviderAst(token, multiProvider, eager, providers, providerType, lifecycleHooks, sourceSpan) {\n        this.token = token;\n        this.multiProvider = multiProvider;\n        this.eager = eager;\n        this.providers = providers;\n        this.providerType = providerType;\n        this.lifecycleHooks = lifecycleHooks;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ProviderAst.prototype.visit = function (visitor, context) {\n        // No visit method in the visitor for now...\n        return null;\n    };\n    return ProviderAst;\n}());\nvar ProviderAstType = {};\nProviderAstType.PublicService = 0;\nProviderAstType.PrivateService = 1;\nProviderAstType.Component = 2;\nProviderAstType.Directive = 3;\nProviderAstType.Builtin = 4;\nProviderAstType[ProviderAstType.PublicService] = \"PublicService\";\nProviderAstType[ProviderAstType.PrivateService] = \"PrivateService\";\nProviderAstType[ProviderAstType.Component] = \"Component\";\nProviderAstType[ProviderAstType.Directive] = \"Directive\";\nProviderAstType[ProviderAstType.Builtin] = \"Builtin\";\n/**\n * Position where content is to be projected (instance of `<ng-content>` in a template).\n */\nvar NgContentAst = (function () {\n    /**\n     * @param {?} index\n     * @param {?} ngContentIndex\n     * @param {?} sourceSpan\n     */\n    function NgContentAst(index, ngContentIndex, sourceSpan) {\n        this.index = index;\n        this.ngContentIndex = ngContentIndex;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    NgContentAst.prototype.visit = function (visitor, context) {\n        return visitor.visitNgContent(this, context);\n    };\n    return NgContentAst;\n}());\nvar PropertyBindingType = {};\nPropertyBindingType.Property = 0;\nPropertyBindingType.Attribute = 1;\nPropertyBindingType.Class = 2;\nPropertyBindingType.Style = 3;\nPropertyBindingType.Animation = 4;\nPropertyBindingType[PropertyBindingType.Property] = \"Property\";\nPropertyBindingType[PropertyBindingType.Attribute] = \"Attribute\";\nPropertyBindingType[PropertyBindingType.Class] = \"Class\";\nPropertyBindingType[PropertyBindingType.Style] = \"Style\";\nPropertyBindingType[PropertyBindingType.Animation] = \"Animation\";\n/**\n * A visitor that accepts each node but doesn't do anything. It is intended to be used\n * as the base class for a visitor that is only interested in a subset of the node types.\n */\nvar NullTemplateVisitor = (function () {\n    function NullTemplateVisitor() {\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    NullTemplateVisitor.prototype.visitNgContent = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    NullTemplateVisitor.prototype.visitEmbeddedTemplate = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    NullTemplateVisitor.prototype.visitElement = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    NullTemplateVisitor.prototype.visitReference = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    NullTemplateVisitor.prototype.visitVariable = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    NullTemplateVisitor.prototype.visitEvent = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    NullTemplateVisitor.prototype.visitElementProperty = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    NullTemplateVisitor.prototype.visitAttr = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    NullTemplateVisitor.prototype.visitBoundText = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    NullTemplateVisitor.prototype.visitText = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    NullTemplateVisitor.prototype.visitDirective = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    NullTemplateVisitor.prototype.visitDirectiveProperty = function (ast, context) { };\n    return NullTemplateVisitor;\n}());\n/**\n * Base class that can be used to build a visitor that visits each node\n * in an template ast recursively.\n */\nvar RecursiveTemplateAstVisitor = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](RecursiveTemplateAstVisitor, _super);\n    function RecursiveTemplateAstVisitor() {\n        return _super.call(this) || this;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveTemplateAstVisitor.prototype.visitEmbeddedTemplate = function (ast, context) {\n        return this.visitChildren(context, function (visit) {\n            visit(ast.attrs);\n            visit(ast.references);\n            visit(ast.variables);\n            visit(ast.directives);\n            visit(ast.providers);\n            visit(ast.children);\n        });\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveTemplateAstVisitor.prototype.visitElement = function (ast, context) {\n        return this.visitChildren(context, function (visit) {\n            visit(ast.attrs);\n            visit(ast.inputs);\n            visit(ast.outputs);\n            visit(ast.references);\n            visit(ast.directives);\n            visit(ast.providers);\n            visit(ast.children);\n        });\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveTemplateAstVisitor.prototype.visitDirective = function (ast, context) {\n        return this.visitChildren(context, function (visit) {\n            visit(ast.inputs);\n            visit(ast.hostProperties);\n            visit(ast.hostEvents);\n        });\n    };\n    /**\n     * @template T\n     * @param {?} context\n     * @param {?} cb\n     * @return {?}\n     */\n    RecursiveTemplateAstVisitor.prototype.visitChildren = function (context, cb) {\n        var /** @type {?} */ results = [];\n        var /** @type {?} */ t = this;\n        /**\n         * @template T\n         * @param {?} children\n         * @return {?}\n         */\n        function visit(children) {\n            if (children && children.length)\n                results.push(templateVisitAll(t, children, context));\n        }\n        cb(visit);\n        return [].concat.apply([], results);\n    };\n    return RecursiveTemplateAstVisitor;\n}(NullTemplateVisitor));\n/**\n * Visit every node in a list of {\\@link TemplateAst}s with the given {\\@link TemplateAstVisitor}.\n * @param {?} visitor\n * @param {?} asts\n * @param {?=} context\n * @return {?}\n */\nfunction templateVisitAll(visitor, asts, context) {\n    if (context === void 0) { context = null; }\n    var /** @type {?} */ result = [];\n    var /** @type {?} */ visit = visitor.visit ?\n        function (ast) { return ((visitor.visit))(ast, context) || ast.visit(visitor, context); } :\n        function (ast) { return ast.visit(visitor, context); };\n    asts.forEach(function (ast) {\n        var /** @type {?} */ astResult = visit(ast);\n        if (astResult) {\n            result.push(astResult);\n        }\n    });\n    return result;\n}\n/**\n * A token representing the a reference to a static type.\n *\n * This token is unique for a filePath and name and can be used as a hash table key.\n */\nvar StaticSymbol = (function () {\n    /**\n     * @param {?} filePath\n     * @param {?} name\n     * @param {?} members\n     */\n    function StaticSymbol(filePath, name, members) {\n        this.filePath = filePath;\n        this.name = name;\n        this.members = members;\n    }\n    /**\n     * @return {?}\n     */\n    StaticSymbol.prototype.assertNoMembers = function () {\n        if (this.members.length) {\n            throw new Error(\"Illegal state: symbol without members expected, but got \" + JSON.stringify(this) + \".\");\n        }\n    };\n    return StaticSymbol;\n}());\n/**\n * A cache of static symbol used by the StaticReflector to return the same symbol for the\n * same symbol values.\n */\nvar StaticSymbolCache = (function () {\n    function StaticSymbolCache() {\n        this.cache = new Map();\n    }\n    /**\n     * @param {?} declarationFile\n     * @param {?} name\n     * @param {?=} members\n     * @return {?}\n     */\n    StaticSymbolCache.prototype.get = function (declarationFile, name, members) {\n        members = members || [];\n        var /** @type {?} */ memberSuffix = members.length ? \".\" + members.join('.') : '';\n        var /** @type {?} */ key = \"\\\"\" + declarationFile + \"\\\".\" + name + memberSuffix;\n        var /** @type {?} */ result = this.cache.get(key);\n        if (!result) {\n            result = new StaticSymbol(declarationFile, name, members);\n            this.cache.set(key, result);\n        }\n        return result;\n    };\n    return StaticSymbolCache;\n}());\nvar TagContentType = {};\nTagContentType.RAW_TEXT = 0;\nTagContentType.ESCAPABLE_RAW_TEXT = 1;\nTagContentType.PARSABLE_DATA = 2;\nTagContentType[TagContentType.RAW_TEXT] = \"RAW_TEXT\";\nTagContentType[TagContentType.ESCAPABLE_RAW_TEXT] = \"ESCAPABLE_RAW_TEXT\";\nTagContentType[TagContentType.PARSABLE_DATA] = \"PARSABLE_DATA\";\n/**\n * @param {?} elementName\n * @return {?}\n */\nfunction splitNsName(elementName) {\n    if (elementName[0] != ':') {\n        return [null, elementName];\n    }\n    var /** @type {?} */ colonIndex = elementName.indexOf(':', 1);\n    if (colonIndex == -1) {\n        throw new Error(\"Unsupported format \\\"\" + elementName + \"\\\" expecting \\\":namespace:name\\\"\");\n    }\n    return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];\n}\n/**\n * @param {?} tagName\n * @return {?}\n */\nfunction isNgContainer(tagName) {\n    return splitNsName(tagName)[1] === 'ng-container';\n}\n/**\n * @param {?} tagName\n * @return {?}\n */\nfunction isNgContent(tagName) {\n    return splitNsName(tagName)[1] === 'ng-content';\n}\n/**\n * @param {?} tagName\n * @return {?}\n */\nfunction isNgTemplate(tagName) {\n    return splitNsName(tagName)[1] === 'ng-template';\n}\n/**\n * @param {?} fullName\n * @return {?}\n */\nfunction getNsPrefix(fullName) {\n    return fullName === null ? null : splitNsName(fullName)[0];\n}\n/**\n * @param {?} prefix\n * @param {?} localName\n * @return {?}\n */\nfunction mergeNsAndName(prefix, localName) {\n    return prefix ? \":\" + prefix + \":\" + localName : localName;\n}\n// see http://www.w3.org/TR/html51/syntax.html#named-character-references\n// see https://html.spec.whatwg.org/multipage/entities.json\n// This list is not exhaustive to keep the compiler footprint low.\n// The `&#123;` / `&#x1ab;` syntax should be used when the named character reference does not\n// exist.\nvar NAMED_ENTITIES = {\n    'Aacute': '\\u00C1',\n    'aacute': '\\u00E1',\n    'Acirc': '\\u00C2',\n    'acirc': '\\u00E2',\n    'acute': '\\u00B4',\n    'AElig': '\\u00C6',\n    'aelig': '\\u00E6',\n    'Agrave': '\\u00C0',\n    'agrave': '\\u00E0',\n    'alefsym': '\\u2135',\n    'Alpha': '\\u0391',\n    'alpha': '\\u03B1',\n    'amp': '&',\n    'and': '\\u2227',\n    'ang': '\\u2220',\n    'apos': '\\u0027',\n    'Aring': '\\u00C5',\n    'aring': '\\u00E5',\n    'asymp': '\\u2248',\n    'Atilde': '\\u00C3',\n    'atilde': '\\u00E3',\n    'Auml': '\\u00C4',\n    'auml': '\\u00E4',\n    'bdquo': '\\u201E',\n    'Beta': '\\u0392',\n    'beta': '\\u03B2',\n    'brvbar': '\\u00A6',\n    'bull': '\\u2022',\n    'cap': '\\u2229',\n    'Ccedil': '\\u00C7',\n    'ccedil': '\\u00E7',\n    'cedil': '\\u00B8',\n    'cent': '\\u00A2',\n    'Chi': '\\u03A7',\n    'chi': '\\u03C7',\n    'circ': '\\u02C6',\n    'clubs': '\\u2663',\n    'cong': '\\u2245',\n    'copy': '\\u00A9',\n    'crarr': '\\u21B5',\n    'cup': '\\u222A',\n    'curren': '\\u00A4',\n    'dagger': '\\u2020',\n    'Dagger': '\\u2021',\n    'darr': '\\u2193',\n    'dArr': '\\u21D3',\n    'deg': '\\u00B0',\n    'Delta': '\\u0394',\n    'delta': '\\u03B4',\n    'diams': '\\u2666',\n    'divide': '\\u00F7',\n    'Eacute': '\\u00C9',\n    'eacute': '\\u00E9',\n    'Ecirc': '\\u00CA',\n    'ecirc': '\\u00EA',\n    'Egrave': '\\u00C8',\n    'egrave': '\\u00E8',\n    'empty': '\\u2205',\n    'emsp': '\\u2003',\n    'ensp': '\\u2002',\n    'Epsilon': '\\u0395',\n    'epsilon': '\\u03B5',\n    'equiv': '\\u2261',\n    'Eta': '\\u0397',\n    'eta': '\\u03B7',\n    'ETH': '\\u00D0',\n    'eth': '\\u00F0',\n    'Euml': '\\u00CB',\n    'euml': '\\u00EB',\n    'euro': '\\u20AC',\n    'exist': '\\u2203',\n    'fnof': '\\u0192',\n    'forall': '\\u2200',\n    'frac12': '\\u00BD',\n    'frac14': '\\u00BC',\n    'frac34': '\\u00BE',\n    'frasl': '\\u2044',\n    'Gamma': '\\u0393',\n    'gamma': '\\u03B3',\n    'ge': '\\u2265',\n    'gt': '>',\n    'harr': '\\u2194',\n    'hArr': '\\u21D4',\n    'hearts': '\\u2665',\n    'hellip': '\\u2026',\n    'Iacute': '\\u00CD',\n    'iacute': '\\u00ED',\n    'Icirc': '\\u00CE',\n    'icirc': '\\u00EE',\n    'iexcl': '\\u00A1',\n    'Igrave': '\\u00CC',\n    'igrave': '\\u00EC',\n    'image': '\\u2111',\n    'infin': '\\u221E',\n    'int': '\\u222B',\n    'Iota': '\\u0399',\n    'iota': '\\u03B9',\n    'iquest': '\\u00BF',\n    'isin': '\\u2208',\n    'Iuml': '\\u00CF',\n    'iuml': '\\u00EF',\n    'Kappa': '\\u039A',\n    'kappa': '\\u03BA',\n    'Lambda': '\\u039B',\n    'lambda': '\\u03BB',\n    'lang': '\\u27E8',\n    'laquo': '\\u00AB',\n    'larr': '\\u2190',\n    'lArr': '\\u21D0',\n    'lceil': '\\u2308',\n    'ldquo': '\\u201C',\n    'le': '\\u2264',\n    'lfloor': '\\u230A',\n    'lowast': '\\u2217',\n    'loz': '\\u25CA',\n    'lrm': '\\u200E',\n    'lsaquo': '\\u2039',\n    'lsquo': '\\u2018',\n    'lt': '<',\n    'macr': '\\u00AF',\n    'mdash': '\\u2014',\n    'micro': '\\u00B5',\n    'middot': '\\u00B7',\n    'minus': '\\u2212',\n    'Mu': '\\u039C',\n    'mu': '\\u03BC',\n    'nabla': '\\u2207',\n    'nbsp': '\\u00A0',\n    'ndash': '\\u2013',\n    'ne': '\\u2260',\n    'ni': '\\u220B',\n    'not': '\\u00AC',\n    'notin': '\\u2209',\n    'nsub': '\\u2284',\n    'Ntilde': '\\u00D1',\n    'ntilde': '\\u00F1',\n    'Nu': '\\u039D',\n    'nu': '\\u03BD',\n    'Oacute': '\\u00D3',\n    'oacute': '\\u00F3',\n    'Ocirc': '\\u00D4',\n    'ocirc': '\\u00F4',\n    'OElig': '\\u0152',\n    'oelig': '\\u0153',\n    'Ograve': '\\u00D2',\n    'ograve': '\\u00F2',\n    'oline': '\\u203E',\n    'Omega': '\\u03A9',\n    'omega': '\\u03C9',\n    'Omicron': '\\u039F',\n    'omicron': '\\u03BF',\n    'oplus': '\\u2295',\n    'or': '\\u2228',\n    'ordf': '\\u00AA',\n    'ordm': '\\u00BA',\n    'Oslash': '\\u00D8',\n    'oslash': '\\u00F8',\n    'Otilde': '\\u00D5',\n    'otilde': '\\u00F5',\n    'otimes': '\\u2297',\n    'Ouml': '\\u00D6',\n    'ouml': '\\u00F6',\n    'para': '\\u00B6',\n    'permil': '\\u2030',\n    'perp': '\\u22A5',\n    'Phi': '\\u03A6',\n    'phi': '\\u03C6',\n    'Pi': '\\u03A0',\n    'pi': '\\u03C0',\n    'piv': '\\u03D6',\n    'plusmn': '\\u00B1',\n    'pound': '\\u00A3',\n    'prime': '\\u2032',\n    'Prime': '\\u2033',\n    'prod': '\\u220F',\n    'prop': '\\u221D',\n    'Psi': '\\u03A8',\n    'psi': '\\u03C8',\n    'quot': '\\u0022',\n    'radic': '\\u221A',\n    'rang': '\\u27E9',\n    'raquo': '\\u00BB',\n    'rarr': '\\u2192',\n    'rArr': '\\u21D2',\n    'rceil': '\\u2309',\n    'rdquo': '\\u201D',\n    'real': '\\u211C',\n    'reg': '\\u00AE',\n    'rfloor': '\\u230B',\n    'Rho': '\\u03A1',\n    'rho': '\\u03C1',\n    'rlm': '\\u200F',\n    'rsaquo': '\\u203A',\n    'rsquo': '\\u2019',\n    'sbquo': '\\u201A',\n    'Scaron': '\\u0160',\n    'scaron': '\\u0161',\n    'sdot': '\\u22C5',\n    'sect': '\\u00A7',\n    'shy': '\\u00AD',\n    'Sigma': '\\u03A3',\n    'sigma': '\\u03C3',\n    'sigmaf': '\\u03C2',\n    'sim': '\\u223C',\n    'spades': '\\u2660',\n    'sub': '\\u2282',\n    'sube': '\\u2286',\n    'sum': '\\u2211',\n    'sup': '\\u2283',\n    'sup1': '\\u00B9',\n    'sup2': '\\u00B2',\n    'sup3': '\\u00B3',\n    'supe': '\\u2287',\n    'szlig': '\\u00DF',\n    'Tau': '\\u03A4',\n    'tau': '\\u03C4',\n    'there4': '\\u2234',\n    'Theta': '\\u0398',\n    'theta': '\\u03B8',\n    'thetasym': '\\u03D1',\n    'thinsp': '\\u2009',\n    'THORN': '\\u00DE',\n    'thorn': '\\u00FE',\n    'tilde': '\\u02DC',\n    'times': '\\u00D7',\n    'trade': '\\u2122',\n    'Uacute': '\\u00DA',\n    'uacute': '\\u00FA',\n    'uarr': '\\u2191',\n    'uArr': '\\u21D1',\n    'Ucirc': '\\u00DB',\n    'ucirc': '\\u00FB',\n    'Ugrave': '\\u00D9',\n    'ugrave': '\\u00F9',\n    'uml': '\\u00A8',\n    'upsih': '\\u03D2',\n    'Upsilon': '\\u03A5',\n    'upsilon': '\\u03C5',\n    'Uuml': '\\u00DC',\n    'uuml': '\\u00FC',\n    'weierp': '\\u2118',\n    'Xi': '\\u039E',\n    'xi': '\\u03BE',\n    'Yacute': '\\u00DD',\n    'yacute': '\\u00FD',\n    'yen': '\\u00A5',\n    'yuml': '\\u00FF',\n    'Yuml': '\\u0178',\n    'Zeta': '\\u0396',\n    'zeta': '\\u03B6',\n    'zwj': '\\u200D',\n    'zwnj': '\\u200C',\n};\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar HtmlTagDefinition = (function () {\n    /**\n     * @param {?=} __0\n     */\n    function HtmlTagDefinition(_a) {\n        var _b = _a === void 0 ? {} : _a, closedByChildren = _b.closedByChildren, requiredParents = _b.requiredParents, implicitNamespacePrefix = _b.implicitNamespacePrefix, _c = _b.contentType, contentType = _c === void 0 ? TagContentType.PARSABLE_DATA : _c, _d = _b.closedByParent, closedByParent = _d === void 0 ? false : _d, _e = _b.isVoid, isVoid = _e === void 0 ? false : _e, _f = _b.ignoreFirstLf, ignoreFirstLf = _f === void 0 ? false : _f;\n        var _this = this;\n        this.closedByChildren = {};\n        this.closedByParent = false;\n        this.canSelfClose = false;\n        if (closedByChildren && closedByChildren.length > 0) {\n            closedByChildren.forEach(function (tagName) { return _this.closedByChildren[tagName] = true; });\n        }\n        this.isVoid = isVoid;\n        this.closedByParent = closedByParent || isVoid;\n        if (requiredParents && requiredParents.length > 0) {\n            this.requiredParents = {};\n            // The first parent is the list is automatically when none of the listed parents are present\n            this.parentToAdd = requiredParents[0];\n            requiredParents.forEach(function (tagName) { return _this.requiredParents[tagName] = true; });\n        }\n        this.implicitNamespacePrefix = implicitNamespacePrefix || null;\n        this.contentType = contentType;\n        this.ignoreFirstLf = ignoreFirstLf;\n    }\n    /**\n     * @param {?} currentParent\n     * @return {?}\n     */\n    HtmlTagDefinition.prototype.requireExtraParent = function (currentParent) {\n        if (!this.requiredParents) {\n            return false;\n        }\n        if (!currentParent) {\n            return true;\n        }\n        var /** @type {?} */ lcParent = currentParent.toLowerCase();\n        var /** @type {?} */ isParentTemplate = lcParent === 'template' || currentParent === 'ng-template';\n        return !isParentTemplate && this.requiredParents[lcParent] != true;\n    };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    HtmlTagDefinition.prototype.isClosedByChild = function (name) {\n        return this.isVoid || name.toLowerCase() in this.closedByChildren;\n    };\n    return HtmlTagDefinition;\n}());\n// see http://www.w3.org/TR/html51/syntax.html#optional-tags\n// This implementation does not fully conform to the HTML5 spec.\nvar TAG_DEFINITIONS = {\n    'base': new HtmlTagDefinition({ isVoid: true }),\n    'meta': new HtmlTagDefinition({ isVoid: true }),\n    'area': new HtmlTagDefinition({ isVoid: true }),\n    'embed': new HtmlTagDefinition({ isVoid: true }),\n    'link': new HtmlTagDefinition({ isVoid: true }),\n    'img': new HtmlTagDefinition({ isVoid: true }),\n    'input': new HtmlTagDefinition({ isVoid: true }),\n    'param': new HtmlTagDefinition({ isVoid: true }),\n    'hr': new HtmlTagDefinition({ isVoid: true }),\n    'br': new HtmlTagDefinition({ isVoid: true }),\n    'source': new HtmlTagDefinition({ isVoid: true }),\n    'track': new HtmlTagDefinition({ isVoid: true }),\n    'wbr': new HtmlTagDefinition({ isVoid: true }),\n    'p': new HtmlTagDefinition({\n        closedByChildren: [\n            'address', 'article', 'aside', 'blockquote', 'div', 'dl', 'fieldset', 'footer', 'form',\n            'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr',\n            'main', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul'\n        ],\n        closedByParent: true\n    }),\n    'thead': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'] }),\n    'tbody': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'], closedByParent: true }),\n    'tfoot': new HtmlTagDefinition({ closedByChildren: ['tbody'], closedByParent: true }),\n    'tr': new HtmlTagDefinition({\n        closedByChildren: ['tr'],\n        requiredParents: ['tbody', 'tfoot', 'thead'],\n        closedByParent: true\n    }),\n    'td': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),\n    'th': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),\n    'col': new HtmlTagDefinition({ requiredParents: ['colgroup'], isVoid: true }),\n    'svg': new HtmlTagDefinition({ implicitNamespacePrefix: 'svg' }),\n    'math': new HtmlTagDefinition({ implicitNamespacePrefix: 'math' }),\n    'li': new HtmlTagDefinition({ closedByChildren: ['li'], closedByParent: true }),\n    'dt': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'] }),\n    'dd': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'], closedByParent: true }),\n    'rb': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\n    'rt': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\n    'rtc': new HtmlTagDefinition({ closedByChildren: ['rb', 'rtc', 'rp'], closedByParent: true }),\n    'rp': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\n    'optgroup': new HtmlTagDefinition({ closedByChildren: ['optgroup'], closedByParent: true }),\n    'option': new HtmlTagDefinition({ closedByChildren: ['option', 'optgroup'], closedByParent: true }),\n    'pre': new HtmlTagDefinition({ ignoreFirstLf: true }),\n    'listing': new HtmlTagDefinition({ ignoreFirstLf: true }),\n    'style': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),\n    'script': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),\n    'title': new HtmlTagDefinition({ contentType: TagContentType.ESCAPABLE_RAW_TEXT }),\n    'textarea': new HtmlTagDefinition({ contentType: TagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true }),\n};\nvar _DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();\n/**\n * @param {?} tagName\n * @return {?}\n */\nfunction getHtmlTagDefinition(tagName) {\n    return TAG_DEFINITIONS[tagName.toLowerCase()] || _DEFAULT_TAG_DEFINITION;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _SELECTOR_REGEXP = new RegExp('(\\\\:not\\\\()|' +\n    '([-\\\\w]+)|' +\n    '(?:\\\\.([-\\\\w]+))|' +\n    // \"-\" should appear first in the regexp below as FF31 parses \"[.-\\w]\" as a range\n    '(?:\\\\[([-.\\\\w*]+)(?:=([\\\"\\']?)([^\\\\]\\\"\\']*)\\\\5)?\\\\])|' +\n    // \"[name=\"value\"]\",\n    // \"[name='value']\"\n    '(\\\\))|' +\n    '(\\\\s*,\\\\s*)', // \",\"\n'g');\n/**\n * A css selector contains an element name,\n * css classes and attribute/value pairs with the purpose\n * of selecting subsets out of them.\n */\nvar CssSelector = (function () {\n    function CssSelector() {\n        this.element = null;\n        this.classNames = [];\n        this.attrs = [];\n        this.notSelectors = [];\n    }\n    /**\n     * @param {?} selector\n     * @return {?}\n     */\n    CssSelector.parse = function (selector) {\n        var /** @type {?} */ results = [];\n        var /** @type {?} */ _addResult = function (res, cssSel) {\n            if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 &&\n                cssSel.attrs.length == 0) {\n                cssSel.element = '*';\n            }\n            res.push(cssSel);\n        };\n        var /** @type {?} */ cssSelector = new CssSelector();\n        var /** @type {?} */ match;\n        var /** @type {?} */ current = cssSelector;\n        var /** @type {?} */ inNot = false;\n        _SELECTOR_REGEXP.lastIndex = 0;\n        while (match = _SELECTOR_REGEXP.exec(selector)) {\n            if (match[1]) {\n                if (inNot) {\n                    throw new Error('Nesting :not is not allowed in a selector');\n                }\n                inNot = true;\n                current = new CssSelector();\n                cssSelector.notSelectors.push(current);\n            }\n            if (match[2]) {\n                current.setElement(match[2]);\n            }\n            if (match[3]) {\n                current.addClassName(match[3]);\n            }\n            if (match[4]) {\n                current.addAttribute(match[4], match[6]);\n            }\n            if (match[7]) {\n                inNot = false;\n                current = cssSelector;\n            }\n            if (match[8]) {\n                if (inNot) {\n                    throw new Error('Multiple selectors in :not are not supported');\n                }\n                _addResult(results, cssSelector);\n                cssSelector = current = new CssSelector();\n            }\n        }\n        _addResult(results, cssSelector);\n        return results;\n    };\n    /**\n     * @return {?}\n     */\n    CssSelector.prototype.isElementSelector = function () {\n        return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 &&\n            this.notSelectors.length === 0;\n    };\n    /**\n     * @return {?}\n     */\n    CssSelector.prototype.hasElementSelector = function () { return !!this.element; };\n    /**\n     * @param {?=} element\n     * @return {?}\n     */\n    CssSelector.prototype.setElement = function (element) {\n        if (element === void 0) { element = null; }\n        this.element = element;\n    };\n    /**\n     * Gets a template string for an element that matches the selector.\n     * @return {?}\n     */\n    CssSelector.prototype.getMatchingElementTemplate = function () {\n        var /** @type {?} */ tagName = this.element || 'div';\n        var /** @type {?} */ classAttr = this.classNames.length > 0 ? \" class=\\\"\" + this.classNames.join(' ') + \"\\\"\" : '';\n        var /** @type {?} */ attrs = '';\n        for (var /** @type {?} */ i = 0; i < this.attrs.length; i += 2) {\n            var /** @type {?} */ attrName = this.attrs[i];\n            var /** @type {?} */ attrValue = this.attrs[i + 1] !== '' ? \"=\\\"\" + this.attrs[i + 1] + \"\\\"\" : '';\n            attrs += \" \" + attrName + attrValue;\n        }\n        return getHtmlTagDefinition(tagName).isVoid ? \"<\" + tagName + classAttr + attrs + \"/>\" :\n            \"<\" + tagName + classAttr + attrs + \"></\" + tagName + \">\";\n    };\n    /**\n     * @param {?} name\n     * @param {?=} value\n     * @return {?}\n     */\n    CssSelector.prototype.addAttribute = function (name, value) {\n        if (value === void 0) { value = ''; }\n        this.attrs.push(name, value && value.toLowerCase() || '');\n    };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    CssSelector.prototype.addClassName = function (name) { this.classNames.push(name.toLowerCase()); };\n    /**\n     * @return {?}\n     */\n    CssSelector.prototype.toString = function () {\n        var /** @type {?} */ res = this.element || '';\n        if (this.classNames) {\n            this.classNames.forEach(function (klass) { return res += \".\" + klass; });\n        }\n        if (this.attrs) {\n            for (var /** @type {?} */ i = 0; i < this.attrs.length; i += 2) {\n                var /** @type {?} */ name = this.attrs[i];\n                var /** @type {?} */ value = this.attrs[i + 1];\n                res += \"[\" + name + (value ? '=' + value : '') + \"]\";\n            }\n        }\n        this.notSelectors.forEach(function (notSelector) { return res += \":not(\" + notSelector + \")\"; });\n        return res;\n    };\n    return CssSelector;\n}());\n/**\n * Reads a list of CssSelectors and allows to calculate which ones\n * are contained in a given CssSelector.\n */\nvar SelectorMatcher = (function () {\n    function SelectorMatcher() {\n        this._elementMap = new Map();\n        this._elementPartialMap = new Map();\n        this._classMap = new Map();\n        this._classPartialMap = new Map();\n        this._attrValueMap = new Map();\n        this._attrValuePartialMap = new Map();\n        this._listContexts = [];\n    }\n    /**\n     * @param {?} notSelectors\n     * @return {?}\n     */\n    SelectorMatcher.createNotMatcher = function (notSelectors) {\n        var /** @type {?} */ notMatcher = new SelectorMatcher();\n        notMatcher.addSelectables(notSelectors, null);\n        return notMatcher;\n    };\n    /**\n     * @param {?} cssSelectors\n     * @param {?=} callbackCtxt\n     * @return {?}\n     */\n    SelectorMatcher.prototype.addSelectables = function (cssSelectors, callbackCtxt) {\n        var /** @type {?} */ listContext = ((null));\n        if (cssSelectors.length > 1) {\n            listContext = new SelectorListContext(cssSelectors);\n            this._listContexts.push(listContext);\n        }\n        for (var /** @type {?} */ i = 0; i < cssSelectors.length; i++) {\n            this._addSelectable(cssSelectors[i], callbackCtxt, listContext);\n        }\n    };\n    /**\n     * Add an object that can be found later on by calling `match`.\n     * @param {?} cssSelector A css selector\n     * @param {?} callbackCtxt An opaque object that will be given to the callback of the `match` function\n     * @param {?} listContext\n     * @return {?}\n     */\n    SelectorMatcher.prototype._addSelectable = function (cssSelector, callbackCtxt, listContext) {\n        var /** @type {?} */ matcher = this;\n        var /** @type {?} */ element = cssSelector.element;\n        var /** @type {?} */ classNames = cssSelector.classNames;\n        var /** @type {?} */ attrs = cssSelector.attrs;\n        var /** @type {?} */ selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);\n        if (element) {\n            var /** @type {?} */ isTerminal = attrs.length === 0 && classNames.length === 0;\n            if (isTerminal) {\n                this._addTerminal(matcher._elementMap, element, selectable);\n            }\n            else {\n                matcher = this._addPartial(matcher._elementPartialMap, element);\n            }\n        }\n        if (classNames) {\n            for (var /** @type {?} */ i = 0; i < classNames.length; i++) {\n                var /** @type {?} */ isTerminal = attrs.length === 0 && i === classNames.length - 1;\n                var /** @type {?} */ className = classNames[i];\n                if (isTerminal) {\n                    this._addTerminal(matcher._classMap, className, selectable);\n                }\n                else {\n                    matcher = this._addPartial(matcher._classPartialMap, className);\n                }\n            }\n        }\n        if (attrs) {\n            for (var /** @type {?} */ i = 0; i < attrs.length; i += 2) {\n                var /** @type {?} */ isTerminal = i === attrs.length - 2;\n                var /** @type {?} */ name = attrs[i];\n                var /** @type {?} */ value = attrs[i + 1];\n                if (isTerminal) {\n                    var /** @type {?} */ terminalMap = matcher._attrValueMap;\n                    var /** @type {?} */ terminalValuesMap = terminalMap.get(name);\n                    if (!terminalValuesMap) {\n                        terminalValuesMap = new Map();\n                        terminalMap.set(name, terminalValuesMap);\n                    }\n                    this._addTerminal(terminalValuesMap, value, selectable);\n                }\n                else {\n                    var /** @type {?} */ partialMap = matcher._attrValuePartialMap;\n                    var /** @type {?} */ partialValuesMap = partialMap.get(name);\n                    if (!partialValuesMap) {\n                        partialValuesMap = new Map();\n                        partialMap.set(name, partialValuesMap);\n                    }\n                    matcher = this._addPartial(partialValuesMap, value);\n                }\n            }\n        }\n    };\n    /**\n     * @param {?} map\n     * @param {?} name\n     * @param {?} selectable\n     * @return {?}\n     */\n    SelectorMatcher.prototype._addTerminal = function (map, name, selectable) {\n        var /** @type {?} */ terminalList = map.get(name);\n        if (!terminalList) {\n            terminalList = [];\n            map.set(name, terminalList);\n        }\n        terminalList.push(selectable);\n    };\n    /**\n     * @param {?} map\n     * @param {?} name\n     * @return {?}\n     */\n    SelectorMatcher.prototype._addPartial = function (map, name) {\n        var /** @type {?} */ matcher = map.get(name);\n        if (!matcher) {\n            matcher = new SelectorMatcher();\n            map.set(name, matcher);\n        }\n        return matcher;\n    };\n    /**\n     * Find the objects that have been added via `addSelectable`\n     * whose css selector is contained in the given css selector.\n     * @param {?} cssSelector A css selector\n     * @param {?} matchedCallback This callback will be called with the object handed into `addSelectable`\n     * @return {?} boolean true if a match was found\n     */\n    SelectorMatcher.prototype.match = function (cssSelector, matchedCallback) {\n        var /** @type {?} */ result = false;\n        var /** @type {?} */ element = ((cssSelector.element));\n        var /** @type {?} */ classNames = cssSelector.classNames;\n        var /** @type {?} */ attrs = cssSelector.attrs;\n        for (var /** @type {?} */ i = 0; i < this._listContexts.length; i++) {\n            this._listContexts[i].alreadyMatched = false;\n        }\n        result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;\n        result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) ||\n            result;\n        if (classNames) {\n            for (var /** @type {?} */ i = 0; i < classNames.length; i++) {\n                var /** @type {?} */ className = classNames[i];\n                result =\n                    this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;\n                result =\n                    this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) ||\n                        result;\n            }\n        }\n        if (attrs) {\n            for (var /** @type {?} */ i = 0; i < attrs.length; i += 2) {\n                var /** @type {?} */ name = attrs[i];\n                var /** @type {?} */ value = attrs[i + 1];\n                var /** @type {?} */ terminalValuesMap = ((this._attrValueMap.get(name)));\n                if (value) {\n                    result =\n                        this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;\n                }\n                result =\n                    this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;\n                var /** @type {?} */ partialValuesMap = ((this._attrValuePartialMap.get(name)));\n                if (value) {\n                    result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;\n                }\n                result =\n                    this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;\n            }\n        }\n        return result;\n    };\n    /**\n     * \\@internal\n     * @param {?} map\n     * @param {?} name\n     * @param {?} cssSelector\n     * @param {?} matchedCallback\n     * @return {?}\n     */\n    SelectorMatcher.prototype._matchTerminal = function (map, name, cssSelector, matchedCallback) {\n        if (!map || typeof name !== 'string') {\n            return false;\n        }\n        var /** @type {?} */ selectables = map.get(name) || [];\n        var /** @type {?} */ starSelectables = ((map.get('*')));\n        if (starSelectables) {\n            selectables = selectables.concat(starSelectables);\n        }\n        if (selectables.length === 0) {\n            return false;\n        }\n        var /** @type {?} */ selectable;\n        var /** @type {?} */ result = false;\n        for (var /** @type {?} */ i = 0; i < selectables.length; i++) {\n            selectable = selectables[i];\n            result = selectable.finalize(cssSelector, matchedCallback) || result;\n        }\n        return result;\n    };\n    /**\n     * \\@internal\n     * @param {?} map\n     * @param {?} name\n     * @param {?} cssSelector\n     * @param {?} matchedCallback\n     * @return {?}\n     */\n    SelectorMatcher.prototype._matchPartial = function (map, name, cssSelector, matchedCallback) {\n        if (!map || typeof name !== 'string') {\n            return false;\n        }\n        var /** @type {?} */ nestedSelector = map.get(name);\n        if (!nestedSelector) {\n            return false;\n        }\n        // TODO(perf): get rid of recursion and measure again\n        // TODO(perf): don't pass the whole selector into the recursion,\n        // but only the not processed parts\n        return nestedSelector.match(cssSelector, matchedCallback);\n    };\n    return SelectorMatcher;\n}());\nvar SelectorListContext = (function () {\n    /**\n     * @param {?} selectors\n     */\n    function SelectorListContext(selectors) {\n        this.selectors = selectors;\n        this.alreadyMatched = false;\n    }\n    return SelectorListContext;\n}());\nvar SelectorContext = (function () {\n    /**\n     * @param {?} selector\n     * @param {?} cbContext\n     * @param {?} listContext\n     */\n    function SelectorContext(selector, cbContext, listContext) {\n        this.selector = selector;\n        this.cbContext = cbContext;\n        this.listContext = listContext;\n        this.notSelectors = selector.notSelectors;\n    }\n    /**\n     * @param {?} cssSelector\n     * @param {?} callback\n     * @return {?}\n     */\n    SelectorContext.prototype.finalize = function (cssSelector, callback) {\n        var /** @type {?} */ result = true;\n        if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {\n            var /** @type {?} */ notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);\n            result = !notMatcher.match(cssSelector, null);\n        }\n        if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {\n            if (this.listContext) {\n                this.listContext.alreadyMatched = true;\n            }\n            callback(this.selector, this.cbContext);\n        }\n        return result;\n    };\n    return SelectorContext;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar MODULE_SUFFIX = '';\nvar DASH_CASE_REGEXP = /-+([a-z0-9])/g;\n/**\n * @param {?} input\n * @return {?}\n */\n/**\n * @param {?} input\n * @return {?}\n */\nfunction dashCaseToCamelCase(input) {\n    return input.replace(DASH_CASE_REGEXP, function () {\n        var m = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            m[_i] = arguments[_i];\n        }\n        return m[1].toUpperCase();\n    });\n}\n/**\n * @param {?} input\n * @param {?} defaultValues\n * @return {?}\n */\nfunction splitAtColon(input, defaultValues) {\n    return _splitAt(input, ':', defaultValues);\n}\n/**\n * @param {?} input\n * @param {?} defaultValues\n * @return {?}\n */\nfunction splitAtPeriod(input, defaultValues) {\n    return _splitAt(input, '.', defaultValues);\n}\n/**\n * @param {?} input\n * @param {?} character\n * @param {?} defaultValues\n * @return {?}\n */\nfunction _splitAt(input, character, defaultValues) {\n    var /** @type {?} */ characterIndex = input.indexOf(character);\n    if (characterIndex == -1)\n        return defaultValues;\n    return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];\n}\n/**\n * @param {?} value\n * @param {?} visitor\n * @param {?} context\n * @return {?}\n */\nfunction visitValue(value, visitor, context) {\n    if (Array.isArray(value)) {\n        return visitor.visitArray(/** @type {?} */ (value), context);\n    }\n    if (isStrictStringMap(value)) {\n        return visitor.visitStringMap(/** @type {?} */ (value), context);\n    }\n    if (value == null || typeof value == 'string' || typeof value == 'number' ||\n        typeof value == 'boolean') {\n        return visitor.visitPrimitive(value, context);\n    }\n    return visitor.visitOther(value, context);\n}\n/**\n * @param {?} val\n * @return {?}\n */\nfunction isDefined(val) {\n    return val !== null && val !== undefined;\n}\n/**\n * @template T\n * @param {?} val\n * @return {?}\n */\nfunction noUndefined(val) {\n    return val === undefined ? ((null)) : val;\n}\nvar ValueTransformer = (function () {\n    function ValueTransformer() {\n    }\n    /**\n     * @param {?} arr\n     * @param {?} context\n     * @return {?}\n     */\n    ValueTransformer.prototype.visitArray = function (arr, context) {\n        var _this = this;\n        return arr.map(function (value) { return visitValue(value, _this, context); });\n    };\n    /**\n     * @param {?} map\n     * @param {?} context\n     * @return {?}\n     */\n    ValueTransformer.prototype.visitStringMap = function (map, context) {\n        var _this = this;\n        var /** @type {?} */ result = {};\n        Object.keys(map).forEach(function (key) { result[key] = visitValue(map[key], _this, context); });\n        return result;\n    };\n    /**\n     * @param {?} value\n     * @param {?} context\n     * @return {?}\n     */\n    ValueTransformer.prototype.visitPrimitive = function (value, context) { return value; };\n    /**\n     * @param {?} value\n     * @param {?} context\n     * @return {?}\n     */\n    ValueTransformer.prototype.visitOther = function (value, context) { return value; };\n    return ValueTransformer;\n}());\nvar SyncAsync = {\n    assertSync: function (value) {\n        if (Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"isPromise\"])(value)) {\n            throw new Error(\"Illegal state: value cannot be a promise\");\n        }\n        return value;\n    },\n    then: function (value, cb) { return Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"isPromise\"])(value) ? value.then(cb) : cb(value); },\n    all: function (syncAsyncValues) {\n        return syncAsyncValues.some(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"isPromise\"]) ? Promise.all(syncAsyncValues) : (syncAsyncValues);\n    }\n};\n/**\n * @param {?} msg\n * @param {?=} parseErrors\n * @return {?}\n */\nfunction syntaxError(msg, parseErrors) {\n    var /** @type {?} */ error = Error(msg);\n    ((error))[ERROR_SYNTAX_ERROR] = true;\n    if (parseErrors)\n        ((error))[ERROR_PARSE_ERRORS] = parseErrors;\n    return error;\n}\nvar ERROR_SYNTAX_ERROR = 'ngSyntaxError';\nvar ERROR_PARSE_ERRORS = 'ngParseErrors';\n/**\n * @param {?} error\n * @return {?}\n */\nfunction isSyntaxError(error) {\n    return ((error))[ERROR_SYNTAX_ERROR];\n}\n/**\n * @param {?} error\n * @return {?}\n */\nfunction getParseErrors(error) {\n    return ((error))[ERROR_PARSE_ERRORS] || [];\n}\n/**\n * @param {?} s\n * @return {?}\n */\nfunction escapeRegExp(s) {\n    return s.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n}\nvar STRING_MAP_PROTO = Object.getPrototypeOf({});\n/**\n * @param {?} obj\n * @return {?}\n */\nfunction isStrictStringMap(obj) {\n    return typeof obj === 'object' && obj !== null && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;\n}\n/**\n * @param {?} str\n * @return {?}\n */\nfunction utf8Encode(str) {\n    var /** @type {?} */ encoded = '';\n    for (var /** @type {?} */ index = 0; index < str.length; index++) {\n        var /** @type {?} */ codePoint = str.charCodeAt(index);\n        // decode surrogate\n        // see https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n        if (codePoint >= 0xd800 && codePoint <= 0xdbff && str.length > (index + 1)) {\n            var /** @type {?} */ low = str.charCodeAt(index + 1);\n            if (low >= 0xdc00 && low <= 0xdfff) {\n                index++;\n                codePoint = ((codePoint - 0xd800) << 10) + low - 0xdc00 + 0x10000;\n            }\n        }\n        if (codePoint <= 0x7f) {\n            encoded += String.fromCharCode(codePoint);\n        }\n        else if (codePoint <= 0x7ff) {\n            encoded += String.fromCharCode(((codePoint >> 6) & 0x1F) | 0xc0, (codePoint & 0x3f) | 0x80);\n        }\n        else if (codePoint <= 0xffff) {\n            encoded += String.fromCharCode((codePoint >> 12) | 0xe0, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n        }\n        else if (codePoint <= 0x1fffff) {\n            encoded += String.fromCharCode(((codePoint >> 18) & 0x07) | 0xf0, ((codePoint >> 12) & 0x3f) | 0x80, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n        }\n    }\n    return encoded;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// group 0: \"[prop] or (event) or @trigger\"\n// group 1: \"prop\" from \"[prop]\"\n// group 2: \"event\" from \"(event)\"\n// group 3: \"@trigger\" from \"@trigger\"\nvar HOST_REG_EXP = /^(?:(?:\\[([^\\]]+)\\])|(?:\\(([^\\)]+)\\)))|(\\@[-\\w]+)$/;\nvar CompileAnimationEntryMetadata = (function () {\n    /**\n     * @param {?=} name\n     * @param {?=} definitions\n     */\n    function CompileAnimationEntryMetadata(name, definitions) {\n        if (name === void 0) { name = null; }\n        if (definitions === void 0) { definitions = null; }\n        this.name = name;\n        this.definitions = definitions;\n    }\n    return CompileAnimationEntryMetadata;\n}());\n/**\n * @abstract\n */\nvar CompileAnimationStateMetadata = (function () {\n    function CompileAnimationStateMetadata() {\n    }\n    return CompileAnimationStateMetadata;\n}());\nvar CompileAnimationStateDeclarationMetadata = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](CompileAnimationStateDeclarationMetadata, _super);\n    /**\n     * @param {?} stateNameExpr\n     * @param {?} styles\n     */\n    function CompileAnimationStateDeclarationMetadata(stateNameExpr, styles) {\n        var _this = _super.call(this) || this;\n        _this.stateNameExpr = stateNameExpr;\n        _this.styles = styles;\n        return _this;\n    }\n    return CompileAnimationStateDeclarationMetadata;\n}(CompileAnimationStateMetadata));\nvar CompileAnimationStateTransitionMetadata = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](CompileAnimationStateTransitionMetadata, _super);\n    /**\n     * @param {?} stateChangeExpr\n     * @param {?} steps\n     */\n    function CompileAnimationStateTransitionMetadata(stateChangeExpr, steps) {\n        var _this = _super.call(this) || this;\n        _this.stateChangeExpr = stateChangeExpr;\n        _this.steps = steps;\n        return _this;\n    }\n    return CompileAnimationStateTransitionMetadata;\n}(CompileAnimationStateMetadata));\n/**\n * @abstract\n */\nvar CompileAnimationMetadata = (function () {\n    function CompileAnimationMetadata() {\n    }\n    return CompileAnimationMetadata;\n}());\nvar CompileAnimationKeyframesSequenceMetadata = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](CompileAnimationKeyframesSequenceMetadata, _super);\n    /**\n     * @param {?=} steps\n     */\n    function CompileAnimationKeyframesSequenceMetadata(steps) {\n        if (steps === void 0) { steps = []; }\n        var _this = _super.call(this) || this;\n        _this.steps = steps;\n        return _this;\n    }\n    return CompileAnimationKeyframesSequenceMetadata;\n}(CompileAnimationMetadata));\nvar CompileAnimationStyleMetadata = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](CompileAnimationStyleMetadata, _super);\n    /**\n     * @param {?} offset\n     * @param {?=} styles\n     */\n    function CompileAnimationStyleMetadata(offset, styles) {\n        if (styles === void 0) { styles = null; }\n        var _this = _super.call(this) || this;\n        _this.offset = offset;\n        _this.styles = styles;\n        return _this;\n    }\n    return CompileAnimationStyleMetadata;\n}(CompileAnimationMetadata));\nvar CompileAnimationAnimateMetadata = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](CompileAnimationAnimateMetadata, _super);\n    /**\n     * @param {?=} timings\n     * @param {?=} styles\n     */\n    function CompileAnimationAnimateMetadata(timings, styles) {\n        if (timings === void 0) { timings = 0; }\n        if (styles === void 0) { styles = null; }\n        var _this = _super.call(this) || this;\n        _this.timings = timings;\n        _this.styles = styles;\n        return _this;\n    }\n    return CompileAnimationAnimateMetadata;\n}(CompileAnimationMetadata));\n/**\n * @abstract\n */\nvar CompileAnimationWithStepsMetadata = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](CompileAnimationWithStepsMetadata, _super);\n    /**\n     * @param {?=} steps\n     */\n    function CompileAnimationWithStepsMetadata(steps) {\n        if (steps === void 0) { steps = null; }\n        var _this = _super.call(this) || this;\n        _this.steps = steps;\n        return _this;\n    }\n    return CompileAnimationWithStepsMetadata;\n}(CompileAnimationMetadata));\nvar CompileAnimationSequenceMetadata = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](CompileAnimationSequenceMetadata, _super);\n    /**\n     * @param {?=} steps\n     */\n    function CompileAnimationSequenceMetadata(steps) {\n        if (steps === void 0) { steps = null; }\n        return _super.call(this, steps) || this;\n    }\n    return CompileAnimationSequenceMetadata;\n}(CompileAnimationWithStepsMetadata));\nvar CompileAnimationGroupMetadata = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](CompileAnimationGroupMetadata, _super);\n    /**\n     * @param {?=} steps\n     */\n    function CompileAnimationGroupMetadata(steps) {\n        if (steps === void 0) { steps = null; }\n        return _super.call(this, steps) || this;\n    }\n    return CompileAnimationGroupMetadata;\n}(CompileAnimationWithStepsMetadata));\n/**\n * @param {?} name\n * @return {?}\n */\nfunction _sanitizeIdentifier(name) {\n    return name.replace(/\\W/g, '_');\n}\nvar _anonymousTypeIndex = 0;\n/**\n * @param {?} compileIdentifier\n * @return {?}\n */\nfunction identifierName(compileIdentifier) {\n    if (!compileIdentifier || !compileIdentifier.reference) {\n        return null;\n    }\n    var /** @type {?} */ ref = compileIdentifier.reference;\n    if (ref instanceof StaticSymbol) {\n        return ref.name;\n    }\n    if (ref['__anonymousType']) {\n        return ref['__anonymousType'];\n    }\n    var /** @type {?} */ identifier = Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"stringify\"])(ref);\n    if (identifier.indexOf('(') >= 0) {\n        // case: anonymous functions!\n        identifier = \"anonymous_\" + _anonymousTypeIndex++;\n        ref['__anonymousType'] = identifier;\n    }\n    else {\n        identifier = _sanitizeIdentifier(identifier);\n    }\n    return identifier;\n}\n/**\n * @param {?} compileIdentifier\n * @return {?}\n */\nfunction identifierModuleUrl(compileIdentifier) {\n    var /** @type {?} */ ref = compileIdentifier.reference;\n    if (ref instanceof StaticSymbol) {\n        return ref.filePath;\n    }\n    // Runtime type\n    return \"./\" + Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"stringify\"])(ref);\n}\n/**\n * @param {?} compType\n * @param {?} embeddedTemplateIndex\n * @return {?}\n */\nfunction viewClassName(compType, embeddedTemplateIndex) {\n    return \"View_\" + identifierName({ reference: compType }) + \"_\" + embeddedTemplateIndex;\n}\n/**\n * @param {?} compType\n * @return {?}\n */\nfunction rendererTypeName(compType) {\n    return \"RenderType_\" + identifierName({ reference: compType });\n}\n/**\n * @param {?} compType\n * @return {?}\n */\nfunction hostViewClassName(compType) {\n    return \"HostView_\" + identifierName({ reference: compType });\n}\n/**\n * @param {?} compType\n * @return {?}\n */\nfunction componentFactoryName(compType) {\n    return identifierName({ reference: compType }) + \"NgFactory\";\n}\nvar CompileSummaryKind = {};\nCompileSummaryKind.Pipe = 0;\nCompileSummaryKind.Directive = 1;\nCompileSummaryKind.NgModule = 2;\nCompileSummaryKind.Injectable = 3;\nCompileSummaryKind[CompileSummaryKind.Pipe] = \"Pipe\";\nCompileSummaryKind[CompileSummaryKind.Directive] = \"Directive\";\nCompileSummaryKind[CompileSummaryKind.NgModule] = \"NgModule\";\nCompileSummaryKind[CompileSummaryKind.Injectable] = \"Injectable\";\n/**\n * @param {?} token\n * @return {?}\n */\nfunction tokenName(token) {\n    return token.value != null ? _sanitizeIdentifier(token.value) : identifierName(token.identifier);\n}\n/**\n * @param {?} token\n * @return {?}\n */\nfunction tokenReference(token) {\n    if (token.identifier != null) {\n        return token.identifier.reference;\n    }\n    else {\n        return token.value;\n    }\n}\n/**\n * Metadata about a stylesheet\n */\nvar CompileStylesheetMetadata = (function () {\n    /**\n     * @param {?=} __0\n     */\n    function CompileStylesheetMetadata(_a) {\n        var _b = _a === void 0 ? {} : _a, moduleUrl = _b.moduleUrl, styles = _b.styles, styleUrls = _b.styleUrls;\n        this.moduleUrl = moduleUrl || null;\n        this.styles = _normalizeArray(styles);\n        this.styleUrls = _normalizeArray(styleUrls);\n    }\n    return CompileStylesheetMetadata;\n}());\n/**\n * Metadata regarding compilation of a template.\n */\nvar CompileTemplateMetadata = (function () {\n    /**\n     * @param {?} __0\n     */\n    function CompileTemplateMetadata(_a) {\n        var encapsulation = _a.encapsulation, template = _a.template, templateUrl = _a.templateUrl, styles = _a.styles, styleUrls = _a.styleUrls, externalStylesheets = _a.externalStylesheets, animations = _a.animations, ngContentSelectors = _a.ngContentSelectors, interpolation = _a.interpolation, isInline = _a.isInline;\n        this.encapsulation = encapsulation;\n        this.template = template;\n        this.templateUrl = templateUrl;\n        this.styles = _normalizeArray(styles);\n        this.styleUrls = _normalizeArray(styleUrls);\n        this.externalStylesheets = _normalizeArray(externalStylesheets);\n        this.animations = animations ? flatten(animations) : [];\n        this.ngContentSelectors = ngContentSelectors || [];\n        if (interpolation && interpolation.length != 2) {\n            throw new Error(\"'interpolation' should have a start and an end symbol.\");\n        }\n        this.interpolation = interpolation;\n        this.isInline = isInline;\n    }\n    /**\n     * @return {?}\n     */\n    CompileTemplateMetadata.prototype.toSummary = function () {\n        return {\n            animations: this.animations.map(function (anim) { return anim.name; }),\n            ngContentSelectors: this.ngContentSelectors,\n            encapsulation: this.encapsulation,\n        };\n    };\n    return CompileTemplateMetadata;\n}());\n/**\n * Metadata regarding compilation of a directive.\n */\nvar CompileDirectiveMetadata = (function () {\n    /**\n     * @param {?} __0\n     */\n    function CompileDirectiveMetadata(_a) {\n        var isHost = _a.isHost, type = _a.type, isComponent = _a.isComponent, selector = _a.selector, exportAs = _a.exportAs, changeDetection = _a.changeDetection, inputs = _a.inputs, outputs = _a.outputs, hostListeners = _a.hostListeners, hostProperties = _a.hostProperties, hostAttributes = _a.hostAttributes, providers = _a.providers, viewProviders = _a.viewProviders, queries = _a.queries, viewQueries = _a.viewQueries, entryComponents = _a.entryComponents, template = _a.template, componentViewType = _a.componentViewType, rendererType = _a.rendererType, componentFactory = _a.componentFactory;\n        this.isHost = !!isHost;\n        this.type = type;\n        this.isComponent = isComponent;\n        this.selector = selector;\n        this.exportAs = exportAs;\n        this.changeDetection = changeDetection;\n        this.inputs = inputs;\n        this.outputs = outputs;\n        this.hostListeners = hostListeners;\n        this.hostProperties = hostProperties;\n        this.hostAttributes = hostAttributes;\n        this.providers = _normalizeArray(providers);\n        this.viewProviders = _normalizeArray(viewProviders);\n        this.queries = _normalizeArray(queries);\n        this.viewQueries = _normalizeArray(viewQueries);\n        this.entryComponents = _normalizeArray(entryComponents);\n        this.template = template;\n        this.componentViewType = componentViewType;\n        this.rendererType = rendererType;\n        this.componentFactory = componentFactory;\n    }\n    /**\n     * @param {?} __0\n     * @return {?}\n     */\n    CompileDirectiveMetadata.create = function (_a) {\n        var isHost = _a.isHost, type = _a.type, isComponent = _a.isComponent, selector = _a.selector, exportAs = _a.exportAs, changeDetection = _a.changeDetection, inputs = _a.inputs, outputs = _a.outputs, host = _a.host, providers = _a.providers, viewProviders = _a.viewProviders, queries = _a.queries, viewQueries = _a.viewQueries, entryComponents = _a.entryComponents, template = _a.template, componentViewType = _a.componentViewType, rendererType = _a.rendererType, componentFactory = _a.componentFactory;\n        var /** @type {?} */ hostListeners = {};\n        var /** @type {?} */ hostProperties = {};\n        var /** @type {?} */ hostAttributes = {};\n        if (host != null) {\n            Object.keys(host).forEach(function (key) {\n                var /** @type {?} */ value = host[key];\n                var /** @type {?} */ matches = key.match(HOST_REG_EXP);\n                if (matches === null) {\n                    hostAttributes[key] = value;\n                }\n                else if (matches[1] != null) {\n                    hostProperties[matches[1]] = value;\n                }\n                else if (matches[2] != null) {\n                    hostListeners[matches[2]] = value;\n                }\n            });\n        }\n        var /** @type {?} */ inputsMap = {};\n        if (inputs != null) {\n            inputs.forEach(function (bindConfig) {\n                // canonical syntax: `dirProp: elProp`\n                // if there is no `:`, use dirProp = elProp\n                var /** @type {?} */ parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);\n                inputsMap[parts[0]] = parts[1];\n            });\n        }\n        var /** @type {?} */ outputsMap = {};\n        if (outputs != null) {\n            outputs.forEach(function (bindConfig) {\n                // canonical syntax: `dirProp: elProp`\n                // if there is no `:`, use dirProp = elProp\n                var /** @type {?} */ parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);\n                outputsMap[parts[0]] = parts[1];\n            });\n        }\n        return new CompileDirectiveMetadata({\n            isHost: isHost,\n            type: type,\n            isComponent: !!isComponent, selector: selector, exportAs: exportAs, changeDetection: changeDetection,\n            inputs: inputsMap,\n            outputs: outputsMap,\n            hostListeners: hostListeners,\n            hostProperties: hostProperties,\n            hostAttributes: hostAttributes,\n            providers: providers,\n            viewProviders: viewProviders,\n            queries: queries,\n            viewQueries: viewQueries,\n            entryComponents: entryComponents,\n            template: template,\n            componentViewType: componentViewType,\n            rendererType: rendererType,\n            componentFactory: componentFactory,\n        });\n    };\n    /**\n     * @return {?}\n     */\n    CompileDirectiveMetadata.prototype.toSummary = function () {\n        return {\n            summaryKind: CompileSummaryKind.Directive,\n            type: this.type,\n            isComponent: this.isComponent,\n            selector: this.selector,\n            exportAs: this.exportAs,\n            inputs: this.inputs,\n            outputs: this.outputs,\n            hostListeners: this.hostListeners,\n            hostProperties: this.hostProperties,\n            hostAttributes: this.hostAttributes,\n            providers: this.providers,\n            viewProviders: this.viewProviders,\n            queries: this.queries,\n            viewQueries: this.viewQueries,\n            entryComponents: this.entryComponents,\n            changeDetection: this.changeDetection,\n            template: this.template && this.template.toSummary(),\n            componentViewType: this.componentViewType,\n            rendererType: this.rendererType,\n            componentFactory: this.componentFactory\n        };\n    };\n    return CompileDirectiveMetadata;\n}());\n/**\n * Construct {\\@link CompileDirectiveMetadata} from {\\@link ComponentTypeMetadata} and a selector.\n * @param {?} hostTypeReference\n * @param {?} compMeta\n * @param {?} hostViewType\n * @return {?}\n */\nfunction createHostComponentMeta(hostTypeReference, compMeta, hostViewType) {\n    var /** @type {?} */ template = CssSelector.parse(/** @type {?} */ ((compMeta.selector)))[0].getMatchingElementTemplate();\n    return CompileDirectiveMetadata.create({\n        isHost: true,\n        type: { reference: hostTypeReference, diDeps: [], lifecycleHooks: [] },\n        template: new CompileTemplateMetadata({\n            encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\n            template: template,\n            templateUrl: '',\n            styles: [],\n            styleUrls: [],\n            ngContentSelectors: [],\n            animations: [],\n            isInline: true,\n            externalStylesheets: [],\n            interpolation: null\n        }),\n        exportAs: null,\n        changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].Default,\n        inputs: [],\n        outputs: [],\n        host: {},\n        isComponent: true,\n        selector: '*',\n        providers: [],\n        viewProviders: [],\n        queries: [],\n        viewQueries: [],\n        componentViewType: hostViewType,\n        rendererType: { id: '__Host__', encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None, styles: [], data: {} },\n        entryComponents: [],\n        componentFactory: null\n    });\n}\nvar CompilePipeMetadata = (function () {\n    /**\n     * @param {?} __0\n     */\n    function CompilePipeMetadata(_a) {\n        var type = _a.type, name = _a.name, pure = _a.pure;\n        this.type = type;\n        this.name = name;\n        this.pure = !!pure;\n    }\n    /**\n     * @return {?}\n     */\n    CompilePipeMetadata.prototype.toSummary = function () {\n        return {\n            summaryKind: CompileSummaryKind.Pipe,\n            type: this.type,\n            name: this.name,\n            pure: this.pure\n        };\n    };\n    return CompilePipeMetadata;\n}());\n/**\n * Metadata regarding compilation of a module.\n */\nvar CompileNgModuleMetadata = (function () {\n    /**\n     * @param {?} __0\n     */\n    function CompileNgModuleMetadata(_a) {\n        var type = _a.type, providers = _a.providers, declaredDirectives = _a.declaredDirectives, exportedDirectives = _a.exportedDirectives, declaredPipes = _a.declaredPipes, exportedPipes = _a.exportedPipes, entryComponents = _a.entryComponents, bootstrapComponents = _a.bootstrapComponents, importedModules = _a.importedModules, exportedModules = _a.exportedModules, schemas = _a.schemas, transitiveModule = _a.transitiveModule, id = _a.id;\n        this.type = type || null;\n        this.declaredDirectives = _normalizeArray(declaredDirectives);\n        this.exportedDirectives = _normalizeArray(exportedDirectives);\n        this.declaredPipes = _normalizeArray(declaredPipes);\n        this.exportedPipes = _normalizeArray(exportedPipes);\n        this.providers = _normalizeArray(providers);\n        this.entryComponents = _normalizeArray(entryComponents);\n        this.bootstrapComponents = _normalizeArray(bootstrapComponents);\n        this.importedModules = _normalizeArray(importedModules);\n        this.exportedModules = _normalizeArray(exportedModules);\n        this.schemas = _normalizeArray(schemas);\n        this.id = id || null;\n        this.transitiveModule = transitiveModule || null;\n    }\n    /**\n     * @return {?}\n     */\n    CompileNgModuleMetadata.prototype.toSummary = function () {\n        var /** @type {?} */ module = ((this.transitiveModule));\n        return {\n            summaryKind: CompileSummaryKind.NgModule,\n            type: this.type,\n            entryComponents: module.entryComponents,\n            providers: module.providers,\n            modules: module.modules,\n            exportedDirectives: module.exportedDirectives,\n            exportedPipes: module.exportedPipes\n        };\n    };\n    return CompileNgModuleMetadata;\n}());\nvar TransitiveCompileNgModuleMetadata = (function () {\n    function TransitiveCompileNgModuleMetadata() {\n        this.directivesSet = new Set();\n        this.directives = [];\n        this.exportedDirectivesSet = new Set();\n        this.exportedDirectives = [];\n        this.pipesSet = new Set();\n        this.pipes = [];\n        this.exportedPipesSet = new Set();\n        this.exportedPipes = [];\n        this.modulesSet = new Set();\n        this.modules = [];\n        this.entryComponentsSet = new Set();\n        this.entryComponents = [];\n        this.providers = [];\n    }\n    /**\n     * @param {?} provider\n     * @param {?} module\n     * @return {?}\n     */\n    TransitiveCompileNgModuleMetadata.prototype.addProvider = function (provider, module) {\n        this.providers.push({ provider: provider, module: module });\n    };\n    /**\n     * @param {?} id\n     * @return {?}\n     */\n    TransitiveCompileNgModuleMetadata.prototype.addDirective = function (id) {\n        if (!this.directivesSet.has(id.reference)) {\n            this.directivesSet.add(id.reference);\n            this.directives.push(id);\n        }\n    };\n    /**\n     * @param {?} id\n     * @return {?}\n     */\n    TransitiveCompileNgModuleMetadata.prototype.addExportedDirective = function (id) {\n        if (!this.exportedDirectivesSet.has(id.reference)) {\n            this.exportedDirectivesSet.add(id.reference);\n            this.exportedDirectives.push(id);\n        }\n    };\n    /**\n     * @param {?} id\n     * @return {?}\n     */\n    TransitiveCompileNgModuleMetadata.prototype.addPipe = function (id) {\n        if (!this.pipesSet.has(id.reference)) {\n            this.pipesSet.add(id.reference);\n            this.pipes.push(id);\n        }\n    };\n    /**\n     * @param {?} id\n     * @return {?}\n     */\n    TransitiveCompileNgModuleMetadata.prototype.addExportedPipe = function (id) {\n        if (!this.exportedPipesSet.has(id.reference)) {\n            this.exportedPipesSet.add(id.reference);\n            this.exportedPipes.push(id);\n        }\n    };\n    /**\n     * @param {?} id\n     * @return {?}\n     */\n    TransitiveCompileNgModuleMetadata.prototype.addModule = function (id) {\n        if (!this.modulesSet.has(id.reference)) {\n            this.modulesSet.add(id.reference);\n            this.modules.push(id);\n        }\n    };\n    /**\n     * @param {?} ec\n     * @return {?}\n     */\n    TransitiveCompileNgModuleMetadata.prototype.addEntryComponent = function (ec) {\n        if (!this.entryComponentsSet.has(ec.componentType)) {\n            this.entryComponentsSet.add(ec.componentType);\n            this.entryComponents.push(ec);\n        }\n    };\n    return TransitiveCompileNgModuleMetadata;\n}());\n/**\n * @param {?} obj\n * @return {?}\n */\nfunction _normalizeArray(obj) {\n    return obj || [];\n}\nvar ProviderMeta = (function () {\n    /**\n     * @param {?} token\n     * @param {?} __1\n     */\n    function ProviderMeta(token, _a) {\n        var useClass = _a.useClass, useValue = _a.useValue, useExisting = _a.useExisting, useFactory = _a.useFactory, deps = _a.deps, multi = _a.multi;\n        this.token = token;\n        this.useClass = useClass || null;\n        this.useValue = useValue;\n        this.useExisting = useExisting;\n        this.useFactory = useFactory || null;\n        this.dependencies = deps || null;\n        this.multi = !!multi;\n    }\n    return ProviderMeta;\n}());\n/**\n * @template T\n * @param {?} list\n * @return {?}\n */\nfunction flatten(list) {\n    return list.reduce(function (flat, item) {\n        var /** @type {?} */ flatItem = Array.isArray(item) ? flatten(item) : item;\n        return ((flat)).concat(flatItem);\n    }, []);\n}\n/**\n * @param {?} url\n * @return {?}\n */\nfunction sourceUrl(url) {\n    // Note: We need 3 \"/\" so that ng shows up as a separate domain\n    // in the chrome dev tools.\n    return url.replace(/(\\w+:\\/\\/[\\w:-]+)?(\\/+)?/, 'ng:///');\n}\n/**\n * @param {?} ngModuleType\n * @param {?} compMeta\n * @param {?} templateMeta\n * @return {?}\n */\nfunction templateSourceUrl(ngModuleType, compMeta, templateMeta) {\n    var /** @type {?} */ url;\n    if (templateMeta.isInline) {\n        if (compMeta.type.reference instanceof StaticSymbol) {\n            // Note: a .ts file might contain multiple components with inline templates,\n            // so we need to give them unique urls, as these will be used for sourcemaps.\n            url = compMeta.type.reference.filePath + \".\" + compMeta.type.reference.name + \".html\";\n        }\n        else {\n            url = identifierName(ngModuleType) + \"/\" + identifierName(compMeta.type) + \".html\";\n        }\n    }\n    else {\n        url = ((templateMeta.templateUrl));\n    }\n    // always prepend ng:// to make angular resources easy to find and not clobber\n    // user resources.\n    return sourceUrl(url);\n}\n/**\n * @param {?} meta\n * @param {?} id\n * @return {?}\n */\nfunction sharedStylesheetJitUrl(meta, id) {\n    var /** @type {?} */ pathParts = ((meta.moduleUrl)).split(/\\/\\\\/g);\n    var /** @type {?} */ baseName = pathParts[pathParts.length - 1];\n    return sourceUrl(\"css/\" + id + baseName + \".ngstyle.js\");\n}\n/**\n * @param {?} moduleMeta\n * @return {?}\n */\nfunction ngModuleJitUrl(moduleMeta) {\n    return sourceUrl(identifierName(moduleMeta.type) + \"/module.ngfactory.js\");\n}\n/**\n * @param {?} ngModuleType\n * @param {?} compMeta\n * @return {?}\n */\nfunction templateJitUrl(ngModuleType, compMeta) {\n    return sourceUrl(identifierName(ngModuleType) + \"/\" + identifierName(compMeta.type) + \".ngfactory.js\");\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Provides access to reflection data about symbols that the compiler needs.\n * @abstract\n */\nvar CompileReflector = (function () {\n    function CompileReflector() {\n    }\n    /**\n     * @abstract\n     * @param {?} typeOrFunc\n     * @return {?}\n     */\n    CompileReflector.prototype.parameters = function (typeOrFunc) { };\n    /**\n     * @abstract\n     * @param {?} typeOrFunc\n     * @return {?}\n     */\n    CompileReflector.prototype.annotations = function (typeOrFunc) { };\n    /**\n     * @abstract\n     * @param {?} typeOrFunc\n     * @return {?}\n     */\n    CompileReflector.prototype.propMetadata = function (typeOrFunc) { };\n    /**\n     * @abstract\n     * @param {?} type\n     * @param {?} lcProperty\n     * @return {?}\n     */\n    CompileReflector.prototype.hasLifecycleHook = function (type, lcProperty) { };\n    /**\n     * @abstract\n     * @param {?} type\n     * @param {?} cmpMetadata\n     * @return {?}\n     */\n    CompileReflector.prototype.componentModuleUrl = function (type, cmpMetadata) { };\n    /**\n     * @abstract\n     * @param {?} ref\n     * @return {?}\n     */\n    CompileReflector.prototype.resolveExternalReference = function (ref) { };\n    return CompileReflector;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar CompilerConfig = (function () {\n    /**\n     * @param {?=} __0\n     */\n    function CompilerConfig(_a) {\n        var _b = _a === void 0 ? {} : _a, _c = _b.defaultEncapsulation, defaultEncapsulation = _c === void 0 ? __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].Emulated : _c, _d = _b.useJit, useJit = _d === void 0 ? true : _d, missingTranslation = _b.missingTranslation, enableLegacyTemplate = _b.enableLegacyTemplate;\n        this.defaultEncapsulation = defaultEncapsulation;\n        this.useJit = !!useJit;\n        this.missingTranslation = missingTranslation || null;\n        this.enableLegacyTemplate = enableLegacyTemplate !== false;\n    }\n    return CompilerConfig;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ParserError = (function () {\n    /**\n     * @param {?} message\n     * @param {?} input\n     * @param {?} errLocation\n     * @param {?=} ctxLocation\n     */\n    function ParserError(message, input, errLocation, ctxLocation) {\n        this.input = input;\n        this.errLocation = errLocation;\n        this.ctxLocation = ctxLocation;\n        this.message = \"Parser Error: \" + message + \" \" + errLocation + \" [\" + input + \"] in \" + ctxLocation;\n    }\n    return ParserError;\n}());\nvar ParseSpan = (function () {\n    /**\n     * @param {?} start\n     * @param {?} end\n     */\n    function ParseSpan(start, end) {\n        this.start = start;\n        this.end = end;\n    }\n    return ParseSpan;\n}());\nvar AST = (function () {\n    /**\n     * @param {?} span\n     */\n    function AST(span) {\n        this.span = span;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    AST.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return null;\n    };\n    /**\n     * @return {?}\n     */\n    AST.prototype.toString = function () { return 'AST'; };\n    return AST;\n}());\n/**\n * Represents a quoted expression of the form:\n *\n * quote = prefix `:` uninterpretedExpression\n * prefix = identifier\n * uninterpretedExpression = arbitrary string\n *\n * A quoted expression is meant to be pre-processed by an AST transformer that\n * converts it into another AST that no longer contains quoted expressions.\n * It is meant to allow third-party developers to extend Angular template\n * expression language. The `uninterpretedExpression` part of the quote is\n * therefore not interpreted by the Angular's own expression parser.\n */\nvar Quote = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](Quote, _super);\n    /**\n     * @param {?} span\n     * @param {?} prefix\n     * @param {?} uninterpretedExpression\n     * @param {?} location\n     */\n    function Quote(span, prefix, uninterpretedExpression, location) {\n        var _this = _super.call(this, span) || this;\n        _this.prefix = prefix;\n        _this.uninterpretedExpression = uninterpretedExpression;\n        _this.location = location;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    Quote.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitQuote(this, context);\n    };\n    /**\n     * @return {?}\n     */\n    Quote.prototype.toString = function () { return 'Quote'; };\n    return Quote;\n}(AST));\nvar EmptyExpr = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](EmptyExpr, _super);\n    function EmptyExpr() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    EmptyExpr.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        // do nothing\n    };\n    return EmptyExpr;\n}(AST));\nvar ImplicitReceiver = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](ImplicitReceiver, _super);\n    function ImplicitReceiver() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    ImplicitReceiver.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitImplicitReceiver(this, context);\n    };\n    return ImplicitReceiver;\n}(AST));\n/**\n * Multiple expressions separated by a semicolon.\n */\nvar Chain = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](Chain, _super);\n    /**\n     * @param {?} span\n     * @param {?} expressions\n     */\n    function Chain(span, expressions) {\n        var _this = _super.call(this, span) || this;\n        _this.expressions = expressions;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    Chain.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitChain(this, context);\n    };\n    return Chain;\n}(AST));\nvar Conditional = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](Conditional, _super);\n    /**\n     * @param {?} span\n     * @param {?} condition\n     * @param {?} trueExp\n     * @param {?} falseExp\n     */\n    function Conditional(span, condition, trueExp, falseExp) {\n        var _this = _super.call(this, span) || this;\n        _this.condition = condition;\n        _this.trueExp = trueExp;\n        _this.falseExp = falseExp;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    Conditional.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitConditional(this, context);\n    };\n    return Conditional;\n}(AST));\nvar PropertyRead = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](PropertyRead, _super);\n    /**\n     * @param {?} span\n     * @param {?} receiver\n     * @param {?} name\n     */\n    function PropertyRead(span, receiver, name) {\n        var _this = _super.call(this, span) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    PropertyRead.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitPropertyRead(this, context);\n    };\n    return PropertyRead;\n}(AST));\nvar PropertyWrite = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](PropertyWrite, _super);\n    /**\n     * @param {?} span\n     * @param {?} receiver\n     * @param {?} name\n     * @param {?} value\n     */\n    function PropertyWrite(span, receiver, name, value) {\n        var _this = _super.call(this, span) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    PropertyWrite.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitPropertyWrite(this, context);\n    };\n    return PropertyWrite;\n}(AST));\nvar SafePropertyRead = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](SafePropertyRead, _super);\n    /**\n     * @param {?} span\n     * @param {?} receiver\n     * @param {?} name\n     */\n    function SafePropertyRead(span, receiver, name) {\n        var _this = _super.call(this, span) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    SafePropertyRead.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitSafePropertyRead(this, context);\n    };\n    return SafePropertyRead;\n}(AST));\nvar KeyedRead = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](KeyedRead, _super);\n    /**\n     * @param {?} span\n     * @param {?} obj\n     * @param {?} key\n     */\n    function KeyedRead(span, obj, key) {\n        var _this = _super.call(this, span) || this;\n        _this.obj = obj;\n        _this.key = key;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    KeyedRead.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitKeyedRead(this, context);\n    };\n    return KeyedRead;\n}(AST));\nvar KeyedWrite = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](KeyedWrite, _super);\n    /**\n     * @param {?} span\n     * @param {?} obj\n     * @param {?} key\n     * @param {?} value\n     */\n    function KeyedWrite(span, obj, key, value) {\n        var _this = _super.call(this, span) || this;\n        _this.obj = obj;\n        _this.key = key;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    KeyedWrite.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitKeyedWrite(this, context);\n    };\n    return KeyedWrite;\n}(AST));\nvar BindingPipe = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](BindingPipe, _super);\n    /**\n     * @param {?} span\n     * @param {?} exp\n     * @param {?} name\n     * @param {?} args\n     */\n    function BindingPipe(span, exp, name, args) {\n        var _this = _super.call(this, span) || this;\n        _this.exp = exp;\n        _this.name = name;\n        _this.args = args;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    BindingPipe.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitPipe(this, context);\n    };\n    return BindingPipe;\n}(AST));\nvar LiteralPrimitive = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](LiteralPrimitive, _super);\n    /**\n     * @param {?} span\n     * @param {?} value\n     */\n    function LiteralPrimitive(span, value) {\n        var _this = _super.call(this, span) || this;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    LiteralPrimitive.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitLiteralPrimitive(this, context);\n    };\n    return LiteralPrimitive;\n}(AST));\nvar LiteralArray = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](LiteralArray, _super);\n    /**\n     * @param {?} span\n     * @param {?} expressions\n     */\n    function LiteralArray(span, expressions) {\n        var _this = _super.call(this, span) || this;\n        _this.expressions = expressions;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    LiteralArray.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitLiteralArray(this, context);\n    };\n    return LiteralArray;\n}(AST));\nvar LiteralMap = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](LiteralMap, _super);\n    /**\n     * @param {?} span\n     * @param {?} keys\n     * @param {?} values\n     */\n    function LiteralMap(span, keys, values) {\n        var _this = _super.call(this, span) || this;\n        _this.keys = keys;\n        _this.values = values;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    LiteralMap.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitLiteralMap(this, context);\n    };\n    return LiteralMap;\n}(AST));\nvar Interpolation = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](Interpolation, _super);\n    /**\n     * @param {?} span\n     * @param {?} strings\n     * @param {?} expressions\n     */\n    function Interpolation(span, strings, expressions) {\n        var _this = _super.call(this, span) || this;\n        _this.strings = strings;\n        _this.expressions = expressions;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    Interpolation.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitInterpolation(this, context);\n    };\n    return Interpolation;\n}(AST));\nvar Binary = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](Binary, _super);\n    /**\n     * @param {?} span\n     * @param {?} operation\n     * @param {?} left\n     * @param {?} right\n     */\n    function Binary(span, operation, left, right) {\n        var _this = _super.call(this, span) || this;\n        _this.operation = operation;\n        _this.left = left;\n        _this.right = right;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    Binary.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitBinary(this, context);\n    };\n    return Binary;\n}(AST));\nvar PrefixNot = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](PrefixNot, _super);\n    /**\n     * @param {?} span\n     * @param {?} expression\n     */\n    function PrefixNot(span, expression) {\n        var _this = _super.call(this, span) || this;\n        _this.expression = expression;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    PrefixNot.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitPrefixNot(this, context);\n    };\n    return PrefixNot;\n}(AST));\nvar NonNullAssert = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](NonNullAssert, _super);\n    /**\n     * @param {?} span\n     * @param {?} expression\n     */\n    function NonNullAssert(span, expression) {\n        var _this = _super.call(this, span) || this;\n        _this.expression = expression;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    NonNullAssert.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitNonNullAssert(this, context);\n    };\n    return NonNullAssert;\n}(AST));\nvar MethodCall = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MethodCall, _super);\n    /**\n     * @param {?} span\n     * @param {?} receiver\n     * @param {?} name\n     * @param {?} args\n     */\n    function MethodCall(span, receiver, name, args) {\n        var _this = _super.call(this, span) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        _this.args = args;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    MethodCall.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitMethodCall(this, context);\n    };\n    return MethodCall;\n}(AST));\nvar SafeMethodCall = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](SafeMethodCall, _super);\n    /**\n     * @param {?} span\n     * @param {?} receiver\n     * @param {?} name\n     * @param {?} args\n     */\n    function SafeMethodCall(span, receiver, name, args) {\n        var _this = _super.call(this, span) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        _this.args = args;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    SafeMethodCall.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitSafeMethodCall(this, context);\n    };\n    return SafeMethodCall;\n}(AST));\nvar FunctionCall = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](FunctionCall, _super);\n    /**\n     * @param {?} span\n     * @param {?} target\n     * @param {?} args\n     */\n    function FunctionCall(span, target, args) {\n        var _this = _super.call(this, span) || this;\n        _this.target = target;\n        _this.args = args;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    FunctionCall.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitFunctionCall(this, context);\n    };\n    return FunctionCall;\n}(AST));\nvar ASTWithSource = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](ASTWithSource, _super);\n    /**\n     * @param {?} ast\n     * @param {?} source\n     * @param {?} location\n     * @param {?} errors\n     */\n    function ASTWithSource(ast, source, location, errors) {\n        var _this = _super.call(this, new ParseSpan(0, source == null ? 0 : source.length)) || this;\n        _this.ast = ast;\n        _this.source = source;\n        _this.location = location;\n        _this.errors = errors;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    ASTWithSource.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return this.ast.visit(visitor, context);\n    };\n    /**\n     * @return {?}\n     */\n    ASTWithSource.prototype.toString = function () { return this.source + \" in \" + this.location; };\n    return ASTWithSource;\n}(AST));\nvar TemplateBinding = (function () {\n    /**\n     * @param {?} span\n     * @param {?} key\n     * @param {?} keyIsVar\n     * @param {?} name\n     * @param {?} expression\n     */\n    function TemplateBinding(span, key, keyIsVar, name, expression) {\n        this.span = span;\n        this.key = key;\n        this.keyIsVar = keyIsVar;\n        this.name = name;\n        this.expression = expression;\n    }\n    return TemplateBinding;\n}());\nvar NullAstVisitor = (function () {\n    function NullAstVisitor() {\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    NullAstVisitor.prototype.visitBinary = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    NullAstVisitor.prototype.visitChain = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    NullAstVisitor.prototype.visitConditional = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    NullAstVisitor.prototype.visitFunctionCall = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    NullAstVisitor.prototype.visitImplicitReceiver = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    NullAstVisitor.prototype.visitInterpolation = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    NullAstVisitor.prototype.visitKeyedRead = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    NullAstVisitor.prototype.visitKeyedWrite = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    NullAstVisitor.prototype.visitLiteralArray = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    NullAstVisitor.prototype.visitLiteralMap = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    NullAstVisitor.prototype.visitLiteralPrimitive = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    NullAstVisitor.prototype.visitMethodCall = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    NullAstVisitor.prototype.visitPipe = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    NullAstVisitor.prototype.visitPrefixNot = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    NullAstVisitor.prototype.visitNonNullAssert = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    NullAstVisitor.prototype.visitPropertyRead = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    NullAstVisitor.prototype.visitPropertyWrite = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    NullAstVisitor.prototype.visitQuote = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    NullAstVisitor.prototype.visitSafeMethodCall = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    NullAstVisitor.prototype.visitSafePropertyRead = function (ast, context) { };\n    return NullAstVisitor;\n}());\nvar RecursiveAstVisitor = (function () {\n    function RecursiveAstVisitor() {\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitBinary = function (ast, context) {\n        ast.left.visit(this);\n        ast.right.visit(this);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitChain = function (ast, context) { return this.visitAll(ast.expressions, context); };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitConditional = function (ast, context) {\n        ast.condition.visit(this);\n        ast.trueExp.visit(this);\n        ast.falseExp.visit(this);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitPipe = function (ast, context) {\n        ast.exp.visit(this);\n        this.visitAll(ast.args, context);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitFunctionCall = function (ast, context) {\n        ((ast.target)).visit(this);\n        this.visitAll(ast.args, context);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitImplicitReceiver = function (ast, context) { return null; };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitInterpolation = function (ast, context) {\n        return this.visitAll(ast.expressions, context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitKeyedRead = function (ast, context) {\n        ast.obj.visit(this);\n        ast.key.visit(this);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitKeyedWrite = function (ast, context) {\n        ast.obj.visit(this);\n        ast.key.visit(this);\n        ast.value.visit(this);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitLiteralArray = function (ast, context) {\n        return this.visitAll(ast.expressions, context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitLiteralMap = function (ast, context) { return this.visitAll(ast.values, context); };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitLiteralPrimitive = function (ast, context) { return null; };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitMethodCall = function (ast, context) {\n        ast.receiver.visit(this);\n        return this.visitAll(ast.args, context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitPrefixNot = function (ast, context) {\n        ast.expression.visit(this);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitNonNullAssert = function (ast, context) {\n        ast.expression.visit(this);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitPropertyRead = function (ast, context) {\n        ast.receiver.visit(this);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitPropertyWrite = function (ast, context) {\n        ast.receiver.visit(this);\n        ast.value.visit(this);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitSafePropertyRead = function (ast, context) {\n        ast.receiver.visit(this);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitSafeMethodCall = function (ast, context) {\n        ast.receiver.visit(this);\n        return this.visitAll(ast.args, context);\n    };\n    /**\n     * @param {?} asts\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitAll = function (asts, context) {\n        var _this = this;\n        asts.forEach(function (ast) { return ast.visit(_this, context); });\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitQuote = function (ast, context) { return null; };\n    return RecursiveAstVisitor;\n}());\nvar AstTransformer = (function () {\n    function AstTransformer() {\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitImplicitReceiver = function (ast, context) { return ast; };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitInterpolation = function (ast, context) {\n        return new Interpolation(ast.span, ast.strings, this.visitAll(ast.expressions));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitLiteralPrimitive = function (ast, context) {\n        return new LiteralPrimitive(ast.span, ast.value);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitPropertyRead = function (ast, context) {\n        return new PropertyRead(ast.span, ast.receiver.visit(this), ast.name);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitPropertyWrite = function (ast, context) {\n        return new PropertyWrite(ast.span, ast.receiver.visit(this), ast.name, ast.value.visit(this));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitSafePropertyRead = function (ast, context) {\n        return new SafePropertyRead(ast.span, ast.receiver.visit(this), ast.name);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitMethodCall = function (ast, context) {\n        return new MethodCall(ast.span, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitSafeMethodCall = function (ast, context) {\n        return new SafeMethodCall(ast.span, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitFunctionCall = function (ast, context) {\n        return new FunctionCall(ast.span, /** @type {?} */ ((ast.target)).visit(this), this.visitAll(ast.args));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitLiteralArray = function (ast, context) {\n        return new LiteralArray(ast.span, this.visitAll(ast.expressions));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitLiteralMap = function (ast, context) {\n        return new LiteralMap(ast.span, ast.keys, this.visitAll(ast.values));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitBinary = function (ast, context) {\n        return new Binary(ast.span, ast.operation, ast.left.visit(this), ast.right.visit(this));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitPrefixNot = function (ast, context) {\n        return new PrefixNot(ast.span, ast.expression.visit(this));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitNonNullAssert = function (ast, context) {\n        return new NonNullAssert(ast.span, ast.expression.visit(this));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitConditional = function (ast, context) {\n        return new Conditional(ast.span, ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitPipe = function (ast, context) {\n        return new BindingPipe(ast.span, ast.exp.visit(this), ast.name, this.visitAll(ast.args));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitKeyedRead = function (ast, context) {\n        return new KeyedRead(ast.span, ast.obj.visit(this), ast.key.visit(this));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitKeyedWrite = function (ast, context) {\n        return new KeyedWrite(ast.span, ast.obj.visit(this), ast.key.visit(this), ast.value.visit(this));\n    };\n    /**\n     * @param {?} asts\n     * @return {?}\n     */\n    AstTransformer.prototype.visitAll = function (asts) {\n        var /** @type {?} */ res = new Array(asts.length);\n        for (var /** @type {?} */ i = 0; i < asts.length; ++i) {\n            res[i] = asts[i].visit(this);\n        }\n        return res;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitChain = function (ast, context) {\n        return new Chain(ast.span, this.visitAll(ast.expressions));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitQuote = function (ast, context) {\n        return new Quote(ast.span, ast.prefix, ast.uninterpretedExpression, ast.location);\n    };\n    return AstTransformer;\n}());\n/**\n * @param {?} ast\n * @param {?} visitor\n * @param {?=} context\n * @return {?}\n */\nfunction visitAstChildren(ast, visitor, context) {\n    /**\n     * @param {?} ast\n     * @return {?}\n     */\n    function visit(ast) {\n        visitor.visit && visitor.visit(ast, context) || ast.visit(visitor, context);\n    }\n    /**\n     * @template T\n     * @param {?} asts\n     * @return {?}\n     */\n    function visitAll(asts) { asts.forEach(visit); }\n    ast.visit({\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitBinary: function (ast) {\n            visit(ast.left);\n            visit(ast.right);\n        },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitChain: function (ast) { visitAll(ast.expressions); },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitConditional: function (ast) {\n            visit(ast.condition);\n            visit(ast.trueExp);\n            visit(ast.falseExp);\n        },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitFunctionCall: function (ast) {\n            if (ast.target) {\n                visit(ast.target);\n            }\n            visitAll(ast.args);\n        },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitImplicitReceiver: function (ast) { },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitInterpolation: function (ast) { visitAll(ast.expressions); },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitKeyedRead: function (ast) {\n            visit(ast.obj);\n            visit(ast.key);\n        },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitKeyedWrite: function (ast) {\n            visit(ast.obj);\n            visit(ast.key);\n            visit(ast.obj);\n        },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitLiteralArray: function (ast) { visitAll(ast.expressions); },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitLiteralMap: function (ast) { },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitLiteralPrimitive: function (ast) { },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitMethodCall: function (ast) {\n            visit(ast.receiver);\n            visitAll(ast.args);\n        },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitPipe: function (ast) {\n            visit(ast.exp);\n            visitAll(ast.args);\n        },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitPrefixNot: function (ast) { visit(ast.expression); },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitNonNullAssert: function (ast) { visit(ast.expression); },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitPropertyRead: function (ast) { visit(ast.receiver); },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitPropertyWrite: function (ast) {\n            visit(ast.receiver);\n            visit(ast.value);\n        },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitQuote: function (ast) { },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitSafeMethodCall: function (ast) {\n            visit(ast.receiver);\n            visitAll(ast.args);\n        },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitSafePropertyRead: function (ast) { visit(ast.receiver); },\n    });\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar $EOF = 0;\nvar $TAB = 9;\nvar $LF = 10;\nvar $VTAB = 11;\nvar $FF = 12;\nvar $CR = 13;\nvar $SPACE = 32;\nvar $BANG = 33;\nvar $DQ = 34;\nvar $HASH = 35;\nvar $$ = 36;\nvar $PERCENT = 37;\nvar $AMPERSAND = 38;\nvar $SQ = 39;\nvar $LPAREN = 40;\nvar $RPAREN = 41;\nvar $STAR = 42;\nvar $PLUS = 43;\nvar $COMMA = 44;\nvar $MINUS = 45;\nvar $PERIOD = 46;\nvar $SLASH = 47;\nvar $COLON = 58;\nvar $SEMICOLON = 59;\nvar $LT = 60;\nvar $EQ = 61;\nvar $GT = 62;\nvar $QUESTION = 63;\nvar $0 = 48;\nvar $9 = 57;\nvar $A = 65;\nvar $E = 69;\nvar $F = 70;\nvar $X = 88;\nvar $Z = 90;\nvar $LBRACKET = 91;\nvar $BACKSLASH = 92;\nvar $RBRACKET = 93;\nvar $CARET = 94;\nvar $_ = 95;\nvar $a = 97;\nvar $e = 101;\nvar $f = 102;\nvar $n = 110;\nvar $r = 114;\nvar $t = 116;\nvar $u = 117;\nvar $v = 118;\nvar $x = 120;\nvar $z = 122;\nvar $LBRACE = 123;\nvar $BAR = 124;\nvar $RBRACE = 125;\nvar $NBSP = 160;\nvar $BT = 96;\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isWhitespace(code) {\n    return (code >= $TAB && code <= $SPACE) || (code == $NBSP);\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isDigit(code) {\n    return $0 <= code && code <= $9;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isAsciiLetter(code) {\n    return code >= $a && code <= $z || code >= $A && code <= $Z;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isAsciiHexDigit(code) {\n    return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);\n}\n/**\n * A replacement for \\@Injectable to be used in the compiler, so that\n * we don't try to evaluate the metadata in the compiler during AoT.\n * This decorator is enough to make the compiler work with the ReflectiveInjector though.\n * \\@Annotation\n * @return {?}\n */\nfunction CompilerInjectable() {\n    return function (x) { return x; };\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} identifier\n * @param {?} value\n * @return {?}\n */\nfunction assertArrayOfStrings(identifier, value) {\n    if (!Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"isDevMode\"])() || value == null) {\n        return;\n    }\n    if (!Array.isArray(value)) {\n        throw new Error(\"Expected '\" + identifier + \"' to be an array of strings.\");\n    }\n    for (var /** @type {?} */ i = 0; i < value.length; i += 1) {\n        if (typeof value[i] !== 'string') {\n            throw new Error(\"Expected '\" + identifier + \"' to be an array of strings.\");\n        }\n    }\n}\nvar INTERPOLATION_BLACKLIST_REGEXPS = [\n    /^\\s*$/,\n    /[<>]/,\n    /^[{}]$/,\n    /&(#|[a-z])/i,\n    /^\\/\\//,\n];\n/**\n * @param {?} identifier\n * @param {?} value\n * @return {?}\n */\nfunction assertInterpolationSymbols(identifier, value) {\n    if (value != null && !(Array.isArray(value) && value.length == 2)) {\n        throw new Error(\"Expected '\" + identifier + \"' to be an array, [start, end].\");\n    }\n    else if (Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"isDevMode\"])() && value != null) {\n        var /** @type {?} */ start_1 = (value[0]);\n        var /** @type {?} */ end_1 = (value[1]);\n        // black list checking\n        INTERPOLATION_BLACKLIST_REGEXPS.forEach(function (regexp) {\n            if (regexp.test(start_1) || regexp.test(end_1)) {\n                throw new Error(\"['\" + start_1 + \"', '\" + end_1 + \"'] contains unusable interpolation symbol.\");\n            }\n        });\n    }\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar InterpolationConfig = (function () {\n    /**\n     * @param {?} start\n     * @param {?} end\n     */\n    function InterpolationConfig(start, end) {\n        this.start = start;\n        this.end = end;\n    }\n    /**\n     * @param {?} markers\n     * @return {?}\n     */\n    InterpolationConfig.fromArray = function (markers) {\n        if (!markers) {\n            return DEFAULT_INTERPOLATION_CONFIG;\n        }\n        assertInterpolationSymbols('interpolation', markers);\n        return new InterpolationConfig(markers[0], markers[1]);\n    };\n    ;\n    return InterpolationConfig;\n}());\nvar DEFAULT_INTERPOLATION_CONFIG = new InterpolationConfig('{{', '}}');\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TokenType = {};\nTokenType.Character = 0;\nTokenType.Identifier = 1;\nTokenType.Keyword = 2;\nTokenType.String = 3;\nTokenType.Operator = 4;\nTokenType.Number = 5;\nTokenType.Error = 6;\nTokenType[TokenType.Character] = \"Character\";\nTokenType[TokenType.Identifier] = \"Identifier\";\nTokenType[TokenType.Keyword] = \"Keyword\";\nTokenType[TokenType.String] = \"String\";\nTokenType[TokenType.Operator] = \"Operator\";\nTokenType[TokenType.Number] = \"Number\";\nTokenType[TokenType.Error] = \"Error\";\nvar KEYWORDS = ['var', 'let', 'as', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];\nvar Lexer = (function () {\n    function Lexer() {\n    }\n    /**\n     * @param {?} text\n     * @return {?}\n     */\n    Lexer.prototype.tokenize = function (text) {\n        var /** @type {?} */ scanner = new _Scanner(text);\n        var /** @type {?} */ tokens = [];\n        var /** @type {?} */ token = scanner.scanToken();\n        while (token != null) {\n            tokens.push(token);\n            token = scanner.scanToken();\n        }\n        return tokens;\n    };\n    return Lexer;\n}());\nLexer.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nLexer.ctorParameters = function () { return []; };\nvar Token = (function () {\n    /**\n     * @param {?} index\n     * @param {?} type\n     * @param {?} numValue\n     * @param {?} strValue\n     */\n    function Token(index, type, numValue, strValue) {\n        this.index = index;\n        this.type = type;\n        this.numValue = numValue;\n        this.strValue = strValue;\n    }\n    /**\n     * @param {?} code\n     * @return {?}\n     */\n    Token.prototype.isCharacter = function (code) {\n        return this.type == TokenType.Character && this.numValue == code;\n    };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isNumber = function () { return this.type == TokenType.Number; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isString = function () { return this.type == TokenType.String; };\n    /**\n     * @param {?} operater\n     * @return {?}\n     */\n    Token.prototype.isOperator = function (operater) {\n        return this.type == TokenType.Operator && this.strValue == operater;\n    };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isIdentifier = function () { return this.type == TokenType.Identifier; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isKeyword = function () { return this.type == TokenType.Keyword; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isKeywordLet = function () { return this.type == TokenType.Keyword && this.strValue == 'let'; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isKeywordAs = function () { return this.type == TokenType.Keyword && this.strValue == 'as'; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isKeywordNull = function () { return this.type == TokenType.Keyword && this.strValue == 'null'; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isKeywordUndefined = function () {\n        return this.type == TokenType.Keyword && this.strValue == 'undefined';\n    };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isKeywordTrue = function () { return this.type == TokenType.Keyword && this.strValue == 'true'; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isKeywordFalse = function () { return this.type == TokenType.Keyword && this.strValue == 'false'; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isKeywordThis = function () { return this.type == TokenType.Keyword && this.strValue == 'this'; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isError = function () { return this.type == TokenType.Error; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.toNumber = function () { return this.type == TokenType.Number ? this.numValue : -1; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.toString = function () {\n        switch (this.type) {\n            case TokenType.Character:\n            case TokenType.Identifier:\n            case TokenType.Keyword:\n            case TokenType.Operator:\n            case TokenType.String:\n            case TokenType.Error:\n                return this.strValue;\n            case TokenType.Number:\n                return this.numValue.toString();\n            default:\n                return null;\n        }\n    };\n    return Token;\n}());\n/**\n * @param {?} index\n * @param {?} code\n * @return {?}\n */\nfunction newCharacterToken(index, code) {\n    return new Token(index, TokenType.Character, code, String.fromCharCode(code));\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newIdentifierToken(index, text) {\n    return new Token(index, TokenType.Identifier, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newKeywordToken(index, text) {\n    return new Token(index, TokenType.Keyword, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newOperatorToken(index, text) {\n    return new Token(index, TokenType.Operator, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newStringToken(index, text) {\n    return new Token(index, TokenType.String, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} n\n * @return {?}\n */\nfunction newNumberToken(index, n) {\n    return new Token(index, TokenType.Number, n, '');\n}\n/**\n * @param {?} index\n * @param {?} message\n * @return {?}\n */\nfunction newErrorToken(index, message) {\n    return new Token(index, TokenType.Error, 0, message);\n}\nvar EOF = new Token(-1, TokenType.Character, 0, '');\nvar _Scanner = (function () {\n    /**\n     * @param {?} input\n     */\n    function _Scanner(input) {\n        this.input = input;\n        this.peek = 0;\n        this.index = -1;\n        this.length = input.length;\n        this.advance();\n    }\n    /**\n     * @return {?}\n     */\n    _Scanner.prototype.advance = function () {\n        this.peek = ++this.index >= this.length ? $EOF : this.input.charCodeAt(this.index);\n    };\n    /**\n     * @return {?}\n     */\n    _Scanner.prototype.scanToken = function () {\n        var /** @type {?} */ input = this.input, /** @type {?} */ length = this.length;\n        var /** @type {?} */ peek = this.peek, /** @type {?} */ index = this.index;\n        // Skip whitespace.\n        while (peek <= $SPACE) {\n            if (++index >= length) {\n                peek = $EOF;\n                break;\n            }\n            else {\n                peek = input.charCodeAt(index);\n            }\n        }\n        this.peek = peek;\n        this.index = index;\n        if (index >= length) {\n            return null;\n        }\n        // Handle identifiers and numbers.\n        if (isIdentifierStart(peek))\n            return this.scanIdentifier();\n        if (isDigit(peek))\n            return this.scanNumber(index);\n        var /** @type {?} */ start = index;\n        switch (peek) {\n            case $PERIOD:\n                this.advance();\n                return isDigit(this.peek) ? this.scanNumber(start) :\n                    newCharacterToken(start, $PERIOD);\n            case $LPAREN:\n            case $RPAREN:\n            case $LBRACE:\n            case $RBRACE:\n            case $LBRACKET:\n            case $RBRACKET:\n            case $COMMA:\n            case $COLON:\n            case $SEMICOLON:\n                return this.scanCharacter(start, peek);\n            case $SQ:\n            case $DQ:\n                return this.scanString();\n            case $HASH:\n            case $PLUS:\n            case $MINUS:\n            case $STAR:\n            case $SLASH:\n            case $PERCENT:\n            case $CARET:\n                return this.scanOperator(start, String.fromCharCode(peek));\n            case $QUESTION:\n                return this.scanComplexOperator(start, '?', $PERIOD, '.');\n            case $LT:\n            case $GT:\n                return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=');\n            case $BANG:\n            case $EQ:\n                return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=', $EQ, '=');\n            case $AMPERSAND:\n                return this.scanComplexOperator(start, '&', $AMPERSAND, '&');\n            case $BAR:\n                return this.scanComplexOperator(start, '|', $BAR, '|');\n            case $NBSP:\n                while (isWhitespace(this.peek))\n                    this.advance();\n                return this.scanToken();\n        }\n        this.advance();\n        return this.error(\"Unexpected character [\" + String.fromCharCode(peek) + \"]\", 0);\n    };\n    /**\n     * @param {?} start\n     * @param {?} code\n     * @return {?}\n     */\n    _Scanner.prototype.scanCharacter = function (start, code) {\n        this.advance();\n        return newCharacterToken(start, code);\n    };\n    /**\n     * @param {?} start\n     * @param {?} str\n     * @return {?}\n     */\n    _Scanner.prototype.scanOperator = function (start, str) {\n        this.advance();\n        return newOperatorToken(start, str);\n    };\n    /**\n     * Tokenize a 2/3 char long operator\n     *\n     * @param {?} start start index in the expression\n     * @param {?} one first symbol (always part of the operator)\n     * @param {?} twoCode code point for the second symbol\n     * @param {?} two second symbol (part of the operator when the second code point matches)\n     * @param {?=} threeCode code point for the third symbol\n     * @param {?=} three third symbol (part of the operator when provided and matches source expression)\n     * @return {?}\n     */\n    _Scanner.prototype.scanComplexOperator = function (start, one, twoCode, two, threeCode, three) {\n        this.advance();\n        var /** @type {?} */ str = one;\n        if (this.peek == twoCode) {\n            this.advance();\n            str += two;\n        }\n        if (threeCode != null && this.peek == threeCode) {\n            this.advance();\n            str += three;\n        }\n        return newOperatorToken(start, str);\n    };\n    /**\n     * @return {?}\n     */\n    _Scanner.prototype.scanIdentifier = function () {\n        var /** @type {?} */ start = this.index;\n        this.advance();\n        while (isIdentifierPart(this.peek))\n            this.advance();\n        var /** @type {?} */ str = this.input.substring(start, this.index);\n        return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, str) :\n            newIdentifierToken(start, str);\n    };\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _Scanner.prototype.scanNumber = function (start) {\n        var /** @type {?} */ simple = (this.index === start);\n        this.advance(); // Skip initial digit.\n        while (true) {\n            if (isDigit(this.peek)) {\n                // Do nothing.\n            }\n            else if (this.peek == $PERIOD) {\n                simple = false;\n            }\n            else if (isExponentStart(this.peek)) {\n                this.advance();\n                if (isExponentSign(this.peek))\n                    this.advance();\n                if (!isDigit(this.peek))\n                    return this.error('Invalid exponent', -1);\n                simple = false;\n            }\n            else {\n                break;\n            }\n            this.advance();\n        }\n        var /** @type {?} */ str = this.input.substring(start, this.index);\n        var /** @type {?} */ value = simple ? parseIntAutoRadix(str) : parseFloat(str);\n        return newNumberToken(start, value);\n    };\n    /**\n     * @return {?}\n     */\n    _Scanner.prototype.scanString = function () {\n        var /** @type {?} */ start = this.index;\n        var /** @type {?} */ quote = this.peek;\n        this.advance(); // Skip initial quote.\n        var /** @type {?} */ buffer = '';\n        var /** @type {?} */ marker = this.index;\n        var /** @type {?} */ input = this.input;\n        while (this.peek != quote) {\n            if (this.peek == $BACKSLASH) {\n                buffer += input.substring(marker, this.index);\n                this.advance();\n                var /** @type {?} */ unescapedCode = void 0;\n                // Workaround for TS2.1-introduced type strictness\n                this.peek = this.peek;\n                if (this.peek == $u) {\n                    // 4 character hex code for unicode character.\n                    var /** @type {?} */ hex = input.substring(this.index + 1, this.index + 5);\n                    if (/^[0-9a-f]+$/i.test(hex)) {\n                        unescapedCode = parseInt(hex, 16);\n                    }\n                    else {\n                        return this.error(\"Invalid unicode escape [\\\\u\" + hex + \"]\", 0);\n                    }\n                    for (var /** @type {?} */ i = 0; i < 5; i++) {\n                        this.advance();\n                    }\n                }\n                else {\n                    unescapedCode = unescape(this.peek);\n                    this.advance();\n                }\n                buffer += String.fromCharCode(unescapedCode);\n                marker = this.index;\n            }\n            else if (this.peek == $EOF) {\n                return this.error('Unterminated quote', 0);\n            }\n            else {\n                this.advance();\n            }\n        }\n        var /** @type {?} */ last = input.substring(marker, this.index);\n        this.advance(); // Skip terminating quote.\n        return newStringToken(start, buffer + last);\n    };\n    /**\n     * @param {?} message\n     * @param {?} offset\n     * @return {?}\n     */\n    _Scanner.prototype.error = function (message, offset) {\n        var /** @type {?} */ position = this.index + offset;\n        return newErrorToken(position, \"Lexer Error: \" + message + \" at column \" + position + \" in expression [\" + this.input + \"]\");\n    };\n    return _Scanner;\n}());\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isIdentifierStart(code) {\n    return ($a <= code && code <= $z) || ($A <= code && code <= $Z) ||\n        (code == $_) || (code == $$);\n}\n/**\n * @param {?} input\n * @return {?}\n */\nfunction isIdentifier(input) {\n    if (input.length == 0)\n        return false;\n    var /** @type {?} */ scanner = new _Scanner(input);\n    if (!isIdentifierStart(scanner.peek))\n        return false;\n    scanner.advance();\n    while (scanner.peek !== $EOF) {\n        if (!isIdentifierPart(scanner.peek))\n            return false;\n        scanner.advance();\n    }\n    return true;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isIdentifierPart(code) {\n    return isAsciiLetter(code) || isDigit(code) || (code == $_) ||\n        (code == $$);\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isExponentStart(code) {\n    return code == $e || code == $E;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isExponentSign(code) {\n    return code == $MINUS || code == $PLUS;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isQuote(code) {\n    return code === $SQ || code === $DQ || code === $BT;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction unescape(code) {\n    switch (code) {\n        case $n:\n            return $LF;\n        case $f:\n            return $FF;\n        case $r:\n            return $CR;\n        case $t:\n            return $TAB;\n        case $v:\n            return $VTAB;\n        default:\n            return code;\n    }\n}\n/**\n * @param {?} text\n * @return {?}\n */\nfunction parseIntAutoRadix(text) {\n    var /** @type {?} */ result = parseInt(text);\n    if (isNaN(result)) {\n        throw new Error('Invalid integer literal when parsing ' + text);\n    }\n    return result;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar SplitInterpolation = (function () {\n    /**\n     * @param {?} strings\n     * @param {?} expressions\n     * @param {?} offsets\n     */\n    function SplitInterpolation(strings, expressions, offsets) {\n        this.strings = strings;\n        this.expressions = expressions;\n        this.offsets = offsets;\n    }\n    return SplitInterpolation;\n}());\nvar TemplateBindingParseResult = (function () {\n    /**\n     * @param {?} templateBindings\n     * @param {?} warnings\n     * @param {?} errors\n     */\n    function TemplateBindingParseResult(templateBindings, warnings, errors) {\n        this.templateBindings = templateBindings;\n        this.warnings = warnings;\n        this.errors = errors;\n    }\n    return TemplateBindingParseResult;\n}());\n/**\n * @param {?} config\n * @return {?}\n */\nfunction _createInterpolateRegExp(config) {\n    var /** @type {?} */ pattern = escapeRegExp(config.start) + '([\\\\s\\\\S]*?)' + escapeRegExp(config.end);\n    return new RegExp(pattern, 'g');\n}\nvar Parser = (function () {\n    /**\n     * @param {?} _lexer\n     */\n    function Parser(_lexer) {\n        this._lexer = _lexer;\n        this.errors = [];\n    }\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    Parser.prototype.parseAction = function (input, location, interpolationConfig) {\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        this._checkNoInterpolation(input, location, interpolationConfig);\n        var /** @type {?} */ sourceToLex = this._stripComments(input);\n        var /** @type {?} */ tokens = this._lexer.tokenize(this._stripComments(input));\n        var /** @type {?} */ ast = new _ParseAST(input, location, tokens, sourceToLex.length, true, this.errors, input.length - sourceToLex.length)\n            .parseChain();\n        return new ASTWithSource(ast, input, location, this.errors);\n    };\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    Parser.prototype.parseBinding = function (input, location, interpolationConfig) {\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        var /** @type {?} */ ast = this._parseBindingAst(input, location, interpolationConfig);\n        return new ASTWithSource(ast, input, location, this.errors);\n    };\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    Parser.prototype.parseSimpleBinding = function (input, location, interpolationConfig) {\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        var /** @type {?} */ ast = this._parseBindingAst(input, location, interpolationConfig);\n        var /** @type {?} */ errors = SimpleExpressionChecker.check(ast);\n        if (errors.length > 0) {\n            this._reportError(\"Host binding expression cannot contain \" + errors.join(' '), input, location);\n        }\n        return new ASTWithSource(ast, input, location, this.errors);\n    };\n    /**\n     * @param {?} message\n     * @param {?} input\n     * @param {?} errLocation\n     * @param {?=} ctxLocation\n     * @return {?}\n     */\n    Parser.prototype._reportError = function (message, input, errLocation, ctxLocation) {\n        this.errors.push(new ParserError(message, input, errLocation, ctxLocation));\n    };\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?} interpolationConfig\n     * @return {?}\n     */\n    Parser.prototype._parseBindingAst = function (input, location, interpolationConfig) {\n        // Quotes expressions use 3rd-party expression language. We don't want to use\n        // our lexer or parser for that, so we check for that ahead of time.\n        var /** @type {?} */ quote = this._parseQuote(input, location);\n        if (quote != null) {\n            return quote;\n        }\n        this._checkNoInterpolation(input, location, interpolationConfig);\n        var /** @type {?} */ sourceToLex = this._stripComments(input);\n        var /** @type {?} */ tokens = this._lexer.tokenize(sourceToLex);\n        return new _ParseAST(input, location, tokens, sourceToLex.length, false, this.errors, input.length - sourceToLex.length)\n            .parseChain();\n    };\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @return {?}\n     */\n    Parser.prototype._parseQuote = function (input, location) {\n        if (input == null)\n            return null;\n        var /** @type {?} */ prefixSeparatorIndex = input.indexOf(':');\n        if (prefixSeparatorIndex == -1)\n            return null;\n        var /** @type {?} */ prefix = input.substring(0, prefixSeparatorIndex).trim();\n        if (!isIdentifier(prefix))\n            return null;\n        var /** @type {?} */ uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);\n        return new Quote(new ParseSpan(0, input.length), prefix, uninterpretedExpression, location);\n    };\n    /**\n     * @param {?} prefixToken\n     * @param {?} input\n     * @param {?} location\n     * @return {?}\n     */\n    Parser.prototype.parseTemplateBindings = function (prefixToken, input, location) {\n        var /** @type {?} */ tokens = this._lexer.tokenize(input);\n        if (prefixToken) {\n            // Prefix the tokens with the tokens from prefixToken but have them take no space (0 index).\n            var /** @type {?} */ prefixTokens = this._lexer.tokenize(prefixToken).map(function (t) {\n                t.index = 0;\n                return t;\n            });\n            tokens.unshift.apply(tokens, prefixTokens);\n        }\n        return new _ParseAST(input, location, tokens, input.length, false, this.errors, 0)\n            .parseTemplateBindings();\n    };\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    Parser.prototype.parseInterpolation = function (input, location, interpolationConfig) {\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        var /** @type {?} */ split = this.splitInterpolation(input, location, interpolationConfig);\n        if (split == null)\n            return null;\n        var /** @type {?} */ expressions = [];\n        for (var /** @type {?} */ i = 0; i < split.expressions.length; ++i) {\n            var /** @type {?} */ expressionText = split.expressions[i];\n            var /** @type {?} */ sourceToLex = this._stripComments(expressionText);\n            var /** @type {?} */ tokens = this._lexer.tokenize(sourceToLex);\n            var /** @type {?} */ ast = new _ParseAST(input, location, tokens, sourceToLex.length, false, this.errors, split.offsets[i] + (expressionText.length - sourceToLex.length))\n                .parseChain();\n            expressions.push(ast);\n        }\n        return new ASTWithSource(new Interpolation(new ParseSpan(0, input == null ? 0 : input.length), split.strings, expressions), input, location, this.errors);\n    };\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    Parser.prototype.splitInterpolation = function (input, location, interpolationConfig) {\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        var /** @type {?} */ regexp = _createInterpolateRegExp(interpolationConfig);\n        var /** @type {?} */ parts = input.split(regexp);\n        if (parts.length <= 1) {\n            return null;\n        }\n        var /** @type {?} */ strings = [];\n        var /** @type {?} */ expressions = [];\n        var /** @type {?} */ offsets = [];\n        var /** @type {?} */ offset = 0;\n        for (var /** @type {?} */ i = 0; i < parts.length; i++) {\n            var /** @type {?} */ part = parts[i];\n            if (i % 2 === 0) {\n                // fixed string\n                strings.push(part);\n                offset += part.length;\n            }\n            else if (part.trim().length > 0) {\n                offset += interpolationConfig.start.length;\n                expressions.push(part);\n                offsets.push(offset);\n                offset += part.length + interpolationConfig.end.length;\n            }\n            else {\n                this._reportError('Blank expressions are not allowed in interpolated strings', input, \"at column \" + this._findInterpolationErrorColumn(parts, i, interpolationConfig) + \" in\", location);\n                expressions.push('$implict');\n                offsets.push(offset);\n            }\n        }\n        return new SplitInterpolation(strings, expressions, offsets);\n    };\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @return {?}\n     */\n    Parser.prototype.wrapLiteralPrimitive = function (input, location) {\n        return new ASTWithSource(new LiteralPrimitive(new ParseSpan(0, input == null ? 0 : input.length), input), input, location, this.errors);\n    };\n    /**\n     * @param {?} input\n     * @return {?}\n     */\n    Parser.prototype._stripComments = function (input) {\n        var /** @type {?} */ i = this._commentStart(input);\n        return i != null ? input.substring(0, i).trim() : input;\n    };\n    /**\n     * @param {?} input\n     * @return {?}\n     */\n    Parser.prototype._commentStart = function (input) {\n        var /** @type {?} */ outerQuote = null;\n        for (var /** @type {?} */ i = 0; i < input.length - 1; i++) {\n            var /** @type {?} */ char = input.charCodeAt(i);\n            var /** @type {?} */ nextChar = input.charCodeAt(i + 1);\n            if (char === $SLASH && nextChar == $SLASH && outerQuote == null)\n                return i;\n            if (outerQuote === char) {\n                outerQuote = null;\n            }\n            else if (outerQuote == null && isQuote(char)) {\n                outerQuote = char;\n            }\n        }\n        return null;\n    };\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?} interpolationConfig\n     * @return {?}\n     */\n    Parser.prototype._checkNoInterpolation = function (input, location, interpolationConfig) {\n        var /** @type {?} */ regexp = _createInterpolateRegExp(interpolationConfig);\n        var /** @type {?} */ parts = input.split(regexp);\n        if (parts.length > 1) {\n            this._reportError(\"Got interpolation (\" + interpolationConfig.start + interpolationConfig.end + \") where expression was expected\", input, \"at column \" + this._findInterpolationErrorColumn(parts, 1, interpolationConfig) + \" in\", location);\n        }\n    };\n    /**\n     * @param {?} parts\n     * @param {?} partInErrIdx\n     * @param {?} interpolationConfig\n     * @return {?}\n     */\n    Parser.prototype._findInterpolationErrorColumn = function (parts, partInErrIdx, interpolationConfig) {\n        var /** @type {?} */ errLocation = '';\n        for (var /** @type {?} */ j = 0; j < partInErrIdx; j++) {\n            errLocation += j % 2 === 0 ?\n                parts[j] :\n                \"\" + interpolationConfig.start + parts[j] + interpolationConfig.end;\n        }\n        return errLocation.length;\n    };\n    return Parser;\n}());\nParser.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nParser.ctorParameters = function () { return [\n    { type: Lexer, },\n]; };\nvar _ParseAST = (function () {\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?} tokens\n     * @param {?} inputLength\n     * @param {?} parseAction\n     * @param {?} errors\n     * @param {?} offset\n     */\n    function _ParseAST(input, location, tokens, inputLength, parseAction, errors, offset) {\n        this.input = input;\n        this.location = location;\n        this.tokens = tokens;\n        this.inputLength = inputLength;\n        this.parseAction = parseAction;\n        this.errors = errors;\n        this.offset = offset;\n        this.rparensExpected = 0;\n        this.rbracketsExpected = 0;\n        this.rbracesExpected = 0;\n        this.index = 0;\n    }\n    /**\n     * @param {?} offset\n     * @return {?}\n     */\n    _ParseAST.prototype.peek = function (offset) {\n        var /** @type {?} */ i = this.index + offset;\n        return i < this.tokens.length ? this.tokens[i] : EOF;\n    };\n    Object.defineProperty(_ParseAST.prototype, \"next\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this.peek(0); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(_ParseAST.prototype, \"inputIndex\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return (this.index < this.tokens.length) ? this.next.index + this.offset :\n                this.inputLength + this.offset;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _ParseAST.prototype.span = function (start) { return new ParseSpan(start, this.inputIndex); };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.advance = function () { this.index++; };\n    /**\n     * @param {?} code\n     * @return {?}\n     */\n    _ParseAST.prototype.optionalCharacter = function (code) {\n        if (this.next.isCharacter(code)) {\n            this.advance();\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.peekKeywordLet = function () { return this.next.isKeywordLet(); };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.peekKeywordAs = function () { return this.next.isKeywordAs(); };\n    /**\n     * @param {?} code\n     * @return {?}\n     */\n    _ParseAST.prototype.expectCharacter = function (code) {\n        if (this.optionalCharacter(code))\n            return;\n        this.error(\"Missing expected \" + String.fromCharCode(code));\n    };\n    /**\n     * @param {?} op\n     * @return {?}\n     */\n    _ParseAST.prototype.optionalOperator = function (op) {\n        if (this.next.isOperator(op)) {\n            this.advance();\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    /**\n     * @param {?} operator\n     * @return {?}\n     */\n    _ParseAST.prototype.expectOperator = function (operator) {\n        if (this.optionalOperator(operator))\n            return;\n        this.error(\"Missing expected operator \" + operator);\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.expectIdentifierOrKeyword = function () {\n        var /** @type {?} */ n = this.next;\n        if (!n.isIdentifier() && !n.isKeyword()) {\n            this.error(\"Unexpected token \" + n + \", expected identifier or keyword\");\n            return '';\n        }\n        this.advance();\n        return (n.toString());\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.expectIdentifierOrKeywordOrString = function () {\n        var /** @type {?} */ n = this.next;\n        if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\n            this.error(\"Unexpected token \" + n + \", expected identifier, keyword, or string\");\n            return '';\n        }\n        this.advance();\n        return (n.toString());\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseChain = function () {\n        var /** @type {?} */ exprs = [];\n        var /** @type {?} */ start = this.inputIndex;\n        while (this.index < this.tokens.length) {\n            var /** @type {?} */ expr = this.parsePipe();\n            exprs.push(expr);\n            if (this.optionalCharacter($SEMICOLON)) {\n                if (!this.parseAction) {\n                    this.error('Binding expression cannot contain chained expression');\n                }\n                while (this.optionalCharacter($SEMICOLON)) {\n                } // read all semicolons\n            }\n            else if (this.index < this.tokens.length) {\n                this.error(\"Unexpected token '\" + this.next + \"'\");\n            }\n        }\n        if (exprs.length == 0)\n            return new EmptyExpr(this.span(start));\n        if (exprs.length == 1)\n            return exprs[0];\n        return new Chain(this.span(start), exprs);\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parsePipe = function () {\n        var /** @type {?} */ result = this.parseExpression();\n        if (this.optionalOperator('|')) {\n            if (this.parseAction) {\n                this.error('Cannot have a pipe in an action expression');\n            }\n            do {\n                var /** @type {?} */ name = this.expectIdentifierOrKeyword();\n                var /** @type {?} */ args = [];\n                while (this.optionalCharacter($COLON)) {\n                    args.push(this.parseExpression());\n                }\n                result = new BindingPipe(this.span(result.span.start), result, name, args);\n            } while (this.optionalOperator('|'));\n        }\n        return result;\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseExpression = function () { return this.parseConditional(); };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseConditional = function () {\n        var /** @type {?} */ start = this.inputIndex;\n        var /** @type {?} */ result = this.parseLogicalOr();\n        if (this.optionalOperator('?')) {\n            var /** @type {?} */ yes = this.parsePipe();\n            var /** @type {?} */ no = void 0;\n            if (!this.optionalCharacter($COLON)) {\n                var /** @type {?} */ end = this.inputIndex;\n                var /** @type {?} */ expression = this.input.substring(start, end);\n                this.error(\"Conditional expression \" + expression + \" requires all 3 expressions\");\n                no = new EmptyExpr(this.span(start));\n            }\n            else {\n                no = this.parsePipe();\n            }\n            return new Conditional(this.span(start), result, yes, no);\n        }\n        else {\n            return result;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseLogicalOr = function () {\n        // '||'\n        var /** @type {?} */ result = this.parseLogicalAnd();\n        while (this.optionalOperator('||')) {\n            var /** @type {?} */ right = this.parseLogicalAnd();\n            result = new Binary(this.span(result.span.start), '||', result, right);\n        }\n        return result;\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseLogicalAnd = function () {\n        // '&&'\n        var /** @type {?} */ result = this.parseEquality();\n        while (this.optionalOperator('&&')) {\n            var /** @type {?} */ right = this.parseEquality();\n            result = new Binary(this.span(result.span.start), '&&', result, right);\n        }\n        return result;\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseEquality = function () {\n        // '==','!=','===','!=='\n        var /** @type {?} */ result = this.parseRelational();\n        while (this.next.type == TokenType.Operator) {\n            var /** @type {?} */ operator = this.next.strValue;\n            switch (operator) {\n                case '==':\n                case '===':\n                case '!=':\n                case '!==':\n                    this.advance();\n                    var /** @type {?} */ right = this.parseRelational();\n                    result = new Binary(this.span(result.span.start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseRelational = function () {\n        // '<', '>', '<=', '>='\n        var /** @type {?} */ result = this.parseAdditive();\n        while (this.next.type == TokenType.Operator) {\n            var /** @type {?} */ operator = this.next.strValue;\n            switch (operator) {\n                case '<':\n                case '>':\n                case '<=':\n                case '>=':\n                    this.advance();\n                    var /** @type {?} */ right = this.parseAdditive();\n                    result = new Binary(this.span(result.span.start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseAdditive = function () {\n        // '+', '-'\n        var /** @type {?} */ result = this.parseMultiplicative();\n        while (this.next.type == TokenType.Operator) {\n            var /** @type {?} */ operator = this.next.strValue;\n            switch (operator) {\n                case '+':\n                case '-':\n                    this.advance();\n                    var /** @type {?} */ right = this.parseMultiplicative();\n                    result = new Binary(this.span(result.span.start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseMultiplicative = function () {\n        // '*', '%', '/'\n        var /** @type {?} */ result = this.parsePrefix();\n        while (this.next.type == TokenType.Operator) {\n            var /** @type {?} */ operator = this.next.strValue;\n            switch (operator) {\n                case '*':\n                case '%':\n                case '/':\n                    this.advance();\n                    var /** @type {?} */ right = this.parsePrefix();\n                    result = new Binary(this.span(result.span.start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parsePrefix = function () {\n        if (this.next.type == TokenType.Operator) {\n            var /** @type {?} */ start = this.inputIndex;\n            var /** @type {?} */ operator = this.next.strValue;\n            var /** @type {?} */ result = void 0;\n            switch (operator) {\n                case '+':\n                    this.advance();\n                    return this.parsePrefix();\n                case '-':\n                    this.advance();\n                    result = this.parsePrefix();\n                    return new Binary(this.span(start), operator, new LiteralPrimitive(new ParseSpan(start, start), 0), result);\n                case '!':\n                    this.advance();\n                    result = this.parsePrefix();\n                    return new PrefixNot(this.span(start), result);\n            }\n        }\n        return this.parseCallChain();\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseCallChain = function () {\n        var /** @type {?} */ result = this.parsePrimary();\n        while (true) {\n            if (this.optionalCharacter($PERIOD)) {\n                result = this.parseAccessMemberOrMethodCall(result, false);\n            }\n            else if (this.optionalOperator('?.')) {\n                result = this.parseAccessMemberOrMethodCall(result, true);\n            }\n            else if (this.optionalCharacter($LBRACKET)) {\n                this.rbracketsExpected++;\n                var /** @type {?} */ key = this.parsePipe();\n                this.rbracketsExpected--;\n                this.expectCharacter($RBRACKET);\n                if (this.optionalOperator('=')) {\n                    var /** @type {?} */ value = this.parseConditional();\n                    result = new KeyedWrite(this.span(result.span.start), result, key, value);\n                }\n                else {\n                    result = new KeyedRead(this.span(result.span.start), result, key);\n                }\n            }\n            else if (this.optionalCharacter($LPAREN)) {\n                this.rparensExpected++;\n                var /** @type {?} */ args = this.parseCallArguments();\n                this.rparensExpected--;\n                this.expectCharacter($RPAREN);\n                result = new FunctionCall(this.span(result.span.start), result, args);\n            }\n            else if (this.optionalOperator('!')) {\n                result = new NonNullAssert(this.span(result.span.start), result);\n            }\n            else {\n                return result;\n            }\n        }\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parsePrimary = function () {\n        var /** @type {?} */ start = this.inputIndex;\n        if (this.optionalCharacter($LPAREN)) {\n            this.rparensExpected++;\n            var /** @type {?} */ result = this.parsePipe();\n            this.rparensExpected--;\n            this.expectCharacter($RPAREN);\n            return result;\n        }\n        else if (this.next.isKeywordNull()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), null);\n        }\n        else if (this.next.isKeywordUndefined()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), void 0);\n        }\n        else if (this.next.isKeywordTrue()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), true);\n        }\n        else if (this.next.isKeywordFalse()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), false);\n        }\n        else if (this.next.isKeywordThis()) {\n            this.advance();\n            return new ImplicitReceiver(this.span(start));\n        }\n        else if (this.optionalCharacter($LBRACKET)) {\n            this.rbracketsExpected++;\n            var /** @type {?} */ elements = this.parseExpressionList($RBRACKET);\n            this.rbracketsExpected--;\n            this.expectCharacter($RBRACKET);\n            return new LiteralArray(this.span(start), elements);\n        }\n        else if (this.next.isCharacter($LBRACE)) {\n            return this.parseLiteralMap();\n        }\n        else if (this.next.isIdentifier()) {\n            return this.parseAccessMemberOrMethodCall(new ImplicitReceiver(this.span(start)), false);\n        }\n        else if (this.next.isNumber()) {\n            var /** @type {?} */ value = this.next.toNumber();\n            this.advance();\n            return new LiteralPrimitive(this.span(start), value);\n        }\n        else if (this.next.isString()) {\n            var /** @type {?} */ literalValue = this.next.toString();\n            this.advance();\n            return new LiteralPrimitive(this.span(start), literalValue);\n        }\n        else if (this.index >= this.tokens.length) {\n            this.error(\"Unexpected end of expression: \" + this.input);\n            return new EmptyExpr(this.span(start));\n        }\n        else {\n            this.error(\"Unexpected token \" + this.next);\n            return new EmptyExpr(this.span(start));\n        }\n    };\n    /**\n     * @param {?} terminator\n     * @return {?}\n     */\n    _ParseAST.prototype.parseExpressionList = function (terminator) {\n        var /** @type {?} */ result = [];\n        if (!this.next.isCharacter(terminator)) {\n            do {\n                result.push(this.parsePipe());\n            } while (this.optionalCharacter($COMMA));\n        }\n        return result;\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseLiteralMap = function () {\n        var /** @type {?} */ keys = [];\n        var /** @type {?} */ values = [];\n        var /** @type {?} */ start = this.inputIndex;\n        this.expectCharacter($LBRACE);\n        if (!this.optionalCharacter($RBRACE)) {\n            this.rbracesExpected++;\n            do {\n                var /** @type {?} */ quoted = this.next.isString();\n                var /** @type {?} */ key = this.expectIdentifierOrKeywordOrString();\n                keys.push({ key: key, quoted: quoted });\n                this.expectCharacter($COLON);\n                values.push(this.parsePipe());\n            } while (this.optionalCharacter($COMMA));\n            this.rbracesExpected--;\n            this.expectCharacter($RBRACE);\n        }\n        return new LiteralMap(this.span(start), keys, values);\n    };\n    /**\n     * @param {?} receiver\n     * @param {?=} isSafe\n     * @return {?}\n     */\n    _ParseAST.prototype.parseAccessMemberOrMethodCall = function (receiver, isSafe) {\n        if (isSafe === void 0) { isSafe = false; }\n        var /** @type {?} */ start = receiver.span.start;\n        var /** @type {?} */ id = this.expectIdentifierOrKeyword();\n        if (this.optionalCharacter($LPAREN)) {\n            this.rparensExpected++;\n            var /** @type {?} */ args = this.parseCallArguments();\n            this.expectCharacter($RPAREN);\n            this.rparensExpected--;\n            var /** @type {?} */ span = this.span(start);\n            return isSafe ? new SafeMethodCall(span, receiver, id, args) :\n                new MethodCall(span, receiver, id, args);\n        }\n        else {\n            if (isSafe) {\n                if (this.optionalOperator('=')) {\n                    this.error('The \\'?.\\' operator cannot be used in the assignment');\n                    return new EmptyExpr(this.span(start));\n                }\n                else {\n                    return new SafePropertyRead(this.span(start), receiver, id);\n                }\n            }\n            else {\n                if (this.optionalOperator('=')) {\n                    if (!this.parseAction) {\n                        this.error('Bindings cannot contain assignments');\n                        return new EmptyExpr(this.span(start));\n                    }\n                    var /** @type {?} */ value = this.parseConditional();\n                    return new PropertyWrite(this.span(start), receiver, id, value);\n                }\n                else {\n                    return new PropertyRead(this.span(start), receiver, id);\n                }\n            }\n        }\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseCallArguments = function () {\n        if (this.next.isCharacter($RPAREN))\n            return [];\n        var /** @type {?} */ positionals = [];\n        do {\n            positionals.push(this.parsePipe());\n        } while (this.optionalCharacter($COMMA));\n        return (positionals);\n    };\n    /**\n     * An identifier, a keyword, a string with an optional `-` inbetween.\n     * @return {?}\n     */\n    _ParseAST.prototype.expectTemplateBindingKey = function () {\n        var /** @type {?} */ result = '';\n        var /** @type {?} */ operatorFound = false;\n        do {\n            result += this.expectIdentifierOrKeywordOrString();\n            operatorFound = this.optionalOperator('-');\n            if (operatorFound) {\n                result += '-';\n            }\n        } while (operatorFound);\n        return result.toString();\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseTemplateBindings = function () {\n        var /** @type {?} */ bindings = [];\n        var /** @type {?} */ prefix = ((null));\n        var /** @type {?} */ warnings = [];\n        while (this.index < this.tokens.length) {\n            var /** @type {?} */ start = this.inputIndex;\n            var /** @type {?} */ keyIsVar = this.peekKeywordLet();\n            if (keyIsVar) {\n                this.advance();\n            }\n            var /** @type {?} */ rawKey = this.expectTemplateBindingKey();\n            var /** @type {?} */ key = rawKey;\n            if (!keyIsVar) {\n                if (prefix == null) {\n                    prefix = key;\n                }\n                else {\n                    key = prefix + key[0].toUpperCase() + key.substring(1);\n                }\n            }\n            this.optionalCharacter($COLON);\n            var /** @type {?} */ name = ((null));\n            var /** @type {?} */ expression = ((null));\n            if (keyIsVar) {\n                if (this.optionalOperator('=')) {\n                    name = this.expectTemplateBindingKey();\n                }\n                else {\n                    name = '\\$implicit';\n                }\n            }\n            else if (this.peekKeywordAs()) {\n                var /** @type {?} */ letStart = this.inputIndex;\n                this.advance(); // consume `as`\n                name = rawKey;\n                key = this.expectTemplateBindingKey(); // read local var name\n                keyIsVar = true;\n            }\n            else if (this.next !== EOF && !this.peekKeywordLet()) {\n                var /** @type {?} */ start_2 = this.inputIndex;\n                var /** @type {?} */ ast = this.parsePipe();\n                var /** @type {?} */ source = this.input.substring(start_2 - this.offset, this.inputIndex - this.offset);\n                expression = new ASTWithSource(ast, source, this.location, this.errors);\n            }\n            bindings.push(new TemplateBinding(this.span(start), key, keyIsVar, name, expression));\n            if (this.peekKeywordAs() && !keyIsVar) {\n                var /** @type {?} */ letStart = this.inputIndex;\n                this.advance(); // consume `as`\n                var /** @type {?} */ letName = this.expectTemplateBindingKey(); // read local var name\n                bindings.push(new TemplateBinding(this.span(letStart), letName, true, key, /** @type {?} */ ((null))));\n            }\n            if (!this.optionalCharacter($SEMICOLON)) {\n                this.optionalCharacter($COMMA);\n            }\n        }\n        return new TemplateBindingParseResult(bindings, warnings, this.errors);\n    };\n    /**\n     * @param {?} message\n     * @param {?=} index\n     * @return {?}\n     */\n    _ParseAST.prototype.error = function (message, index) {\n        if (index === void 0) { index = null; }\n        this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));\n        this.skip();\n    };\n    /**\n     * @param {?=} index\n     * @return {?}\n     */\n    _ParseAST.prototype.locationText = function (index) {\n        if (index === void 0) { index = null; }\n        if (index == null)\n            index = this.index;\n        return (index < this.tokens.length) ? \"at column \" + (this.tokens[index].index + 1) + \" in\" :\n            \"at the end of the expression\";\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.skip = function () {\n        var /** @type {?} */ n = this.next;\n        while (this.index < this.tokens.length && !n.isCharacter($SEMICOLON) &&\n            (this.rparensExpected <= 0 || !n.isCharacter($RPAREN)) &&\n            (this.rbracesExpected <= 0 || !n.isCharacter($RBRACE)) &&\n            (this.rbracketsExpected <= 0 || !n.isCharacter($RBRACKET))) {\n            if (this.next.isError()) {\n                this.errors.push(new ParserError(/** @type {?} */ ((this.next.toString())), this.input, this.locationText(), this.location));\n            }\n            this.advance();\n            n = this.next;\n        }\n    };\n    return _ParseAST;\n}());\nvar SimpleExpressionChecker = (function () {\n    function SimpleExpressionChecker() {\n        this.errors = [];\n    }\n    /**\n     * @param {?} ast\n     * @return {?}\n     */\n    SimpleExpressionChecker.check = function (ast) {\n        var /** @type {?} */ s = new SimpleExpressionChecker();\n        ast.visit(s);\n        return s.errors;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitImplicitReceiver = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitInterpolation = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitLiteralPrimitive = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitPropertyRead = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitPropertyWrite = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitSafePropertyRead = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitMethodCall = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitSafeMethodCall = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitFunctionCall = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitLiteralArray = function (ast, context) { this.visitAll(ast.expressions); };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitLiteralMap = function (ast, context) { this.visitAll(ast.values); };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitBinary = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitPrefixNot = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitNonNullAssert = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitConditional = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitPipe = function (ast, context) { this.errors.push('pipes'); };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitKeyedRead = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitKeyedWrite = function (ast, context) { };\n    /**\n     * @param {?} asts\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitAll = function (asts) {\n        var _this = this;\n        return asts.map(function (node) { return node.visit(_this); });\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitChain = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitQuote = function (ast, context) { };\n    return SimpleExpressionChecker;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ParseLocation = (function () {\n    /**\n     * @param {?} file\n     * @param {?} offset\n     * @param {?} line\n     * @param {?} col\n     */\n    function ParseLocation(file, offset, line, col) {\n        this.file = file;\n        this.offset = offset;\n        this.line = line;\n        this.col = col;\n    }\n    /**\n     * @return {?}\n     */\n    ParseLocation.prototype.toString = function () {\n        return this.offset != null ? this.file.url + \"@\" + this.line + \":\" + this.col : this.file.url;\n    };\n    /**\n     * @param {?} delta\n     * @return {?}\n     */\n    ParseLocation.prototype.moveBy = function (delta) {\n        var /** @type {?} */ source = this.file.content;\n        var /** @type {?} */ len = source.length;\n        var /** @type {?} */ offset = this.offset;\n        var /** @type {?} */ line = this.line;\n        var /** @type {?} */ col = this.col;\n        while (offset > 0 && delta < 0) {\n            offset--;\n            delta++;\n            var /** @type {?} */ ch = source.charCodeAt(offset);\n            if (ch == $LF) {\n                line--;\n                var /** @type {?} */ priorLine = source.substr(0, offset - 1).lastIndexOf(String.fromCharCode($LF));\n                col = priorLine > 0 ? offset - priorLine : offset;\n            }\n            else {\n                col--;\n            }\n        }\n        while (offset < len && delta > 0) {\n            var /** @type {?} */ ch = source.charCodeAt(offset);\n            offset++;\n            delta--;\n            if (ch == $LF) {\n                line++;\n                col = 0;\n            }\n            else {\n                col++;\n            }\n        }\n        return new ParseLocation(this.file, offset, line, col);\n    };\n    /**\n     * @param {?} maxChars\n     * @param {?} maxLines\n     * @return {?}\n     */\n    ParseLocation.prototype.getContext = function (maxChars, maxLines) {\n        var /** @type {?} */ content = this.file.content;\n        var /** @type {?} */ startOffset = this.offset;\n        if (startOffset != null) {\n            if (startOffset > content.length - 1) {\n                startOffset = content.length - 1;\n            }\n            var /** @type {?} */ endOffset = startOffset;\n            var /** @type {?} */ ctxChars = 0;\n            var /** @type {?} */ ctxLines = 0;\n            while (ctxChars < maxChars && startOffset > 0) {\n                startOffset--;\n                ctxChars++;\n                if (content[startOffset] == '\\n') {\n                    if (++ctxLines == maxLines) {\n                        break;\n                    }\n                }\n            }\n            ctxChars = 0;\n            ctxLines = 0;\n            while (ctxChars < maxChars && endOffset < content.length - 1) {\n                endOffset++;\n                ctxChars++;\n                if (content[endOffset] == '\\n') {\n                    if (++ctxLines == maxLines) {\n                        break;\n                    }\n                }\n            }\n            return {\n                before: content.substring(startOffset, this.offset),\n                after: content.substring(this.offset, endOffset + 1),\n            };\n        }\n        return null;\n    };\n    return ParseLocation;\n}());\nvar ParseSourceFile = (function () {\n    /**\n     * @param {?} content\n     * @param {?} url\n     */\n    function ParseSourceFile(content, url) {\n        this.content = content;\n        this.url = url;\n    }\n    return ParseSourceFile;\n}());\nvar ParseSourceSpan = (function () {\n    /**\n     * @param {?} start\n     * @param {?} end\n     * @param {?=} details\n     */\n    function ParseSourceSpan(start, end, details) {\n        if (details === void 0) { details = null; }\n        this.start = start;\n        this.end = end;\n        this.details = details;\n    }\n    /**\n     * @return {?}\n     */\n    ParseSourceSpan.prototype.toString = function () {\n        return this.start.file.content.substring(this.start.offset, this.end.offset);\n    };\n    return ParseSourceSpan;\n}());\nvar ParseErrorLevel = {};\nParseErrorLevel.WARNING = 0;\nParseErrorLevel.ERROR = 1;\nParseErrorLevel[ParseErrorLevel.WARNING] = \"WARNING\";\nParseErrorLevel[ParseErrorLevel.ERROR] = \"ERROR\";\nvar ParseError = (function () {\n    /**\n     * @param {?} span\n     * @param {?} msg\n     * @param {?=} level\n     */\n    function ParseError(span, msg, level) {\n        if (level === void 0) { level = ParseErrorLevel.ERROR; }\n        this.span = span;\n        this.msg = msg;\n        this.level = level;\n    }\n    /**\n     * @return {?}\n     */\n    ParseError.prototype.contextualMessage = function () {\n        var /** @type {?} */ ctx = this.span.start.getContext(100, 3);\n        return ctx ? \" (\\\"\" + ctx.before + \"[\" + ParseErrorLevel[this.level] + \" ->]\" + ctx.after + \"\\\")\" : '';\n    };\n    /**\n     * @return {?}\n     */\n    ParseError.prototype.toString = function () {\n        var /** @type {?} */ details = this.span.details ? \", \" + this.span.details : '';\n        return \"\" + this.msg + this.contextualMessage() + \": \" + this.span.start + details;\n    };\n    return ParseError;\n}());\n/**\n * @param {?} kind\n * @param {?} type\n * @return {?}\n */\nfunction typeSourceSpan(kind, type) {\n    var /** @type {?} */ moduleUrl = identifierModuleUrl(type);\n    var /** @type {?} */ sourceFileName = moduleUrl != null ? \"in \" + kind + \" \" + identifierName(type) + \" in \" + moduleUrl :\n        \"in \" + kind + \" \" + identifierName(type);\n    var /** @type {?} */ sourceFile = new ParseSourceFile('', sourceFileName);\n    return new ParseSourceSpan(new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));\n}\n/**\n * A path is an ordered set of elements. Typically a path is to  a\n * particular offset in a source file. The head of the list is the top\n * most node. The tail is the node that contains the offset directly.\n *\n * For example, the expresion `a + b + c` might have an ast that looks\n * like:\n *     +\n *    / \\\n *   a   +\n *      / \\\n *     b   c\n *\n * The path to the node at offset 9 would be `['+' at 1-10, '+' at 7-10,\n * 'c' at 9-10]` and the path the node at offset 1 would be\n * `['+' at 1-10, 'a' at 1-2]`.\n */\nvar AstPath = (function () {\n    /**\n     * @param {?} path\n     * @param {?=} position\n     */\n    function AstPath(path, position) {\n        if (position === void 0) { position = -1; }\n        this.path = path;\n        this.position = position;\n    }\n    Object.defineProperty(AstPath.prototype, \"empty\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return !this.path || !this.path.length; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AstPath.prototype, \"head\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this.path[0]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AstPath.prototype, \"tail\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this.path[this.path.length - 1]; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} node\n     * @return {?}\n     */\n    AstPath.prototype.parentOf = function (node) {\n        return node && this.path[this.path.indexOf(node) - 1];\n    };\n    /**\n     * @param {?} node\n     * @return {?}\n     */\n    AstPath.prototype.childOf = function (node) { return this.path[this.path.indexOf(node) + 1]; };\n    /**\n     * @template N\n     * @param {?} ctor\n     * @return {?}\n     */\n    AstPath.prototype.first = function (ctor) {\n        for (var /** @type {?} */ i = this.path.length - 1; i >= 0; i--) {\n            var /** @type {?} */ item = this.path[i];\n            if (item instanceof ctor)\n                return (item);\n        }\n    };\n    /**\n     * @param {?} node\n     * @return {?}\n     */\n    AstPath.prototype.push = function (node) { this.path.push(node); };\n    /**\n     * @return {?}\n     */\n    AstPath.prototype.pop = function () { return ((this.path.pop())); };\n    return AstPath;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar Text = (function () {\n    /**\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    function Text(value, sourceSpan) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    Text.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };\n    return Text;\n}());\nvar Expansion = (function () {\n    /**\n     * @param {?} switchValue\n     * @param {?} type\n     * @param {?} cases\n     * @param {?} sourceSpan\n     * @param {?} switchValueSourceSpan\n     */\n    function Expansion(switchValue, type, cases, sourceSpan, switchValueSourceSpan) {\n        this.switchValue = switchValue;\n        this.type = type;\n        this.cases = cases;\n        this.sourceSpan = sourceSpan;\n        this.switchValueSourceSpan = switchValueSourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    Expansion.prototype.visit = function (visitor, context) { return visitor.visitExpansion(this, context); };\n    return Expansion;\n}());\nvar ExpansionCase = (function () {\n    /**\n     * @param {?} value\n     * @param {?} expression\n     * @param {?} sourceSpan\n     * @param {?} valueSourceSpan\n     * @param {?} expSourceSpan\n     */\n    function ExpansionCase(value, expression, sourceSpan, valueSourceSpan, expSourceSpan) {\n        this.value = value;\n        this.expression = expression;\n        this.sourceSpan = sourceSpan;\n        this.valueSourceSpan = valueSourceSpan;\n        this.expSourceSpan = expSourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ExpansionCase.prototype.visit = function (visitor, context) { return visitor.visitExpansionCase(this, context); };\n    return ExpansionCase;\n}());\nvar Attribute$1 = (function () {\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @param {?=} valueSpan\n     */\n    function Attribute$1(name, value, sourceSpan, valueSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n        this.valueSpan = valueSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    Attribute$1.prototype.visit = function (visitor, context) { return visitor.visitAttribute(this, context); };\n    return Attribute$1;\n}());\nvar Element = (function () {\n    /**\n     * @param {?} name\n     * @param {?} attrs\n     * @param {?} children\n     * @param {?} sourceSpan\n     * @param {?=} startSourceSpan\n     * @param {?=} endSourceSpan\n     */\n    function Element(name, attrs, children, sourceSpan, startSourceSpan, endSourceSpan) {\n        if (startSourceSpan === void 0) { startSourceSpan = null; }\n        if (endSourceSpan === void 0) { endSourceSpan = null; }\n        this.name = name;\n        this.attrs = attrs;\n        this.children = children;\n        this.sourceSpan = sourceSpan;\n        this.startSourceSpan = startSourceSpan;\n        this.endSourceSpan = endSourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    Element.prototype.visit = function (visitor, context) { return visitor.visitElement(this, context); };\n    return Element;\n}());\nvar Comment = (function () {\n    /**\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    function Comment(value, sourceSpan) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    Comment.prototype.visit = function (visitor, context) { return visitor.visitComment(this, context); };\n    return Comment;\n}());\n/**\n * @param {?} visitor\n * @param {?} nodes\n * @param {?=} context\n * @return {?}\n */\nfunction visitAll(visitor, nodes, context) {\n    if (context === void 0) { context = null; }\n    var /** @type {?} */ result = [];\n    var /** @type {?} */ visit = visitor.visit ?\n        function (ast) { return ((visitor.visit))(ast, context) || ast.visit(visitor, context); } :\n        function (ast) { return ast.visit(visitor, context); };\n    nodes.forEach(function (ast) {\n        var /** @type {?} */ astResult = visit(ast);\n        if (astResult) {\n            result.push(astResult);\n        }\n    });\n    return result;\n}\nvar RecursiveVisitor = (function () {\n    function RecursiveVisitor() {\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveVisitor.prototype.visitElement = function (ast, context) {\n        this.visitChildren(context, function (visit) {\n            visit(ast.attrs);\n            visit(ast.children);\n        });\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveVisitor.prototype.visitAttribute = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveVisitor.prototype.visitText = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveVisitor.prototype.visitComment = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveVisitor.prototype.visitExpansion = function (ast, context) {\n        return this.visitChildren(context, function (visit) { visit(ast.cases); });\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveVisitor.prototype.visitExpansionCase = function (ast, context) { };\n    /**\n     * @template T\n     * @param {?} context\n     * @param {?} cb\n     * @return {?}\n     */\n    RecursiveVisitor.prototype.visitChildren = function (context, cb) {\n        var /** @type {?} */ results = [];\n        var /** @type {?} */ t = this;\n        /**\n         * @template T\n         * @param {?} children\n         * @return {?}\n         */\n        function visit(children) {\n            if (children)\n                results.push(visitAll(t, children, context));\n        }\n        cb(visit);\n        return [].concat.apply([], results);\n    };\n    return RecursiveVisitor;\n}());\n/**\n * @param {?} ast\n * @return {?}\n */\nfunction spanOf(ast) {\n    var /** @type {?} */ start = ast.sourceSpan.start.offset;\n    var /** @type {?} */ end = ast.sourceSpan.end.offset;\n    if (ast instanceof Element) {\n        if (ast.endSourceSpan) {\n            end = ast.endSourceSpan.end.offset;\n        }\n        else if (ast.children && ast.children.length) {\n            end = spanOf(ast.children[ast.children.length - 1]).end;\n        }\n    }\n    return { start: start, end: end };\n}\n/**\n * @param {?} nodes\n * @param {?} position\n * @return {?}\n */\nfunction findNode(nodes, position) {\n    var /** @type {?} */ path = [];\n    var /** @type {?} */ visitor = new (function (_super) {\n        __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](class_1, _super);\n        function class_1() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        /**\n         * @param {?} ast\n         * @param {?} context\n         * @return {?}\n         */\n        class_1.prototype.visit = function (ast, context) {\n            var /** @type {?} */ span = spanOf(ast);\n            if (span.start <= position && position < span.end) {\n                path.push(ast);\n            }\n            else {\n                // Returning a value here will result in the children being skipped.\n                return true;\n            }\n        };\n        return class_1;\n    }(RecursiveVisitor));\n    visitAll(visitor, nodes);\n    return new AstPath(path, position);\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TokenType$1 = {};\nTokenType$1.TAG_OPEN_START = 0;\nTokenType$1.TAG_OPEN_END = 1;\nTokenType$1.TAG_OPEN_END_VOID = 2;\nTokenType$1.TAG_CLOSE = 3;\nTokenType$1.TEXT = 4;\nTokenType$1.ESCAPABLE_RAW_TEXT = 5;\nTokenType$1.RAW_TEXT = 6;\nTokenType$1.COMMENT_START = 7;\nTokenType$1.COMMENT_END = 8;\nTokenType$1.CDATA_START = 9;\nTokenType$1.CDATA_END = 10;\nTokenType$1.ATTR_NAME = 11;\nTokenType$1.ATTR_VALUE = 12;\nTokenType$1.DOC_TYPE = 13;\nTokenType$1.EXPANSION_FORM_START = 14;\nTokenType$1.EXPANSION_CASE_VALUE = 15;\nTokenType$1.EXPANSION_CASE_EXP_START = 16;\nTokenType$1.EXPANSION_CASE_EXP_END = 17;\nTokenType$1.EXPANSION_FORM_END = 18;\nTokenType$1.EOF = 19;\nTokenType$1[TokenType$1.TAG_OPEN_START] = \"TAG_OPEN_START\";\nTokenType$1[TokenType$1.TAG_OPEN_END] = \"TAG_OPEN_END\";\nTokenType$1[TokenType$1.TAG_OPEN_END_VOID] = \"TAG_OPEN_END_VOID\";\nTokenType$1[TokenType$1.TAG_CLOSE] = \"TAG_CLOSE\";\nTokenType$1[TokenType$1.TEXT] = \"TEXT\";\nTokenType$1[TokenType$1.ESCAPABLE_RAW_TEXT] = \"ESCAPABLE_RAW_TEXT\";\nTokenType$1[TokenType$1.RAW_TEXT] = \"RAW_TEXT\";\nTokenType$1[TokenType$1.COMMENT_START] = \"COMMENT_START\";\nTokenType$1[TokenType$1.COMMENT_END] = \"COMMENT_END\";\nTokenType$1[TokenType$1.CDATA_START] = \"CDATA_START\";\nTokenType$1[TokenType$1.CDATA_END] = \"CDATA_END\";\nTokenType$1[TokenType$1.ATTR_NAME] = \"ATTR_NAME\";\nTokenType$1[TokenType$1.ATTR_VALUE] = \"ATTR_VALUE\";\nTokenType$1[TokenType$1.DOC_TYPE] = \"DOC_TYPE\";\nTokenType$1[TokenType$1.EXPANSION_FORM_START] = \"EXPANSION_FORM_START\";\nTokenType$1[TokenType$1.EXPANSION_CASE_VALUE] = \"EXPANSION_CASE_VALUE\";\nTokenType$1[TokenType$1.EXPANSION_CASE_EXP_START] = \"EXPANSION_CASE_EXP_START\";\nTokenType$1[TokenType$1.EXPANSION_CASE_EXP_END] = \"EXPANSION_CASE_EXP_END\";\nTokenType$1[TokenType$1.EXPANSION_FORM_END] = \"EXPANSION_FORM_END\";\nTokenType$1[TokenType$1.EOF] = \"EOF\";\nvar Token$1 = (function () {\n    /**\n     * @param {?} type\n     * @param {?} parts\n     * @param {?} sourceSpan\n     */\n    function Token$1(type, parts, sourceSpan) {\n        this.type = type;\n        this.parts = parts;\n        this.sourceSpan = sourceSpan;\n    }\n    return Token$1;\n}());\nvar TokenError = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](TokenError, _super);\n    /**\n     * @param {?} errorMsg\n     * @param {?} tokenType\n     * @param {?} span\n     */\n    function TokenError(errorMsg, tokenType, span) {\n        var _this = _super.call(this, span, errorMsg) || this;\n        _this.tokenType = tokenType;\n        return _this;\n    }\n    return TokenError;\n}(ParseError));\nvar TokenizeResult = (function () {\n    /**\n     * @param {?} tokens\n     * @param {?} errors\n     */\n    function TokenizeResult(tokens, errors) {\n        this.tokens = tokens;\n        this.errors = errors;\n    }\n    return TokenizeResult;\n}());\n/**\n * @param {?} source\n * @param {?} url\n * @param {?} getTagDefinition\n * @param {?=} tokenizeExpansionForms\n * @param {?=} interpolationConfig\n * @return {?}\n */\nfunction tokenize(source, url, getTagDefinition, tokenizeExpansionForms, interpolationConfig) {\n    if (tokenizeExpansionForms === void 0) { tokenizeExpansionForms = false; }\n    if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n    return new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, tokenizeExpansionForms, interpolationConfig)\n        .tokenize();\n}\nvar _CR_OR_CRLF_REGEXP = /\\r\\n?/g;\n/**\n * @param {?} charCode\n * @return {?}\n */\nfunction _unexpectedCharacterErrorMsg(charCode) {\n    var /** @type {?} */ char = charCode === $EOF ? 'EOF' : String.fromCharCode(charCode);\n    return \"Unexpected character \\\"\" + char + \"\\\"\";\n}\n/**\n * @param {?} entitySrc\n * @return {?}\n */\nfunction _unknownEntityErrorMsg(entitySrc) {\n    return \"Unknown entity \\\"\" + entitySrc + \"\\\" - use the \\\"&#<decimal>;\\\" or  \\\"&#x<hex>;\\\" syntax\";\n}\nvar _ControlFlowError = (function () {\n    /**\n     * @param {?} error\n     */\n    function _ControlFlowError(error) {\n        this.error = error;\n    }\n    return _ControlFlowError;\n}());\nvar _Tokenizer = (function () {\n    /**\n     * @param {?} _file The html source\n     * @param {?} _getTagDefinition\n     * @param {?} _tokenizeIcu Whether to tokenize ICU messages (considered as text nodes when false)\n     * @param {?=} _interpolationConfig\n     */\n    function _Tokenizer(_file, _getTagDefinition, _tokenizeIcu, _interpolationConfig) {\n        if (_interpolationConfig === void 0) { _interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        this._file = _file;\n        this._getTagDefinition = _getTagDefinition;\n        this._tokenizeIcu = _tokenizeIcu;\n        this._interpolationConfig = _interpolationConfig;\n        this._peek = -1;\n        this._nextPeek = -1;\n        this._index = -1;\n        this._line = 0;\n        this._column = -1;\n        this._expansionCaseStack = [];\n        this._inInterpolation = false;\n        this.tokens = [];\n        this.errors = [];\n        this._input = _file.content;\n        this._length = _file.content.length;\n        this._advance();\n    }\n    /**\n     * @param {?} content\n     * @return {?}\n     */\n    _Tokenizer.prototype._processCarriageReturns = function (content) {\n        // http://www.w3.org/TR/html5/syntax.html#preprocessing-the-input-stream\n        // In order to keep the original position in the source, we can not\n        // pre-process it.\n        // Instead CRs are processed right before instantiating the tokens.\n        return content.replace(_CR_OR_CRLF_REGEXP, '\\n');\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype.tokenize = function () {\n        while (this._peek !== $EOF) {\n            var /** @type {?} */ start = this._getLocation();\n            try {\n                if (this._attemptCharCode($LT)) {\n                    if (this._attemptCharCode($BANG)) {\n                        if (this._attemptCharCode($LBRACKET)) {\n                            this._consumeCdata(start);\n                        }\n                        else if (this._attemptCharCode($MINUS)) {\n                            this._consumeComment(start);\n                        }\n                        else {\n                            this._consumeDocType(start);\n                        }\n                    }\n                    else if (this._attemptCharCode($SLASH)) {\n                        this._consumeTagClose(start);\n                    }\n                    else {\n                        this._consumeTagOpen(start);\n                    }\n                }\n                else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {\n                    this._consumeText();\n                }\n            }\n            catch (e) {\n                if (e instanceof _ControlFlowError) {\n                    this.errors.push(e.error);\n                }\n                else {\n                    throw e;\n                }\n            }\n        }\n        this._beginToken(TokenType$1.EOF);\n        this._endToken([]);\n        return new TokenizeResult(mergeTextTokens(this.tokens), this.errors);\n    };\n    /**\n     * \\@internal\n     * @return {?}\n     */\n    _Tokenizer.prototype._tokenizeExpansionForm = function () {\n        if (isExpansionFormStart(this._input, this._index, this._interpolationConfig)) {\n            this._consumeExpansionFormStart();\n            return true;\n        }\n        if (isExpansionCaseStart(this._peek) && this._isInExpansionForm()) {\n            this._consumeExpansionCaseStart();\n            return true;\n        }\n        if (this._peek === $RBRACE) {\n            if (this._isInExpansionCase()) {\n                this._consumeExpansionCaseEnd();\n                return true;\n            }\n            if (this._isInExpansionForm()) {\n                this._consumeExpansionFormEnd();\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._getLocation = function () {\n        return new ParseLocation(this._file, this._index, this._line, this._column);\n    };\n    /**\n     * @param {?=} start\n     * @param {?=} end\n     * @return {?}\n     */\n    _Tokenizer.prototype._getSpan = function (start, end) {\n        if (start === void 0) { start = this._getLocation(); }\n        if (end === void 0) { end = this._getLocation(); }\n        return new ParseSourceSpan(start, end);\n    };\n    /**\n     * @param {?} type\n     * @param {?=} start\n     * @return {?}\n     */\n    _Tokenizer.prototype._beginToken = function (type, start) {\n        if (start === void 0) { start = this._getLocation(); }\n        this._currentTokenStart = start;\n        this._currentTokenType = type;\n    };\n    /**\n     * @param {?} parts\n     * @param {?=} end\n     * @return {?}\n     */\n    _Tokenizer.prototype._endToken = function (parts, end) {\n        if (end === void 0) { end = this._getLocation(); }\n        var /** @type {?} */ token = new Token$1(this._currentTokenType, parts, new ParseSourceSpan(this._currentTokenStart, end));\n        this.tokens.push(token);\n        this._currentTokenStart = ((null));\n        this._currentTokenType = ((null));\n        return token;\n    };\n    /**\n     * @param {?} msg\n     * @param {?} span\n     * @return {?}\n     */\n    _Tokenizer.prototype._createError = function (msg, span) {\n        if (this._isInExpansionForm()) {\n            msg += \" (Do you have an unescaped \\\"{\\\" in your template? Use \\\"{{ '{' }}\\\") to escape it.)\";\n        }\n        var /** @type {?} */ error = new TokenError(msg, this._currentTokenType, span);\n        this._currentTokenStart = ((null));\n        this._currentTokenType = ((null));\n        return new _ControlFlowError(error);\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._advance = function () {\n        if (this._index >= this._length) {\n            throw this._createError(_unexpectedCharacterErrorMsg($EOF), this._getSpan());\n        }\n        if (this._peek === $LF) {\n            this._line++;\n            this._column = 0;\n        }\n        else if (this._peek !== $LF && this._peek !== $CR) {\n            this._column++;\n        }\n        this._index++;\n        this._peek = this._index >= this._length ? $EOF : this._input.charCodeAt(this._index);\n        this._nextPeek =\n            this._index + 1 >= this._length ? $EOF : this._input.charCodeAt(this._index + 1);\n    };\n    /**\n     * @param {?} charCode\n     * @return {?}\n     */\n    _Tokenizer.prototype._attemptCharCode = function (charCode) {\n        if (this._peek === charCode) {\n            this._advance();\n            return true;\n        }\n        return false;\n    };\n    /**\n     * @param {?} charCode\n     * @return {?}\n     */\n    _Tokenizer.prototype._attemptCharCodeCaseInsensitive = function (charCode) {\n        if (compareCharCodeCaseInsensitive(this._peek, charCode)) {\n            this._advance();\n            return true;\n        }\n        return false;\n    };\n    /**\n     * @param {?} charCode\n     * @return {?}\n     */\n    _Tokenizer.prototype._requireCharCode = function (charCode) {\n        var /** @type {?} */ location = this._getLocation();\n        if (!this._attemptCharCode(charCode)) {\n            throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(location, location));\n        }\n    };\n    /**\n     * @param {?} chars\n     * @return {?}\n     */\n    _Tokenizer.prototype._attemptStr = function (chars) {\n        var /** @type {?} */ len = chars.length;\n        if (this._index + len > this._length) {\n            return false;\n        }\n        var /** @type {?} */ initialPosition = this._savePosition();\n        for (var /** @type {?} */ i = 0; i < len; i++) {\n            if (!this._attemptCharCode(chars.charCodeAt(i))) {\n                // If attempting to parse the string fails, we want to reset the parser\n                // to where it was before the attempt\n                this._restorePosition(initialPosition);\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * @param {?} chars\n     * @return {?}\n     */\n    _Tokenizer.prototype._attemptStrCaseInsensitive = function (chars) {\n        for (var /** @type {?} */ i = 0; i < chars.length; i++) {\n            if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * @param {?} chars\n     * @return {?}\n     */\n    _Tokenizer.prototype._requireStr = function (chars) {\n        var /** @type {?} */ location = this._getLocation();\n        if (!this._attemptStr(chars)) {\n            throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(location));\n        }\n    };\n    /**\n     * @param {?} predicate\n     * @return {?}\n     */\n    _Tokenizer.prototype._attemptCharCodeUntilFn = function (predicate) {\n        while (!predicate(this._peek)) {\n            this._advance();\n        }\n    };\n    /**\n     * @param {?} predicate\n     * @param {?} len\n     * @return {?}\n     */\n    _Tokenizer.prototype._requireCharCodeUntilFn = function (predicate, len) {\n        var /** @type {?} */ start = this._getLocation();\n        this._attemptCharCodeUntilFn(predicate);\n        if (this._index - start.offset < len) {\n            throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(start, start));\n        }\n    };\n    /**\n     * @param {?} char\n     * @return {?}\n     */\n    _Tokenizer.prototype._attemptUntilChar = function (char) {\n        while (this._peek !== char) {\n            this._advance();\n        }\n    };\n    /**\n     * @param {?} decodeEntities\n     * @return {?}\n     */\n    _Tokenizer.prototype._readChar = function (decodeEntities) {\n        if (decodeEntities && this._peek === $AMPERSAND) {\n            return this._decodeEntity();\n        }\n        else {\n            var /** @type {?} */ index = this._index;\n            this._advance();\n            return this._input[index];\n        }\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._decodeEntity = function () {\n        var /** @type {?} */ start = this._getLocation();\n        this._advance();\n        if (this._attemptCharCode($HASH)) {\n            var /** @type {?} */ isHex = this._attemptCharCode($x) || this._attemptCharCode($X);\n            var /** @type {?} */ numberStart = this._getLocation().offset;\n            this._attemptCharCodeUntilFn(isDigitEntityEnd);\n            if (this._peek != $SEMICOLON) {\n                throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan());\n            }\n            this._advance();\n            var /** @type {?} */ strNum = this._input.substring(numberStart, this._index - 1);\n            try {\n                var /** @type {?} */ charCode = parseInt(strNum, isHex ? 16 : 10);\n                return String.fromCharCode(charCode);\n            }\n            catch (e) {\n                var /** @type {?} */ entity = this._input.substring(start.offset + 1, this._index - 1);\n                throw this._createError(_unknownEntityErrorMsg(entity), this._getSpan(start));\n            }\n        }\n        else {\n            var /** @type {?} */ startPosition = this._savePosition();\n            this._attemptCharCodeUntilFn(isNamedEntityEnd);\n            if (this._peek != $SEMICOLON) {\n                this._restorePosition(startPosition);\n                return '&';\n            }\n            this._advance();\n            var /** @type {?} */ name = this._input.substring(start.offset + 1, this._index - 1);\n            var /** @type {?} */ char = NAMED_ENTITIES[name];\n            if (!char) {\n                throw this._createError(_unknownEntityErrorMsg(name), this._getSpan(start));\n            }\n            return char;\n        }\n    };\n    /**\n     * @param {?} decodeEntities\n     * @param {?} firstCharOfEnd\n     * @param {?} attemptEndRest\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeRawText = function (decodeEntities, firstCharOfEnd, attemptEndRest) {\n        var /** @type {?} */ tagCloseStart;\n        var /** @type {?} */ textStart = this._getLocation();\n        this._beginToken(decodeEntities ? TokenType$1.ESCAPABLE_RAW_TEXT : TokenType$1.RAW_TEXT, textStart);\n        var /** @type {?} */ parts = [];\n        while (true) {\n            tagCloseStart = this._getLocation();\n            if (this._attemptCharCode(firstCharOfEnd) && attemptEndRest()) {\n                break;\n            }\n            if (this._index > tagCloseStart.offset) {\n                // add the characters consumed by the previous if statement to the output\n                parts.push(this._input.substring(tagCloseStart.offset, this._index));\n            }\n            while (this._peek !== firstCharOfEnd) {\n                parts.push(this._readChar(decodeEntities));\n            }\n        }\n        return this._endToken([this._processCarriageReturns(parts.join(''))], tagCloseStart);\n    };\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeComment = function (start) {\n        var _this = this;\n        this._beginToken(TokenType$1.COMMENT_START, start);\n        this._requireCharCode($MINUS);\n        this._endToken([]);\n        var /** @type {?} */ textToken = this._consumeRawText(false, $MINUS, function () { return _this._attemptStr('->'); });\n        this._beginToken(TokenType$1.COMMENT_END, textToken.sourceSpan.end);\n        this._endToken([]);\n    };\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeCdata = function (start) {\n        var _this = this;\n        this._beginToken(TokenType$1.CDATA_START, start);\n        this._requireStr('CDATA[');\n        this._endToken([]);\n        var /** @type {?} */ textToken = this._consumeRawText(false, $RBRACKET, function () { return _this._attemptStr(']>'); });\n        this._beginToken(TokenType$1.CDATA_END, textToken.sourceSpan.end);\n        this._endToken([]);\n    };\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeDocType = function (start) {\n        this._beginToken(TokenType$1.DOC_TYPE, start);\n        this._attemptUntilChar($GT);\n        this._advance();\n        this._endToken([this._input.substring(start.offset + 2, this._index - 1)]);\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumePrefixAndName = function () {\n        var /** @type {?} */ nameOrPrefixStart = this._index;\n        var /** @type {?} */ prefix = ((null));\n        while (this._peek !== $COLON && !isPrefixEnd(this._peek)) {\n            this._advance();\n        }\n        var /** @type {?} */ nameStart;\n        if (this._peek === $COLON) {\n            this._advance();\n            prefix = this._input.substring(nameOrPrefixStart, this._index - 1);\n            nameStart = this._index;\n        }\n        else {\n            nameStart = nameOrPrefixStart;\n        }\n        this._requireCharCodeUntilFn(isNameEnd, this._index === nameStart ? 1 : 0);\n        var /** @type {?} */ name = this._input.substring(nameStart, this._index);\n        return [prefix, name];\n    };\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeTagOpen = function (start) {\n        var /** @type {?} */ savedPos = this._savePosition();\n        var /** @type {?} */ tagName;\n        var /** @type {?} */ lowercaseTagName;\n        try {\n            if (!isAsciiLetter(this._peek)) {\n                throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan());\n            }\n            var /** @type {?} */ nameStart = this._index;\n            this._consumeTagOpenStart(start);\n            tagName = this._input.substring(nameStart, this._index);\n            lowercaseTagName = tagName.toLowerCase();\n            this._attemptCharCodeUntilFn(isNotWhitespace);\n            while (this._peek !== $SLASH && this._peek !== $GT) {\n                this._consumeAttributeName();\n                this._attemptCharCodeUntilFn(isNotWhitespace);\n                if (this._attemptCharCode($EQ)) {\n                    this._attemptCharCodeUntilFn(isNotWhitespace);\n                    this._consumeAttributeValue();\n                }\n                this._attemptCharCodeUntilFn(isNotWhitespace);\n            }\n            this._consumeTagOpenEnd();\n        }\n        catch (e) {\n            if (e instanceof _ControlFlowError) {\n                // When the start tag is invalid, assume we want a \"<\"\n                this._restorePosition(savedPos);\n                // Back to back text tokens are merged at the end\n                this._beginToken(TokenType$1.TEXT, start);\n                this._endToken(['<']);\n                return;\n            }\n            throw e;\n        }\n        var /** @type {?} */ contentTokenType = this._getTagDefinition(tagName).contentType;\n        if (contentTokenType === TagContentType.RAW_TEXT) {\n            this._consumeRawTextWithTagClose(lowercaseTagName, false);\n        }\n        else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {\n            this._consumeRawTextWithTagClose(lowercaseTagName, true);\n        }\n    };\n    /**\n     * @param {?} lowercaseTagName\n     * @param {?} decodeEntities\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeRawTextWithTagClose = function (lowercaseTagName, decodeEntities) {\n        var _this = this;\n        var /** @type {?} */ textToken = this._consumeRawText(decodeEntities, $LT, function () {\n            if (!_this._attemptCharCode($SLASH))\n                return false;\n            _this._attemptCharCodeUntilFn(isNotWhitespace);\n            if (!_this._attemptStrCaseInsensitive(lowercaseTagName))\n                return false;\n            _this._attemptCharCodeUntilFn(isNotWhitespace);\n            return _this._attemptCharCode($GT);\n        });\n        this._beginToken(TokenType$1.TAG_CLOSE, textToken.sourceSpan.end);\n        this._endToken([/** @type {?} */ ((null)), lowercaseTagName]);\n    };\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeTagOpenStart = function (start) {\n        this._beginToken(TokenType$1.TAG_OPEN_START, start);\n        var /** @type {?} */ parts = this._consumePrefixAndName();\n        this._endToken(parts);\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeAttributeName = function () {\n        this._beginToken(TokenType$1.ATTR_NAME);\n        var /** @type {?} */ prefixAndName = this._consumePrefixAndName();\n        this._endToken(prefixAndName);\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeAttributeValue = function () {\n        this._beginToken(TokenType$1.ATTR_VALUE);\n        var /** @type {?} */ value;\n        if (this._peek === $SQ || this._peek === $DQ) {\n            var /** @type {?} */ quoteChar = this._peek;\n            this._advance();\n            var /** @type {?} */ parts = [];\n            while (this._peek !== quoteChar) {\n                parts.push(this._readChar(true));\n            }\n            value = parts.join('');\n            this._advance();\n        }\n        else {\n            var /** @type {?} */ valueStart = this._index;\n            this._requireCharCodeUntilFn(isNameEnd, 1);\n            value = this._input.substring(valueStart, this._index);\n        }\n        this._endToken([this._processCarriageReturns(value)]);\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeTagOpenEnd = function () {\n        var /** @type {?} */ tokenType = this._attemptCharCode($SLASH) ? TokenType$1.TAG_OPEN_END_VOID : TokenType$1.TAG_OPEN_END;\n        this._beginToken(tokenType);\n        this._requireCharCode($GT);\n        this._endToken([]);\n    };\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeTagClose = function (start) {\n        this._beginToken(TokenType$1.TAG_CLOSE, start);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        var /** @type {?} */ prefixAndName = this._consumePrefixAndName();\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._requireCharCode($GT);\n        this._endToken(prefixAndName);\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeExpansionFormStart = function () {\n        this._beginToken(TokenType$1.EXPANSION_FORM_START, this._getLocation());\n        this._requireCharCode($LBRACE);\n        this._endToken([]);\n        this._expansionCaseStack.push(TokenType$1.EXPANSION_FORM_START);\n        this._beginToken(TokenType$1.RAW_TEXT, this._getLocation());\n        var /** @type {?} */ condition = this._readUntil($COMMA);\n        this._endToken([condition], this._getLocation());\n        this._requireCharCode($COMMA);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._beginToken(TokenType$1.RAW_TEXT, this._getLocation());\n        var /** @type {?} */ type = this._readUntil($COMMA);\n        this._endToken([type], this._getLocation());\n        this._requireCharCode($COMMA);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeExpansionCaseStart = function () {\n        this._beginToken(TokenType$1.EXPANSION_CASE_VALUE, this._getLocation());\n        var /** @type {?} */ value = this._readUntil($LBRACE).trim();\n        this._endToken([value], this._getLocation());\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._beginToken(TokenType$1.EXPANSION_CASE_EXP_START, this._getLocation());\n        this._requireCharCode($LBRACE);\n        this._endToken([], this._getLocation());\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._expansionCaseStack.push(TokenType$1.EXPANSION_CASE_EXP_START);\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeExpansionCaseEnd = function () {\n        this._beginToken(TokenType$1.EXPANSION_CASE_EXP_END, this._getLocation());\n        this._requireCharCode($RBRACE);\n        this._endToken([], this._getLocation());\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._expansionCaseStack.pop();\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeExpansionFormEnd = function () {\n        this._beginToken(TokenType$1.EXPANSION_FORM_END, this._getLocation());\n        this._requireCharCode($RBRACE);\n        this._endToken([]);\n        this._expansionCaseStack.pop();\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeText = function () {\n        var /** @type {?} */ start = this._getLocation();\n        this._beginToken(TokenType$1.TEXT, start);\n        var /** @type {?} */ parts = [];\n        do {\n            if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {\n                parts.push(this._interpolationConfig.start);\n                this._inInterpolation = true;\n            }\n            else if (this._interpolationConfig && this._inInterpolation &&\n                this._attemptStr(this._interpolationConfig.end)) {\n                parts.push(this._interpolationConfig.end);\n                this._inInterpolation = false;\n            }\n            else {\n                parts.push(this._readChar(true));\n            }\n        } while (!this._isTextEnd());\n        this._endToken([this._processCarriageReturns(parts.join(''))]);\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._isTextEnd = function () {\n        if (this._peek === $LT || this._peek === $EOF) {\n            return true;\n        }\n        if (this._tokenizeIcu && !this._inInterpolation) {\n            if (isExpansionFormStart(this._input, this._index, this._interpolationConfig)) {\n                // start of an expansion form\n                return true;\n            }\n            if (this._peek === $RBRACE && this._isInExpansionCase()) {\n                // end of and expansion case\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._savePosition = function () {\n        return [this._peek, this._index, this._column, this._line, this.tokens.length];\n    };\n    /**\n     * @param {?} char\n     * @return {?}\n     */\n    _Tokenizer.prototype._readUntil = function (char) {\n        var /** @type {?} */ start = this._index;\n        this._attemptUntilChar(char);\n        return this._input.substring(start, this._index);\n    };\n    /**\n     * @param {?} position\n     * @return {?}\n     */\n    _Tokenizer.prototype._restorePosition = function (position) {\n        this._peek = position[0];\n        this._index = position[1];\n        this._column = position[2];\n        this._line = position[3];\n        var /** @type {?} */ nbTokens = position[4];\n        if (nbTokens < this.tokens.length) {\n            // remove any extra tokens\n            this.tokens = this.tokens.slice(0, nbTokens);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._isInExpansionCase = function () {\n        return this._expansionCaseStack.length > 0 &&\n            this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n                TokenType$1.EXPANSION_CASE_EXP_START;\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._isInExpansionForm = function () {\n        return this._expansionCaseStack.length > 0 &&\n            this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n                TokenType$1.EXPANSION_FORM_START;\n    };\n    return _Tokenizer;\n}());\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isNotWhitespace(code) {\n    return !isWhitespace(code) || code === $EOF;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isNameEnd(code) {\n    return isWhitespace(code) || code === $GT || code === $SLASH ||\n        code === $SQ || code === $DQ || code === $EQ;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isPrefixEnd(code) {\n    return (code < $a || $z < code) && (code < $A || $Z < code) &&\n        (code < $0 || code > $9);\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isDigitEntityEnd(code) {\n    return code == $SEMICOLON || code == $EOF || !isAsciiHexDigit(code);\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isNamedEntityEnd(code) {\n    return code == $SEMICOLON || code == $EOF || !isAsciiLetter(code);\n}\n/**\n * @param {?} input\n * @param {?} offset\n * @param {?} interpolationConfig\n * @return {?}\n */\nfunction isExpansionFormStart(input, offset, interpolationConfig) {\n    var /** @type {?} */ isInterpolationStart = interpolationConfig ? input.indexOf(interpolationConfig.start, offset) == offset : false;\n    return input.charCodeAt(offset) == $LBRACE && !isInterpolationStart;\n}\n/**\n * @param {?} peek\n * @return {?}\n */\nfunction isExpansionCaseStart(peek) {\n    return peek === $EQ || isAsciiLetter(peek) || isDigit(peek);\n}\n/**\n * @param {?} code1\n * @param {?} code2\n * @return {?}\n */\nfunction compareCharCodeCaseInsensitive(code1, code2) {\n    return toUpperCaseCharCode(code1) == toUpperCaseCharCode(code2);\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction toUpperCaseCharCode(code) {\n    return code >= $a && code <= $z ? code - $a + $A : code;\n}\n/**\n * @param {?} srcTokens\n * @return {?}\n */\nfunction mergeTextTokens(srcTokens) {\n    var /** @type {?} */ dstTokens = [];\n    var /** @type {?} */ lastDstToken = undefined;\n    for (var /** @type {?} */ i = 0; i < srcTokens.length; i++) {\n        var /** @type {?} */ token = srcTokens[i];\n        if (lastDstToken && lastDstToken.type == TokenType$1.TEXT && token.type == TokenType$1.TEXT) {\n            lastDstToken.parts[0] += token.parts[0];\n            lastDstToken.sourceSpan.end = token.sourceSpan.end;\n        }\n        else {\n            lastDstToken = token;\n            dstTokens.push(lastDstToken);\n        }\n    }\n    return dstTokens;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TreeError = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](TreeError, _super);\n    /**\n     * @param {?} elementName\n     * @param {?} span\n     * @param {?} msg\n     */\n    function TreeError(elementName, span, msg) {\n        var _this = _super.call(this, span, msg) || this;\n        _this.elementName = elementName;\n        return _this;\n    }\n    /**\n     * @param {?} elementName\n     * @param {?} span\n     * @param {?} msg\n     * @return {?}\n     */\n    TreeError.create = function (elementName, span, msg) {\n        return new TreeError(elementName, span, msg);\n    };\n    return TreeError;\n}(ParseError));\nvar ParseTreeResult = (function () {\n    /**\n     * @param {?} rootNodes\n     * @param {?} errors\n     */\n    function ParseTreeResult(rootNodes, errors) {\n        this.rootNodes = rootNodes;\n        this.errors = errors;\n    }\n    return ParseTreeResult;\n}());\nvar Parser$1 = (function () {\n    /**\n     * @param {?} getTagDefinition\n     */\n    function Parser$1(getTagDefinition) {\n        this.getTagDefinition = getTagDefinition;\n    }\n    /**\n     * @param {?} source\n     * @param {?} url\n     * @param {?=} parseExpansionForms\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    Parser$1.prototype.parse = function (source, url, parseExpansionForms, interpolationConfig) {\n        if (parseExpansionForms === void 0) { parseExpansionForms = false; }\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        var /** @type {?} */ tokensAndErrors = tokenize(source, url, this.getTagDefinition, parseExpansionForms, interpolationConfig);\n        var /** @type {?} */ treeAndErrors = new _TreeBuilder(tokensAndErrors.tokens, this.getTagDefinition).build();\n        return new ParseTreeResult(treeAndErrors.rootNodes, ((tokensAndErrors.errors)).concat(treeAndErrors.errors));\n    };\n    return Parser$1;\n}());\nvar _TreeBuilder = (function () {\n    /**\n     * @param {?} tokens\n     * @param {?} getTagDefinition\n     */\n    function _TreeBuilder(tokens, getTagDefinition) {\n        this.tokens = tokens;\n        this.getTagDefinition = getTagDefinition;\n        this._index = -1;\n        this._rootNodes = [];\n        this._errors = [];\n        this._elementStack = [];\n        this._advance();\n    }\n    /**\n     * @return {?}\n     */\n    _TreeBuilder.prototype.build = function () {\n        while (this._peek.type !== TokenType$1.EOF) {\n            if (this._peek.type === TokenType$1.TAG_OPEN_START) {\n                this._consumeStartTag(this._advance());\n            }\n            else if (this._peek.type === TokenType$1.TAG_CLOSE) {\n                this._consumeEndTag(this._advance());\n            }\n            else if (this._peek.type === TokenType$1.CDATA_START) {\n                this._closeVoidElement();\n                this._consumeCdata(this._advance());\n            }\n            else if (this._peek.type === TokenType$1.COMMENT_START) {\n                this._closeVoidElement();\n                this._consumeComment(this._advance());\n            }\n            else if (this._peek.type === TokenType$1.TEXT || this._peek.type === TokenType$1.RAW_TEXT ||\n                this._peek.type === TokenType$1.ESCAPABLE_RAW_TEXT) {\n                this._closeVoidElement();\n                this._consumeText(this._advance());\n            }\n            else if (this._peek.type === TokenType$1.EXPANSION_FORM_START) {\n                this._consumeExpansion(this._advance());\n            }\n            else {\n                // Skip all other tokens...\n                this._advance();\n            }\n        }\n        return new ParseTreeResult(this._rootNodes, this._errors);\n    };\n    /**\n     * @return {?}\n     */\n    _TreeBuilder.prototype._advance = function () {\n        var /** @type {?} */ prev = this._peek;\n        if (this._index < this.tokens.length - 1) {\n            // Note: there is always an EOF token at the end\n            this._index++;\n        }\n        this._peek = this.tokens[this._index];\n        return prev;\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    _TreeBuilder.prototype._advanceIf = function (type) {\n        if (this._peek.type === type) {\n            return this._advance();\n        }\n        return null;\n    };\n    /**\n     * @param {?} startToken\n     * @return {?}\n     */\n    _TreeBuilder.prototype._consumeCdata = function (startToken) {\n        this._consumeText(this._advance());\n        this._advanceIf(TokenType$1.CDATA_END);\n    };\n    /**\n     * @param {?} token\n     * @return {?}\n     */\n    _TreeBuilder.prototype._consumeComment = function (token) {\n        var /** @type {?} */ text = this._advanceIf(TokenType$1.RAW_TEXT);\n        this._advanceIf(TokenType$1.COMMENT_END);\n        var /** @type {?} */ value = text != null ? text.parts[0].trim() : null;\n        this._addToParent(new Comment(value, token.sourceSpan));\n    };\n    /**\n     * @param {?} token\n     * @return {?}\n     */\n    _TreeBuilder.prototype._consumeExpansion = function (token) {\n        var /** @type {?} */ switchValue = this._advance();\n        var /** @type {?} */ type = this._advance();\n        var /** @type {?} */ cases = [];\n        // read =\n        while (this._peek.type === TokenType$1.EXPANSION_CASE_VALUE) {\n            var /** @type {?} */ expCase = this._parseExpansionCase();\n            if (!expCase)\n                return; // error\n            cases.push(expCase);\n        }\n        // read the final }\n        if (this._peek.type !== TokenType$1.EXPANSION_FORM_END) {\n            this._errors.push(TreeError.create(null, this._peek.sourceSpan, \"Invalid ICU message. Missing '}'.\"));\n            return;\n        }\n        var /** @type {?} */ sourceSpan = new ParseSourceSpan(token.sourceSpan.start, this._peek.sourceSpan.end);\n        this._addToParent(new Expansion(switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan));\n        this._advance();\n    };\n    /**\n     * @return {?}\n     */\n    _TreeBuilder.prototype._parseExpansionCase = function () {\n        var /** @type {?} */ value = this._advance();\n        // read {\n        if (this._peek.type !== TokenType$1.EXPANSION_CASE_EXP_START) {\n            this._errors.push(TreeError.create(null, this._peek.sourceSpan, \"Invalid ICU message. Missing '{'.\"));\n            return null;\n        }\n        // read until }\n        var /** @type {?} */ start = this._advance();\n        var /** @type {?} */ exp = this._collectExpansionExpTokens(start);\n        if (!exp)\n            return null;\n        var /** @type {?} */ end = this._advance();\n        exp.push(new Token$1(TokenType$1.EOF, [], end.sourceSpan));\n        // parse everything in between { and }\n        var /** @type {?} */ parsedExp = new _TreeBuilder(exp, this.getTagDefinition).build();\n        if (parsedExp.errors.length > 0) {\n            this._errors = this._errors.concat(/** @type {?} */ (parsedExp.errors));\n            return null;\n        }\n        var /** @type {?} */ sourceSpan = new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end);\n        var /** @type {?} */ expSourceSpan = new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end);\n        return new ExpansionCase(value.parts[0], parsedExp.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);\n    };\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _TreeBuilder.prototype._collectExpansionExpTokens = function (start) {\n        var /** @type {?} */ exp = [];\n        var /** @type {?} */ expansionFormStack = [TokenType$1.EXPANSION_CASE_EXP_START];\n        while (true) {\n            if (this._peek.type === TokenType$1.EXPANSION_FORM_START ||\n                this._peek.type === TokenType$1.EXPANSION_CASE_EXP_START) {\n                expansionFormStack.push(this._peek.type);\n            }\n            if (this._peek.type === TokenType$1.EXPANSION_CASE_EXP_END) {\n                if (lastOnStack(expansionFormStack, TokenType$1.EXPANSION_CASE_EXP_START)) {\n                    expansionFormStack.pop();\n                    if (expansionFormStack.length == 0)\n                        return exp;\n                }\n                else {\n                    this._errors.push(TreeError.create(null, start.sourceSpan, \"Invalid ICU message. Missing '}'.\"));\n                    return null;\n                }\n            }\n            if (this._peek.type === TokenType$1.EXPANSION_FORM_END) {\n                if (lastOnStack(expansionFormStack, TokenType$1.EXPANSION_FORM_START)) {\n                    expansionFormStack.pop();\n                }\n                else {\n                    this._errors.push(TreeError.create(null, start.sourceSpan, \"Invalid ICU message. Missing '}'.\"));\n                    return null;\n                }\n            }\n            if (this._peek.type === TokenType$1.EOF) {\n                this._errors.push(TreeError.create(null, start.sourceSpan, \"Invalid ICU message. Missing '}'.\"));\n                return null;\n            }\n            exp.push(this._advance());\n        }\n    };\n    /**\n     * @param {?} token\n     * @return {?}\n     */\n    _TreeBuilder.prototype._consumeText = function (token) {\n        var /** @type {?} */ text = token.parts[0];\n        if (text.length > 0 && text[0] == '\\n') {\n            var /** @type {?} */ parent = this._getParentElement();\n            if (parent != null && parent.children.length == 0 &&\n                this.getTagDefinition(parent.name).ignoreFirstLf) {\n                text = text.substring(1);\n            }\n        }\n        if (text.length > 0) {\n            this._addToParent(new Text(text, token.sourceSpan));\n        }\n    };\n    /**\n     * @return {?}\n     */\n    _TreeBuilder.prototype._closeVoidElement = function () {\n        var /** @type {?} */ el = this._getParentElement();\n        if (el && this.getTagDefinition(el.name).isVoid) {\n            this._elementStack.pop();\n        }\n    };\n    /**\n     * @param {?} startTagToken\n     * @return {?}\n     */\n    _TreeBuilder.prototype._consumeStartTag = function (startTagToken) {\n        var /** @type {?} */ prefix = startTagToken.parts[0];\n        var /** @type {?} */ name = startTagToken.parts[1];\n        var /** @type {?} */ attrs = [];\n        while (this._peek.type === TokenType$1.ATTR_NAME) {\n            attrs.push(this._consumeAttr(this._advance()));\n        }\n        var /** @type {?} */ fullName = this._getElementFullName(prefix, name, this._getParentElement());\n        var /** @type {?} */ selfClosing = false;\n        // Note: There could have been a tokenizer error\n        // so that we don't get a token for the end tag...\n        if (this._peek.type === TokenType$1.TAG_OPEN_END_VOID) {\n            this._advance();\n            selfClosing = true;\n            var /** @type {?} */ tagDef = this.getTagDefinition(fullName);\n            if (!(tagDef.canSelfClose || getNsPrefix(fullName) !== null || tagDef.isVoid)) {\n                this._errors.push(TreeError.create(fullName, startTagToken.sourceSpan, \"Only void and foreign elements can be self closed \\\"\" + startTagToken.parts[1] + \"\\\"\"));\n            }\n        }\n        else if (this._peek.type === TokenType$1.TAG_OPEN_END) {\n            this._advance();\n            selfClosing = false;\n        }\n        var /** @type {?} */ end = this._peek.sourceSpan.start;\n        var /** @type {?} */ span = new ParseSourceSpan(startTagToken.sourceSpan.start, end);\n        var /** @type {?} */ el = new Element(fullName, attrs, [], span, span, undefined);\n        this._pushElement(el);\n        if (selfClosing) {\n            this._popElement(fullName);\n            el.endSourceSpan = span;\n        }\n    };\n    /**\n     * @param {?} el\n     * @return {?}\n     */\n    _TreeBuilder.prototype._pushElement = function (el) {\n        var /** @type {?} */ parentEl = this._getParentElement();\n        if (parentEl && this.getTagDefinition(parentEl.name).isClosedByChild(el.name)) {\n            this._elementStack.pop();\n        }\n        var /** @type {?} */ tagDef = this.getTagDefinition(el.name);\n        var _a = this._getParentElementSkippingContainers(), parent = _a.parent, container = _a.container;\n        if (parent && tagDef.requireExtraParent(parent.name)) {\n            var /** @type {?} */ newParent = new Element(tagDef.parentToAdd, [], [], el.sourceSpan, el.startSourceSpan, el.endSourceSpan);\n            this._insertBeforeContainer(parent, container, newParent);\n        }\n        this._addToParent(el);\n        this._elementStack.push(el);\n    };\n    /**\n     * @param {?} endTagToken\n     * @return {?}\n     */\n    _TreeBuilder.prototype._consumeEndTag = function (endTagToken) {\n        var /** @type {?} */ fullName = this._getElementFullName(endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());\n        if (this._getParentElement()) {\n            ((this._getParentElement())).endSourceSpan = endTagToken.sourceSpan;\n        }\n        if (this.getTagDefinition(fullName).isVoid) {\n            this._errors.push(TreeError.create(fullName, endTagToken.sourceSpan, \"Void elements do not have end tags \\\"\" + endTagToken.parts[1] + \"\\\"\"));\n        }\n        else if (!this._popElement(fullName)) {\n            var /** @type {?} */ errMsg = \"Unexpected closing tag \\\"\" + fullName + \"\\\". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags\";\n            this._errors.push(TreeError.create(fullName, endTagToken.sourceSpan, errMsg));\n        }\n    };\n    /**\n     * @param {?} fullName\n     * @return {?}\n     */\n    _TreeBuilder.prototype._popElement = function (fullName) {\n        for (var /** @type {?} */ stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {\n            var /** @type {?} */ el = this._elementStack[stackIndex];\n            if (el.name == fullName) {\n                this._elementStack.splice(stackIndex, this._elementStack.length - stackIndex);\n                return true;\n            }\n            if (!this.getTagDefinition(el.name).closedByParent) {\n                return false;\n            }\n        }\n        return false;\n    };\n    /**\n     * @param {?} attrName\n     * @return {?}\n     */\n    _TreeBuilder.prototype._consumeAttr = function (attrName) {\n        var /** @type {?} */ fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);\n        var /** @type {?} */ end = attrName.sourceSpan.end;\n        var /** @type {?} */ value = '';\n        var /** @type {?} */ valueSpan = ((undefined));\n        if (this._peek.type === TokenType$1.ATTR_VALUE) {\n            var /** @type {?} */ valueToken = this._advance();\n            value = valueToken.parts[0];\n            end = valueToken.sourceSpan.end;\n            valueSpan = valueToken.sourceSpan;\n        }\n        return new Attribute$1(fullName, value, new ParseSourceSpan(attrName.sourceSpan.start, end), valueSpan);\n    };\n    /**\n     * @return {?}\n     */\n    _TreeBuilder.prototype._getParentElement = function () {\n        return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;\n    };\n    /**\n     * Returns the parent in the DOM and the container.\n     *\n     * `<ng-container>` elements are skipped as they are not rendered as DOM element.\n     * @return {?}\n     */\n    _TreeBuilder.prototype._getParentElementSkippingContainers = function () {\n        var /** @type {?} */ container = null;\n        for (var /** @type {?} */ i = this._elementStack.length - 1; i >= 0; i--) {\n            if (!isNgContainer(this._elementStack[i].name)) {\n                return { parent: this._elementStack[i], container: container };\n            }\n            container = this._elementStack[i];\n        }\n        return { parent: null, container: container };\n    };\n    /**\n     * @param {?} node\n     * @return {?}\n     */\n    _TreeBuilder.prototype._addToParent = function (node) {\n        var /** @type {?} */ parent = this._getParentElement();\n        if (parent != null) {\n            parent.children.push(node);\n        }\n        else {\n            this._rootNodes.push(node);\n        }\n    };\n    /**\n     * Insert a node between the parent and the container.\n     * When no container is given, the node is appended as a child of the parent.\n     * Also updates the element stack accordingly.\n     *\n     * \\@internal\n     * @param {?} parent\n     * @param {?} container\n     * @param {?} node\n     * @return {?}\n     */\n    _TreeBuilder.prototype._insertBeforeContainer = function (parent, container, node) {\n        if (!container) {\n            this._addToParent(node);\n            this._elementStack.push(node);\n        }\n        else {\n            if (parent) {\n                // replace the container with the new node in the children\n                var /** @type {?} */ index = parent.children.indexOf(container);\n                parent.children[index] = node;\n            }\n            else {\n                this._rootNodes.push(node);\n            }\n            node.children.push(container);\n            this._elementStack.splice(this._elementStack.indexOf(container), 0, node);\n        }\n    };\n    /**\n     * @param {?} prefix\n     * @param {?} localName\n     * @param {?} parentElement\n     * @return {?}\n     */\n    _TreeBuilder.prototype._getElementFullName = function (prefix, localName, parentElement) {\n        if (prefix == null) {\n            prefix = ((this.getTagDefinition(localName).implicitNamespacePrefix));\n            if (prefix == null && parentElement != null) {\n                prefix = getNsPrefix(parentElement.name);\n            }\n        }\n        return mergeNsAndName(prefix, localName);\n    };\n    return _TreeBuilder;\n}());\n/**\n * @param {?} stack\n * @param {?} element\n * @return {?}\n */\nfunction lastOnStack(stack, element) {\n    return stack.length > 0 && stack[stack.length - 1] === element;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} message\n * @return {?}\n */\nfunction digest(message) {\n    return message.id || sha1(serializeNodes(message.nodes).join('') + (\"[\" + message.meaning + \"]\"));\n}\n/**\n * @param {?} message\n * @return {?}\n */\nfunction decimalDigest(message) {\n    if (message.id) {\n        return message.id;\n    }\n    var /** @type {?} */ visitor = new _SerializerIgnoreIcuExpVisitor();\n    var /** @type {?} */ parts = message.nodes.map(function (a) { return a.visit(visitor, null); });\n    return computeMsgId(parts.join(''), message.meaning);\n}\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * The visitor is also used in the i18n parser tests\n *\n * \\@internal\n */\nvar _SerializerVisitor = (function () {\n    function _SerializerVisitor() {\n    }\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    _SerializerVisitor.prototype.visitText = function (text, context) { return text.value; };\n    /**\n     * @param {?} container\n     * @param {?} context\n     * @return {?}\n     */\n    _SerializerVisitor.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        return \"[\" + container.children.map(function (child) { return child.visit(_this); }).join(', ') + \"]\";\n    };\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    _SerializerVisitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var /** @type {?} */ strCases = Object.keys(icu.cases).map(function (k) { return k + \" {\" + icu.cases[k].visit(_this) + \"}\"; });\n        return \"{\" + icu.expression + \", \" + icu.type + \", \" + strCases.join(', ') + \"}\";\n    };\n    /**\n     * @param {?} ph\n     * @param {?} context\n     * @return {?}\n     */\n    _SerializerVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n        var _this = this;\n        return ph.isVoid ?\n            \"<ph tag name=\\\"\" + ph.startName + \"\\\"/>\" :\n            \"<ph tag name=\\\"\" + ph.startName + \"\\\">\" + ph.children.map(function (child) { return child.visit(_this); }).join(', ') + \"</ph name=\\\"\" + ph.closeName + \"\\\">\";\n    };\n    /**\n     * @param {?} ph\n     * @param {?} context\n     * @return {?}\n     */\n    _SerializerVisitor.prototype.visitPlaceholder = function (ph, context) {\n        return ph.value ? \"<ph name=\\\"\" + ph.name + \"\\\">\" + ph.value + \"</ph>\" : \"<ph name=\\\"\" + ph.name + \"\\\"/>\";\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    _SerializerVisitor.prototype.visitIcuPlaceholder = function (ph, context) {\n        return \"<ph icu name=\\\"\" + ph.name + \"\\\">\" + ph.value.visit(this) + \"</ph>\";\n    };\n    return _SerializerVisitor;\n}());\nvar serializerVisitor = new _SerializerVisitor();\n/**\n * @param {?} nodes\n * @return {?}\n */\nfunction serializeNodes(nodes) {\n    return nodes.map(function (a) { return a.visit(serializerVisitor, null); });\n}\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * Ignore the ICU expressions so that message IDs stays identical if only the expression changes.\n *\n * \\@internal\n */\nvar _SerializerIgnoreIcuExpVisitor = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](_SerializerIgnoreIcuExpVisitor, _super);\n    function _SerializerIgnoreIcuExpVisitor() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    _SerializerIgnoreIcuExpVisitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var /** @type {?} */ strCases = Object.keys(icu.cases).map(function (k) { return k + \" {\" + icu.cases[k].visit(_this) + \"}\"; });\n        // Do not take the expression into account\n        return \"{\" + icu.type + \", \" + strCases.join(', ') + \"}\";\n    };\n    return _SerializerIgnoreIcuExpVisitor;\n}(_SerializerVisitor));\n/**\n * Compute the SHA1 of the given string\n *\n * see http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf\n *\n * WARNING: this function has not been designed not tested with security in mind.\n *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.\n * @param {?} str\n * @return {?}\n */\nfunction sha1(str) {\n    var /** @type {?} */ utf8 = utf8Encode(str);\n    var /** @type {?} */ words32 = stringToWords32(utf8, Endian.Big);\n    var /** @type {?} */ len = utf8.length * 8;\n    var /** @type {?} */ w = new Array(80);\n    var _a = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0], a = _a[0], b = _a[1], c = _a[2], d = _a[3], e = _a[4];\n    words32[len >> 5] |= 0x80 << (24 - len % 32);\n    words32[((len + 64 >> 9) << 4) + 15] = len;\n    for (var /** @type {?} */ i = 0; i < words32.length; i += 16) {\n        var _b = [a, b, c, d, e], h0 = _b[0], h1 = _b[1], h2 = _b[2], h3 = _b[3], h4 = _b[4];\n        for (var /** @type {?} */ j = 0; j < 80; j++) {\n            if (j < 16) {\n                w[j] = words32[i + j];\n            }\n            else {\n                w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);\n            }\n            var _c = fk(j, b, c, d), f = _c[0], k = _c[1];\n            var /** @type {?} */ temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);\n            _d = [d, c, rol32(b, 30), a, temp], e = _d[0], d = _d[1], c = _d[2], b = _d[3], a = _d[4];\n        }\n        _e = [add32(a, h0), add32(b, h1), add32(c, h2), add32(d, h3), add32(e, h4)], a = _e[0], b = _e[1], c = _e[2], d = _e[3], e = _e[4];\n    }\n    return byteStringToHexString(words32ToByteString([a, b, c, d, e]));\n    var _d, _e;\n}\n/**\n * @param {?} index\n * @param {?} b\n * @param {?} c\n * @param {?} d\n * @return {?}\n */\nfunction fk(index, b, c, d) {\n    if (index < 20) {\n        return [(b & c) | (~b & d), 0x5a827999];\n    }\n    if (index < 40) {\n        return [b ^ c ^ d, 0x6ed9eba1];\n    }\n    if (index < 60) {\n        return [(b & c) | (b & d) | (c & d), 0x8f1bbcdc];\n    }\n    return [b ^ c ^ d, 0xca62c1d6];\n}\n/**\n * Compute the fingerprint of the given string\n *\n * The output is 64 bit number encoded as a decimal string\n *\n * based on:\n * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java\n * @param {?} str\n * @return {?}\n */\nfunction fingerprint(str) {\n    var /** @type {?} */ utf8 = utf8Encode(str);\n    var _a = [hash32(utf8, 0), hash32(utf8, 102072)], hi = _a[0], lo = _a[1];\n    if (hi == 0 && (lo == 0 || lo == 1)) {\n        hi = hi ^ 0x130f9bef;\n        lo = lo ^ -0x6b5f56d8;\n    }\n    return [hi, lo];\n}\n/**\n * @param {?} msg\n * @param {?} meaning\n * @return {?}\n */\nfunction computeMsgId(msg, meaning) {\n    var _a = fingerprint(msg), hi = _a[0], lo = _a[1];\n    if (meaning) {\n        var _b = fingerprint(meaning), him = _b[0], lom = _b[1];\n        _c = add64(rol64([hi, lo], 1), [him, lom]), hi = _c[0], lo = _c[1];\n    }\n    return byteStringToDecString(words32ToByteString([hi & 0x7fffffff, lo]));\n    var _c;\n}\n/**\n * @param {?} str\n * @param {?} c\n * @return {?}\n */\nfunction hash32(str, c) {\n    var _a = [0x9e3779b9, 0x9e3779b9], a = _a[0], b = _a[1];\n    var /** @type {?} */ i;\n    var /** @type {?} */ len = str.length;\n    for (i = 0; i + 12 <= len; i += 12) {\n        a = add32(a, wordAt(str, i, Endian.Little));\n        b = add32(b, wordAt(str, i + 4, Endian.Little));\n        c = add32(c, wordAt(str, i + 8, Endian.Little));\n        _b = mix([a, b, c]), a = _b[0], b = _b[1], c = _b[2];\n    }\n    a = add32(a, wordAt(str, i, Endian.Little));\n    b = add32(b, wordAt(str, i + 4, Endian.Little));\n    // the first byte of c is reserved for the length\n    c = add32(c, len);\n    c = add32(c, wordAt(str, i + 8, Endian.Little) << 8);\n    return mix([a, b, c])[2];\n    var _b;\n}\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction mix(_a) {\n    var a = _a[0], b = _a[1], c = _a[2];\n    a = sub32(a, b);\n    a = sub32(a, c);\n    a ^= c >>> 13;\n    b = sub32(b, c);\n    b = sub32(b, a);\n    b ^= a << 8;\n    c = sub32(c, a);\n    c = sub32(c, b);\n    c ^= b >>> 13;\n    a = sub32(a, b);\n    a = sub32(a, c);\n    a ^= c >>> 12;\n    b = sub32(b, c);\n    b = sub32(b, a);\n    b ^= a << 16;\n    c = sub32(c, a);\n    c = sub32(c, b);\n    c ^= b >>> 5;\n    a = sub32(a, b);\n    a = sub32(a, c);\n    a ^= c >>> 3;\n    b = sub32(b, c);\n    b = sub32(b, a);\n    b ^= a << 10;\n    c = sub32(c, a);\n    c = sub32(c, b);\n    c ^= b >>> 15;\n    return [a, b, c];\n}\nvar Endian = {};\nEndian.Little = 0;\nEndian.Big = 1;\nEndian[Endian.Little] = \"Little\";\nEndian[Endian.Big] = \"Big\";\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nfunction add32(a, b) {\n    return add32to64(a, b)[1];\n}\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nfunction add32to64(a, b) {\n    var /** @type {?} */ low = (a & 0xffff) + (b & 0xffff);\n    var /** @type {?} */ high = (a >>> 16) + (b >>> 16) + (low >>> 16);\n    return [high >>> 16, (high << 16) | (low & 0xffff)];\n}\n/**\n * @param {?} __0\n * @param {?} __1\n * @return {?}\n */\nfunction add64(_a, _b) {\n    var ah = _a[0], al = _a[1];\n    var bh = _b[0], bl = _b[1];\n    var _c = add32to64(al, bl), carry = _c[0], l = _c[1];\n    var /** @type {?} */ h = add32(add32(ah, bh), carry);\n    return [h, l];\n}\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nfunction sub32(a, b) {\n    var /** @type {?} */ low = (a & 0xffff) - (b & 0xffff);\n    var /** @type {?} */ high = (a >> 16) - (b >> 16) + (low >> 16);\n    return (high << 16) | (low & 0xffff);\n}\n/**\n * @param {?} a\n * @param {?} count\n * @return {?}\n */\nfunction rol32(a, count) {\n    return (a << count) | (a >>> (32 - count));\n}\n/**\n * @param {?} __0\n * @param {?} count\n * @return {?}\n */\nfunction rol64(_a, count) {\n    var hi = _a[0], lo = _a[1];\n    var /** @type {?} */ h = (hi << count) | (lo >>> (32 - count));\n    var /** @type {?} */ l = (lo << count) | (hi >>> (32 - count));\n    return [h, l];\n}\n/**\n * @param {?} str\n * @param {?} endian\n * @return {?}\n */\nfunction stringToWords32(str, endian) {\n    var /** @type {?} */ words32 = Array((str.length + 3) >>> 2);\n    for (var /** @type {?} */ i = 0; i < words32.length; i++) {\n        words32[i] = wordAt(str, i * 4, endian);\n    }\n    return words32;\n}\n/**\n * @param {?} str\n * @param {?} index\n * @return {?}\n */\nfunction byteAt(str, index) {\n    return index >= str.length ? 0 : str.charCodeAt(index) & 0xff;\n}\n/**\n * @param {?} str\n * @param {?} index\n * @param {?} endian\n * @return {?}\n */\nfunction wordAt(str, index, endian) {\n    var /** @type {?} */ word = 0;\n    if (endian === Endian.Big) {\n        for (var /** @type {?} */ i = 0; i < 4; i++) {\n            word += byteAt(str, index + i) << (24 - 8 * i);\n        }\n    }\n    else {\n        for (var /** @type {?} */ i = 0; i < 4; i++) {\n            word += byteAt(str, index + i) << 8 * i;\n        }\n    }\n    return word;\n}\n/**\n * @param {?} words32\n * @return {?}\n */\nfunction words32ToByteString(words32) {\n    return words32.reduce(function (str, word) { return str + word32ToByteString(word); }, '');\n}\n/**\n * @param {?} word\n * @return {?}\n */\nfunction word32ToByteString(word) {\n    var /** @type {?} */ str = '';\n    for (var /** @type {?} */ i = 0; i < 4; i++) {\n        str += String.fromCharCode((word >>> 8 * (3 - i)) & 0xff);\n    }\n    return str;\n}\n/**\n * @param {?} str\n * @return {?}\n */\nfunction byteStringToHexString(str) {\n    var /** @type {?} */ hex = '';\n    for (var /** @type {?} */ i = 0; i < str.length; i++) {\n        var /** @type {?} */ b = byteAt(str, i);\n        hex += (b >>> 4).toString(16) + (b & 0x0f).toString(16);\n    }\n    return hex.toLowerCase();\n}\n/**\n * @param {?} str\n * @return {?}\n */\nfunction byteStringToDecString(str) {\n    var /** @type {?} */ decimal = '';\n    var /** @type {?} */ toThePower = '1';\n    for (var /** @type {?} */ i = str.length - 1; i >= 0; i--) {\n        decimal = addBigInt(decimal, numberTimesBigInt(byteAt(str, i), toThePower));\n        toThePower = numberTimesBigInt(256, toThePower);\n    }\n    return decimal.split('').reverse().join('');\n}\n/**\n * @param {?} x\n * @param {?} y\n * @return {?}\n */\nfunction addBigInt(x, y) {\n    var /** @type {?} */ sum = '';\n    var /** @type {?} */ len = Math.max(x.length, y.length);\n    for (var /** @type {?} */ i = 0, /** @type {?} */ carry = 0; i < len || carry; i++) {\n        var /** @type {?} */ tmpSum = carry + +(x[i] || 0) + +(y[i] || 0);\n        if (tmpSum >= 10) {\n            carry = 1;\n            sum += tmpSum - 10;\n        }\n        else {\n            carry = 0;\n            sum += tmpSum;\n        }\n    }\n    return sum;\n}\n/**\n * @param {?} num\n * @param {?} b\n * @return {?}\n */\nfunction numberTimesBigInt(num, b) {\n    var /** @type {?} */ product = '';\n    var /** @type {?} */ bToThePower = b;\n    for (; num !== 0; num = num >>> 1) {\n        if (num & 1)\n            product = addBigInt(product, bToThePower);\n        bToThePower = addBigInt(bToThePower, bToThePower);\n    }\n    return product;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar Message = (function () {\n    /**\n     * @param {?} nodes message AST\n     * @param {?} placeholders maps placeholder names to static content\n     * @param {?} placeholderToMessage maps placeholder names to messages (used for nested ICU messages)\n     * @param {?} meaning\n     * @param {?} description\n     * @param {?} id\n     */\n    function Message(nodes, placeholders, placeholderToMessage, meaning, description, id) {\n        this.nodes = nodes;\n        this.placeholders = placeholders;\n        this.placeholderToMessage = placeholderToMessage;\n        this.meaning = meaning;\n        this.description = description;\n        this.id = id;\n        if (nodes.length) {\n            this.sources = [{\n                    filePath: nodes[0].sourceSpan.start.file.url,\n                    startLine: nodes[0].sourceSpan.start.line + 1,\n                    startCol: nodes[0].sourceSpan.start.col + 1,\n                    endLine: nodes[nodes.length - 1].sourceSpan.end.line + 1,\n                    endCol: nodes[0].sourceSpan.start.col + 1\n                }];\n        }\n        else {\n            this.sources = [];\n        }\n    }\n    return Message;\n}());\nvar Text$1 = (function () {\n    /**\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    function Text$1(value, sourceSpan) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    Text$1.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };\n    return Text$1;\n}());\nvar Container = (function () {\n    /**\n     * @param {?} children\n     * @param {?} sourceSpan\n     */\n    function Container(children, sourceSpan) {\n        this.children = children;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    Container.prototype.visit = function (visitor, context) { return visitor.visitContainer(this, context); };\n    return Container;\n}());\nvar Icu = (function () {\n    /**\n     * @param {?} expression\n     * @param {?} type\n     * @param {?} cases\n     * @param {?} sourceSpan\n     */\n    function Icu(expression, type, cases, sourceSpan) {\n        this.expression = expression;\n        this.type = type;\n        this.cases = cases;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    Icu.prototype.visit = function (visitor, context) { return visitor.visitIcu(this, context); };\n    return Icu;\n}());\nvar TagPlaceholder = (function () {\n    /**\n     * @param {?} tag\n     * @param {?} attrs\n     * @param {?} startName\n     * @param {?} closeName\n     * @param {?} children\n     * @param {?} isVoid\n     * @param {?} sourceSpan\n     */\n    function TagPlaceholder(tag, attrs, startName, closeName, children, isVoid, sourceSpan) {\n        this.tag = tag;\n        this.attrs = attrs;\n        this.startName = startName;\n        this.closeName = closeName;\n        this.children = children;\n        this.isVoid = isVoid;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    TagPlaceholder.prototype.visit = function (visitor, context) { return visitor.visitTagPlaceholder(this, context); };\n    return TagPlaceholder;\n}());\nvar Placeholder = (function () {\n    /**\n     * @param {?} value\n     * @param {?} name\n     * @param {?} sourceSpan\n     */\n    function Placeholder(value, name, sourceSpan) {\n        this.value = value;\n        this.name = name;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    Placeholder.prototype.visit = function (visitor, context) { return visitor.visitPlaceholder(this, context); };\n    return Placeholder;\n}());\nvar IcuPlaceholder = (function () {\n    /**\n     * @param {?} value\n     * @param {?} name\n     * @param {?} sourceSpan\n     */\n    function IcuPlaceholder(value, name, sourceSpan) {\n        this.value = value;\n        this.name = name;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    IcuPlaceholder.prototype.visit = function (visitor, context) { return visitor.visitIcuPlaceholder(this, context); };\n    return IcuPlaceholder;\n}());\nvar CloneVisitor = (function () {\n    function CloneVisitor() {\n    }\n    /**\n     * @param {?} text\n     * @param {?=} context\n     * @return {?}\n     */\n    CloneVisitor.prototype.visitText = function (text, context) { return new Text$1(text.value, text.sourceSpan); };\n    /**\n     * @param {?} container\n     * @param {?=} context\n     * @return {?}\n     */\n    CloneVisitor.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        var /** @type {?} */ children = container.children.map(function (n) { return n.visit(_this, context); });\n        return new Container(children, container.sourceSpan);\n    };\n    /**\n     * @param {?} icu\n     * @param {?=} context\n     * @return {?}\n     */\n    CloneVisitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var /** @type {?} */ cases = {};\n        Object.keys(icu.cases).forEach(function (key) { return cases[key] = icu.cases[key].visit(_this, context); });\n        var /** @type {?} */ msg = new Icu(icu.expression, icu.type, cases, icu.sourceSpan);\n        msg.expressionPlaceholder = icu.expressionPlaceholder;\n        return msg;\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    CloneVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n        var _this = this;\n        var /** @type {?} */ children = ph.children.map(function (n) { return n.visit(_this, context); });\n        return new TagPlaceholder(ph.tag, ph.attrs, ph.startName, ph.closeName, children, ph.isVoid, ph.sourceSpan);\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    CloneVisitor.prototype.visitPlaceholder = function (ph, context) {\n        return new Placeholder(ph.value, ph.name, ph.sourceSpan);\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    CloneVisitor.prototype.visitIcuPlaceholder = function (ph, context) {\n        return new IcuPlaceholder(ph.value, ph.name, ph.sourceSpan);\n    };\n    return CloneVisitor;\n}());\nvar RecurseVisitor = (function () {\n    function RecurseVisitor() {\n    }\n    /**\n     * @param {?} text\n     * @param {?=} context\n     * @return {?}\n     */\n    RecurseVisitor.prototype.visitText = function (text, context) { };\n    ;\n    /**\n     * @param {?} container\n     * @param {?=} context\n     * @return {?}\n     */\n    RecurseVisitor.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        container.children.forEach(function (child) { return child.visit(_this); });\n    };\n    /**\n     * @param {?} icu\n     * @param {?=} context\n     * @return {?}\n     */\n    RecurseVisitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        Object.keys(icu.cases).forEach(function (k) { icu.cases[k].visit(_this); });\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    RecurseVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n        var _this = this;\n        ph.children.forEach(function (child) { return child.visit(_this); });\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    RecurseVisitor.prototype.visitPlaceholder = function (ph, context) { };\n    ;\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    RecurseVisitor.prototype.visitIcuPlaceholder = function (ph, context) { };\n    ;\n    return RecurseVisitor;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TAG_TO_PLACEHOLDER_NAMES = {\n    'A': 'LINK',\n    'B': 'BOLD_TEXT',\n    'BR': 'LINE_BREAK',\n    'EM': 'EMPHASISED_TEXT',\n    'H1': 'HEADING_LEVEL1',\n    'H2': 'HEADING_LEVEL2',\n    'H3': 'HEADING_LEVEL3',\n    'H4': 'HEADING_LEVEL4',\n    'H5': 'HEADING_LEVEL5',\n    'H6': 'HEADING_LEVEL6',\n    'HR': 'HORIZONTAL_RULE',\n    'I': 'ITALIC_TEXT',\n    'LI': 'LIST_ITEM',\n    'LINK': 'MEDIA_LINK',\n    'OL': 'ORDERED_LIST',\n    'P': 'PARAGRAPH',\n    'Q': 'QUOTATION',\n    'S': 'STRIKETHROUGH_TEXT',\n    'SMALL': 'SMALL_TEXT',\n    'SUB': 'SUBSTRIPT',\n    'SUP': 'SUPERSCRIPT',\n    'TBODY': 'TABLE_BODY',\n    'TD': 'TABLE_CELL',\n    'TFOOT': 'TABLE_FOOTER',\n    'TH': 'TABLE_HEADER_CELL',\n    'THEAD': 'TABLE_HEADER',\n    'TR': 'TABLE_ROW',\n    'TT': 'MONOSPACED_TEXT',\n    'U': 'UNDERLINED_TEXT',\n    'UL': 'UNORDERED_LIST',\n};\n/**\n * Creates unique names for placeholder with different content.\n *\n * Returns the same placeholder name when the content is identical.\n *\n * \\@internal\n */\nvar PlaceholderRegistry = (function () {\n    function PlaceholderRegistry() {\n        this._placeHolderNameCounts = {};\n        this._signatureToName = {};\n    }\n    /**\n     * @param {?} tag\n     * @param {?} attrs\n     * @param {?} isVoid\n     * @return {?}\n     */\n    PlaceholderRegistry.prototype.getStartTagPlaceholderName = function (tag, attrs, isVoid) {\n        var /** @type {?} */ signature = this._hashTag(tag, attrs, isVoid);\n        if (this._signatureToName[signature]) {\n            return this._signatureToName[signature];\n        }\n        var /** @type {?} */ upperTag = tag.toUpperCase();\n        var /** @type {?} */ baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || \"TAG_\" + upperTag;\n        var /** @type {?} */ name = this._generateUniqueName(isVoid ? baseName : \"START_\" + baseName);\n        this._signatureToName[signature] = name;\n        return name;\n    };\n    /**\n     * @param {?} tag\n     * @return {?}\n     */\n    PlaceholderRegistry.prototype.getCloseTagPlaceholderName = function (tag) {\n        var /** @type {?} */ signature = this._hashClosingTag(tag);\n        if (this._signatureToName[signature]) {\n            return this._signatureToName[signature];\n        }\n        var /** @type {?} */ upperTag = tag.toUpperCase();\n        var /** @type {?} */ baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || \"TAG_\" + upperTag;\n        var /** @type {?} */ name = this._generateUniqueName(\"CLOSE_\" + baseName);\n        this._signatureToName[signature] = name;\n        return name;\n    };\n    /**\n     * @param {?} name\n     * @param {?} content\n     * @return {?}\n     */\n    PlaceholderRegistry.prototype.getPlaceholderName = function (name, content) {\n        var /** @type {?} */ upperName = name.toUpperCase();\n        var /** @type {?} */ signature = \"PH: \" + upperName + \"=\" + content;\n        if (this._signatureToName[signature]) {\n            return this._signatureToName[signature];\n        }\n        var /** @type {?} */ uniqueName = this._generateUniqueName(upperName);\n        this._signatureToName[signature] = uniqueName;\n        return uniqueName;\n    };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    PlaceholderRegistry.prototype.getUniquePlaceholder = function (name) {\n        return this._generateUniqueName(name.toUpperCase());\n    };\n    /**\n     * @param {?} tag\n     * @param {?} attrs\n     * @param {?} isVoid\n     * @return {?}\n     */\n    PlaceholderRegistry.prototype._hashTag = function (tag, attrs, isVoid) {\n        var /** @type {?} */ start = \"<\" + tag;\n        var /** @type {?} */ strAttrs = Object.keys(attrs).sort().map(function (name) { return \" \" + name + \"=\" + attrs[name]; }).join('');\n        var /** @type {?} */ end = isVoid ? '/>' : \"></\" + tag + \">\";\n        return start + strAttrs + end;\n    };\n    /**\n     * @param {?} tag\n     * @return {?}\n     */\n    PlaceholderRegistry.prototype._hashClosingTag = function (tag) { return this._hashTag(\"/\" + tag, {}, false); };\n    /**\n     * @param {?} base\n     * @return {?}\n     */\n    PlaceholderRegistry.prototype._generateUniqueName = function (base) {\n        var /** @type {?} */ seen = this._placeHolderNameCounts.hasOwnProperty(base);\n        if (!seen) {\n            this._placeHolderNameCounts[base] = 1;\n            return base;\n        }\n        var /** @type {?} */ id = this._placeHolderNameCounts[base];\n        this._placeHolderNameCounts[base] = id + 1;\n        return base + \"_\" + id;\n    };\n    return PlaceholderRegistry;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _expParser = new Parser(new Lexer());\n/**\n * Returns a function converting html nodes to an i18n Message given an interpolationConfig\n * @param {?} interpolationConfig\n * @return {?}\n */\nfunction createI18nMessageFactory(interpolationConfig) {\n    var /** @type {?} */ visitor = new _I18nVisitor(_expParser, interpolationConfig);\n    return function (nodes, meaning, description, id) { return visitor.toI18nMessage(nodes, meaning, description, id); };\n}\nvar _I18nVisitor = (function () {\n    /**\n     * @param {?} _expressionParser\n     * @param {?} _interpolationConfig\n     */\n    function _I18nVisitor(_expressionParser, _interpolationConfig) {\n        this._expressionParser = _expressionParser;\n        this._interpolationConfig = _interpolationConfig;\n    }\n    /**\n     * @param {?} nodes\n     * @param {?} meaning\n     * @param {?} description\n     * @param {?} id\n     * @return {?}\n     */\n    _I18nVisitor.prototype.toI18nMessage = function (nodes, meaning, description, id) {\n        this._isIcu = nodes.length == 1 && nodes[0] instanceof Expansion;\n        this._icuDepth = 0;\n        this._placeholderRegistry = new PlaceholderRegistry();\n        this._placeholderToContent = {};\n        this._placeholderToMessage = {};\n        var /** @type {?} */ i18nodes = visitAll(this, nodes, {});\n        return new Message(i18nodes, this._placeholderToContent, this._placeholderToMessage, meaning, description, id);\n    };\n    /**\n     * @param {?} el\n     * @param {?} context\n     * @return {?}\n     */\n    _I18nVisitor.prototype.visitElement = function (el, context) {\n        var /** @type {?} */ children = visitAll(this, el.children);\n        var /** @type {?} */ attrs = {};\n        el.attrs.forEach(function (attr) {\n            // Do not visit the attributes, translatable ones are top-level ASTs\n            attrs[attr.name] = attr.value;\n        });\n        var /** @type {?} */ isVoid = getHtmlTagDefinition(el.name).isVoid;\n        var /** @type {?} */ startPhName = this._placeholderRegistry.getStartTagPlaceholderName(el.name, attrs, isVoid);\n        this._placeholderToContent[startPhName] = ((el.sourceSpan)).toString();\n        var /** @type {?} */ closePhName = '';\n        if (!isVoid) {\n            closePhName = this._placeholderRegistry.getCloseTagPlaceholderName(el.name);\n            this._placeholderToContent[closePhName] = \"</\" + el.name + \">\";\n        }\n        return new TagPlaceholder(el.name, attrs, startPhName, closePhName, children, isVoid, /** @type {?} */ ((el.sourceSpan)));\n    };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    _I18nVisitor.prototype.visitAttribute = function (attribute, context) {\n        return this._visitTextWithInterpolation(attribute.value, attribute.sourceSpan);\n    };\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    _I18nVisitor.prototype.visitText = function (text, context) {\n        return this._visitTextWithInterpolation(text.value, /** @type {?} */ ((text.sourceSpan)));\n    };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    _I18nVisitor.prototype.visitComment = function (comment, context) { return null; };\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    _I18nVisitor.prototype.visitExpansion = function (icu, context) {\n        var _this = this;\n        this._icuDepth++;\n        var /** @type {?} */ i18nIcuCases = {};\n        var /** @type {?} */ i18nIcu = new Icu(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);\n        icu.cases.forEach(function (caze) {\n            i18nIcuCases[caze.value] = new Container(caze.expression.map(function (node) { return node.visit(_this, {}); }), caze.expSourceSpan);\n        });\n        this._icuDepth--;\n        if (this._isIcu || this._icuDepth > 0) {\n            // Returns an ICU node when:\n            // - the message (vs a part of the message) is an ICU message, or\n            // - the ICU message is nested.\n            var /** @type {?} */ expPh = this._placeholderRegistry.getUniquePlaceholder(\"VAR_\" + icu.type);\n            i18nIcu.expressionPlaceholder = expPh;\n            this._placeholderToContent[expPh] = icu.switchValue;\n            return i18nIcu;\n        }\n        // Else returns a placeholder\n        // ICU placeholders should not be replaced with their original content but with the their\n        // translations. We need to create a new visitor (they are not re-entrant) to compute the\n        // message id.\n        // TODO(vicb): add a html.Node -> i18n.Message cache to avoid having to re-create the msg\n        var /** @type {?} */ phName = this._placeholderRegistry.getPlaceholderName('ICU', icu.sourceSpan.toString());\n        var /** @type {?} */ visitor = new _I18nVisitor(this._expressionParser, this._interpolationConfig);\n        this._placeholderToMessage[phName] = visitor.toI18nMessage([icu], '', '', '');\n        return new IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);\n    };\n    /**\n     * @param {?} icuCase\n     * @param {?} context\n     * @return {?}\n     */\n    _I18nVisitor.prototype.visitExpansionCase = function (icuCase, context) {\n        throw new Error('Unreachable code');\n    };\n    /**\n     * @param {?} text\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    _I18nVisitor.prototype._visitTextWithInterpolation = function (text, sourceSpan) {\n        var /** @type {?} */ splitInterpolation = this._expressionParser.splitInterpolation(text, sourceSpan.start.toString(), this._interpolationConfig);\n        if (!splitInterpolation) {\n            // No expression, return a single text\n            return new Text$1(text, sourceSpan);\n        }\n        // Return a group of text + expressions\n        var /** @type {?} */ nodes = [];\n        var /** @type {?} */ container = new Container(nodes, sourceSpan);\n        var _a = this._interpolationConfig, sDelimiter = _a.start, eDelimiter = _a.end;\n        for (var /** @type {?} */ i = 0; i < splitInterpolation.strings.length - 1; i++) {\n            var /** @type {?} */ expression = splitInterpolation.expressions[i];\n            var /** @type {?} */ baseName = _extractPlaceholderName(expression) || 'INTERPOLATION';\n            var /** @type {?} */ phName = this._placeholderRegistry.getPlaceholderName(baseName, expression);\n            if (splitInterpolation.strings[i].length) {\n                // No need to add empty strings\n                nodes.push(new Text$1(splitInterpolation.strings[i], sourceSpan));\n            }\n            nodes.push(new Placeholder(expression, phName, sourceSpan));\n            this._placeholderToContent[phName] = sDelimiter + expression + eDelimiter;\n        }\n        // The last index contains no expression\n        var /** @type {?} */ lastStringIdx = splitInterpolation.strings.length - 1;\n        if (splitInterpolation.strings[lastStringIdx].length) {\n            nodes.push(new Text$1(splitInterpolation.strings[lastStringIdx], sourceSpan));\n        }\n        return container;\n    };\n    return _I18nVisitor;\n}());\nvar _CUSTOM_PH_EXP = /\\/\\/[\\s\\S]*i18n[\\s\\S]*\\([\\s\\S]*ph[\\s\\S]*=[\\s\\S]*(\"|')([\\s\\S]*?)\\1[\\s\\S]*\\)/g;\n/**\n * @param {?} input\n * @return {?}\n */\nfunction _extractPlaceholderName(input) {\n    return input.split(_CUSTOM_PH_EXP)[2];\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * An i18n error.\n */\nvar I18nError = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](I18nError, _super);\n    /**\n     * @param {?} span\n     * @param {?} msg\n     */\n    function I18nError(span, msg) {\n        return _super.call(this, span, msg) || this;\n    }\n    return I18nError;\n}(ParseError));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _I18N_ATTR = 'i18n';\nvar _I18N_ATTR_PREFIX = 'i18n-';\nvar _I18N_COMMENT_PREFIX_REGEXP = /^i18n:?/;\nvar MEANING_SEPARATOR = '|';\nvar ID_SEPARATOR = '@@';\n/**\n * Extract translatable messages from an html AST\n * @param {?} nodes\n * @param {?} interpolationConfig\n * @param {?} implicitTags\n * @param {?} implicitAttrs\n * @return {?}\n */\nfunction extractMessages(nodes, interpolationConfig, implicitTags, implicitAttrs) {\n    var /** @type {?} */ visitor = new _Visitor(implicitTags, implicitAttrs);\n    return visitor.extract(nodes, interpolationConfig);\n}\n/**\n * @param {?} nodes\n * @param {?} translations\n * @param {?} interpolationConfig\n * @param {?} implicitTags\n * @param {?} implicitAttrs\n * @return {?}\n */\nfunction mergeTranslations(nodes, translations, interpolationConfig, implicitTags, implicitAttrs) {\n    var /** @type {?} */ visitor = new _Visitor(implicitTags, implicitAttrs);\n    return visitor.merge(nodes, translations, interpolationConfig);\n}\nvar ExtractionResult = (function () {\n    /**\n     * @param {?} messages\n     * @param {?} errors\n     */\n    function ExtractionResult(messages, errors) {\n        this.messages = messages;\n        this.errors = errors;\n    }\n    return ExtractionResult;\n}());\nvar _VisitorMode = {};\n_VisitorMode.Extract = 0;\n_VisitorMode.Merge = 1;\n_VisitorMode[_VisitorMode.Extract] = \"Extract\";\n_VisitorMode[_VisitorMode.Merge] = \"Merge\";\n/**\n * This Visitor is used:\n * 1. to extract all the translatable strings from an html AST (see `extract()`),\n * 2. to replace the translatable strings with the actual translations (see `merge()`)\n *\n * \\@internal\n */\nvar _Visitor = (function () {\n    /**\n     * @param {?} _implicitTags\n     * @param {?} _implicitAttrs\n     */\n    function _Visitor(_implicitTags, _implicitAttrs) {\n        this._implicitTags = _implicitTags;\n        this._implicitAttrs = _implicitAttrs;\n    }\n    /**\n     * Extracts the messages from the tree\n     * @param {?} nodes\n     * @param {?} interpolationConfig\n     * @return {?}\n     */\n    _Visitor.prototype.extract = function (nodes, interpolationConfig) {\n        var _this = this;\n        this._init(_VisitorMode.Extract, interpolationConfig);\n        nodes.forEach(function (node) { return node.visit(_this, null); });\n        if (this._inI18nBlock) {\n            this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n        }\n        return new ExtractionResult(this._messages, this._errors);\n    };\n    /**\n     * Returns a tree where all translatable nodes are translated\n     * @param {?} nodes\n     * @param {?} translations\n     * @param {?} interpolationConfig\n     * @return {?}\n     */\n    _Visitor.prototype.merge = function (nodes, translations, interpolationConfig) {\n        this._init(_VisitorMode.Merge, interpolationConfig);\n        this._translations = translations;\n        // Construct a single fake root element\n        var /** @type {?} */ wrapper = new Element('wrapper', [], nodes, /** @type {?} */ ((undefined)), undefined, undefined);\n        var /** @type {?} */ translatedNode = wrapper.visit(this, null);\n        if (this._inI18nBlock) {\n            this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n        }\n        return new ParseTreeResult(translatedNode.children, this._errors);\n    };\n    /**\n     * @param {?} icuCase\n     * @param {?} context\n     * @return {?}\n     */\n    _Visitor.prototype.visitExpansionCase = function (icuCase, context) {\n        // Parse cases for translatable html attributes\n        var /** @type {?} */ expression = visitAll(this, icuCase.expression, context);\n        if (this._mode === _VisitorMode.Merge) {\n            return new ExpansionCase(icuCase.value, expression, icuCase.sourceSpan, icuCase.valueSourceSpan, icuCase.expSourceSpan);\n        }\n    };\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    _Visitor.prototype.visitExpansion = function (icu, context) {\n        this._mayBeAddBlockChildren(icu);\n        var /** @type {?} */ wasInIcu = this._inIcu;\n        if (!this._inIcu) {\n            // nested ICU messages should not be extracted but top-level translated as a whole\n            if (this._isInTranslatableSection) {\n                this._addMessage([icu]);\n            }\n            this._inIcu = true;\n        }\n        var /** @type {?} */ cases = visitAll(this, icu.cases, context);\n        if (this._mode === _VisitorMode.Merge) {\n            icu = new Expansion(icu.switchValue, icu.type, cases, icu.sourceSpan, icu.switchValueSourceSpan);\n        }\n        this._inIcu = wasInIcu;\n        return icu;\n    };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    _Visitor.prototype.visitComment = function (comment, context) {\n        var /** @type {?} */ isOpening = _isOpeningComment(comment);\n        if (isOpening && this._isInTranslatableSection) {\n            this._reportError(comment, 'Could not start a block inside a translatable section');\n            return;\n        }\n        var /** @type {?} */ isClosing = _isClosingComment(comment);\n        if (isClosing && !this._inI18nBlock) {\n            this._reportError(comment, 'Trying to close an unopened block');\n            return;\n        }\n        if (!this._inI18nNode && !this._inIcu) {\n            if (!this._inI18nBlock) {\n                if (isOpening) {\n                    this._inI18nBlock = true;\n                    this._blockStartDepth = this._depth;\n                    this._blockChildren = [];\n                    this._blockMeaningAndDesc = ((comment.value)).replace(_I18N_COMMENT_PREFIX_REGEXP, '').trim();\n                    this._openTranslatableSection(comment);\n                }\n            }\n            else {\n                if (isClosing) {\n                    if (this._depth == this._blockStartDepth) {\n                        this._closeTranslatableSection(comment, this._blockChildren);\n                        this._inI18nBlock = false;\n                        var /** @type {?} */ message = ((this._addMessage(this._blockChildren, this._blockMeaningAndDesc)));\n                        // merge attributes in sections\n                        var /** @type {?} */ nodes = this._translateMessage(comment, message);\n                        return visitAll(this, nodes);\n                    }\n                    else {\n                        this._reportError(comment, 'I18N blocks should not cross element boundaries');\n                        return;\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    _Visitor.prototype.visitText = function (text, context) {\n        if (this._isInTranslatableSection) {\n            this._mayBeAddBlockChildren(text);\n        }\n        return text;\n    };\n    /**\n     * @param {?} el\n     * @param {?} context\n     * @return {?}\n     */\n    _Visitor.prototype.visitElement = function (el, context) {\n        var _this = this;\n        this._mayBeAddBlockChildren(el);\n        this._depth++;\n        var /** @type {?} */ wasInI18nNode = this._inI18nNode;\n        var /** @type {?} */ wasInImplicitNode = this._inImplicitNode;\n        var /** @type {?} */ childNodes = [];\n        var /** @type {?} */ translatedChildNodes = ((undefined));\n        // Extract:\n        // - top level nodes with the (implicit) \"i18n\" attribute if not already in a section\n        // - ICU messages\n        var /** @type {?} */ i18nAttr = _getI18nAttr(el);\n        var /** @type {?} */ i18nMeta = i18nAttr ? i18nAttr.value : '';\n        var /** @type {?} */ isImplicit = this._implicitTags.some(function (tag) { return el.name === tag; }) && !this._inIcu &&\n            !this._isInTranslatableSection;\n        var /** @type {?} */ isTopLevelImplicit = !wasInImplicitNode && isImplicit;\n        this._inImplicitNode = wasInImplicitNode || isImplicit;\n        if (!this._isInTranslatableSection && !this._inIcu) {\n            if (i18nAttr || isTopLevelImplicit) {\n                this._inI18nNode = true;\n                var /** @type {?} */ message = ((this._addMessage(el.children, i18nMeta)));\n                translatedChildNodes = this._translateMessage(el, message);\n            }\n            if (this._mode == _VisitorMode.Extract) {\n                var /** @type {?} */ isTranslatable = i18nAttr || isTopLevelImplicit;\n                if (isTranslatable)\n                    this._openTranslatableSection(el);\n                visitAll(this, el.children);\n                if (isTranslatable)\n                    this._closeTranslatableSection(el, el.children);\n            }\n        }\n        else {\n            if (i18nAttr || isTopLevelImplicit) {\n                this._reportError(el, 'Could not mark an element as translatable inside a translatable section');\n            }\n            if (this._mode == _VisitorMode.Extract) {\n                // Descend into child nodes for extraction\n                visitAll(this, el.children);\n            }\n        }\n        if (this._mode === _VisitorMode.Merge) {\n            var /** @type {?} */ visitNodes = translatedChildNodes || el.children;\n            visitNodes.forEach(function (child) {\n                var /** @type {?} */ visited = child.visit(_this, context);\n                if (visited && !_this._isInTranslatableSection) {\n                    // Do not add the children from translatable sections (= i18n blocks here)\n                    // They will be added later in this loop when the block closes (i.e. on `<!-- /i18n -->`)\n                    childNodes = childNodes.concat(visited);\n                }\n            });\n        }\n        this._visitAttributesOf(el);\n        this._depth--;\n        this._inI18nNode = wasInI18nNode;\n        this._inImplicitNode = wasInImplicitNode;\n        if (this._mode === _VisitorMode.Merge) {\n            var /** @type {?} */ translatedAttrs = this._translateAttributes(el);\n            return new Element(el.name, translatedAttrs, childNodes, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);\n        }\n        return null;\n    };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    _Visitor.prototype.visitAttribute = function (attribute, context) {\n        throw new Error('unreachable code');\n    };\n    /**\n     * @param {?} mode\n     * @param {?} interpolationConfig\n     * @return {?}\n     */\n    _Visitor.prototype._init = function (mode, interpolationConfig) {\n        this._mode = mode;\n        this._inI18nBlock = false;\n        this._inI18nNode = false;\n        this._depth = 0;\n        this._inIcu = false;\n        this._msgCountAtSectionStart = undefined;\n        this._errors = [];\n        this._messages = [];\n        this._inImplicitNode = false;\n        this._createI18nMessage = createI18nMessageFactory(interpolationConfig);\n    };\n    /**\n     * @param {?} el\n     * @return {?}\n     */\n    _Visitor.prototype._visitAttributesOf = function (el) {\n        var _this = this;\n        var /** @type {?} */ explicitAttrNameToValue = {};\n        var /** @type {?} */ implicitAttrNames = this._implicitAttrs[el.name] || [];\n        el.attrs.filter(function (attr) { return attr.name.startsWith(_I18N_ATTR_PREFIX); })\n            .forEach(function (attr) { return explicitAttrNameToValue[attr.name.slice(_I18N_ATTR_PREFIX.length)] =\n            attr.value; });\n        el.attrs.forEach(function (attr) {\n            if (attr.name in explicitAttrNameToValue) {\n                _this._addMessage([attr], explicitAttrNameToValue[attr.name]);\n            }\n            else if (implicitAttrNames.some(function (name) { return attr.name === name; })) {\n                _this._addMessage([attr]);\n            }\n        });\n    };\n    /**\n     * @param {?} ast\n     * @param {?=} msgMeta\n     * @return {?}\n     */\n    _Visitor.prototype._addMessage = function (ast, msgMeta) {\n        if (ast.length == 0 ||\n            ast.length == 1 && ast[0] instanceof Attribute$1 && !((ast[0])).value) {\n            // Do not create empty messages\n            return null;\n        }\n        var _a = _parseMessageMeta(msgMeta), meaning = _a.meaning, description = _a.description, id = _a.id;\n        var /** @type {?} */ message = this._createI18nMessage(ast, meaning, description, id);\n        this._messages.push(message);\n        return message;\n    };\n    /**\n     * @param {?} el\n     * @param {?} message\n     * @return {?}\n     */\n    _Visitor.prototype._translateMessage = function (el, message) {\n        if (message && this._mode === _VisitorMode.Merge) {\n            var /** @type {?} */ nodes = this._translations.get(message);\n            if (nodes) {\n                return nodes;\n            }\n            this._reportError(el, \"Translation unavailable for message id=\\\"\" + this._translations.digest(message) + \"\\\"\");\n        }\n        return [];\n    };\n    /**\n     * @param {?} el\n     * @return {?}\n     */\n    _Visitor.prototype._translateAttributes = function (el) {\n        var _this = this;\n        var /** @type {?} */ attributes = el.attrs;\n        var /** @type {?} */ i18nParsedMessageMeta = {};\n        attributes.forEach(function (attr) {\n            if (attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n                i18nParsedMessageMeta[attr.name.slice(_I18N_ATTR_PREFIX.length)] =\n                    _parseMessageMeta(attr.value);\n            }\n        });\n        var /** @type {?} */ translatedAttributes = [];\n        attributes.forEach(function (attr) {\n            if (attr.name === _I18N_ATTR || attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n                // strip i18n specific attributes\n                return;\n            }\n            if (attr.value && attr.value != '' && i18nParsedMessageMeta.hasOwnProperty(attr.name)) {\n                var _a = i18nParsedMessageMeta[attr.name], meaning = _a.meaning, description = _a.description, id = _a.id;\n                var /** @type {?} */ message = _this._createI18nMessage([attr], meaning, description, id);\n                var /** @type {?} */ nodes = _this._translations.get(message);\n                if (nodes) {\n                    if (nodes.length == 0) {\n                        translatedAttributes.push(new Attribute$1(attr.name, '', attr.sourceSpan));\n                    }\n                    else if (nodes[0] instanceof Text) {\n                        var /** @type {?} */ value = ((nodes[0])).value;\n                        translatedAttributes.push(new Attribute$1(attr.name, value, attr.sourceSpan));\n                    }\n                    else {\n                        _this._reportError(el, \"Unexpected translation for attribute \\\"\" + attr.name + \"\\\" (id=\\\"\" + (id || _this._translations.digest(message)) + \"\\\")\");\n                    }\n                }\n                else {\n                    _this._reportError(el, \"Translation unavailable for attribute \\\"\" + attr.name + \"\\\" (id=\\\"\" + (id || _this._translations.digest(message)) + \"\\\")\");\n                }\n            }\n            else {\n                translatedAttributes.push(attr);\n            }\n        });\n        return translatedAttributes;\n    };\n    /**\n     * Add the node as a child of the block when:\n     * - we are in a block,\n     * - we are not inside a ICU message (those are handled separately),\n     * - the node is a \"direct child\" of the block\n     * @param {?} node\n     * @return {?}\n     */\n    _Visitor.prototype._mayBeAddBlockChildren = function (node) {\n        if (this._inI18nBlock && !this._inIcu && this._depth == this._blockStartDepth) {\n            this._blockChildren.push(node);\n        }\n    };\n    /**\n     * Marks the start of a section, see `_closeTranslatableSection`\n     * @param {?} node\n     * @return {?}\n     */\n    _Visitor.prototype._openTranslatableSection = function (node) {\n        if (this._isInTranslatableSection) {\n            this._reportError(node, 'Unexpected section start');\n        }\n        else {\n            this._msgCountAtSectionStart = this._messages.length;\n        }\n    };\n    Object.defineProperty(_Visitor.prototype, \"_isInTranslatableSection\", {\n        /**\n         * A translatable section could be:\n         * - the content of translatable element,\n         * - nodes between `<!-- i18n -->` and `<!-- /i18n -->` comments\n         * @return {?}\n         */\n        get: function () {\n            return this._msgCountAtSectionStart !== void 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Terminates a section.\n     *\n     * If a section has only one significant children (comments not significant) then we should not\n     * keep the message from this children:\n     *\n     * `<p i18n=\"meaning|description\">{ICU message}</p>` would produce two messages:\n     * - one for the <p> content with meaning and description,\n     * - another one for the ICU message.\n     *\n     * In this case the last message is discarded as it contains less information (the AST is\n     * otherwise identical).\n     *\n     * Note that we should still keep messages extracted from attributes inside the section (ie in the\n     * ICU message here)\n     * @param {?} node\n     * @param {?} directChildren\n     * @return {?}\n     */\n    _Visitor.prototype._closeTranslatableSection = function (node, directChildren) {\n        if (!this._isInTranslatableSection) {\n            this._reportError(node, 'Unexpected section end');\n            return;\n        }\n        var /** @type {?} */ startIndex = this._msgCountAtSectionStart;\n        var /** @type {?} */ significantChildren = directChildren.reduce(function (count, node) { return count + (node instanceof Comment ? 0 : 1); }, 0);\n        if (significantChildren == 1) {\n            for (var /** @type {?} */ i = this._messages.length - 1; i >= ((startIndex)); i--) {\n                var /** @type {?} */ ast = this._messages[i].nodes;\n                if (!(ast.length == 1 && ast[0] instanceof Text$1)) {\n                    this._messages.splice(i, 1);\n                    break;\n                }\n            }\n        }\n        this._msgCountAtSectionStart = undefined;\n    };\n    /**\n     * @param {?} node\n     * @param {?} msg\n     * @return {?}\n     */\n    _Visitor.prototype._reportError = function (node, msg) {\n        this._errors.push(new I18nError(/** @type {?} */ ((node.sourceSpan)), msg));\n    };\n    return _Visitor;\n}());\n/**\n * @param {?} n\n * @return {?}\n */\nfunction _isOpeningComment(n) {\n    return !!(n instanceof Comment && n.value && n.value.startsWith('i18n'));\n}\n/**\n * @param {?} n\n * @return {?}\n */\nfunction _isClosingComment(n) {\n    return !!(n instanceof Comment && n.value && n.value === '/i18n');\n}\n/**\n * @param {?} p\n * @return {?}\n */\nfunction _getI18nAttr(p) {\n    return p.attrs.find(function (attr) { return attr.name === _I18N_ATTR; }) || null;\n}\n/**\n * @param {?=} i18n\n * @return {?}\n */\nfunction _parseMessageMeta(i18n) {\n    if (!i18n)\n        return { meaning: '', description: '', id: '' };\n    var /** @type {?} */ idIndex = i18n.indexOf(ID_SEPARATOR);\n    var /** @type {?} */ descIndex = i18n.indexOf(MEANING_SEPARATOR);\n    var _a = (idIndex > -1) ? [i18n.slice(0, idIndex), i18n.slice(idIndex + 2)] : [i18n, ''], meaningAndDesc = _a[0], id = _a[1];\n    var _b = (descIndex > -1) ?\n        [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] :\n        ['', meaningAndDesc], meaning = _b[0], description = _b[1];\n    return { meaning: meaning, description: description, id: id };\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar XmlTagDefinition = (function () {\n    function XmlTagDefinition() {\n        this.closedByParent = false;\n        this.contentType = TagContentType.PARSABLE_DATA;\n        this.isVoid = false;\n        this.ignoreFirstLf = false;\n        this.canSelfClose = true;\n    }\n    /**\n     * @param {?} currentParent\n     * @return {?}\n     */\n    XmlTagDefinition.prototype.requireExtraParent = function (currentParent) { return false; };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    XmlTagDefinition.prototype.isClosedByChild = function (name) { return false; };\n    return XmlTagDefinition;\n}());\nvar _TAG_DEFINITION = new XmlTagDefinition();\n/**\n * @param {?} tagName\n * @return {?}\n */\nfunction getXmlTagDefinition(tagName) {\n    return _TAG_DEFINITION;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar XmlParser = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](XmlParser, _super);\n    function XmlParser() {\n        return _super.call(this, getXmlTagDefinition) || this;\n    }\n    /**\n     * @param {?} source\n     * @param {?} url\n     * @param {?=} parseExpansionForms\n     * @return {?}\n     */\n    XmlParser.prototype.parse = function (source, url, parseExpansionForms) {\n        if (parseExpansionForms === void 0) { parseExpansionForms = false; }\n        return _super.prototype.parse.call(this, source, url, parseExpansionForms);\n    };\n    return XmlParser;\n}(Parser$1));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @abstract\n */\nvar Serializer = (function () {\n    function Serializer() {\n    }\n    /**\n     * @abstract\n     * @param {?} messages\n     * @param {?} locale\n     * @return {?}\n     */\n    Serializer.prototype.write = function (messages, locale) { };\n    /**\n     * @abstract\n     * @param {?} content\n     * @param {?} url\n     * @return {?}\n     */\n    Serializer.prototype.load = function (content, url) { };\n    /**\n     * @abstract\n     * @param {?} message\n     * @return {?}\n     */\n    Serializer.prototype.digest = function (message) { };\n    /**\n     * @param {?} message\n     * @return {?}\n     */\n    Serializer.prototype.createNameMapper = function (message) { return null; };\n    return Serializer;\n}());\n/**\n * A simple mapper that take a function to transform an internal name to a public name\n */\nvar SimplePlaceholderMapper = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](SimplePlaceholderMapper, _super);\n    /**\n     * @param {?} message\n     * @param {?} mapName\n     */\n    function SimplePlaceholderMapper(message, mapName) {\n        var _this = _super.call(this) || this;\n        _this.mapName = mapName;\n        _this.internalToPublic = {};\n        _this.publicToNextId = {};\n        _this.publicToInternal = {};\n        message.nodes.forEach(function (node) { return node.visit(_this); });\n        return _this;\n    }\n    /**\n     * @param {?} internalName\n     * @return {?}\n     */\n    SimplePlaceholderMapper.prototype.toPublicName = function (internalName) {\n        return this.internalToPublic.hasOwnProperty(internalName) ?\n            this.internalToPublic[internalName] :\n            null;\n    };\n    /**\n     * @param {?} publicName\n     * @return {?}\n     */\n    SimplePlaceholderMapper.prototype.toInternalName = function (publicName) {\n        return this.publicToInternal.hasOwnProperty(publicName) ? this.publicToInternal[publicName] :\n            null;\n    };\n    /**\n     * @param {?} text\n     * @param {?=} context\n     * @return {?}\n     */\n    SimplePlaceholderMapper.prototype.visitText = function (text, context) { return null; };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    SimplePlaceholderMapper.prototype.visitTagPlaceholder = function (ph, context) {\n        this.visitPlaceholderName(ph.startName);\n        _super.prototype.visitTagPlaceholder.call(this, ph, context);\n        this.visitPlaceholderName(ph.closeName);\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    SimplePlaceholderMapper.prototype.visitPlaceholder = function (ph, context) { this.visitPlaceholderName(ph.name); };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    SimplePlaceholderMapper.prototype.visitIcuPlaceholder = function (ph, context) {\n        this.visitPlaceholderName(ph.name);\n    };\n    /**\n     * @param {?} internalName\n     * @return {?}\n     */\n    SimplePlaceholderMapper.prototype.visitPlaceholderName = function (internalName) {\n        if (!internalName || this.internalToPublic.hasOwnProperty(internalName)) {\n            return;\n        }\n        var /** @type {?} */ publicName = this.mapName(internalName);\n        if (this.publicToInternal.hasOwnProperty(publicName)) {\n            // Create a new XMB when it has already been used\n            var /** @type {?} */ nextId = this.publicToNextId[publicName];\n            this.publicToNextId[publicName] = nextId + 1;\n            publicName = publicName + \"_\" + nextId;\n        }\n        else {\n            this.publicToNextId[publicName] = 1;\n        }\n        this.internalToPublic[internalName] = publicName;\n        this.publicToInternal[publicName] = internalName;\n    };\n    return SimplePlaceholderMapper;\n}(RecurseVisitor));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _Visitor$1 = (function () {\n    function _Visitor$1() {\n    }\n    /**\n     * @param {?} tag\n     * @return {?}\n     */\n    _Visitor$1.prototype.visitTag = function (tag) {\n        var _this = this;\n        var /** @type {?} */ strAttrs = this._serializeAttributes(tag.attrs);\n        if (tag.children.length == 0) {\n            return \"<\" + tag.name + strAttrs + \"/>\";\n        }\n        var /** @type {?} */ strChildren = tag.children.map(function (node) { return node.visit(_this); });\n        return \"<\" + tag.name + strAttrs + \">\" + strChildren.join('') + \"</\" + tag.name + \">\";\n    };\n    /**\n     * @param {?} text\n     * @return {?}\n     */\n    _Visitor$1.prototype.visitText = function (text) { return text.value; };\n    /**\n     * @param {?} decl\n     * @return {?}\n     */\n    _Visitor$1.prototype.visitDeclaration = function (decl) {\n        return \"<?xml\" + this._serializeAttributes(decl.attrs) + \" ?>\";\n    };\n    /**\n     * @param {?} attrs\n     * @return {?}\n     */\n    _Visitor$1.prototype._serializeAttributes = function (attrs) {\n        var /** @type {?} */ strAttrs = Object.keys(attrs).map(function (name) { return name + \"=\\\"\" + attrs[name] + \"\\\"\"; }).join(' ');\n        return strAttrs.length > 0 ? ' ' + strAttrs : '';\n    };\n    /**\n     * @param {?} doctype\n     * @return {?}\n     */\n    _Visitor$1.prototype.visitDoctype = function (doctype) {\n        return \"<!DOCTYPE \" + doctype.rootTag + \" [\\n\" + doctype.dtd + \"\\n]>\";\n    };\n    return _Visitor$1;\n}());\nvar _visitor = new _Visitor$1();\n/**\n * @param {?} nodes\n * @return {?}\n */\nfunction serialize(nodes) {\n    return nodes.map(function (node) { return node.visit(_visitor); }).join('');\n}\nvar Declaration = (function () {\n    /**\n     * @param {?} unescapedAttrs\n     */\n    function Declaration(unescapedAttrs) {\n        var _this = this;\n        this.attrs = {};\n        Object.keys(unescapedAttrs).forEach(function (k) {\n            _this.attrs[k] = _escapeXml(unescapedAttrs[k]);\n        });\n    }\n    /**\n     * @param {?} visitor\n     * @return {?}\n     */\n    Declaration.prototype.visit = function (visitor) { return visitor.visitDeclaration(this); };\n    return Declaration;\n}());\nvar Doctype = (function () {\n    /**\n     * @param {?} rootTag\n     * @param {?} dtd\n     */\n    function Doctype(rootTag, dtd) {\n        this.rootTag = rootTag;\n        this.dtd = dtd;\n    }\n    ;\n    /**\n     * @param {?} visitor\n     * @return {?}\n     */\n    Doctype.prototype.visit = function (visitor) { return visitor.visitDoctype(this); };\n    return Doctype;\n}());\nvar Tag = (function () {\n    /**\n     * @param {?} name\n     * @param {?=} unescapedAttrs\n     * @param {?=} children\n     */\n    function Tag(name, unescapedAttrs, children) {\n        if (unescapedAttrs === void 0) { unescapedAttrs = {}; }\n        if (children === void 0) { children = []; }\n        var _this = this;\n        this.name = name;\n        this.children = children;\n        this.attrs = {};\n        Object.keys(unescapedAttrs).forEach(function (k) {\n            _this.attrs[k] = _escapeXml(unescapedAttrs[k]);\n        });\n    }\n    /**\n     * @param {?} visitor\n     * @return {?}\n     */\n    Tag.prototype.visit = function (visitor) { return visitor.visitTag(this); };\n    return Tag;\n}());\nvar Text$2 = (function () {\n    /**\n     * @param {?} unescapedValue\n     */\n    function Text$2(unescapedValue) {\n        this.value = _escapeXml(unescapedValue);\n    }\n    ;\n    /**\n     * @param {?} visitor\n     * @return {?}\n     */\n    Text$2.prototype.visit = function (visitor) { return visitor.visitText(this); };\n    return Text$2;\n}());\nvar CR = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](CR, _super);\n    /**\n     * @param {?=} ws\n     */\n    function CR(ws) {\n        if (ws === void 0) { ws = 0; }\n        return _super.call(this, \"\\n\" + new Array(ws + 1).join(' ')) || this;\n    }\n    return CR;\n}(Text$2));\nvar _ESCAPED_CHARS = [\n    [/&/g, '&amp;'],\n    [/\"/g, '&quot;'],\n    [/'/g, '&apos;'],\n    [/</g, '&lt;'],\n    [/>/g, '&gt;'],\n];\n/**\n * @param {?} text\n * @return {?}\n */\nfunction _escapeXml(text) {\n    return _ESCAPED_CHARS.reduce(function (text, entry) { return text.replace(entry[0], entry[1]); }, text);\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _VERSION = '1.2';\nvar _XMLNS = 'urn:oasis:names:tc:xliff:document:1.2';\n// TODO(vicb): make this a param (s/_/-/)\nvar _DEFAULT_SOURCE_LANG = 'en';\nvar _PLACEHOLDER_TAG = 'x';\nvar _FILE_TAG = 'file';\nvar _SOURCE_TAG = 'source';\nvar _TARGET_TAG = 'target';\nvar _UNIT_TAG = 'trans-unit';\nvar _CONTEXT_GROUP_TAG = 'context-group';\nvar _CONTEXT_TAG = 'context';\nvar Xliff = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](Xliff, _super);\n    function Xliff() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} messages\n     * @param {?} locale\n     * @return {?}\n     */\n    Xliff.prototype.write = function (messages, locale) {\n        var /** @type {?} */ visitor = new _WriteVisitor();\n        var /** @type {?} */ transUnits = [];\n        messages.forEach(function (message) {\n            var /** @type {?} */ contextTags = [];\n            message.sources.forEach(function (source) {\n                var /** @type {?} */ contextGroupTag = new Tag(_CONTEXT_GROUP_TAG, { purpose: 'location' });\n                contextGroupTag.children.push(new CR(10), new Tag(_CONTEXT_TAG, { 'context-type': 'sourcefile' }, [new Text$2(source.filePath)]), new CR(10), new Tag(_CONTEXT_TAG, { 'context-type': 'linenumber' }, [new Text$2(\"\" + source.startLine)]), new CR(8));\n                contextTags.push(new CR(8), contextGroupTag);\n            });\n            var /** @type {?} */ transUnit = new Tag(_UNIT_TAG, { id: message.id, datatype: 'html' });\n            (_a = transUnit.children).push.apply(_a, [new CR(8), new Tag(_SOURCE_TAG, {}, visitor.serialize(message.nodes))].concat(contextTags));\n            if (message.description) {\n                transUnit.children.push(new CR(8), new Tag('note', { priority: '1', from: 'description' }, [new Text$2(message.description)]));\n            }\n            if (message.meaning) {\n                transUnit.children.push(new CR(8), new Tag('note', { priority: '1', from: 'meaning' }, [new Text$2(message.meaning)]));\n            }\n            transUnit.children.push(new CR(6));\n            transUnits.push(new CR(6), transUnit);\n            var _a;\n        });\n        var /** @type {?} */ body = new Tag('body', {}, transUnits.concat([new CR(4)]));\n        var /** @type {?} */ file = new Tag('file', {\n            'source-language': locale || _DEFAULT_SOURCE_LANG,\n            datatype: 'plaintext',\n            original: 'ng2.template',\n        }, [new CR(4), body, new CR(2)]);\n        var /** @type {?} */ xliff = new Tag('xliff', { version: _VERSION, xmlns: _XMLNS }, [new CR(2), file, new CR()]);\n        return serialize([\n            new Declaration({ version: '1.0', encoding: 'UTF-8' }), new CR(), xliff, new CR()\n        ]);\n    };\n    /**\n     * @param {?} content\n     * @param {?} url\n     * @return {?}\n     */\n    Xliff.prototype.load = function (content, url) {\n        // xliff to xml nodes\n        var /** @type {?} */ xliffParser = new XliffParser();\n        var _a = xliffParser.parse(content, url), locale = _a.locale, msgIdToHtml = _a.msgIdToHtml, errors = _a.errors;\n        // xml nodes to i18n nodes\n        var /** @type {?} */ i18nNodesByMsgId = {};\n        var /** @type {?} */ converter = new XmlToI18n();\n        Object.keys(msgIdToHtml).forEach(function (msgId) {\n            var _a = converter.convert(msgIdToHtml[msgId], url), i18nNodes = _a.i18nNodes, e = _a.errors;\n            errors.push.apply(errors, e);\n            i18nNodesByMsgId[msgId] = i18nNodes;\n        });\n        if (errors.length) {\n            throw new Error(\"xliff parse errors:\\n\" + errors.join('\\n'));\n        }\n        return { locale: /** @type {?} */ ((locale)), i18nNodesByMsgId: i18nNodesByMsgId };\n    };\n    /**\n     * @param {?} message\n     * @return {?}\n     */\n    Xliff.prototype.digest = function (message) { return digest(message); };\n    return Xliff;\n}(Serializer));\nvar _WriteVisitor = (function () {\n    function _WriteVisitor() {\n    }\n    /**\n     * @param {?} text\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor.prototype.visitText = function (text, context) { return [new Text$2(text.value)]; };\n    /**\n     * @param {?} container\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        var /** @type {?} */ nodes = [];\n        container.children.forEach(function (node) { return nodes.push.apply(nodes, node.visit(_this)); });\n        return nodes;\n    };\n    /**\n     * @param {?} icu\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var /** @type {?} */ nodes = [new Text$2(\"{\" + icu.expressionPlaceholder + \", \" + icu.type + \", \")];\n        Object.keys(icu.cases).forEach(function (c) {\n            nodes.push.apply(nodes, [new Text$2(c + \" {\")].concat(icu.cases[c].visit(_this), [new Text$2(\"} \")]));\n        });\n        nodes.push(new Text$2(\"}\"));\n        return nodes;\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n        var /** @type {?} */ ctype = getCtypeForTag(ph.tag);\n        var /** @type {?} */ startTagPh = new Tag(_PLACEHOLDER_TAG, { id: ph.startName, ctype: ctype });\n        if (ph.isVoid) {\n            // void tags have no children nor closing tags\n            return [startTagPh];\n        }\n        var /** @type {?} */ closeTagPh = new Tag(_PLACEHOLDER_TAG, { id: ph.closeName, ctype: ctype });\n        return [startTagPh].concat(this.serialize(ph.children), [closeTagPh]);\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor.prototype.visitPlaceholder = function (ph, context) {\n        return [new Tag(_PLACEHOLDER_TAG, { id: ph.name })];\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor.prototype.visitIcuPlaceholder = function (ph, context) {\n        return [new Tag(_PLACEHOLDER_TAG, { id: ph.name })];\n    };\n    /**\n     * @param {?} nodes\n     * @return {?}\n     */\n    _WriteVisitor.prototype.serialize = function (nodes) {\n        var _this = this;\n        return [].concat.apply([], nodes.map(function (node) { return node.visit(_this); }));\n    };\n    return _WriteVisitor;\n}());\nvar XliffParser = (function () {\n    function XliffParser() {\n        this._locale = null;\n    }\n    /**\n     * @param {?} xliff\n     * @param {?} url\n     * @return {?}\n     */\n    XliffParser.prototype.parse = function (xliff, url) {\n        this._unitMlString = null;\n        this._msgIdToHtml = {};\n        var /** @type {?} */ xml = new XmlParser().parse(xliff, url, false);\n        this._errors = xml.errors;\n        visitAll(this, xml.rootNodes, null);\n        return {\n            msgIdToHtml: this._msgIdToHtml,\n            errors: this._errors,\n            locale: this._locale,\n        };\n    };\n    /**\n     * @param {?} element\n     * @param {?} context\n     * @return {?}\n     */\n    XliffParser.prototype.visitElement = function (element, context) {\n        switch (element.name) {\n            case _UNIT_TAG:\n                this._unitMlString = ((null));\n                var /** @type {?} */ idAttr = element.attrs.find(function (attr) { return attr.name === 'id'; });\n                if (!idAttr) {\n                    this._addError(element, \"<\" + _UNIT_TAG + \"> misses the \\\"id\\\" attribute\");\n                }\n                else {\n                    var /** @type {?} */ id = idAttr.value;\n                    if (this._msgIdToHtml.hasOwnProperty(id)) {\n                        this._addError(element, \"Duplicated translations for msg \" + id);\n                    }\n                    else {\n                        visitAll(this, element.children, null);\n                        if (typeof this._unitMlString === 'string') {\n                            this._msgIdToHtml[id] = this._unitMlString;\n                        }\n                        else {\n                            this._addError(element, \"Message \" + id + \" misses a translation\");\n                        }\n                    }\n                }\n                break;\n            case _SOURCE_TAG:\n                // ignore source message\n                break;\n            case _TARGET_TAG:\n                var /** @type {?} */ innerTextStart = ((element.startSourceSpan)).end.offset;\n                var /** @type {?} */ innerTextEnd = ((element.endSourceSpan)).start.offset;\n                var /** @type {?} */ content = ((element.startSourceSpan)).start.file.content;\n                var /** @type {?} */ innerText = content.slice(innerTextStart, innerTextEnd);\n                this._unitMlString = innerText;\n                break;\n            case _FILE_TAG:\n                var /** @type {?} */ localeAttr = element.attrs.find(function (attr) { return attr.name === 'target-language'; });\n                if (localeAttr) {\n                    this._locale = localeAttr.value;\n                }\n                visitAll(this, element.children, null);\n                break;\n            default:\n                // TODO(vicb): assert file structure, xliff version\n                // For now only recurse on unhandled nodes\n                visitAll(this, element.children, null);\n        }\n    };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    XliffParser.prototype.visitAttribute = function (attribute, context) { };\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    XliffParser.prototype.visitText = function (text, context) { };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    XliffParser.prototype.visitComment = function (comment, context) { };\n    /**\n     * @param {?} expansion\n     * @param {?} context\n     * @return {?}\n     */\n    XliffParser.prototype.visitExpansion = function (expansion, context) { };\n    /**\n     * @param {?} expansionCase\n     * @param {?} context\n     * @return {?}\n     */\n    XliffParser.prototype.visitExpansionCase = function (expansionCase, context) { };\n    /**\n     * @param {?} node\n     * @param {?} message\n     * @return {?}\n     */\n    XliffParser.prototype._addError = function (node, message) {\n        this._errors.push(new I18nError(/** @type {?} */ ((node.sourceSpan)), message));\n    };\n    return XliffParser;\n}());\nvar XmlToI18n = (function () {\n    function XmlToI18n() {\n    }\n    /**\n     * @param {?} message\n     * @param {?} url\n     * @return {?}\n     */\n    XmlToI18n.prototype.convert = function (message, url) {\n        var /** @type {?} */ xmlIcu = new XmlParser().parse(message, url, true);\n        this._errors = xmlIcu.errors;\n        var /** @type {?} */ i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?\n            [] :\n            visitAll(this, xmlIcu.rootNodes);\n        return {\n            i18nNodes: i18nNodes,\n            errors: this._errors,\n        };\n    };\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n.prototype.visitText = function (text, context) { return new Text$1(text.value, /** @type {?} */ ((text.sourceSpan))); };\n    /**\n     * @param {?} el\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n.prototype.visitElement = function (el, context) {\n        if (el.name === _PLACEHOLDER_TAG) {\n            var /** @type {?} */ nameAttr = el.attrs.find(function (attr) { return attr.name === 'id'; });\n            if (nameAttr) {\n                return new Placeholder('', nameAttr.value, /** @type {?} */ ((el.sourceSpan)));\n            }\n            this._addError(el, \"<\" + _PLACEHOLDER_TAG + \"> misses the \\\"id\\\" attribute\");\n        }\n        else {\n            this._addError(el, \"Unexpected tag\");\n        }\n        return null;\n    };\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n.prototype.visitExpansion = function (icu, context) {\n        var /** @type {?} */ caseMap = {};\n        visitAll(this, icu.cases).forEach(function (c) {\n            caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\n        });\n        return new Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n    };\n    /**\n     * @param {?} icuCase\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n.prototype.visitExpansionCase = function (icuCase, context) {\n        return {\n            value: icuCase.value,\n            nodes: visitAll(this, icuCase.expression),\n        };\n    };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n.prototype.visitComment = function (comment, context) { };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n.prototype.visitAttribute = function (attribute, context) { };\n    /**\n     * @param {?} node\n     * @param {?} message\n     * @return {?}\n     */\n    XmlToI18n.prototype._addError = function (node, message) {\n        this._errors.push(new I18nError(/** @type {?} */ ((node.sourceSpan)), message));\n    };\n    return XmlToI18n;\n}());\n/**\n * @param {?} tag\n * @return {?}\n */\nfunction getCtypeForTag(tag) {\n    switch (tag.toLowerCase()) {\n        case 'br':\n            return 'lb';\n        case 'img':\n            return 'image';\n        default:\n            return \"x-\" + tag;\n    }\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _VERSION$1 = '2.0';\nvar _XMLNS$1 = 'urn:oasis:names:tc:xliff:document:2.0';\n// TODO(vicb): make this a param (s/_/-/)\nvar _DEFAULT_SOURCE_LANG$1 = 'en';\nvar _PLACEHOLDER_TAG$1 = 'ph';\nvar _PLACEHOLDER_SPANNING_TAG = 'pc';\nvar _XLIFF_TAG = 'xliff';\nvar _SOURCE_TAG$1 = 'source';\nvar _TARGET_TAG$1 = 'target';\nvar _UNIT_TAG$1 = 'unit';\nvar Xliff2 = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](Xliff2, _super);\n    function Xliff2() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} messages\n     * @param {?} locale\n     * @return {?}\n     */\n    Xliff2.prototype.write = function (messages, locale) {\n        var /** @type {?} */ visitor = new _WriteVisitor$1();\n        var /** @type {?} */ units = [];\n        messages.forEach(function (message) {\n            var /** @type {?} */ unit = new Tag(_UNIT_TAG$1, { id: message.id });\n            var /** @type {?} */ notes = new Tag('notes');\n            if (message.description || message.meaning) {\n                if (message.description) {\n                    notes.children.push(new CR(8), new Tag('note', { category: 'description' }, [new Text$2(message.description)]));\n                }\n                if (message.meaning) {\n                    notes.children.push(new CR(8), new Tag('note', { category: 'meaning' }, [new Text$2(message.meaning)]));\n                }\n            }\n            message.sources.forEach(function (source) {\n                notes.children.push(new CR(8), new Tag('note', { category: 'location' }, [\n                    new Text$2(source.filePath + \":\" + source.startLine + (source.endLine !== source.startLine ? ',' + source.endLine : ''))\n                ]));\n            });\n            notes.children.push(new CR(6));\n            unit.children.push(new CR(6), notes);\n            var /** @type {?} */ segment = new Tag('segment');\n            segment.children.push(new CR(8), new Tag(_SOURCE_TAG$1, {}, visitor.serialize(message.nodes)), new CR(6));\n            unit.children.push(new CR(6), segment, new CR(4));\n            units.push(new CR(4), unit);\n        });\n        var /** @type {?} */ file = new Tag('file', { 'original': 'ng.template', id: 'ngi18n' }, units.concat([new CR(2)]));\n        var /** @type {?} */ xliff = new Tag(_XLIFF_TAG, { version: _VERSION$1, xmlns: _XMLNS$1, srcLang: locale || _DEFAULT_SOURCE_LANG$1 }, [new CR(2), file, new CR()]);\n        return serialize([\n            new Declaration({ version: '1.0', encoding: 'UTF-8' }), new CR(), xliff, new CR()\n        ]);\n    };\n    /**\n     * @param {?} content\n     * @param {?} url\n     * @return {?}\n     */\n    Xliff2.prototype.load = function (content, url) {\n        // xliff to xml nodes\n        var /** @type {?} */ xliff2Parser = new Xliff2Parser();\n        var _a = xliff2Parser.parse(content, url), locale = _a.locale, msgIdToHtml = _a.msgIdToHtml, errors = _a.errors;\n        // xml nodes to i18n nodes\n        var /** @type {?} */ i18nNodesByMsgId = {};\n        var /** @type {?} */ converter = new XmlToI18n$1();\n        Object.keys(msgIdToHtml).forEach(function (msgId) {\n            var _a = converter.convert(msgIdToHtml[msgId], url), i18nNodes = _a.i18nNodes, e = _a.errors;\n            errors.push.apply(errors, e);\n            i18nNodesByMsgId[msgId] = i18nNodes;\n        });\n        if (errors.length) {\n            throw new Error(\"xliff2 parse errors:\\n\" + errors.join('\\n'));\n        }\n        return { locale: /** @type {?} */ ((locale)), i18nNodesByMsgId: i18nNodesByMsgId };\n    };\n    /**\n     * @param {?} message\n     * @return {?}\n     */\n    Xliff2.prototype.digest = function (message) { return decimalDigest(message); };\n    return Xliff2;\n}(Serializer));\nvar _WriteVisitor$1 = (function () {\n    function _WriteVisitor$1() {\n    }\n    /**\n     * @param {?} text\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor$1.prototype.visitText = function (text, context) { return [new Text$2(text.value)]; };\n    /**\n     * @param {?} container\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor$1.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        var /** @type {?} */ nodes = [];\n        container.children.forEach(function (node) { return nodes.push.apply(nodes, node.visit(_this)); });\n        return nodes;\n    };\n    /**\n     * @param {?} icu\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor$1.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var /** @type {?} */ nodes = [new Text$2(\"{\" + icu.expressionPlaceholder + \", \" + icu.type + \", \")];\n        Object.keys(icu.cases).forEach(function (c) {\n            nodes.push.apply(nodes, [new Text$2(c + \" {\")].concat(icu.cases[c].visit(_this), [new Text$2(\"} \")]));\n        });\n        nodes.push(new Text$2(\"}\"));\n        return nodes;\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor$1.prototype.visitTagPlaceholder = function (ph, context) {\n        var _this = this;\n        var /** @type {?} */ type = getTypeForTag(ph.tag);\n        if (ph.isVoid) {\n            var /** @type {?} */ tagPh = new Tag(_PLACEHOLDER_TAG$1, {\n                id: (this._nextPlaceholderId++).toString(),\n                equiv: ph.startName,\n                type: type,\n                disp: \"<\" + ph.tag + \"/>\",\n            });\n            return [tagPh];\n        }\n        var /** @type {?} */ tagPc = new Tag(_PLACEHOLDER_SPANNING_TAG, {\n            id: (this._nextPlaceholderId++).toString(),\n            equivStart: ph.startName,\n            equivEnd: ph.closeName,\n            type: type,\n            dispStart: \"<\" + ph.tag + \">\",\n            dispEnd: \"</\" + ph.tag + \">\",\n        });\n        var /** @type {?} */ nodes = [].concat.apply([], ph.children.map(function (node) { return node.visit(_this); }));\n        if (nodes.length) {\n            nodes.forEach(function (node) { return tagPc.children.push(node); });\n        }\n        else {\n            tagPc.children.push(new Text$2(''));\n        }\n        return [tagPc];\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor$1.prototype.visitPlaceholder = function (ph, context) {\n        var /** @type {?} */ idStr = (this._nextPlaceholderId++).toString();\n        return [new Tag(_PLACEHOLDER_TAG$1, {\n                id: idStr,\n                equiv: ph.name,\n                disp: \"{{\" + ph.value + \"}}\",\n            })];\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor$1.prototype.visitIcuPlaceholder = function (ph, context) {\n        var /** @type {?} */ cases = Object.keys(ph.value.cases).map(function (value) { return value + ' {...}'; }).join(' ');\n        var /** @type {?} */ idStr = (this._nextPlaceholderId++).toString();\n        return [new Tag(_PLACEHOLDER_TAG$1, { id: idStr, equiv: ph.name, disp: \"{\" + ph.value.expression + \", \" + ph.value.type + \", \" + cases + \"}\" })];\n    };\n    /**\n     * @param {?} nodes\n     * @return {?}\n     */\n    _WriteVisitor$1.prototype.serialize = function (nodes) {\n        var _this = this;\n        this._nextPlaceholderId = 0;\n        return [].concat.apply([], nodes.map(function (node) { return node.visit(_this); }));\n    };\n    return _WriteVisitor$1;\n}());\nvar Xliff2Parser = (function () {\n    function Xliff2Parser() {\n        this._locale = null;\n    }\n    /**\n     * @param {?} xliff\n     * @param {?} url\n     * @return {?}\n     */\n    Xliff2Parser.prototype.parse = function (xliff, url) {\n        this._unitMlString = null;\n        this._msgIdToHtml = {};\n        var /** @type {?} */ xml = new XmlParser().parse(xliff, url, false);\n        this._errors = xml.errors;\n        visitAll(this, xml.rootNodes, null);\n        return {\n            msgIdToHtml: this._msgIdToHtml,\n            errors: this._errors,\n            locale: this._locale,\n        };\n    };\n    /**\n     * @param {?} element\n     * @param {?} context\n     * @return {?}\n     */\n    Xliff2Parser.prototype.visitElement = function (element, context) {\n        switch (element.name) {\n            case _UNIT_TAG$1:\n                this._unitMlString = null;\n                var /** @type {?} */ idAttr = element.attrs.find(function (attr) { return attr.name === 'id'; });\n                if (!idAttr) {\n                    this._addError(element, \"<\" + _UNIT_TAG$1 + \"> misses the \\\"id\\\" attribute\");\n                }\n                else {\n                    var /** @type {?} */ id = idAttr.value;\n                    if (this._msgIdToHtml.hasOwnProperty(id)) {\n                        this._addError(element, \"Duplicated translations for msg \" + id);\n                    }\n                    else {\n                        visitAll(this, element.children, null);\n                        if (typeof this._unitMlString === 'string') {\n                            this._msgIdToHtml[id] = this._unitMlString;\n                        }\n                        else {\n                            this._addError(element, \"Message \" + id + \" misses a translation\");\n                        }\n                    }\n                }\n                break;\n            case _SOURCE_TAG$1:\n                // ignore source message\n                break;\n            case _TARGET_TAG$1:\n                var /** @type {?} */ innerTextStart = ((element.startSourceSpan)).end.offset;\n                var /** @type {?} */ innerTextEnd = ((element.endSourceSpan)).start.offset;\n                var /** @type {?} */ content = ((element.startSourceSpan)).start.file.content;\n                var /** @type {?} */ innerText = content.slice(innerTextStart, innerTextEnd);\n                this._unitMlString = innerText;\n                break;\n            case _XLIFF_TAG:\n                var /** @type {?} */ localeAttr = element.attrs.find(function (attr) { return attr.name === 'trgLang'; });\n                if (localeAttr) {\n                    this._locale = localeAttr.value;\n                }\n                var /** @type {?} */ versionAttr = element.attrs.find(function (attr) { return attr.name === 'version'; });\n                if (versionAttr) {\n                    var /** @type {?} */ version = versionAttr.value;\n                    if (version !== '2.0') {\n                        this._addError(element, \"The XLIFF file version \" + version + \" is not compatible with XLIFF 2.0 serializer\");\n                    }\n                    else {\n                        visitAll(this, element.children, null);\n                    }\n                }\n                break;\n            default:\n                visitAll(this, element.children, null);\n        }\n    };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    Xliff2Parser.prototype.visitAttribute = function (attribute, context) { };\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    Xliff2Parser.prototype.visitText = function (text, context) { };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    Xliff2Parser.prototype.visitComment = function (comment, context) { };\n    /**\n     * @param {?} expansion\n     * @param {?} context\n     * @return {?}\n     */\n    Xliff2Parser.prototype.visitExpansion = function (expansion, context) { };\n    /**\n     * @param {?} expansionCase\n     * @param {?} context\n     * @return {?}\n     */\n    Xliff2Parser.prototype.visitExpansionCase = function (expansionCase, context) { };\n    /**\n     * @param {?} node\n     * @param {?} message\n     * @return {?}\n     */\n    Xliff2Parser.prototype._addError = function (node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    };\n    return Xliff2Parser;\n}());\nvar XmlToI18n$1 = (function () {\n    function XmlToI18n$1() {\n    }\n    /**\n     * @param {?} message\n     * @param {?} url\n     * @return {?}\n     */\n    XmlToI18n$1.prototype.convert = function (message, url) {\n        var /** @type {?} */ xmlIcu = new XmlParser().parse(message, url, true);\n        this._errors = xmlIcu.errors;\n        var /** @type {?} */ i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?\n            [] : [].concat.apply([], visitAll(this, xmlIcu.rootNodes));\n        return {\n            i18nNodes: i18nNodes,\n            errors: this._errors,\n        };\n    };\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$1.prototype.visitText = function (text, context) { return new Text$1(text.value, text.sourceSpan); };\n    /**\n     * @param {?} el\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$1.prototype.visitElement = function (el, context) {\n        var _this = this;\n        switch (el.name) {\n            case _PLACEHOLDER_TAG$1:\n                var /** @type {?} */ nameAttr = el.attrs.find(function (attr) { return attr.name === 'equiv'; });\n                if (nameAttr) {\n                    return [new Placeholder('', nameAttr.value, el.sourceSpan)];\n                }\n                this._addError(el, \"<\" + _PLACEHOLDER_TAG$1 + \"> misses the \\\"equiv\\\" attribute\");\n                break;\n            case _PLACEHOLDER_SPANNING_TAG:\n                var /** @type {?} */ startAttr = el.attrs.find(function (attr) { return attr.name === 'equivStart'; });\n                var /** @type {?} */ endAttr = el.attrs.find(function (attr) { return attr.name === 'equivEnd'; });\n                if (!startAttr) {\n                    this._addError(el, \"<\" + _PLACEHOLDER_TAG$1 + \"> misses the \\\"equivStart\\\" attribute\");\n                }\n                else if (!endAttr) {\n                    this._addError(el, \"<\" + _PLACEHOLDER_TAG$1 + \"> misses the \\\"equivEnd\\\" attribute\");\n                }\n                else {\n                    var /** @type {?} */ startId = startAttr.value;\n                    var /** @type {?} */ endId = endAttr.value;\n                    var /** @type {?} */ nodes = [];\n                    return nodes.concat.apply(nodes, [new Placeholder('', startId, el.sourceSpan)].concat(el.children.map(function (node) { return node.visit(_this, null); }), [new Placeholder('', endId, el.sourceSpan)]));\n                }\n                break;\n            default:\n                this._addError(el, \"Unexpected tag\");\n        }\n        return null;\n    };\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$1.prototype.visitExpansion = function (icu, context) {\n        var /** @type {?} */ caseMap = {};\n        visitAll(this, icu.cases).forEach(function (c) {\n            caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\n        });\n        return new Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n    };\n    /**\n     * @param {?} icuCase\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$1.prototype.visitExpansionCase = function (icuCase, context) {\n        return {\n            value: icuCase.value,\n            nodes: [].concat.apply([], visitAll(this, icuCase.expression)),\n        };\n    };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$1.prototype.visitComment = function (comment, context) { };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$1.prototype.visitAttribute = function (attribute, context) { };\n    /**\n     * @param {?} node\n     * @param {?} message\n     * @return {?}\n     */\n    XmlToI18n$1.prototype._addError = function (node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    };\n    return XmlToI18n$1;\n}());\n/**\n * @param {?} tag\n * @return {?}\n */\nfunction getTypeForTag(tag) {\n    switch (tag.toLowerCase()) {\n        case 'br':\n        case 'b':\n        case 'i':\n        case 'u':\n            return 'fmt';\n        case 'img':\n            return 'image';\n        case 'a':\n            return 'link';\n        default:\n            return 'other';\n    }\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _MESSAGES_TAG = 'messagebundle';\nvar _MESSAGE_TAG = 'msg';\nvar _PLACEHOLDER_TAG$2 = 'ph';\nvar _EXEMPLE_TAG = 'ex';\nvar _SOURCE_TAG$2 = 'source';\nvar _DOCTYPE = \"<!ELEMENT messagebundle (msg)*>\\n<!ATTLIST messagebundle class CDATA #IMPLIED>\\n\\n<!ELEMENT msg (#PCDATA|ph|source)*>\\n<!ATTLIST msg id CDATA #IMPLIED>\\n<!ATTLIST msg seq CDATA #IMPLIED>\\n<!ATTLIST msg name CDATA #IMPLIED>\\n<!ATTLIST msg desc CDATA #IMPLIED>\\n<!ATTLIST msg meaning CDATA #IMPLIED>\\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\\n<!ATTLIST msg xml:space (default|preserve) \\\"default\\\">\\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\\n\\n<!ELEMENT source (#PCDATA)>\\n\\n<!ELEMENT ph (#PCDATA|ex)*>\\n<!ATTLIST ph name CDATA #REQUIRED>\\n\\n<!ELEMENT ex (#PCDATA)>\";\nvar Xmb = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](Xmb, _super);\n    function Xmb() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} messages\n     * @param {?} locale\n     * @return {?}\n     */\n    Xmb.prototype.write = function (messages, locale) {\n        var /** @type {?} */ exampleVisitor = new ExampleVisitor();\n        var /** @type {?} */ visitor = new _Visitor$2();\n        var /** @type {?} */ rootNode = new Tag(_MESSAGES_TAG);\n        messages.forEach(function (message) {\n            var /** @type {?} */ attrs = { id: message.id };\n            if (message.description) {\n                attrs['desc'] = message.description;\n            }\n            if (message.meaning) {\n                attrs['meaning'] = message.meaning;\n            }\n            var /** @type {?} */ sourceTags = [];\n            message.sources.forEach(function (source) {\n                sourceTags.push(new Tag(_SOURCE_TAG$2, {}, [\n                    new Text$2(source.filePath + \":\" + source.startLine + (source.endLine !== source.startLine ? ',' + source.endLine : ''))\n                ]));\n            });\n            rootNode.children.push(new CR(2), new Tag(_MESSAGE_TAG, attrs, sourceTags.concat(visitor.serialize(message.nodes))));\n        });\n        rootNode.children.push(new CR());\n        return serialize([\n            new Declaration({ version: '1.0', encoding: 'UTF-8' }),\n            new CR(),\n            new Doctype(_MESSAGES_TAG, _DOCTYPE),\n            new CR(),\n            exampleVisitor.addDefaultExamples(rootNode),\n            new CR(),\n        ]);\n    };\n    /**\n     * @param {?} content\n     * @param {?} url\n     * @return {?}\n     */\n    Xmb.prototype.load = function (content, url) {\n        throw new Error('Unsupported');\n    };\n    /**\n     * @param {?} message\n     * @return {?}\n     */\n    Xmb.prototype.digest = function (message) { return digest$1(message); };\n    /**\n     * @param {?} message\n     * @return {?}\n     */\n    Xmb.prototype.createNameMapper = function (message) {\n        return new SimplePlaceholderMapper(message, toPublicName);\n    };\n    return Xmb;\n}(Serializer));\nvar _Visitor$2 = (function () {\n    function _Visitor$2() {\n    }\n    /**\n     * @param {?} text\n     * @param {?=} context\n     * @return {?}\n     */\n    _Visitor$2.prototype.visitText = function (text, context) { return [new Text$2(text.value)]; };\n    /**\n     * @param {?} container\n     * @param {?} context\n     * @return {?}\n     */\n    _Visitor$2.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        var /** @type {?} */ nodes = [];\n        container.children.forEach(function (node) { return nodes.push.apply(nodes, node.visit(_this)); });\n        return nodes;\n    };\n    /**\n     * @param {?} icu\n     * @param {?=} context\n     * @return {?}\n     */\n    _Visitor$2.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var /** @type {?} */ nodes = [new Text$2(\"{\" + icu.expressionPlaceholder + \", \" + icu.type + \", \")];\n        Object.keys(icu.cases).forEach(function (c) {\n            nodes.push.apply(nodes, [new Text$2(c + \" {\")].concat(icu.cases[c].visit(_this), [new Text$2(\"} \")]));\n        });\n        nodes.push(new Text$2(\"}\"));\n        return nodes;\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    _Visitor$2.prototype.visitTagPlaceholder = function (ph, context) {\n        var /** @type {?} */ startEx = new Tag(_EXEMPLE_TAG, {}, [new Text$2(\"<\" + ph.tag + \">\")]);\n        var /** @type {?} */ startTagPh = new Tag(_PLACEHOLDER_TAG$2, { name: ph.startName }, [startEx]);\n        if (ph.isVoid) {\n            // void tags have no children nor closing tags\n            return [startTagPh];\n        }\n        var /** @type {?} */ closeEx = new Tag(_EXEMPLE_TAG, {}, [new Text$2(\"</\" + ph.tag + \">\")]);\n        var /** @type {?} */ closeTagPh = new Tag(_PLACEHOLDER_TAG$2, { name: ph.closeName }, [closeEx]);\n        return [startTagPh].concat(this.serialize(ph.children), [closeTagPh]);\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    _Visitor$2.prototype.visitPlaceholder = function (ph, context) {\n        return [new Tag(_PLACEHOLDER_TAG$2, { name: ph.name })];\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    _Visitor$2.prototype.visitIcuPlaceholder = function (ph, context) {\n        return [new Tag(_PLACEHOLDER_TAG$2, { name: ph.name })];\n    };\n    /**\n     * @param {?} nodes\n     * @return {?}\n     */\n    _Visitor$2.prototype.serialize = function (nodes) {\n        var _this = this;\n        return [].concat.apply([], nodes.map(function (node) { return node.visit(_this); }));\n    };\n    return _Visitor$2;\n}());\n/**\n * @param {?} message\n * @return {?}\n */\nfunction digest$1(message) {\n    return decimalDigest(message);\n}\nvar ExampleVisitor = (function () {\n    function ExampleVisitor() {\n    }\n    /**\n     * @param {?} node\n     * @return {?}\n     */\n    ExampleVisitor.prototype.addDefaultExamples = function (node) {\n        node.visit(this);\n        return node;\n    };\n    /**\n     * @param {?} tag\n     * @return {?}\n     */\n    ExampleVisitor.prototype.visitTag = function (tag) {\n        var _this = this;\n        if (tag.name === _PLACEHOLDER_TAG$2) {\n            if (!tag.children || tag.children.length == 0) {\n                var /** @type {?} */ exText = new Text$2(tag.attrs['name'] || '...');\n                tag.children = [new Tag(_EXEMPLE_TAG, {}, [exText])];\n            }\n        }\n        else if (tag.children) {\n            tag.children.forEach(function (node) { return node.visit(_this); });\n        }\n    };\n    /**\n     * @param {?} text\n     * @return {?}\n     */\n    ExampleVisitor.prototype.visitText = function (text) { };\n    /**\n     * @param {?} decl\n     * @return {?}\n     */\n    ExampleVisitor.prototype.visitDeclaration = function (decl) { };\n    /**\n     * @param {?} doctype\n     * @return {?}\n     */\n    ExampleVisitor.prototype.visitDoctype = function (doctype) { };\n    return ExampleVisitor;\n}());\n/**\n * @param {?} internalName\n * @return {?}\n */\nfunction toPublicName(internalName) {\n    return internalName.toUpperCase().replace(/[^A-Z0-9_]/g, '_');\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _TRANSLATIONS_TAG = 'translationbundle';\nvar _TRANSLATION_TAG = 'translation';\nvar _PLACEHOLDER_TAG$3 = 'ph';\nvar Xtb = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](Xtb, _super);\n    function Xtb() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} messages\n     * @param {?} locale\n     * @return {?}\n     */\n    Xtb.prototype.write = function (messages, locale) { throw new Error('Unsupported'); };\n    /**\n     * @param {?} content\n     * @param {?} url\n     * @return {?}\n     */\n    Xtb.prototype.load = function (content, url) {\n        // xtb to xml nodes\n        var /** @type {?} */ xtbParser = new XtbParser();\n        var _a = xtbParser.parse(content, url), locale = _a.locale, msgIdToHtml = _a.msgIdToHtml, errors = _a.errors;\n        // xml nodes to i18n nodes\n        var /** @type {?} */ i18nNodesByMsgId = {};\n        var /** @type {?} */ converter = new XmlToI18n$2();\n        // Because we should be able to load xtb files that rely on features not supported by angular,\n        // we need to delay the conversion of html to i18n nodes so that non angular messages are not\n        // converted\n        Object.keys(msgIdToHtml).forEach(function (msgId) {\n            var /** @type {?} */ valueFn = function () {\n                var _a = converter.convert(msgIdToHtml[msgId], url), i18nNodes = _a.i18nNodes, errors = _a.errors;\n                if (errors.length) {\n                    throw new Error(\"xtb parse errors:\\n\" + errors.join('\\n'));\n                }\n                return i18nNodes;\n            };\n            createLazyProperty(i18nNodesByMsgId, msgId, valueFn);\n        });\n        if (errors.length) {\n            throw new Error(\"xtb parse errors:\\n\" + errors.join('\\n'));\n        }\n        return { locale: /** @type {?} */ ((locale)), i18nNodesByMsgId: i18nNodesByMsgId };\n    };\n    /**\n     * @param {?} message\n     * @return {?}\n     */\n    Xtb.prototype.digest = function (message) { return digest$1(message); };\n    /**\n     * @param {?} message\n     * @return {?}\n     */\n    Xtb.prototype.createNameMapper = function (message) {\n        return new SimplePlaceholderMapper(message, toPublicName);\n    };\n    return Xtb;\n}(Serializer));\n/**\n * @param {?} messages\n * @param {?} id\n * @param {?} valueFn\n * @return {?}\n */\nfunction createLazyProperty(messages, id, valueFn) {\n    Object.defineProperty(messages, id, {\n        configurable: true,\n        enumerable: true,\n        get: function () {\n            var /** @type {?} */ value = valueFn();\n            Object.defineProperty(messages, id, { enumerable: true, value: value });\n            return value;\n        },\n        set: function (_) { throw new Error('Could not overwrite an XTB translation'); },\n    });\n}\nvar XtbParser = (function () {\n    function XtbParser() {\n        this._locale = null;\n    }\n    /**\n     * @param {?} xtb\n     * @param {?} url\n     * @return {?}\n     */\n    XtbParser.prototype.parse = function (xtb, url) {\n        this._bundleDepth = 0;\n        this._msgIdToHtml = {};\n        // We can not parse the ICU messages at this point as some messages might not originate\n        // from Angular that could not be lex'd.\n        var /** @type {?} */ xml = new XmlParser().parse(xtb, url, false);\n        this._errors = xml.errors;\n        visitAll(this, xml.rootNodes);\n        return {\n            msgIdToHtml: this._msgIdToHtml,\n            errors: this._errors,\n            locale: this._locale,\n        };\n    };\n    /**\n     * @param {?} element\n     * @param {?} context\n     * @return {?}\n     */\n    XtbParser.prototype.visitElement = function (element, context) {\n        switch (element.name) {\n            case _TRANSLATIONS_TAG:\n                this._bundleDepth++;\n                if (this._bundleDepth > 1) {\n                    this._addError(element, \"<\" + _TRANSLATIONS_TAG + \"> elements can not be nested\");\n                }\n                var /** @type {?} */ langAttr = element.attrs.find(function (attr) { return attr.name === 'lang'; });\n                if (langAttr) {\n                    this._locale = langAttr.value;\n                }\n                visitAll(this, element.children, null);\n                this._bundleDepth--;\n                break;\n            case _TRANSLATION_TAG:\n                var /** @type {?} */ idAttr = element.attrs.find(function (attr) { return attr.name === 'id'; });\n                if (!idAttr) {\n                    this._addError(element, \"<\" + _TRANSLATION_TAG + \"> misses the \\\"id\\\" attribute\");\n                }\n                else {\n                    var /** @type {?} */ id = idAttr.value;\n                    if (this._msgIdToHtml.hasOwnProperty(id)) {\n                        this._addError(element, \"Duplicated translations for msg \" + id);\n                    }\n                    else {\n                        var /** @type {?} */ innerTextStart = ((element.startSourceSpan)).end.offset;\n                        var /** @type {?} */ innerTextEnd = ((element.endSourceSpan)).start.offset;\n                        var /** @type {?} */ content = ((element.startSourceSpan)).start.file.content;\n                        var /** @type {?} */ innerText = content.slice(/** @type {?} */ ((innerTextStart)), /** @type {?} */ ((innerTextEnd)));\n                        this._msgIdToHtml[id] = innerText;\n                    }\n                }\n                break;\n            default:\n                this._addError(element, 'Unexpected tag');\n        }\n    };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    XtbParser.prototype.visitAttribute = function (attribute, context) { };\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    XtbParser.prototype.visitText = function (text, context) { };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    XtbParser.prototype.visitComment = function (comment, context) { };\n    /**\n     * @param {?} expansion\n     * @param {?} context\n     * @return {?}\n     */\n    XtbParser.prototype.visitExpansion = function (expansion, context) { };\n    /**\n     * @param {?} expansionCase\n     * @param {?} context\n     * @return {?}\n     */\n    XtbParser.prototype.visitExpansionCase = function (expansionCase, context) { };\n    /**\n     * @param {?} node\n     * @param {?} message\n     * @return {?}\n     */\n    XtbParser.prototype._addError = function (node, message) {\n        this._errors.push(new I18nError(/** @type {?} */ ((node.sourceSpan)), message));\n    };\n    return XtbParser;\n}());\nvar XmlToI18n$2 = (function () {\n    function XmlToI18n$2() {\n    }\n    /**\n     * @param {?} message\n     * @param {?} url\n     * @return {?}\n     */\n    XmlToI18n$2.prototype.convert = function (message, url) {\n        var /** @type {?} */ xmlIcu = new XmlParser().parse(message, url, true);\n        this._errors = xmlIcu.errors;\n        var /** @type {?} */ i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?\n            [] :\n            visitAll(this, xmlIcu.rootNodes);\n        return {\n            i18nNodes: i18nNodes,\n            errors: this._errors,\n        };\n    };\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$2.prototype.visitText = function (text, context) { return new Text$1(text.value, /** @type {?} */ ((text.sourceSpan))); };\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$2.prototype.visitExpansion = function (icu, context) {\n        var /** @type {?} */ caseMap = {};\n        visitAll(this, icu.cases).forEach(function (c) {\n            caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\n        });\n        return new Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n    };\n    /**\n     * @param {?} icuCase\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$2.prototype.visitExpansionCase = function (icuCase, context) {\n        return {\n            value: icuCase.value,\n            nodes: visitAll(this, icuCase.expression),\n        };\n    };\n    /**\n     * @param {?} el\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$2.prototype.visitElement = function (el, context) {\n        if (el.name === _PLACEHOLDER_TAG$3) {\n            var /** @type {?} */ nameAttr = el.attrs.find(function (attr) { return attr.name === 'name'; });\n            if (nameAttr) {\n                return new Placeholder('', nameAttr.value, /** @type {?} */ ((el.sourceSpan)));\n            }\n            this._addError(el, \"<\" + _PLACEHOLDER_TAG$3 + \"> misses the \\\"name\\\" attribute\");\n        }\n        else {\n            this._addError(el, \"Unexpected tag\");\n        }\n        return null;\n    };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$2.prototype.visitComment = function (comment, context) { };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$2.prototype.visitAttribute = function (attribute, context) { };\n    /**\n     * @param {?} node\n     * @param {?} message\n     * @return {?}\n     */\n    XmlToI18n$2.prototype._addError = function (node, message) {\n        this._errors.push(new I18nError(/** @type {?} */ ((node.sourceSpan)), message));\n    };\n    return XmlToI18n$2;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar HtmlParser = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](HtmlParser, _super);\n    function HtmlParser() {\n        return _super.call(this, getHtmlTagDefinition) || this;\n    }\n    /**\n     * @param {?} source\n     * @param {?} url\n     * @param {?=} parseExpansionForms\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    HtmlParser.prototype.parse = function (source, url, parseExpansionForms, interpolationConfig) {\n        if (parseExpansionForms === void 0) { parseExpansionForms = false; }\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        return _super.prototype.parse.call(this, source, url, parseExpansionForms, interpolationConfig);\n    };\n    return HtmlParser;\n}(Parser$1));\nHtmlParser.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nHtmlParser.ctorParameters = function () { return []; };\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A container for translated messages\n */\nvar TranslationBundle = (function () {\n    /**\n     * @param {?=} _i18nNodesByMsgId\n     * @param {?=} locale\n     * @param {?=} digest\n     * @param {?=} mapperFactory\n     * @param {?=} missingTranslationStrategy\n     * @param {?=} console\n     */\n    function TranslationBundle(_i18nNodesByMsgId, locale, digest, mapperFactory, missingTranslationStrategy, console) {\n        if (_i18nNodesByMsgId === void 0) { _i18nNodesByMsgId = {}; }\n        if (missingTranslationStrategy === void 0) { missingTranslationStrategy = __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"MissingTranslationStrategy\"].Warning; }\n        this._i18nNodesByMsgId = _i18nNodesByMsgId;\n        this.digest = digest;\n        this.mapperFactory = mapperFactory;\n        this._i18nToHtml = new I18nToHtmlVisitor(_i18nNodesByMsgId, locale, digest, mapperFactory, missingTranslationStrategy, console);\n    }\n    /**\n     * @param {?} content\n     * @param {?} url\n     * @param {?} serializer\n     * @param {?} missingTranslationStrategy\n     * @param {?=} console\n     * @return {?}\n     */\n    TranslationBundle.load = function (content, url, serializer, missingTranslationStrategy, console) {\n        var _a = serializer.load(content, url), locale = _a.locale, i18nNodesByMsgId = _a.i18nNodesByMsgId;\n        var /** @type {?} */ digestFn = function (m) { return serializer.digest(m); };\n        var /** @type {?} */ mapperFactory = function (m) { return ((serializer.createNameMapper(m))); };\n        return new TranslationBundle(i18nNodesByMsgId, locale, digestFn, mapperFactory, missingTranslationStrategy, console);\n    };\n    /**\n     * @param {?} srcMsg\n     * @return {?}\n     */\n    TranslationBundle.prototype.get = function (srcMsg) {\n        var /** @type {?} */ html = this._i18nToHtml.convert(srcMsg);\n        if (html.errors.length) {\n            throw new Error(html.errors.join('\\n'));\n        }\n        return html.nodes;\n    };\n    /**\n     * @param {?} srcMsg\n     * @return {?}\n     */\n    TranslationBundle.prototype.has = function (srcMsg) { return this.digest(srcMsg) in this._i18nNodesByMsgId; };\n    return TranslationBundle;\n}());\nvar I18nToHtmlVisitor = (function () {\n    /**\n     * @param {?=} _i18nNodesByMsgId\n     * @param {?=} _locale\n     * @param {?=} _digest\n     * @param {?=} _mapperFactory\n     * @param {?=} _missingTranslationStrategy\n     * @param {?=} _console\n     */\n    function I18nToHtmlVisitor(_i18nNodesByMsgId, _locale, _digest, _mapperFactory, _missingTranslationStrategy, _console) {\n        if (_i18nNodesByMsgId === void 0) { _i18nNodesByMsgId = {}; }\n        this._i18nNodesByMsgId = _i18nNodesByMsgId;\n        this._locale = _locale;\n        this._digest = _digest;\n        this._mapperFactory = _mapperFactory;\n        this._missingTranslationStrategy = _missingTranslationStrategy;\n        this._console = _console;\n        this._contextStack = [];\n        this._errors = [];\n    }\n    /**\n     * @param {?} srcMsg\n     * @return {?}\n     */\n    I18nToHtmlVisitor.prototype.convert = function (srcMsg) {\n        this._contextStack.length = 0;\n        this._errors.length = 0;\n        // i18n to text\n        var /** @type {?} */ text = this._convertToText(srcMsg);\n        // text to html\n        var /** @type {?} */ url = srcMsg.nodes[0].sourceSpan.start.file.url;\n        var /** @type {?} */ html = new HtmlParser().parse(text, url, true);\n        return {\n            nodes: html.rootNodes,\n            errors: this._errors.concat(html.errors),\n        };\n    };\n    /**\n     * @param {?} text\n     * @param {?=} context\n     * @return {?}\n     */\n    I18nToHtmlVisitor.prototype.visitText = function (text, context) { return text.value; };\n    /**\n     * @param {?} container\n     * @param {?=} context\n     * @return {?}\n     */\n    I18nToHtmlVisitor.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        return container.children.map(function (n) { return n.visit(_this); }).join('');\n    };\n    /**\n     * @param {?} icu\n     * @param {?=} context\n     * @return {?}\n     */\n    I18nToHtmlVisitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var /** @type {?} */ cases = Object.keys(icu.cases).map(function (k) { return k + \" {\" + icu.cases[k].visit(_this) + \"}\"; });\n        // TODO(vicb): Once all format switch to using expression placeholders\n        // we should throw when the placeholder is not in the source message\n        var /** @type {?} */ exp = this._srcMsg.placeholders.hasOwnProperty(icu.expression) ?\n            this._srcMsg.placeholders[icu.expression] :\n            icu.expression;\n        return \"{\" + exp + \", \" + icu.type + \", \" + cases.join(' ') + \"}\";\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    I18nToHtmlVisitor.prototype.visitPlaceholder = function (ph, context) {\n        var /** @type {?} */ phName = this._mapper(ph.name);\n        if (this._srcMsg.placeholders.hasOwnProperty(phName)) {\n            return this._srcMsg.placeholders[phName];\n        }\n        if (this._srcMsg.placeholderToMessage.hasOwnProperty(phName)) {\n            return this._convertToText(this._srcMsg.placeholderToMessage[phName]);\n        }\n        this._addError(ph, \"Unknown placeholder \\\"\" + ph.name + \"\\\"\");\n        return '';\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    I18nToHtmlVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n        var _this = this;\n        var /** @type {?} */ tag = \"\" + ph.tag;\n        var /** @type {?} */ attrs = Object.keys(ph.attrs).map(function (name) { return name + \"=\\\"\" + ph.attrs[name] + \"\\\"\"; }).join(' ');\n        if (ph.isVoid) {\n            return \"<\" + tag + \" \" + attrs + \"/>\";\n        }\n        var /** @type {?} */ children = ph.children.map(function (c) { return c.visit(_this); }).join('');\n        return \"<\" + tag + \" \" + attrs + \">\" + children + \"</\" + tag + \">\";\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    I18nToHtmlVisitor.prototype.visitIcuPlaceholder = function (ph, context) {\n        // An ICU placeholder references the source message to be serialized\n        return this._convertToText(this._srcMsg.placeholderToMessage[ph.name]);\n    };\n    /**\n     * Convert a source message to a translated text string:\n     * - text nodes are replaced with their translation,\n     * - placeholders are replaced with their content,\n     * - ICU nodes are converted to ICU expressions.\n     * @param {?} srcMsg\n     * @return {?}\n     */\n    I18nToHtmlVisitor.prototype._convertToText = function (srcMsg) {\n        var _this = this;\n        var /** @type {?} */ id = this._digest(srcMsg);\n        var /** @type {?} */ mapper = this._mapperFactory ? this._mapperFactory(srcMsg) : null;\n        var /** @type {?} */ nodes;\n        this._contextStack.push({ msg: this._srcMsg, mapper: this._mapper });\n        this._srcMsg = srcMsg;\n        if (this._i18nNodesByMsgId.hasOwnProperty(id)) {\n            // When there is a translation use its nodes as the source\n            // And create a mapper to convert serialized placeholder names to internal names\n            nodes = this._i18nNodesByMsgId[id];\n            this._mapper = function (name) { return mapper ? ((mapper.toInternalName(name))) : name; };\n        }\n        else {\n            // When no translation has been found\n            // - report an error / a warning / nothing,\n            // - use the nodes from the original message\n            // - placeholders are already internal and need no mapper\n            if (this._missingTranslationStrategy === __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"MissingTranslationStrategy\"].Error) {\n                var /** @type {?} */ ctx = this._locale ? \" for locale \\\"\" + this._locale + \"\\\"\" : '';\n                this._addError(srcMsg.nodes[0], \"Missing translation for message \\\"\" + id + \"\\\"\" + ctx);\n            }\n            else if (this._console &&\n                this._missingTranslationStrategy === __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"MissingTranslationStrategy\"].Warning) {\n                var /** @type {?} */ ctx = this._locale ? \" for locale \\\"\" + this._locale + \"\\\"\" : '';\n                this._console.warn(\"Missing translation for message \\\"\" + id + \"\\\"\" + ctx);\n            }\n            nodes = srcMsg.nodes;\n            this._mapper = function (name) { return name; };\n        }\n        var /** @type {?} */ text = nodes.map(function (node) { return node.visit(_this); }).join('');\n        var /** @type {?} */ context = ((this._contextStack.pop()));\n        this._srcMsg = context.msg;\n        this._mapper = context.mapper;\n        return text;\n    };\n    /**\n     * @param {?} el\n     * @param {?} msg\n     * @return {?}\n     */\n    I18nToHtmlVisitor.prototype._addError = function (el, msg) {\n        this._errors.push(new I18nError(el.sourceSpan, msg));\n    };\n    return I18nToHtmlVisitor;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar I18NHtmlParser = (function () {\n    /**\n     * @param {?} _htmlParser\n     * @param {?=} translations\n     * @param {?=} translationsFormat\n     * @param {?=} missingTranslation\n     * @param {?=} console\n     */\n    function I18NHtmlParser(_htmlParser, translations, translationsFormat, missingTranslation, console) {\n        if (missingTranslation === void 0) { missingTranslation = __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"MissingTranslationStrategy\"].Warning; }\n        this._htmlParser = _htmlParser;\n        if (translations) {\n            var serializer = createSerializer(translationsFormat);\n            this._translationBundle =\n                TranslationBundle.load(translations, 'i18n', serializer, missingTranslation, console);\n        }\n        else {\n            this._translationBundle =\n                new TranslationBundle({}, null, digest, undefined, missingTranslation, console);\n        }\n    }\n    /**\n     * @param {?} source\n     * @param {?} url\n     * @param {?=} parseExpansionForms\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    I18NHtmlParser.prototype.parse = function (source, url, parseExpansionForms, interpolationConfig) {\n        if (parseExpansionForms === void 0) { parseExpansionForms = false; }\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        var /** @type {?} */ parseResult = this._htmlParser.parse(source, url, parseExpansionForms, interpolationConfig);\n        if (parseResult.errors.length) {\n            return new ParseTreeResult(parseResult.rootNodes, parseResult.errors);\n        }\n        return mergeTranslations(parseResult.rootNodes, this._translationBundle, interpolationConfig, [], {});\n    };\n    return I18NHtmlParser;\n}());\n/**\n * @param {?=} format\n * @return {?}\n */\nfunction createSerializer(format) {\n    format = (format || 'xlf').toLowerCase();\n    switch (format) {\n        case 'xmb':\n            return new Xmb();\n        case 'xtb':\n            return new Xtb();\n        case 'xliff2':\n        case 'xlf2':\n            return new Xliff2();\n        case 'xliff':\n        case 'xlf':\n        default:\n            return new Xliff();\n    }\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar CORE = '@angular/core';\nvar Identifiers = (function () {\n    function Identifiers() {\n    }\n    return Identifiers;\n}());\nIdentifiers.ANALYZE_FOR_ENTRY_COMPONENTS = {\n    name: 'ANALYZE_FOR_ENTRY_COMPONENTS',\n    moduleName: CORE,\n    runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ANALYZE_FOR_ENTRY_COMPONENTS\"]\n};\nIdentifiers.ElementRef = { name: 'ElementRef', moduleName: CORE, runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"] };\nIdentifiers.NgModuleRef = { name: 'NgModuleRef', moduleName: CORE, runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModuleRef\"] };\nIdentifiers.ViewContainerRef = { name: 'ViewContainerRef', moduleName: CORE, runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewContainerRef\"] };\nIdentifiers.ChangeDetectorRef = {\n    name: 'ChangeDetectorRef',\n    moduleName: CORE,\n    runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectorRef\"]\n};\nIdentifiers.QueryList = { name: 'QueryList', moduleName: CORE, runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"QueryList\"] };\nIdentifiers.TemplateRef = { name: 'TemplateRef', moduleName: CORE, runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"TemplateRef\"] };\nIdentifiers.CodegenComponentFactoryResolver = {\n    name: 'CodegenComponentFactoryResolver',\n    moduleName: CORE,\n    runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"CodegenComponentFactoryResolver\"]\n};\nIdentifiers.ComponentFactoryResolver = {\n    name: 'ComponentFactoryResolver',\n    moduleName: CORE,\n    runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ComponentFactoryResolver\"]\n};\nIdentifiers.ComponentFactory = { name: 'ComponentFactory', moduleName: CORE, runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ComponentFactory\"] };\nIdentifiers.ComponentRef = { name: 'ComponentRef', moduleName: CORE, runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ComponentRef\"] };\nIdentifiers.NgModuleFactory = { name: 'NgModuleFactory', moduleName: CORE, runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModuleFactory\"] };\nIdentifiers.createModuleFactory = {\n    name: 'cmf',\n    moduleName: CORE,\n    runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"cmf\"],\n};\nIdentifiers.moduleDef = {\n    name: 'mod',\n    moduleName: CORE,\n    runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"mod\"],\n};\nIdentifiers.moduleProviderDef = {\n    name: 'mpd',\n    moduleName: CORE,\n    runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"mpd\"],\n};\nIdentifiers.RegisterModuleFactoryFn = {\n    name: 'registerModuleFactory',\n    moduleName: CORE,\n    runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"registerModuleFactory\"],\n};\nIdentifiers.Injector = { name: 'Injector', moduleName: CORE, runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injector\"] };\nIdentifiers.ViewEncapsulation = {\n    name: 'ViewEncapsulation',\n    moduleName: CORE,\n    runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"]\n};\nIdentifiers.ChangeDetectionStrategy = {\n    name: 'ChangeDetectionStrategy',\n    moduleName: CORE,\n    runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"]\n};\nIdentifiers.SecurityContext = {\n    name: 'SecurityContext',\n    moduleName: CORE,\n    runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SecurityContext\"],\n};\nIdentifiers.LOCALE_ID = { name: 'LOCALE_ID', moduleName: CORE, runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"LOCALE_ID\"] };\nIdentifiers.TRANSLATIONS_FORMAT = {\n    name: 'TRANSLATIONS_FORMAT',\n    moduleName: CORE,\n    runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"TRANSLATIONS_FORMAT\"]\n};\nIdentifiers.inlineInterpolate = {\n    name: 'inlineInterpolate',\n    moduleName: CORE,\n    runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"inlineInterpolate\"]\n};\nIdentifiers.interpolate = { name: 'interpolate', moduleName: CORE, runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"interpolate\"] };\nIdentifiers.EMPTY_ARRAY = { name: 'EMPTY_ARRAY', moduleName: CORE, runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EMPTY_ARRAY\"] };\nIdentifiers.EMPTY_MAP = { name: 'EMPTY_MAP', moduleName: CORE, runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EMPTY_MAP\"] };\nIdentifiers.Renderer = { name: 'Renderer', moduleName: CORE, runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer\"] };\nIdentifiers.viewDef = { name: 'vid', moduleName: CORE, runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"vid\"] };\nIdentifiers.elementDef = { name: 'eld', moduleName: CORE, runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"eld\"] };\nIdentifiers.anchorDef = { name: 'and', moduleName: CORE, runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"and\"] };\nIdentifiers.textDef = { name: 'ted', moduleName: CORE, runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ted\"] };\nIdentifiers.directiveDef = { name: 'did', moduleName: CORE, runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"did\"] };\nIdentifiers.providerDef = { name: 'prd', moduleName: CORE, runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"prd\"] };\nIdentifiers.queryDef = { name: 'qud', moduleName: CORE, runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"qud\"] };\nIdentifiers.pureArrayDef = { name: 'pad', moduleName: CORE, runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"pad\"] };\nIdentifiers.pureObjectDef = { name: 'pod', moduleName: CORE, runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"pod\"] };\nIdentifiers.purePipeDef = { name: 'ppd', moduleName: CORE, runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ppd\"] };\nIdentifiers.pipeDef = { name: 'pid', moduleName: CORE, runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"pid\"] };\nIdentifiers.nodeValue = { name: 'nov', moduleName: CORE, runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"nov\"] };\nIdentifiers.ngContentDef = { name: 'ncd', moduleName: CORE, runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ncd\"] };\nIdentifiers.unwrapValue = { name: 'unv', moduleName: CORE, runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"unv\"] };\nIdentifiers.createRendererType2 = { name: 'crt', moduleName: CORE, runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"crt\"] };\nIdentifiers.RendererType2 = {\n    name: 'RendererType2',\n    moduleName: CORE,\n    // type only\n    runtime: null\n};\nIdentifiers.ViewDefinition = {\n    name: 'ViewDefinition',\n    moduleName: CORE,\n    // type only\n    runtime: null\n};\nIdentifiers.createComponentFactory = { name: 'ccf', moduleName: CORE, runtime: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ccf\"] };\n/**\n * @param {?} reference\n * @return {?}\n */\nfunction createTokenForReference(reference) {\n    return { identifier: { reference: reference } };\n}\n/**\n * @param {?} reflector\n * @param {?} reference\n * @return {?}\n */\nfunction createTokenForExternalReference(reflector, reference) {\n    return createTokenForReference(reflector.resolveExternalReference(reference));\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// http://cldr.unicode.org/index/cldr-spec/plural-rules\nvar PLURAL_CASES = ['zero', 'one', 'two', 'few', 'many', 'other'];\n/**\n * Expands special forms into elements.\n *\n * For example,\n *\n * ```\n * { messages.length, plural,\n *   =0 {zero}\n *   =1 {one}\n *   other {more than one}\n * }\n * ```\n *\n * will be expanded into\n *\n * ```\n * <ng-container [ngPlural]=\"messages.length\">\n *   <ng-template ngPluralCase=\"=0\">zero</ng-template>\n *   <ng-template ngPluralCase=\"=1\">one</ng-template>\n *   <ng-template ngPluralCase=\"other\">more than one</ng-template>\n * </ng-container>\n * ```\n * @param {?} nodes\n * @return {?}\n */\nfunction expandNodes(nodes) {\n    var /** @type {?} */ expander = new _Expander();\n    return new ExpansionResult(visitAll(expander, nodes), expander.isExpanded, expander.errors);\n}\nvar ExpansionResult = (function () {\n    /**\n     * @param {?} nodes\n     * @param {?} expanded\n     * @param {?} errors\n     */\n    function ExpansionResult(nodes, expanded, errors) {\n        this.nodes = nodes;\n        this.expanded = expanded;\n        this.errors = errors;\n    }\n    return ExpansionResult;\n}());\nvar ExpansionError = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](ExpansionError, _super);\n    /**\n     * @param {?} span\n     * @param {?} errorMsg\n     */\n    function ExpansionError(span, errorMsg) {\n        return _super.call(this, span, errorMsg) || this;\n    }\n    return ExpansionError;\n}(ParseError));\n/**\n * Expand expansion forms (plural, select) to directives\n *\n * \\@internal\n */\nvar _Expander = (function () {\n    function _Expander() {\n        this.isExpanded = false;\n        this.errors = [];\n    }\n    /**\n     * @param {?} element\n     * @param {?} context\n     * @return {?}\n     */\n    _Expander.prototype.visitElement = function (element, context) {\n        return new Element(element.name, element.attrs, visitAll(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan);\n    };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    _Expander.prototype.visitAttribute = function (attribute, context) { return attribute; };\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    _Expander.prototype.visitText = function (text, context) { return text; };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    _Expander.prototype.visitComment = function (comment, context) { return comment; };\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    _Expander.prototype.visitExpansion = function (icu, context) {\n        this.isExpanded = true;\n        return icu.type == 'plural' ? _expandPluralForm(icu, this.errors) :\n            _expandDefaultForm(icu, this.errors);\n    };\n    /**\n     * @param {?} icuCase\n     * @param {?} context\n     * @return {?}\n     */\n    _Expander.prototype.visitExpansionCase = function (icuCase, context) {\n        throw new Error('Should not be reached');\n    };\n    return _Expander;\n}());\n/**\n * @param {?} ast\n * @param {?} errors\n * @return {?}\n */\nfunction _expandPluralForm(ast, errors) {\n    var /** @type {?} */ children = ast.cases.map(function (c) {\n        if (PLURAL_CASES.indexOf(c.value) == -1 && !c.value.match(/^=\\d+$/)) {\n            errors.push(new ExpansionError(c.valueSourceSpan, \"Plural cases should be \\\"=<number>\\\" or one of \" + PLURAL_CASES.join(\", \")));\n        }\n        var /** @type {?} */ expansionResult = expandNodes(c.expression);\n        errors.push.apply(errors, expansionResult.errors);\n        return new Element(\"ng-template\", [new Attribute$1('ngPluralCase', \"\" + c.value, c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);\n    });\n    var /** @type {?} */ switchAttr = new Attribute$1('[ngPlural]', ast.switchValue, ast.switchValueSourceSpan);\n    return new Element('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);\n}\n/**\n * @param {?} ast\n * @param {?} errors\n * @return {?}\n */\nfunction _expandDefaultForm(ast, errors) {\n    var /** @type {?} */ children = ast.cases.map(function (c) {\n        var /** @type {?} */ expansionResult = expandNodes(c.expression);\n        errors.push.apply(errors, expansionResult.errors);\n        if (c.value === 'other') {\n            // other is the default case when no values match\n            return new Element(\"ng-template\", [new Attribute$1('ngSwitchDefault', '', c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);\n        }\n        return new Element(\"ng-template\", [new Attribute$1('ngSwitchCase', \"\" + c.value, c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);\n    });\n    var /** @type {?} */ switchAttr = new Attribute$1('[ngSwitch]', ast.switchValue, ast.switchValueSourceSpan);\n    return new Element('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ProviderError = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](ProviderError, _super);\n    /**\n     * @param {?} message\n     * @param {?} span\n     */\n    function ProviderError(message, span) {\n        return _super.call(this, span, message) || this;\n    }\n    return ProviderError;\n}(ParseError));\nvar ProviderViewContext = (function () {\n    /**\n     * @param {?} reflector\n     * @param {?} component\n     */\n    function ProviderViewContext(reflector, component) {\n        var _this = this;\n        this.reflector = reflector;\n        this.component = component;\n        this.errors = [];\n        this.viewQueries = _getViewQueries(component);\n        this.viewProviders = new Map();\n        component.viewProviders.forEach(function (provider) {\n            if (_this.viewProviders.get(tokenReference(provider.token)) == null) {\n                _this.viewProviders.set(tokenReference(provider.token), true);\n            }\n        });\n    }\n    return ProviderViewContext;\n}());\nvar ProviderElementContext = (function () {\n    /**\n     * @param {?} viewContext\n     * @param {?} _parent\n     * @param {?} _isViewRoot\n     * @param {?} _directiveAsts\n     * @param {?} attrs\n     * @param {?} refs\n     * @param {?} isTemplate\n     * @param {?} contentQueryStartId\n     * @param {?} _sourceSpan\n     */\n    function ProviderElementContext(viewContext, _parent, _isViewRoot, _directiveAsts, attrs, refs, isTemplate, contentQueryStartId, _sourceSpan) {\n        var _this = this;\n        this.viewContext = viewContext;\n        this._parent = _parent;\n        this._isViewRoot = _isViewRoot;\n        this._directiveAsts = _directiveAsts;\n        this._sourceSpan = _sourceSpan;\n        this._transformedProviders = new Map();\n        this._seenProviders = new Map();\n        this._hasViewContainer = false;\n        this._queriedTokens = new Map();\n        this._attrs = {};\n        attrs.forEach(function (attrAst) { return _this._attrs[attrAst.name] = attrAst.value; });\n        var directivesMeta = _directiveAsts.map(function (directiveAst) { return directiveAst.directive; });\n        this._allProviders =\n            _resolveProvidersFromDirectives(directivesMeta, _sourceSpan, viewContext.errors);\n        this._contentQueries = _getContentQueries(contentQueryStartId, directivesMeta);\n        Array.from(this._allProviders.values()).forEach(function (provider) {\n            _this._addQueryReadsTo(provider.token, provider.token, _this._queriedTokens);\n        });\n        if (isTemplate) {\n            var templateRefId = createTokenForExternalReference(this.viewContext.reflector, Identifiers.TemplateRef);\n            this._addQueryReadsTo(templateRefId, templateRefId, this._queriedTokens);\n        }\n        refs.forEach(function (refAst) {\n            var defaultQueryValue = refAst.value ||\n                createTokenForExternalReference(_this.viewContext.reflector, Identifiers.ElementRef);\n            _this._addQueryReadsTo({ value: refAst.name }, defaultQueryValue, _this._queriedTokens);\n        });\n        if (this._queriedTokens.get(this.viewContext.reflector.resolveExternalReference(Identifiers.ViewContainerRef))) {\n            this._hasViewContainer = true;\n        }\n        // create the providers that we know are eager first\n        Array.from(this._allProviders.values()).forEach(function (provider) {\n            var eager = provider.eager || _this._queriedTokens.get(tokenReference(provider.token));\n            if (eager) {\n                _this._getOrCreateLocalProvider(provider.providerType, provider.token, true);\n            }\n        });\n    }\n    /**\n     * @return {?}\n     */\n    ProviderElementContext.prototype.afterElement = function () {\n        var _this = this;\n        // collect lazy providers\n        Array.from(this._allProviders.values()).forEach(function (provider) {\n            _this._getOrCreateLocalProvider(provider.providerType, provider.token, false);\n        });\n    };\n    Object.defineProperty(ProviderElementContext.prototype, \"transformProviders\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            // Note: Maps keep their insertion order.\n            var /** @type {?} */ lazyProviders = [];\n            var /** @type {?} */ eagerProviders = [];\n            this._transformedProviders.forEach(function (provider) {\n                if (provider.eager) {\n                    eagerProviders.push(provider);\n                }\n                else {\n                    lazyProviders.push(provider);\n                }\n            });\n            return lazyProviders.concat(eagerProviders);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ProviderElementContext.prototype, \"transformedDirectiveAsts\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            var /** @type {?} */ sortedProviderTypes = this.transformProviders.map(function (provider) { return provider.token.identifier; });\n            var /** @type {?} */ sortedDirectives = this._directiveAsts.slice();\n            sortedDirectives.sort(function (dir1, dir2) { return sortedProviderTypes.indexOf(dir1.directive.type) -\n                sortedProviderTypes.indexOf(dir2.directive.type); });\n            return sortedDirectives;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ProviderElementContext.prototype, \"transformedHasViewContainer\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this._hasViewContainer; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ProviderElementContext.prototype, \"queryMatches\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            var /** @type {?} */ allMatches = [];\n            this._queriedTokens.forEach(function (matches) { allMatches.push.apply(allMatches, matches); });\n            return allMatches;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} token\n     * @param {?} defaultValue\n     * @param {?} queryReadTokens\n     * @return {?}\n     */\n    ProviderElementContext.prototype._addQueryReadsTo = function (token, defaultValue, queryReadTokens) {\n        this._getQueriesFor(token).forEach(function (query) {\n            var /** @type {?} */ queryValue = query.meta.read || defaultValue;\n            var /** @type {?} */ tokenRef = tokenReference(queryValue);\n            var /** @type {?} */ queryMatches = queryReadTokens.get(tokenRef);\n            if (!queryMatches) {\n                queryMatches = [];\n                queryReadTokens.set(tokenRef, queryMatches);\n            }\n            queryMatches.push({ queryId: query.queryId, value: queryValue });\n        });\n    };\n    /**\n     * @param {?} token\n     * @return {?}\n     */\n    ProviderElementContext.prototype._getQueriesFor = function (token) {\n        var /** @type {?} */ result = [];\n        var /** @type {?} */ currentEl = this;\n        var /** @type {?} */ distance = 0;\n        var /** @type {?} */ queries;\n        while (currentEl !== null) {\n            queries = currentEl._contentQueries.get(tokenReference(token));\n            if (queries) {\n                result.push.apply(result, queries.filter(function (query) { return query.meta.descendants || distance <= 1; }));\n            }\n            if (currentEl._directiveAsts.length > 0) {\n                distance++;\n            }\n            currentEl = currentEl._parent;\n        }\n        queries = this.viewContext.viewQueries.get(tokenReference(token));\n        if (queries) {\n            result.push.apply(result, queries);\n        }\n        return result;\n    };\n    /**\n     * @param {?} requestingProviderType\n     * @param {?} token\n     * @param {?} eager\n     * @return {?}\n     */\n    ProviderElementContext.prototype._getOrCreateLocalProvider = function (requestingProviderType, token, eager) {\n        var _this = this;\n        var /** @type {?} */ resolvedProvider = this._allProviders.get(tokenReference(token));\n        if (!resolvedProvider || ((requestingProviderType === ProviderAstType.Directive ||\n            requestingProviderType === ProviderAstType.PublicService) &&\n            resolvedProvider.providerType === ProviderAstType.PrivateService) ||\n            ((requestingProviderType === ProviderAstType.PrivateService ||\n                requestingProviderType === ProviderAstType.PublicService) &&\n                resolvedProvider.providerType === ProviderAstType.Builtin)) {\n            return null;\n        }\n        var /** @type {?} */ transformedProviderAst = this._transformedProviders.get(tokenReference(token));\n        if (transformedProviderAst) {\n            return transformedProviderAst;\n        }\n        if (this._seenProviders.get(tokenReference(token)) != null) {\n            this.viewContext.errors.push(new ProviderError(\"Cannot instantiate cyclic dependency! \" + tokenName(token), this._sourceSpan));\n            return null;\n        }\n        this._seenProviders.set(tokenReference(token), true);\n        var /** @type {?} */ transformedProviders = resolvedProvider.providers.map(function (provider) {\n            var /** @type {?} */ transformedUseValue = provider.useValue;\n            var /** @type {?} */ transformedUseExisting = ((provider.useExisting));\n            var /** @type {?} */ transformedDeps = ((undefined));\n            if (provider.useExisting != null) {\n                var /** @type {?} */ existingDiDep = ((_this._getDependency(resolvedProvider.providerType, { token: provider.useExisting }, eager)));\n                if (existingDiDep.token != null) {\n                    transformedUseExisting = existingDiDep.token;\n                }\n                else {\n                    transformedUseExisting = ((null));\n                    transformedUseValue = existingDiDep.value;\n                }\n            }\n            else if (provider.useFactory) {\n                var /** @type {?} */ deps = provider.deps || provider.useFactory.diDeps;\n                transformedDeps =\n                    deps.map(function (dep) { return ((_this._getDependency(resolvedProvider.providerType, dep, eager))); });\n            }\n            else if (provider.useClass) {\n                var /** @type {?} */ deps = provider.deps || provider.useClass.diDeps;\n                transformedDeps =\n                    deps.map(function (dep) { return ((_this._getDependency(resolvedProvider.providerType, dep, eager))); });\n            }\n            return _transformProvider(provider, {\n                useExisting: transformedUseExisting,\n                useValue: transformedUseValue,\n                deps: transformedDeps\n            });\n        });\n        transformedProviderAst =\n            _transformProviderAst(resolvedProvider, { eager: eager, providers: transformedProviders });\n        this._transformedProviders.set(tokenReference(token), transformedProviderAst);\n        return transformedProviderAst;\n    };\n    /**\n     * @param {?} requestingProviderType\n     * @param {?} dep\n     * @param {?=} eager\n     * @return {?}\n     */\n    ProviderElementContext.prototype._getLocalDependency = function (requestingProviderType, dep, eager) {\n        if (eager === void 0) { eager = false; }\n        if (dep.isAttribute) {\n            var /** @type {?} */ attrValue = this._attrs[((dep.token)).value];\n            return { isValue: true, value: attrValue == null ? null : attrValue };\n        }\n        if (dep.token != null) {\n            // access builtints\n            if ((requestingProviderType === ProviderAstType.Directive ||\n                requestingProviderType === ProviderAstType.Component)) {\n                if (tokenReference(dep.token) ===\n                    this.viewContext.reflector.resolveExternalReference(Identifiers.Renderer) ||\n                    tokenReference(dep.token) ===\n                        this.viewContext.reflector.resolveExternalReference(Identifiers.ElementRef) ||\n                    tokenReference(dep.token) ===\n                        this.viewContext.reflector.resolveExternalReference(Identifiers.ChangeDetectorRef) ||\n                    tokenReference(dep.token) ===\n                        this.viewContext.reflector.resolveExternalReference(Identifiers.TemplateRef)) {\n                    return dep;\n                }\n                if (tokenReference(dep.token) ===\n                    this.viewContext.reflector.resolveExternalReference(Identifiers.ViewContainerRef)) {\n                    this._hasViewContainer = true;\n                }\n            }\n            // access the injector\n            if (tokenReference(dep.token) ===\n                this.viewContext.reflector.resolveExternalReference(Identifiers.Injector)) {\n                return dep;\n            }\n            // access providers\n            if (this._getOrCreateLocalProvider(requestingProviderType, dep.token, eager) != null) {\n                return dep;\n            }\n        }\n        return null;\n    };\n    /**\n     * @param {?} requestingProviderType\n     * @param {?} dep\n     * @param {?=} eager\n     * @return {?}\n     */\n    ProviderElementContext.prototype._getDependency = function (requestingProviderType, dep, eager) {\n        if (eager === void 0) { eager = false; }\n        var /** @type {?} */ currElement = this;\n        var /** @type {?} */ currEager = eager;\n        var /** @type {?} */ result = null;\n        if (!dep.isSkipSelf) {\n            result = this._getLocalDependency(requestingProviderType, dep, eager);\n        }\n        if (dep.isSelf) {\n            if (!result && dep.isOptional) {\n                result = { isValue: true, value: null };\n            }\n        }\n        else {\n            // check parent elements\n            while (!result && currElement._parent) {\n                var /** @type {?} */ prevElement = currElement;\n                currElement = currElement._parent;\n                if (prevElement._isViewRoot) {\n                    currEager = false;\n                }\n                result = currElement._getLocalDependency(ProviderAstType.PublicService, dep, currEager);\n            }\n            // check @Host restriction\n            if (!result) {\n                if (!dep.isHost || this.viewContext.component.isHost ||\n                    this.viewContext.component.type.reference === tokenReference(/** @type {?} */ ((dep.token))) ||\n                    this.viewContext.viewProviders.get(tokenReference(/** @type {?} */ ((dep.token)))) != null) {\n                    result = dep;\n                }\n                else {\n                    result = dep.isOptional ? result = { isValue: true, value: null } : null;\n                }\n            }\n        }\n        if (!result) {\n            this.viewContext.errors.push(new ProviderError(\"No provider for \" + tokenName(/** @type {?} */ ((dep.token))), this._sourceSpan));\n        }\n        return result;\n    };\n    return ProviderElementContext;\n}());\nvar NgModuleProviderAnalyzer = (function () {\n    /**\n     * @param {?} reflector\n     * @param {?} ngModule\n     * @param {?} extraProviders\n     * @param {?} sourceSpan\n     */\n    function NgModuleProviderAnalyzer(reflector, ngModule, extraProviders, sourceSpan) {\n        var _this = this;\n        this.reflector = reflector;\n        this._transformedProviders = new Map();\n        this._seenProviders = new Map();\n        this._errors = [];\n        this._allProviders = new Map();\n        ngModule.transitiveModule.modules.forEach(function (ngModuleType) {\n            var ngModuleProvider = { token: { identifier: ngModuleType }, useClass: ngModuleType };\n            _resolveProviders([ngModuleProvider], ProviderAstType.PublicService, true, sourceSpan, _this._errors, _this._allProviders);\n        });\n        _resolveProviders(ngModule.transitiveModule.providers.map(function (entry) { return entry.provider; }).concat(extraProviders), ProviderAstType.PublicService, false, sourceSpan, this._errors, this._allProviders);\n    }\n    /**\n     * @return {?}\n     */\n    NgModuleProviderAnalyzer.prototype.parse = function () {\n        var _this = this;\n        Array.from(this._allProviders.values()).forEach(function (provider) {\n            _this._getOrCreateLocalProvider(provider.token, provider.eager);\n        });\n        if (this._errors.length > 0) {\n            var /** @type {?} */ errorString = this._errors.join('\\n');\n            throw new Error(\"Provider parse errors:\\n\" + errorString);\n        }\n        // Note: Maps keep their insertion order.\n        var /** @type {?} */ lazyProviders = [];\n        var /** @type {?} */ eagerProviders = [];\n        this._transformedProviders.forEach(function (provider) {\n            if (provider.eager) {\n                eagerProviders.push(provider);\n            }\n            else {\n                lazyProviders.push(provider);\n            }\n        });\n        return lazyProviders.concat(eagerProviders);\n    };\n    /**\n     * @param {?} token\n     * @param {?} eager\n     * @return {?}\n     */\n    NgModuleProviderAnalyzer.prototype._getOrCreateLocalProvider = function (token, eager) {\n        var _this = this;\n        var /** @type {?} */ resolvedProvider = this._allProviders.get(tokenReference(token));\n        if (!resolvedProvider) {\n            return null;\n        }\n        var /** @type {?} */ transformedProviderAst = this._transformedProviders.get(tokenReference(token));\n        if (transformedProviderAst) {\n            return transformedProviderAst;\n        }\n        if (this._seenProviders.get(tokenReference(token)) != null) {\n            this._errors.push(new ProviderError(\"Cannot instantiate cyclic dependency! \" + tokenName(token), resolvedProvider.sourceSpan));\n            return null;\n        }\n        this._seenProviders.set(tokenReference(token), true);\n        var /** @type {?} */ transformedProviders = resolvedProvider.providers.map(function (provider) {\n            var /** @type {?} */ transformedUseValue = provider.useValue;\n            var /** @type {?} */ transformedUseExisting = ((provider.useExisting));\n            var /** @type {?} */ transformedDeps = ((undefined));\n            if (provider.useExisting != null) {\n                var /** @type {?} */ existingDiDep = _this._getDependency({ token: provider.useExisting }, eager, resolvedProvider.sourceSpan);\n                if (existingDiDep.token != null) {\n                    transformedUseExisting = existingDiDep.token;\n                }\n                else {\n                    transformedUseExisting = ((null));\n                    transformedUseValue = existingDiDep.value;\n                }\n            }\n            else if (provider.useFactory) {\n                var /** @type {?} */ deps = provider.deps || provider.useFactory.diDeps;\n                transformedDeps =\n                    deps.map(function (dep) { return _this._getDependency(dep, eager, resolvedProvider.sourceSpan); });\n            }\n            else if (provider.useClass) {\n                var /** @type {?} */ deps = provider.deps || provider.useClass.diDeps;\n                transformedDeps =\n                    deps.map(function (dep) { return _this._getDependency(dep, eager, resolvedProvider.sourceSpan); });\n            }\n            return _transformProvider(provider, {\n                useExisting: transformedUseExisting,\n                useValue: transformedUseValue,\n                deps: transformedDeps\n            });\n        });\n        transformedProviderAst =\n            _transformProviderAst(resolvedProvider, { eager: eager, providers: transformedProviders });\n        this._transformedProviders.set(tokenReference(token), transformedProviderAst);\n        return transformedProviderAst;\n    };\n    /**\n     * @param {?} dep\n     * @param {?=} eager\n     * @param {?=} requestorSourceSpan\n     * @return {?}\n     */\n    NgModuleProviderAnalyzer.prototype._getDependency = function (dep, eager, requestorSourceSpan) {\n        if (eager === void 0) { eager = false; }\n        var /** @type {?} */ foundLocal = false;\n        if (!dep.isSkipSelf && dep.token != null) {\n            // access the injector\n            if (tokenReference(dep.token) ===\n                this.reflector.resolveExternalReference(Identifiers.Injector) ||\n                tokenReference(dep.token) ===\n                    this.reflector.resolveExternalReference(Identifiers.ComponentFactoryResolver)) {\n                foundLocal = true;\n                // access providers\n            }\n            else if (this._getOrCreateLocalProvider(dep.token, eager) != null) {\n                foundLocal = true;\n            }\n        }\n        var /** @type {?} */ result = dep;\n        if (dep.isSelf && !foundLocal) {\n            if (dep.isOptional) {\n                result = { isValue: true, value: null };\n            }\n            else {\n                this._errors.push(new ProviderError(\"No provider for \" + tokenName(/** @type {?} */ ((dep.token))), requestorSourceSpan));\n            }\n        }\n        return result;\n    };\n    return NgModuleProviderAnalyzer;\n}());\n/**\n * @param {?} provider\n * @param {?} __1\n * @return {?}\n */\nfunction _transformProvider(provider, _a) {\n    var useExisting = _a.useExisting, useValue = _a.useValue, deps = _a.deps;\n    return {\n        token: provider.token,\n        useClass: provider.useClass,\n        useExisting: useExisting,\n        useFactory: provider.useFactory,\n        useValue: useValue,\n        deps: deps,\n        multi: provider.multi\n    };\n}\n/**\n * @param {?} provider\n * @param {?} __1\n * @return {?}\n */\nfunction _transformProviderAst(provider, _a) {\n    var eager = _a.eager, providers = _a.providers;\n    return new ProviderAst(provider.token, provider.multiProvider, provider.eager || eager, providers, provider.providerType, provider.lifecycleHooks, provider.sourceSpan);\n}\n/**\n * @param {?} directives\n * @param {?} sourceSpan\n * @param {?} targetErrors\n * @return {?}\n */\nfunction _resolveProvidersFromDirectives(directives, sourceSpan, targetErrors) {\n    var /** @type {?} */ providersByToken = new Map();\n    directives.forEach(function (directive) {\n        var /** @type {?} */ dirProvider = { token: { identifier: directive.type }, useClass: directive.type };\n        _resolveProviders([dirProvider], directive.isComponent ? ProviderAstType.Component : ProviderAstType.Directive, true, sourceSpan, targetErrors, providersByToken);\n    });\n    // Note: directives need to be able to overwrite providers of a component!\n    var /** @type {?} */ directivesWithComponentFirst = directives.filter(function (dir) { return dir.isComponent; }).concat(directives.filter(function (dir) { return !dir.isComponent; }));\n    directivesWithComponentFirst.forEach(function (directive) {\n        _resolveProviders(directive.providers, ProviderAstType.PublicService, false, sourceSpan, targetErrors, providersByToken);\n        _resolveProviders(directive.viewProviders, ProviderAstType.PrivateService, false, sourceSpan, targetErrors, providersByToken);\n    });\n    return providersByToken;\n}\n/**\n * @param {?} providers\n * @param {?} providerType\n * @param {?} eager\n * @param {?} sourceSpan\n * @param {?} targetErrors\n * @param {?} targetProvidersByToken\n * @return {?}\n */\nfunction _resolveProviders(providers, providerType, eager, sourceSpan, targetErrors, targetProvidersByToken) {\n    providers.forEach(function (provider) {\n        var /** @type {?} */ resolvedProvider = targetProvidersByToken.get(tokenReference(provider.token));\n        if (resolvedProvider != null && !!resolvedProvider.multiProvider !== !!provider.multi) {\n            targetErrors.push(new ProviderError(\"Mixing multi and non multi provider is not possible for token \" + tokenName(resolvedProvider.token), sourceSpan));\n        }\n        if (!resolvedProvider) {\n            var /** @type {?} */ lifecycleHooks = provider.token.identifier &&\n                ((provider.token.identifier)).lifecycleHooks ?\n                ((provider.token.identifier)).lifecycleHooks :\n                [];\n            var /** @type {?} */ isUseValue = !(provider.useClass || provider.useExisting || provider.useFactory);\n            resolvedProvider = new ProviderAst(provider.token, !!provider.multi, eager || isUseValue, [provider], providerType, lifecycleHooks, sourceSpan);\n            targetProvidersByToken.set(tokenReference(provider.token), resolvedProvider);\n        }\n        else {\n            if (!provider.multi) {\n                resolvedProvider.providers.length = 0;\n            }\n            resolvedProvider.providers.push(provider);\n        }\n    });\n}\n/**\n * @param {?} component\n * @return {?}\n */\nfunction _getViewQueries(component) {\n    // Note: queries start with id 1 so we can use the number in a Bloom filter!\n    var /** @type {?} */ viewQueryId = 1;\n    var /** @type {?} */ viewQueries = new Map();\n    if (component.viewQueries) {\n        component.viewQueries.forEach(function (query) { return _addQueryToTokenMap(viewQueries, { meta: query, queryId: viewQueryId++ }); });\n    }\n    return viewQueries;\n}\n/**\n * @param {?} contentQueryStartId\n * @param {?} directives\n * @return {?}\n */\nfunction _getContentQueries(contentQueryStartId, directives) {\n    var /** @type {?} */ contentQueryId = contentQueryStartId;\n    var /** @type {?} */ contentQueries = new Map();\n    directives.forEach(function (directive, directiveIndex) {\n        if (directive.queries) {\n            directive.queries.forEach(function (query) { return _addQueryToTokenMap(contentQueries, { meta: query, queryId: contentQueryId++ }); });\n        }\n    });\n    return contentQueries;\n}\n/**\n * @param {?} map\n * @param {?} query\n * @return {?}\n */\nfunction _addQueryToTokenMap(map, query) {\n    query.meta.selectors.forEach(function (token) {\n        var /** @type {?} */ entry = map.get(tokenReference(token));\n        if (!entry) {\n            entry = [];\n            map.set(tokenReference(token), entry);\n        }\n        entry.push(query);\n    });\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @abstract\n */\nvar ElementSchemaRegistry = (function () {\n    function ElementSchemaRegistry() {\n    }\n    /**\n     * @abstract\n     * @param {?} tagName\n     * @param {?} propName\n     * @param {?} schemaMetas\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.hasProperty = function (tagName, propName, schemaMetas) { };\n    /**\n     * @abstract\n     * @param {?} tagName\n     * @param {?} schemaMetas\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.hasElement = function (tagName, schemaMetas) { };\n    /**\n     * @abstract\n     * @param {?} elementName\n     * @param {?} propName\n     * @param {?} isAttribute\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.securityContext = function (elementName, propName, isAttribute) { };\n    /**\n     * @abstract\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.allKnownElementNames = function () { };\n    /**\n     * @abstract\n     * @param {?} propName\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.getMappedPropName = function (propName) { };\n    /**\n     * @abstract\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.getDefaultComponentElementName = function () { };\n    /**\n     * @abstract\n     * @param {?} name\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.validateProperty = function (name) { };\n    /**\n     * @abstract\n     * @param {?} name\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.validateAttribute = function (name) { };\n    /**\n     * @abstract\n     * @param {?} propName\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.normalizeAnimationStyleProperty = function (propName) { };\n    /**\n     * @abstract\n     * @param {?} camelCaseProp\n     * @param {?} userProvidedProp\n     * @param {?} val\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.normalizeAnimationStyleValue = function (camelCaseProp, userProvidedProp, val) { };\n    return ElementSchemaRegistry;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar StyleWithImports = (function () {\n    /**\n     * @param {?} style\n     * @param {?} styleUrls\n     */\n    function StyleWithImports(style$$1, styleUrls) {\n        this.style = style$$1;\n        this.styleUrls = styleUrls;\n    }\n    return StyleWithImports;\n}());\n/**\n * @param {?} url\n * @return {?}\n */\nfunction isStyleUrlResolvable(url) {\n    if (url == null || url.length === 0 || url[0] == '/')\n        return false;\n    var /** @type {?} */ schemeMatch = url.match(URL_WITH_SCHEMA_REGEXP);\n    return schemeMatch === null || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';\n}\n/**\n * Rewrites stylesheets by resolving and removing the \\@import urls that\n * are either relative or don't have a `package:` scheme\n * @param {?} resolver\n * @param {?} baseUrl\n * @param {?} cssText\n * @return {?}\n */\nfunction extractStyleUrls(resolver, baseUrl, cssText) {\n    var /** @type {?} */ foundUrls = [];\n    var /** @type {?} */ modifiedCssText = cssText.replace(CSS_COMMENT_REGEXP, '').replace(CSS_IMPORT_REGEXP, function () {\n        var m = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            m[_i] = arguments[_i];\n        }\n        var /** @type {?} */ url = m[1] || m[2];\n        if (!isStyleUrlResolvable(url)) {\n            // Do not attempt to resolve non-package absolute URLs with URI scheme\n            return m[0];\n        }\n        foundUrls.push(resolver.resolve(baseUrl, url));\n        return '';\n    });\n    return new StyleWithImports(modifiedCssText, foundUrls);\n}\nvar CSS_IMPORT_REGEXP = /@import\\s+(?:url\\()?\\s*(?:(?:['\"]([^'\"]*))|([^;\\)\\s]*))[^;]*;?/g;\nvar CSS_COMMENT_REGEXP = /\\/\\*.+?\\*\\//g;\nvar URL_WITH_SCHEMA_REGEXP = /^([^:/?#]+):/;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar PROPERTY_PARTS_SEPARATOR = '.';\nvar ATTRIBUTE_PREFIX = 'attr';\nvar CLASS_PREFIX = 'class';\nvar STYLE_PREFIX = 'style';\nvar ANIMATE_PROP_PREFIX = 'animate-';\nvar BoundPropertyType = {};\nBoundPropertyType.DEFAULT = 0;\nBoundPropertyType.LITERAL_ATTR = 1;\nBoundPropertyType.ANIMATION = 2;\nBoundPropertyType[BoundPropertyType.DEFAULT] = \"DEFAULT\";\nBoundPropertyType[BoundPropertyType.LITERAL_ATTR] = \"LITERAL_ATTR\";\nBoundPropertyType[BoundPropertyType.ANIMATION] = \"ANIMATION\";\n/**\n * Represents a parsed property.\n */\nvar BoundProperty = (function () {\n    /**\n     * @param {?} name\n     * @param {?} expression\n     * @param {?} type\n     * @param {?} sourceSpan\n     */\n    function BoundProperty(name, expression, type, sourceSpan) {\n        this.name = name;\n        this.expression = expression;\n        this.type = type;\n        this.sourceSpan = sourceSpan;\n    }\n    Object.defineProperty(BoundProperty.prototype, \"isLiteral\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this.type === BoundPropertyType.LITERAL_ATTR; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BoundProperty.prototype, \"isAnimation\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this.type === BoundPropertyType.ANIMATION; },\n        enumerable: true,\n        configurable: true\n    });\n    return BoundProperty;\n}());\n/**\n * Parses bindings in templates and in the directive host area.\n */\nvar BindingParser = (function () {\n    /**\n     * @param {?} _exprParser\n     * @param {?} _interpolationConfig\n     * @param {?} _schemaRegistry\n     * @param {?} pipes\n     * @param {?} _targetErrors\n     */\n    function BindingParser(_exprParser, _interpolationConfig, _schemaRegistry, pipes, _targetErrors) {\n        var _this = this;\n        this._exprParser = _exprParser;\n        this._interpolationConfig = _interpolationConfig;\n        this._schemaRegistry = _schemaRegistry;\n        this._targetErrors = _targetErrors;\n        this.pipesByName = new Map();\n        this._usedPipes = new Map();\n        pipes.forEach(function (pipe) { return _this.pipesByName.set(pipe.name, pipe); });\n    }\n    /**\n     * @return {?}\n     */\n    BindingParser.prototype.getUsedPipes = function () { return Array.from(this._usedPipes.values()); };\n    /**\n     * @param {?} dirMeta\n     * @param {?} elementSelector\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    BindingParser.prototype.createDirectiveHostPropertyAsts = function (dirMeta, elementSelector, sourceSpan) {\n        var _this = this;\n        if (dirMeta.hostProperties) {\n            var /** @type {?} */ boundProps_1 = [];\n            Object.keys(dirMeta.hostProperties).forEach(function (propName) {\n                var /** @type {?} */ expression = dirMeta.hostProperties[propName];\n                if (typeof expression === 'string') {\n                    _this.parsePropertyBinding(propName, expression, true, sourceSpan, [], boundProps_1);\n                }\n                else {\n                    _this._reportError(\"Value of the host property binding \\\"\" + propName + \"\\\" needs to be a string representing an expression but got \\\"\" + expression + \"\\\" (\" + typeof expression + \")\", sourceSpan);\n                }\n            });\n            return boundProps_1.map(function (prop) { return _this.createElementPropertyAst(elementSelector, prop); });\n        }\n        return null;\n    };\n    /**\n     * @param {?} dirMeta\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    BindingParser.prototype.createDirectiveHostEventAsts = function (dirMeta, sourceSpan) {\n        var _this = this;\n        if (dirMeta.hostListeners) {\n            var /** @type {?} */ targetEventAsts_1 = [];\n            Object.keys(dirMeta.hostListeners).forEach(function (propName) {\n                var /** @type {?} */ expression = dirMeta.hostListeners[propName];\n                if (typeof expression === 'string') {\n                    _this.parseEvent(propName, expression, sourceSpan, [], targetEventAsts_1);\n                }\n                else {\n                    _this._reportError(\"Value of the host listener \\\"\" + propName + \"\\\" needs to be a string representing an expression but got \\\"\" + expression + \"\\\" (\" + typeof expression + \")\", sourceSpan);\n                }\n            });\n            return targetEventAsts_1;\n        }\n        return null;\n    };\n    /**\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    BindingParser.prototype.parseInterpolation = function (value, sourceSpan) {\n        var /** @type {?} */ sourceInfo = sourceSpan.start.toString();\n        try {\n            var /** @type {?} */ ast = ((this._exprParser.parseInterpolation(value, sourceInfo, this._interpolationConfig)));\n            if (ast)\n                this._reportExpressionParserErrors(ast.errors, sourceSpan);\n            this._checkPipes(ast, sourceSpan);\n            return ast;\n        }\n        catch (e) {\n            this._reportError(\"\" + e, sourceSpan);\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n        }\n    };\n    /**\n     * @param {?} prefixToken\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetProps\n     * @param {?} targetVars\n     * @return {?}\n     */\n    BindingParser.prototype.parseInlineTemplateBinding = function (prefixToken, value, sourceSpan, targetMatchableAttrs, targetProps, targetVars) {\n        var /** @type {?} */ bindings = this._parseTemplateBindings(prefixToken, value, sourceSpan);\n        for (var /** @type {?} */ i = 0; i < bindings.length; i++) {\n            var /** @type {?} */ binding = bindings[i];\n            if (binding.keyIsVar) {\n                targetVars.push(new VariableAst(binding.key, binding.name, sourceSpan));\n            }\n            else if (binding.expression) {\n                this._parsePropertyAst(binding.key, binding.expression, sourceSpan, targetMatchableAttrs, targetProps);\n            }\n            else {\n                targetMatchableAttrs.push([binding.key, '']);\n                this.parseLiteralAttr(binding.key, null, sourceSpan, targetMatchableAttrs, targetProps);\n            }\n        }\n    };\n    /**\n     * @param {?} prefixToken\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    BindingParser.prototype._parseTemplateBindings = function (prefixToken, value, sourceSpan) {\n        var _this = this;\n        var /** @type {?} */ sourceInfo = sourceSpan.start.toString();\n        try {\n            var /** @type {?} */ bindingsResult = this._exprParser.parseTemplateBindings(prefixToken, value, sourceInfo);\n            this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);\n            bindingsResult.templateBindings.forEach(function (binding) {\n                if (binding.expression) {\n                    _this._checkPipes(binding.expression, sourceSpan);\n                }\n            });\n            bindingsResult.warnings.forEach(function (warning) { _this._reportError(warning, sourceSpan, ParseErrorLevel.WARNING); });\n            return bindingsResult.templateBindings;\n        }\n        catch (e) {\n            this._reportError(\"\" + e, sourceSpan);\n            return [];\n        }\n    };\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetProps\n     * @return {?}\n     */\n    BindingParser.prototype.parseLiteralAttr = function (name, value, sourceSpan, targetMatchableAttrs, targetProps) {\n        if (_isAnimationLabel(name)) {\n            name = name.substring(1);\n            if (value) {\n                this._reportError(\"Assigning animation triggers via @prop=\\\"exp\\\" attributes with an expression is invalid.\" +\n                    \" Use property bindings (e.g. [@prop]=\\\"exp\\\") or use an attribute without a value (e.g. @prop) instead.\", sourceSpan, ParseErrorLevel.ERROR);\n            }\n            this._parseAnimation(name, value, sourceSpan, targetMatchableAttrs, targetProps);\n        }\n        else {\n            targetProps.push(new BoundProperty(name, this._exprParser.wrapLiteralPrimitive(value, ''), BoundPropertyType.LITERAL_ATTR, sourceSpan));\n        }\n    };\n    /**\n     * @param {?} name\n     * @param {?} expression\n     * @param {?} isHost\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetProps\n     * @return {?}\n     */\n    BindingParser.prototype.parsePropertyBinding = function (name, expression, isHost, sourceSpan, targetMatchableAttrs, targetProps) {\n        var /** @type {?} */ isAnimationProp = false;\n        if (name.startsWith(ANIMATE_PROP_PREFIX)) {\n            isAnimationProp = true;\n            name = name.substring(ANIMATE_PROP_PREFIX.length);\n        }\n        else if (_isAnimationLabel(name)) {\n            isAnimationProp = true;\n            name = name.substring(1);\n        }\n        if (isAnimationProp) {\n            this._parseAnimation(name, expression, sourceSpan, targetMatchableAttrs, targetProps);\n        }\n        else {\n            this._parsePropertyAst(name, this._parseBinding(expression, isHost, sourceSpan), sourceSpan, targetMatchableAttrs, targetProps);\n        }\n    };\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetProps\n     * @return {?}\n     */\n    BindingParser.prototype.parsePropertyInterpolation = function (name, value, sourceSpan, targetMatchableAttrs, targetProps) {\n        var /** @type {?} */ expr = this.parseInterpolation(value, sourceSpan);\n        if (expr) {\n            this._parsePropertyAst(name, expr, sourceSpan, targetMatchableAttrs, targetProps);\n            return true;\n        }\n        return false;\n    };\n    /**\n     * @param {?} name\n     * @param {?} ast\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetProps\n     * @return {?}\n     */\n    BindingParser.prototype._parsePropertyAst = function (name, ast, sourceSpan, targetMatchableAttrs, targetProps) {\n        targetMatchableAttrs.push([name, /** @type {?} */ ((ast.source))]);\n        targetProps.push(new BoundProperty(name, ast, BoundPropertyType.DEFAULT, sourceSpan));\n    };\n    /**\n     * @param {?} name\n     * @param {?} expression\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetProps\n     * @return {?}\n     */\n    BindingParser.prototype._parseAnimation = function (name, expression, sourceSpan, targetMatchableAttrs, targetProps) {\n        // This will occur when a @trigger is not paired with an expression.\n        // For animations it is valid to not have an expression since */void\n        // states will be applied by angular when the element is attached/detached\n        var /** @type {?} */ ast = this._parseBinding(expression || 'null', false, sourceSpan);\n        targetMatchableAttrs.push([name, /** @type {?} */ ((ast.source))]);\n        targetProps.push(new BoundProperty(name, ast, BoundPropertyType.ANIMATION, sourceSpan));\n    };\n    /**\n     * @param {?} value\n     * @param {?} isHostBinding\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    BindingParser.prototype._parseBinding = function (value, isHostBinding, sourceSpan) {\n        var /** @type {?} */ sourceInfo = sourceSpan.start.toString();\n        try {\n            var /** @type {?} */ ast = isHostBinding ?\n                this._exprParser.parseSimpleBinding(value, sourceInfo, this._interpolationConfig) :\n                this._exprParser.parseBinding(value, sourceInfo, this._interpolationConfig);\n            if (ast)\n                this._reportExpressionParserErrors(ast.errors, sourceSpan);\n            this._checkPipes(ast, sourceSpan);\n            return ast;\n        }\n        catch (e) {\n            this._reportError(\"\" + e, sourceSpan);\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n        }\n    };\n    /**\n     * @param {?} elementSelector\n     * @param {?} boundProp\n     * @return {?}\n     */\n    BindingParser.prototype.createElementPropertyAst = function (elementSelector, boundProp) {\n        if (boundProp.isAnimation) {\n            return new BoundElementPropertyAst(boundProp.name, PropertyBindingType.Animation, __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SecurityContext\"].NONE, boundProp.expression, null, boundProp.sourceSpan);\n        }\n        var /** @type {?} */ unit = null;\n        var /** @type {?} */ bindingType = ((undefined));\n        var /** @type {?} */ boundPropertyName = null;\n        var /** @type {?} */ parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);\n        var /** @type {?} */ securityContexts = ((undefined));\n        // Check check for special cases (prefix style, attr, class)\n        if (parts.length > 1) {\n            if (parts[0] == ATTRIBUTE_PREFIX) {\n                boundPropertyName = parts[1];\n                this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);\n                securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, true);\n                var /** @type {?} */ nsSeparatorIdx = boundPropertyName.indexOf(':');\n                if (nsSeparatorIdx > -1) {\n                    var /** @type {?} */ ns = boundPropertyName.substring(0, nsSeparatorIdx);\n                    var /** @type {?} */ name = boundPropertyName.substring(nsSeparatorIdx + 1);\n                    boundPropertyName = mergeNsAndName(ns, name);\n                }\n                bindingType = PropertyBindingType.Attribute;\n            }\n            else if (parts[0] == CLASS_PREFIX) {\n                boundPropertyName = parts[1];\n                bindingType = PropertyBindingType.Class;\n                securityContexts = [__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SecurityContext\"].NONE];\n            }\n            else if (parts[0] == STYLE_PREFIX) {\n                unit = parts.length > 2 ? parts[2] : null;\n                boundPropertyName = parts[1];\n                bindingType = PropertyBindingType.Style;\n                securityContexts = [__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SecurityContext\"].STYLE];\n            }\n        }\n        // If not a special case, use the full property name\n        if (boundPropertyName === null) {\n            boundPropertyName = this._schemaRegistry.getMappedPropName(boundProp.name);\n            securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, false);\n            bindingType = PropertyBindingType.Property;\n            this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, false);\n        }\n        return new BoundElementPropertyAst(boundPropertyName, bindingType, securityContexts[0], boundProp.expression, unit, boundProp.sourceSpan);\n    };\n    /**\n     * @param {?} name\n     * @param {?} expression\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetEvents\n     * @return {?}\n     */\n    BindingParser.prototype.parseEvent = function (name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {\n        if (_isAnimationLabel(name)) {\n            name = name.substr(1);\n            this._parseAnimationEvent(name, expression, sourceSpan, targetEvents);\n        }\n        else {\n            this._parseEvent(name, expression, sourceSpan, targetMatchableAttrs, targetEvents);\n        }\n    };\n    /**\n     * @param {?} name\n     * @param {?} expression\n     * @param {?} sourceSpan\n     * @param {?} targetEvents\n     * @return {?}\n     */\n    BindingParser.prototype._parseAnimationEvent = function (name, expression, sourceSpan, targetEvents) {\n        var /** @type {?} */ matches = splitAtPeriod(name, [name, '']);\n        var /** @type {?} */ eventName = matches[0];\n        var /** @type {?} */ phase = matches[1].toLowerCase();\n        if (phase) {\n            switch (phase) {\n                case 'start':\n                case 'done':\n                    var /** @type {?} */ ast = this._parseAction(expression, sourceSpan);\n                    targetEvents.push(new BoundEventAst(eventName, null, phase, ast, sourceSpan));\n                    break;\n                default:\n                    this._reportError(\"The provided animation output phase value \\\"\" + phase + \"\\\" for \\\"@\" + eventName + \"\\\" is not supported (use start or done)\", sourceSpan);\n                    break;\n            }\n        }\n        else {\n            this._reportError(\"The animation trigger output event (@\" + eventName + \") is missing its phase value name (start or done are currently supported)\", sourceSpan);\n        }\n    };\n    /**\n     * @param {?} name\n     * @param {?} expression\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetEvents\n     * @return {?}\n     */\n    BindingParser.prototype._parseEvent = function (name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {\n        // long format: 'target: eventName'\n        var _a = splitAtColon(name, [/** @type {?} */ ((null)), name]), target = _a[0], eventName = _a[1];\n        var /** @type {?} */ ast = this._parseAction(expression, sourceSpan);\n        targetMatchableAttrs.push([/** @type {?} */ ((name)), /** @type {?} */ ((ast.source))]);\n        targetEvents.push(new BoundEventAst(eventName, target, null, ast, sourceSpan));\n        // Don't detect directives for event names for now,\n        // so don't add the event name to the matchableAttrs\n    };\n    /**\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    BindingParser.prototype._parseAction = function (value, sourceSpan) {\n        var /** @type {?} */ sourceInfo = sourceSpan.start.toString();\n        try {\n            var /** @type {?} */ ast = this._exprParser.parseAction(value, sourceInfo, this._interpolationConfig);\n            if (ast) {\n                this._reportExpressionParserErrors(ast.errors, sourceSpan);\n            }\n            if (!ast || ast.ast instanceof EmptyExpr) {\n                this._reportError(\"Empty expressions are not allowed\", sourceSpan);\n                return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n            }\n            this._checkPipes(ast, sourceSpan);\n            return ast;\n        }\n        catch (e) {\n            this._reportError(\"\" + e, sourceSpan);\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n        }\n    };\n    /**\n     * @param {?} message\n     * @param {?} sourceSpan\n     * @param {?=} level\n     * @return {?}\n     */\n    BindingParser.prototype._reportError = function (message, sourceSpan, level) {\n        if (level === void 0) { level = ParseErrorLevel.ERROR; }\n        this._targetErrors.push(new ParseError(sourceSpan, message, level));\n    };\n    /**\n     * @param {?} errors\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    BindingParser.prototype._reportExpressionParserErrors = function (errors, sourceSpan) {\n        for (var _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {\n            var error = errors_1[_i];\n            this._reportError(error.message, sourceSpan);\n        }\n    };\n    /**\n     * @param {?} ast\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    BindingParser.prototype._checkPipes = function (ast, sourceSpan) {\n        var _this = this;\n        if (ast) {\n            var /** @type {?} */ collector = new PipeCollector();\n            ast.visit(collector);\n            collector.pipes.forEach(function (ast, pipeName) {\n                var /** @type {?} */ pipeMeta = _this.pipesByName.get(pipeName);\n                if (!pipeMeta) {\n                    _this._reportError(\"The pipe '\" + pipeName + \"' could not be found\", new ParseSourceSpan(sourceSpan.start.moveBy(ast.span.start), sourceSpan.start.moveBy(ast.span.end)));\n                }\n                else {\n                    _this._usedPipes.set(pipeName, pipeMeta);\n                }\n            });\n        }\n    };\n    /**\n     * @param {?} propName the name of the property / attribute\n     * @param {?} sourceSpan\n     * @param {?} isAttr true when binding to an attribute\n     * @return {?}\n     */\n    BindingParser.prototype._validatePropertyOrAttributeName = function (propName, sourceSpan, isAttr) {\n        var /** @type {?} */ report = isAttr ? this._schemaRegistry.validateAttribute(propName) :\n            this._schemaRegistry.validateProperty(propName);\n        if (report.error) {\n            this._reportError(/** @type {?} */ ((report.msg)), sourceSpan, ParseErrorLevel.ERROR);\n        }\n    };\n    return BindingParser;\n}());\nvar PipeCollector = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](PipeCollector, _super);\n    function PipeCollector() {\n        var _this = _super.apply(this, arguments) || this;\n        _this.pipes = new Map();\n        return _this;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    PipeCollector.prototype.visitPipe = function (ast, context) {\n        this.pipes.set(ast.name, ast);\n        ast.exp.visit(this);\n        this.visitAll(ast.args, context);\n        return null;\n    };\n    return PipeCollector;\n}(RecursiveAstVisitor));\n/**\n * @param {?} name\n * @return {?}\n */\nfunction _isAnimationLabel(name) {\n    return name[0] == '@';\n}\n/**\n * @param {?} registry\n * @param {?} selector\n * @param {?} propName\n * @param {?} isAttribute\n * @return {?}\n */\nfunction calcPossibleSecurityContexts(registry, selector, propName, isAttribute) {\n    var /** @type {?} */ ctxs = [];\n    CssSelector.parse(selector).forEach(function (selector) {\n        var /** @type {?} */ elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();\n        var /** @type {?} */ notElementNames = new Set(selector.notSelectors.filter(function (selector) { return selector.isElementSelector(); })\n            .map(function (selector) { return selector.element; }));\n        var /** @type {?} */ possibleElementNames = elementNames.filter(function (elementName) { return !notElementNames.has(elementName); });\n        ctxs.push.apply(ctxs, possibleElementNames.map(function (elementName) { return registry.securityContext(elementName, propName, isAttribute); }));\n    });\n    return ctxs.length === 0 ? [__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SecurityContext\"].NONE] : Array.from(new Set(ctxs)).sort();\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar NG_CONTENT_SELECT_ATTR = 'select';\nvar LINK_ELEMENT = 'link';\nvar LINK_STYLE_REL_ATTR = 'rel';\nvar LINK_STYLE_HREF_ATTR = 'href';\nvar LINK_STYLE_REL_VALUE = 'stylesheet';\nvar STYLE_ELEMENT = 'style';\nvar SCRIPT_ELEMENT = 'script';\nvar NG_NON_BINDABLE_ATTR = 'ngNonBindable';\nvar NG_PROJECT_AS = 'ngProjectAs';\n/**\n * @param {?} ast\n * @return {?}\n */\nfunction preparseElement(ast) {\n    var /** @type {?} */ selectAttr = ((null));\n    var /** @type {?} */ hrefAttr = ((null));\n    var /** @type {?} */ relAttr = ((null));\n    var /** @type {?} */ nonBindable = false;\n    var /** @type {?} */ projectAs = ((null));\n    ast.attrs.forEach(function (attr) {\n        var /** @type {?} */ lcAttrName = attr.name.toLowerCase();\n        if (lcAttrName == NG_CONTENT_SELECT_ATTR) {\n            selectAttr = attr.value;\n        }\n        else if (lcAttrName == LINK_STYLE_HREF_ATTR) {\n            hrefAttr = attr.value;\n        }\n        else if (lcAttrName == LINK_STYLE_REL_ATTR) {\n            relAttr = attr.value;\n        }\n        else if (attr.name == NG_NON_BINDABLE_ATTR) {\n            nonBindable = true;\n        }\n        else if (attr.name == NG_PROJECT_AS) {\n            if (attr.value.length > 0) {\n                projectAs = attr.value;\n            }\n        }\n    });\n    selectAttr = normalizeNgContentSelect(selectAttr);\n    var /** @type {?} */ nodeName = ast.name.toLowerCase();\n    var /** @type {?} */ type = PreparsedElementType.OTHER;\n    if (isNgContent(nodeName)) {\n        type = PreparsedElementType.NG_CONTENT;\n    }\n    else if (nodeName == STYLE_ELEMENT) {\n        type = PreparsedElementType.STYLE;\n    }\n    else if (nodeName == SCRIPT_ELEMENT) {\n        type = PreparsedElementType.SCRIPT;\n    }\n    else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {\n        type = PreparsedElementType.STYLESHEET;\n    }\n    return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);\n}\nvar PreparsedElementType = {};\nPreparsedElementType.NG_CONTENT = 0;\nPreparsedElementType.STYLE = 1;\nPreparsedElementType.STYLESHEET = 2;\nPreparsedElementType.SCRIPT = 3;\nPreparsedElementType.OTHER = 4;\nPreparsedElementType[PreparsedElementType.NG_CONTENT] = \"NG_CONTENT\";\nPreparsedElementType[PreparsedElementType.STYLE] = \"STYLE\";\nPreparsedElementType[PreparsedElementType.STYLESHEET] = \"STYLESHEET\";\nPreparsedElementType[PreparsedElementType.SCRIPT] = \"SCRIPT\";\nPreparsedElementType[PreparsedElementType.OTHER] = \"OTHER\";\nvar PreparsedElement = (function () {\n    /**\n     * @param {?} type\n     * @param {?} selectAttr\n     * @param {?} hrefAttr\n     * @param {?} nonBindable\n     * @param {?} projectAs\n     */\n    function PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs) {\n        this.type = type;\n        this.selectAttr = selectAttr;\n        this.hrefAttr = hrefAttr;\n        this.nonBindable = nonBindable;\n        this.projectAs = projectAs;\n    }\n    return PreparsedElement;\n}());\n/**\n * @param {?} selectAttr\n * @return {?}\n */\nfunction normalizeNgContentSelect(selectAttr) {\n    if (selectAttr === null || selectAttr.length === 0) {\n        return '*';\n    }\n    return selectAttr;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar BIND_NAME_REGEXP = /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.+))|\\[\\(([^\\)]+)\\)\\]|\\[([^\\]]+)\\]|\\(([^\\)]+)\\))$/;\n// Group 1 = \"bind-\"\nvar KW_BIND_IDX = 1;\n// Group 2 = \"let-\"\nvar KW_LET_IDX = 2;\n// Group 3 = \"ref-/#\"\nvar KW_REF_IDX = 3;\n// Group 4 = \"on-\"\nvar KW_ON_IDX = 4;\n// Group 5 = \"bindon-\"\nvar KW_BINDON_IDX = 5;\n// Group 6 = \"@\"\nvar KW_AT_IDX = 6;\n// Group 7 = the identifier after \"bind-\", \"let-\", \"ref-/#\", \"on-\", \"bindon-\" or \"@\"\nvar IDENT_KW_IDX = 7;\n// Group 8 = identifier inside [()]\nvar IDENT_BANANA_BOX_IDX = 8;\n// Group 9 = identifier inside []\nvar IDENT_PROPERTY_IDX = 9;\n// Group 10 = identifier inside ()\nvar IDENT_EVENT_IDX = 10;\n// deprecated in 4.x\nvar TEMPLATE_ELEMENT = 'template';\n// deprecated in 4.x\nvar TEMPLATE_ATTR = 'template';\nvar TEMPLATE_ATTR_PREFIX = '*';\nvar CLASS_ATTR = 'class';\nvar TEXT_CSS_SELECTOR = CssSelector.parse('*')[0];\nvar TEMPLATE_ELEMENT_DEPRECATION_WARNING = 'The <template> element is deprecated. Use <ng-template> instead';\nvar TEMPLATE_ATTR_DEPRECATION_WARNING = 'The template attribute is deprecated. Use an ng-template element instead.';\nvar warningCounts = {};\n/**\n * @param {?} warnings\n * @return {?}\n */\nfunction warnOnlyOnce(warnings) {\n    return function (error) {\n        if (warnings.indexOf(error.msg) !== -1) {\n            warningCounts[error.msg] = (warningCounts[error.msg] || 0) + 1;\n            return warningCounts[error.msg] <= 1;\n        }\n        return true;\n    };\n}\n/**\n * Provides an array of {\\@link TemplateAstVisitor}s which will be used to transform\n * parsed templates before compilation is invoked, allowing custom expression syntax\n * and other advanced transformations.\n *\n * This is currently an internal-only feature and not meant for general use.\n */\nvar TEMPLATE_TRANSFORMS = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"InjectionToken\"]('TemplateTransforms');\nvar TemplateParseError = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](TemplateParseError, _super);\n    /**\n     * @param {?} message\n     * @param {?} span\n     * @param {?} level\n     */\n    function TemplateParseError(message, span, level) {\n        return _super.call(this, span, message, level) || this;\n    }\n    return TemplateParseError;\n}(ParseError));\nvar TemplateParseResult = (function () {\n    /**\n     * @param {?=} templateAst\n     * @param {?=} usedPipes\n     * @param {?=} errors\n     */\n    function TemplateParseResult(templateAst, usedPipes, errors) {\n        this.templateAst = templateAst;\n        this.usedPipes = usedPipes;\n        this.errors = errors;\n    }\n    return TemplateParseResult;\n}());\nvar TemplateParser = (function () {\n    /**\n     * @param {?} _config\n     * @param {?} _reflector\n     * @param {?} _exprParser\n     * @param {?} _schemaRegistry\n     * @param {?} _htmlParser\n     * @param {?} _console\n     * @param {?} transforms\n     */\n    function TemplateParser(_config, _reflector, _exprParser, _schemaRegistry, _htmlParser, _console, transforms) {\n        this._config = _config;\n        this._reflector = _reflector;\n        this._exprParser = _exprParser;\n        this._schemaRegistry = _schemaRegistry;\n        this._htmlParser = _htmlParser;\n        this._console = _console;\n        this.transforms = transforms;\n    }\n    /**\n     * @param {?} component\n     * @param {?} template\n     * @param {?} directives\n     * @param {?} pipes\n     * @param {?} schemas\n     * @param {?} templateUrl\n     * @return {?}\n     */\n    TemplateParser.prototype.parse = function (component, template, directives, pipes, schemas, templateUrl) {\n        var /** @type {?} */ result = this.tryParse(component, template, directives, pipes, schemas, templateUrl);\n        var /** @type {?} */ warnings = ((result.errors)).filter(function (error) { return error.level === ParseErrorLevel.WARNING; })\n            .filter(warnOnlyOnce([TEMPLATE_ATTR_DEPRECATION_WARNING, TEMPLATE_ELEMENT_DEPRECATION_WARNING]));\n        var /** @type {?} */ errors = ((result.errors)).filter(function (error) { return error.level === ParseErrorLevel.ERROR; });\n        if (warnings.length > 0) {\n            this._console.warn(\"Template parse warnings:\\n\" + warnings.join('\\n'));\n        }\n        if (errors.length > 0) {\n            var /** @type {?} */ errorString = errors.join('\\n');\n            throw syntaxError(\"Template parse errors:\\n\" + errorString, errors);\n        }\n        return { template: /** @type {?} */ ((result.templateAst)), pipes: /** @type {?} */ ((result.usedPipes)) };\n    };\n    /**\n     * @param {?} component\n     * @param {?} template\n     * @param {?} directives\n     * @param {?} pipes\n     * @param {?} schemas\n     * @param {?} templateUrl\n     * @return {?}\n     */\n    TemplateParser.prototype.tryParse = function (component, template, directives, pipes, schemas, templateUrl) {\n        return this.tryParseHtml(this.expandHtml(/** @type {?} */ ((this._htmlParser)).parse(template, templateUrl, true, this.getInterpolationConfig(component))), component, directives, pipes, schemas);\n    };\n    /**\n     * @param {?} htmlAstWithErrors\n     * @param {?} component\n     * @param {?} directives\n     * @param {?} pipes\n     * @param {?} schemas\n     * @return {?}\n     */\n    TemplateParser.prototype.tryParseHtml = function (htmlAstWithErrors, component, directives, pipes, schemas) {\n        var /** @type {?} */ result;\n        var /** @type {?} */ errors = htmlAstWithErrors.errors;\n        var /** @type {?} */ usedPipes = [];\n        if (htmlAstWithErrors.rootNodes.length > 0) {\n            var /** @type {?} */ uniqDirectives = removeSummaryDuplicates(directives);\n            var /** @type {?} */ uniqPipes = removeSummaryDuplicates(pipes);\n            var /** @type {?} */ providerViewContext = new ProviderViewContext(this._reflector, component);\n            var /** @type {?} */ interpolationConfig = ((undefined));\n            if (component.template && component.template.interpolation) {\n                interpolationConfig = {\n                    start: component.template.interpolation[0],\n                    end: component.template.interpolation[1]\n                };\n            }\n            var /** @type {?} */ bindingParser = new BindingParser(this._exprParser, /** @type {?} */ ((interpolationConfig)), this._schemaRegistry, uniqPipes, errors);\n            var /** @type {?} */ parseVisitor = new TemplateParseVisitor(this._reflector, this._config, providerViewContext, uniqDirectives, bindingParser, this._schemaRegistry, schemas, errors);\n            result = visitAll(parseVisitor, htmlAstWithErrors.rootNodes, EMPTY_ELEMENT_CONTEXT);\n            errors.push.apply(errors, providerViewContext.errors);\n            usedPipes.push.apply(usedPipes, bindingParser.getUsedPipes());\n        }\n        else {\n            result = [];\n        }\n        this._assertNoReferenceDuplicationOnTemplate(result, errors);\n        if (errors.length > 0) {\n            return new TemplateParseResult(result, usedPipes, errors);\n        }\n        if (this.transforms) {\n            this.transforms.forEach(function (transform) { result = templateVisitAll(transform, result); });\n        }\n        return new TemplateParseResult(result, usedPipes, errors);\n    };\n    /**\n     * @param {?} htmlAstWithErrors\n     * @param {?=} forced\n     * @return {?}\n     */\n    TemplateParser.prototype.expandHtml = function (htmlAstWithErrors, forced) {\n        if (forced === void 0) { forced = false; }\n        var /** @type {?} */ errors = htmlAstWithErrors.errors;\n        if (errors.length == 0 || forced) {\n            // Transform ICU messages to angular directives\n            var /** @type {?} */ expandedHtmlAst = expandNodes(htmlAstWithErrors.rootNodes);\n            errors.push.apply(errors, expandedHtmlAst.errors);\n            htmlAstWithErrors = new ParseTreeResult(expandedHtmlAst.nodes, errors);\n        }\n        return htmlAstWithErrors;\n    };\n    /**\n     * @param {?} component\n     * @return {?}\n     */\n    TemplateParser.prototype.getInterpolationConfig = function (component) {\n        if (component.template) {\n            return InterpolationConfig.fromArray(component.template.interpolation);\n        }\n        return undefined;\n    };\n    /**\n     * \\@internal\n     * @param {?} result\n     * @param {?} errors\n     * @return {?}\n     */\n    TemplateParser.prototype._assertNoReferenceDuplicationOnTemplate = function (result, errors) {\n        var /** @type {?} */ existingReferences = [];\n        result.filter(function (element) { return !!((element)).references; })\n            .forEach(function (element) { return ((element)).references.forEach(function (reference) {\n            var /** @type {?} */ name = reference.name;\n            if (existingReferences.indexOf(name) < 0) {\n                existingReferences.push(name);\n            }\n            else {\n                var /** @type {?} */ error = new TemplateParseError(\"Reference \\\"#\" + name + \"\\\" is defined several times\", reference.sourceSpan, ParseErrorLevel.ERROR);\n                errors.push(error);\n            }\n        }); });\n    };\n    return TemplateParser;\n}());\nTemplateParser.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nTemplateParser.ctorParameters = function () { return [\n    { type: CompilerConfig, },\n    { type: CompileReflector, },\n    { type: Parser, },\n    { type: ElementSchemaRegistry, },\n    { type: I18NHtmlParser, },\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Console\"], },\n    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [TEMPLATE_TRANSFORMS,] },] },\n]; };\nvar TemplateParseVisitor = (function () {\n    /**\n     * @param {?} reflector\n     * @param {?} config\n     * @param {?} providerViewContext\n     * @param {?} directives\n     * @param {?} _bindingParser\n     * @param {?} _schemaRegistry\n     * @param {?} _schemas\n     * @param {?} _targetErrors\n     */\n    function TemplateParseVisitor(reflector, config, providerViewContext, directives, _bindingParser, _schemaRegistry, _schemas, _targetErrors) {\n        var _this = this;\n        this.reflector = reflector;\n        this.config = config;\n        this.providerViewContext = providerViewContext;\n        this._bindingParser = _bindingParser;\n        this._schemaRegistry = _schemaRegistry;\n        this._schemas = _schemas;\n        this._targetErrors = _targetErrors;\n        this.selectorMatcher = new SelectorMatcher();\n        this.directivesIndex = new Map();\n        this.ngContentCount = 0;\n        // Note: queries start with id 1 so we can use the number in a Bloom filter!\n        this.contentQueryStartId = providerViewContext.component.viewQueries.length + 1;\n        directives.forEach(function (directive, index) {\n            var selector = CssSelector.parse(directive.selector);\n            _this.selectorMatcher.addSelectables(selector, directive);\n            _this.directivesIndex.set(directive, index);\n        });\n    }\n    /**\n     * @param {?} expansion\n     * @param {?} context\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype.visitExpansion = function (expansion, context) { return null; };\n    /**\n     * @param {?} expansionCase\n     * @param {?} context\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype.visitExpansionCase = function (expansionCase, context) { return null; };\n    /**\n     * @param {?} text\n     * @param {?} parent\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype.visitText = function (text, parent) {\n        var /** @type {?} */ ngContentIndex = ((parent.findNgContentIndex(TEXT_CSS_SELECTOR)));\n        var /** @type {?} */ expr = this._bindingParser.parseInterpolation(text.value, /** @type {?} */ ((text.sourceSpan)));\n        return expr ? new BoundTextAst(expr, ngContentIndex, /** @type {?} */ ((text.sourceSpan))) :\n            new TextAst(text.value, ngContentIndex, /** @type {?} */ ((text.sourceSpan)));\n    };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype.visitAttribute = function (attribute, context) {\n        return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);\n    };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype.visitComment = function (comment, context) { return null; };\n    /**\n     * @param {?} element\n     * @param {?} parent\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype.visitElement = function (element, parent) {\n        var _this = this;\n        var /** @type {?} */ queryStartIndex = this.contentQueryStartId;\n        var /** @type {?} */ nodeName = element.name;\n        var /** @type {?} */ preparsedElement = preparseElement(element);\n        if (preparsedElement.type === PreparsedElementType.SCRIPT ||\n            preparsedElement.type === PreparsedElementType.STYLE) {\n            // Skipping <script> for security reasons\n            // Skipping <style> as we already processed them\n            // in the StyleCompiler\n            return null;\n        }\n        if (preparsedElement.type === PreparsedElementType.STYLESHEET &&\n            isStyleUrlResolvable(preparsedElement.hrefAttr)) {\n            // Skipping stylesheets with either relative urls or package scheme as we already processed\n            // them in the StyleCompiler\n            return null;\n        }\n        var /** @type {?} */ matchableAttrs = [];\n        var /** @type {?} */ elementOrDirectiveProps = [];\n        var /** @type {?} */ elementOrDirectiveRefs = [];\n        var /** @type {?} */ elementVars = [];\n        var /** @type {?} */ events = [];\n        var /** @type {?} */ templateElementOrDirectiveProps = [];\n        var /** @type {?} */ templateMatchableAttrs = [];\n        var /** @type {?} */ templateElementVars = [];\n        var /** @type {?} */ hasInlineTemplates = false;\n        var /** @type {?} */ attrs = [];\n        var /** @type {?} */ isTemplateElement = isTemplate(element, this.config.enableLegacyTemplate, function (m, span) { return _this._reportError(m, span, ParseErrorLevel.WARNING); });\n        element.attrs.forEach(function (attr) {\n            var /** @type {?} */ hasBinding = _this._parseAttr(isTemplateElement, attr, matchableAttrs, elementOrDirectiveProps, events, elementOrDirectiveRefs, elementVars);\n            var /** @type {?} */ templateBindingsSource;\n            var /** @type {?} */ prefixToken;\n            var /** @type {?} */ normalizedName = _this._normalizeAttributeName(attr.name);\n            if (_this.config.enableLegacyTemplate && normalizedName == TEMPLATE_ATTR) {\n                _this._reportError(TEMPLATE_ATTR_DEPRECATION_WARNING, attr.sourceSpan, ParseErrorLevel.WARNING);\n                templateBindingsSource = attr.value;\n            }\n            else if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX)) {\n                templateBindingsSource = attr.value;\n                prefixToken = normalizedName.substring(TEMPLATE_ATTR_PREFIX.length) + ':';\n            }\n            var /** @type {?} */ hasTemplateBinding = templateBindingsSource != null;\n            if (hasTemplateBinding) {\n                if (hasInlineTemplates) {\n                    _this._reportError(\"Can't have multiple template bindings on one element. Use only one attribute named 'template' or prefixed with *\", attr.sourceSpan);\n                }\n                hasInlineTemplates = true;\n                _this._bindingParser.parseInlineTemplateBinding(/** @type {?} */ ((prefixToken)), /** @type {?} */ ((templateBindingsSource)), attr.sourceSpan, templateMatchableAttrs, templateElementOrDirectiveProps, templateElementVars);\n            }\n            if (!hasBinding && !hasTemplateBinding) {\n                // don't include the bindings as attributes as well in the AST\n                attrs.push(_this.visitAttribute(attr, null));\n                matchableAttrs.push([attr.name, attr.value]);\n            }\n        });\n        var /** @type {?} */ elementCssSelector = createElementCssSelector(nodeName, matchableAttrs);\n        var _a = this._parseDirectives(this.selectorMatcher, elementCssSelector), directiveMetas = _a.directives, matchElement = _a.matchElement;\n        var /** @type {?} */ references = [];\n        var /** @type {?} */ boundDirectivePropNames = new Set();\n        var /** @type {?} */ directiveAsts = this._createDirectiveAsts(isTemplateElement, element.name, directiveMetas, elementOrDirectiveProps, elementOrDirectiveRefs, /** @type {?} */ ((element.sourceSpan)), references, boundDirectivePropNames);\n        var /** @type {?} */ elementProps = this._createElementPropertyAsts(element.name, elementOrDirectiveProps, boundDirectivePropNames);\n        var /** @type {?} */ isViewRoot = parent.isTemplateElement || hasInlineTemplates;\n        var /** @type {?} */ providerContext = new ProviderElementContext(this.providerViewContext, /** @type {?} */ ((parent.providerContext)), isViewRoot, directiveAsts, attrs, references, isTemplateElement, queryStartIndex, /** @type {?} */ ((element.sourceSpan)));\n        var /** @type {?} */ children = visitAll(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children, ElementContext.create(isTemplateElement, directiveAsts, isTemplateElement ? ((parent.providerContext)) : providerContext));\n        providerContext.afterElement();\n        // Override the actual selector when the `ngProjectAs` attribute is provided\n        var /** @type {?} */ projectionSelector = preparsedElement.projectAs != null ?\n            CssSelector.parse(preparsedElement.projectAs)[0] :\n            elementCssSelector;\n        var /** @type {?} */ ngContentIndex = ((parent.findNgContentIndex(projectionSelector)));\n        var /** @type {?} */ parsedElement;\n        if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {\n            if (element.children && !element.children.every(_isEmptyTextNode)) {\n                this._reportError(\"<ng-content> element cannot have content.\", /** @type {?} */ ((element.sourceSpan)));\n            }\n            parsedElement = new NgContentAst(this.ngContentCount++, hasInlineTemplates ? ((null)) : ngContentIndex, /** @type {?} */ ((element.sourceSpan)));\n        }\n        else if (isTemplateElement) {\n            this._assertAllEventsPublishedByDirectives(directiveAsts, events);\n            this._assertNoComponentsNorElementBindingsOnTemplate(directiveAsts, elementProps, /** @type {?} */ ((element.sourceSpan)));\n            parsedElement = new EmbeddedTemplateAst(attrs, events, references, elementVars, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, providerContext.queryMatches, children, hasInlineTemplates ? ((null)) : ngContentIndex, /** @type {?} */ ((element.sourceSpan)));\n        }\n        else {\n            this._assertElementExists(matchElement, element);\n            this._assertOnlyOneComponent(directiveAsts, /** @type {?} */ ((element.sourceSpan)));\n            var /** @type {?} */ ngContentIndex_1 = hasInlineTemplates ? null : parent.findNgContentIndex(projectionSelector);\n            parsedElement = new ElementAst(nodeName, attrs, elementProps, events, references, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, providerContext.queryMatches, children, hasInlineTemplates ? null : ngContentIndex_1, element.sourceSpan, element.endSourceSpan || null);\n        }\n        if (hasInlineTemplates) {\n            var /** @type {?} */ templateQueryStartIndex = this.contentQueryStartId;\n            var /** @type {?} */ templateSelector = createElementCssSelector(TEMPLATE_ELEMENT, templateMatchableAttrs);\n            var templateDirectiveMetas = this._parseDirectives(this.selectorMatcher, templateSelector).directives;\n            var /** @type {?} */ templateBoundDirectivePropNames = new Set();\n            var /** @type {?} */ templateDirectiveAsts = this._createDirectiveAsts(true, element.name, templateDirectiveMetas, templateElementOrDirectiveProps, [], /** @type {?} */ ((element.sourceSpan)), [], templateBoundDirectivePropNames);\n            var /** @type {?} */ templateElementProps = this._createElementPropertyAsts(element.name, templateElementOrDirectiveProps, templateBoundDirectivePropNames);\n            this._assertNoComponentsNorElementBindingsOnTemplate(templateDirectiveAsts, templateElementProps, /** @type {?} */ ((element.sourceSpan)));\n            var /** @type {?} */ templateProviderContext = new ProviderElementContext(this.providerViewContext, /** @type {?} */ ((parent.providerContext)), parent.isTemplateElement, templateDirectiveAsts, [], [], true, templateQueryStartIndex, /** @type {?} */ ((element.sourceSpan)));\n            templateProviderContext.afterElement();\n            parsedElement = new EmbeddedTemplateAst([], [], [], templateElementVars, templateProviderContext.transformedDirectiveAsts, templateProviderContext.transformProviders, templateProviderContext.transformedHasViewContainer, templateProviderContext.queryMatches, [parsedElement], ngContentIndex, /** @type {?} */ ((element.sourceSpan)));\n        }\n        return parsedElement;\n    };\n    /**\n     * @param {?} isTemplateElement\n     * @param {?} attr\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetProps\n     * @param {?} targetEvents\n     * @param {?} targetRefs\n     * @param {?} targetVars\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._parseAttr = function (isTemplateElement, attr, targetMatchableAttrs, targetProps, targetEvents, targetRefs, targetVars) {\n        var /** @type {?} */ name = this._normalizeAttributeName(attr.name);\n        var /** @type {?} */ value = attr.value;\n        var /** @type {?} */ srcSpan = attr.sourceSpan;\n        var /** @type {?} */ bindParts = name.match(BIND_NAME_REGEXP);\n        var /** @type {?} */ hasBinding = false;\n        if (bindParts !== null) {\n            hasBinding = true;\n            if (bindParts[KW_BIND_IDX] != null) {\n                this._bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);\n            }\n            else if (bindParts[KW_LET_IDX]) {\n                if (isTemplateElement) {\n                    var /** @type {?} */ identifier = bindParts[IDENT_KW_IDX];\n                    this._parseVariable(identifier, value, srcSpan, targetVars);\n                }\n                else {\n                    this._reportError(\"\\\"let-\\\" is only supported on template elements.\", srcSpan);\n                }\n            }\n            else if (bindParts[KW_REF_IDX]) {\n                var /** @type {?} */ identifier = bindParts[IDENT_KW_IDX];\n                this._parseReference(identifier, value, srcSpan, targetRefs);\n            }\n            else if (bindParts[KW_ON_IDX]) {\n                this._bindingParser.parseEvent(bindParts[IDENT_KW_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);\n            }\n            else if (bindParts[KW_BINDON_IDX]) {\n                this._bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);\n                this._parseAssignmentEvent(bindParts[IDENT_KW_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);\n            }\n            else if (bindParts[KW_AT_IDX]) {\n                this._bindingParser.parseLiteralAttr(name, value, srcSpan, targetMatchableAttrs, targetProps);\n            }\n            else if (bindParts[IDENT_BANANA_BOX_IDX]) {\n                this._bindingParser.parsePropertyBinding(bindParts[IDENT_BANANA_BOX_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);\n                this._parseAssignmentEvent(bindParts[IDENT_BANANA_BOX_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);\n            }\n            else if (bindParts[IDENT_PROPERTY_IDX]) {\n                this._bindingParser.parsePropertyBinding(bindParts[IDENT_PROPERTY_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);\n            }\n            else if (bindParts[IDENT_EVENT_IDX]) {\n                this._bindingParser.parseEvent(bindParts[IDENT_EVENT_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);\n            }\n        }\n        else {\n            hasBinding = this._bindingParser.parsePropertyInterpolation(name, value, srcSpan, targetMatchableAttrs, targetProps);\n        }\n        if (!hasBinding) {\n            this._bindingParser.parseLiteralAttr(name, value, srcSpan, targetMatchableAttrs, targetProps);\n        }\n        return hasBinding;\n    };\n    /**\n     * @param {?} attrName\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._normalizeAttributeName = function (attrName) {\n        return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;\n    };\n    /**\n     * @param {?} identifier\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @param {?} targetVars\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._parseVariable = function (identifier, value, sourceSpan, targetVars) {\n        if (identifier.indexOf('-') > -1) {\n            this._reportError(\"\\\"-\\\" is not allowed in variable names\", sourceSpan);\n        }\n        targetVars.push(new VariableAst(identifier, value, sourceSpan));\n    };\n    /**\n     * @param {?} identifier\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @param {?} targetRefs\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._parseReference = function (identifier, value, sourceSpan, targetRefs) {\n        if (identifier.indexOf('-') > -1) {\n            this._reportError(\"\\\"-\\\" is not allowed in reference names\", sourceSpan);\n        }\n        targetRefs.push(new ElementOrDirectiveRef(identifier, value, sourceSpan));\n    };\n    /**\n     * @param {?} name\n     * @param {?} expression\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetEvents\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._parseAssignmentEvent = function (name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {\n        this._bindingParser.parseEvent(name + \"Change\", expression + \"=$event\", sourceSpan, targetMatchableAttrs, targetEvents);\n    };\n    /**\n     * @param {?} selectorMatcher\n     * @param {?} elementCssSelector\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._parseDirectives = function (selectorMatcher, elementCssSelector) {\n        var _this = this;\n        // Need to sort the directives so that we get consistent results throughout,\n        // as selectorMatcher uses Maps inside.\n        // Also deduplicate directives as they might match more than one time!\n        var /** @type {?} */ directives = new Array(this.directivesIndex.size);\n        // Whether any directive selector matches on the element name\n        var /** @type {?} */ matchElement = false;\n        selectorMatcher.match(elementCssSelector, function (selector, directive) {\n            directives[((_this.directivesIndex.get(directive)))] = directive;\n            matchElement = matchElement || selector.hasElementSelector();\n        });\n        return {\n            directives: directives.filter(function (dir) { return !!dir; }),\n            matchElement: matchElement,\n        };\n    };\n    /**\n     * @param {?} isTemplateElement\n     * @param {?} elementName\n     * @param {?} directives\n     * @param {?} props\n     * @param {?} elementOrDirectiveRefs\n     * @param {?} elementSourceSpan\n     * @param {?} targetReferences\n     * @param {?} targetBoundDirectivePropNames\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._createDirectiveAsts = function (isTemplateElement, elementName, directives, props, elementOrDirectiveRefs, elementSourceSpan, targetReferences, targetBoundDirectivePropNames) {\n        var _this = this;\n        var /** @type {?} */ matchedReferences = new Set();\n        var /** @type {?} */ component = ((null));\n        var /** @type {?} */ directiveAsts = directives.map(function (directive) {\n            var /** @type {?} */ sourceSpan = new ParseSourceSpan(elementSourceSpan.start, elementSourceSpan.end, \"Directive \" + identifierName(directive.type));\n            if (directive.isComponent) {\n                component = directive;\n            }\n            var /** @type {?} */ directiveProperties = [];\n            var /** @type {?} */ hostProperties = ((_this._bindingParser.createDirectiveHostPropertyAsts(directive, elementName, sourceSpan)));\n            // Note: We need to check the host properties here as well,\n            // as we don't know the element name in the DirectiveWrapperCompiler yet.\n            hostProperties = _this._checkPropertiesInSchema(elementName, hostProperties);\n            var /** @type {?} */ hostEvents = ((_this._bindingParser.createDirectiveHostEventAsts(directive, sourceSpan)));\n            _this._createDirectivePropertyAsts(directive.inputs, props, directiveProperties, targetBoundDirectivePropNames);\n            elementOrDirectiveRefs.forEach(function (elOrDirRef) {\n                if ((elOrDirRef.value.length === 0 && directive.isComponent) ||\n                    (directive.exportAs == elOrDirRef.value)) {\n                    targetReferences.push(new ReferenceAst(elOrDirRef.name, createTokenForReference(directive.type.reference), elOrDirRef.sourceSpan));\n                    matchedReferences.add(elOrDirRef.name);\n                }\n            });\n            var /** @type {?} */ contentQueryStartId = _this.contentQueryStartId;\n            _this.contentQueryStartId += directive.queries.length;\n            return new DirectiveAst(directive, directiveProperties, hostProperties, hostEvents, contentQueryStartId, sourceSpan);\n        });\n        elementOrDirectiveRefs.forEach(function (elOrDirRef) {\n            if (elOrDirRef.value.length > 0) {\n                if (!matchedReferences.has(elOrDirRef.name)) {\n                    _this._reportError(\"There is no directive with \\\"exportAs\\\" set to \\\"\" + elOrDirRef.value + \"\\\"\", elOrDirRef.sourceSpan);\n                }\n            }\n            else if (!component) {\n                var /** @type {?} */ refToken = ((null));\n                if (isTemplateElement) {\n                    refToken = createTokenForExternalReference(_this.reflector, Identifiers.TemplateRef);\n                }\n                targetReferences.push(new ReferenceAst(elOrDirRef.name, refToken, elOrDirRef.sourceSpan));\n            }\n        });\n        return directiveAsts;\n    };\n    /**\n     * @param {?} directiveProperties\n     * @param {?} boundProps\n     * @param {?} targetBoundDirectiveProps\n     * @param {?} targetBoundDirectivePropNames\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._createDirectivePropertyAsts = function (directiveProperties, boundProps, targetBoundDirectiveProps, targetBoundDirectivePropNames) {\n        if (directiveProperties) {\n            var /** @type {?} */ boundPropsByName_1 = new Map();\n            boundProps.forEach(function (boundProp) {\n                var /** @type {?} */ prevValue = boundPropsByName_1.get(boundProp.name);\n                if (!prevValue || prevValue.isLiteral) {\n                    // give [a]=\"b\" a higher precedence than a=\"b\" on the same element\n                    boundPropsByName_1.set(boundProp.name, boundProp);\n                }\n            });\n            Object.keys(directiveProperties).forEach(function (dirProp) {\n                var /** @type {?} */ elProp = directiveProperties[dirProp];\n                var /** @type {?} */ boundProp = boundPropsByName_1.get(elProp);\n                // Bindings are optional, so this binding only needs to be set up if an expression is given.\n                if (boundProp) {\n                    targetBoundDirectivePropNames.add(boundProp.name);\n                    if (!isEmptyExpression(boundProp.expression)) {\n                        targetBoundDirectiveProps.push(new BoundDirectivePropertyAst(dirProp, boundProp.name, boundProp.expression, boundProp.sourceSpan));\n                    }\n                }\n            });\n        }\n    };\n    /**\n     * @param {?} elementName\n     * @param {?} props\n     * @param {?} boundDirectivePropNames\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._createElementPropertyAsts = function (elementName, props, boundDirectivePropNames) {\n        var _this = this;\n        var /** @type {?} */ boundElementProps = [];\n        props.forEach(function (prop) {\n            if (!prop.isLiteral && !boundDirectivePropNames.has(prop.name)) {\n                boundElementProps.push(_this._bindingParser.createElementPropertyAst(elementName, prop));\n            }\n        });\n        return this._checkPropertiesInSchema(elementName, boundElementProps);\n    };\n    /**\n     * @param {?} directives\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._findComponentDirectives = function (directives) {\n        return directives.filter(function (directive) { return directive.directive.isComponent; });\n    };\n    /**\n     * @param {?} directives\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._findComponentDirectiveNames = function (directives) {\n        return this._findComponentDirectives(directives)\n            .map(function (directive) { return ((identifierName(directive.directive.type))); });\n    };\n    /**\n     * @param {?} directives\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._assertOnlyOneComponent = function (directives, sourceSpan) {\n        var /** @type {?} */ componentTypeNames = this._findComponentDirectiveNames(directives);\n        if (componentTypeNames.length > 1) {\n            this._reportError(\"More than one component matched on this element.\\n\" +\n                \"Make sure that only one component's selector can match a given element.\\n\" +\n                (\"Conflicting components: \" + componentTypeNames.join(',')), sourceSpan);\n        }\n    };\n    /**\n     * Make sure that non-angular tags conform to the schemas.\n     *\n     * Note: An element is considered an angular tag when at least one directive selector matches the\n     * tag name.\n     *\n     * @param {?} matchElement Whether any directive has matched on the tag name\n     * @param {?} element the html element\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._assertElementExists = function (matchElement, element) {\n        var /** @type {?} */ elName = element.name.replace(/^:xhtml:/, '');\n        if (!matchElement && !this._schemaRegistry.hasElement(elName, this._schemas)) {\n            var /** @type {?} */ errorMsg = \"'\" + elName + \"' is not a known element:\\n\";\n            errorMsg +=\n                \"1. If '\" + elName + \"' is an Angular component, then verify that it is part of this module.\\n\";\n            if (elName.indexOf('-') > -1) {\n                errorMsg +=\n                    \"2. If '\" + elName + \"' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.\";\n            }\n            else {\n                errorMsg +=\n                    \"2. To allow any element add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.\";\n            }\n            this._reportError(errorMsg, /** @type {?} */ ((element.sourceSpan)));\n        }\n    };\n    /**\n     * @param {?} directives\n     * @param {?} elementProps\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._assertNoComponentsNorElementBindingsOnTemplate = function (directives, elementProps, sourceSpan) {\n        var _this = this;\n        var /** @type {?} */ componentTypeNames = this._findComponentDirectiveNames(directives);\n        if (componentTypeNames.length > 0) {\n            this._reportError(\"Components on an embedded template: \" + componentTypeNames.join(','), sourceSpan);\n        }\n        elementProps.forEach(function (prop) {\n            _this._reportError(\"Property binding \" + prop.name + \" not used by any directive on an embedded template. Make sure that the property name is spelled correctly and all directives are listed in the \\\"@NgModule.declarations\\\".\", sourceSpan);\n        });\n    };\n    /**\n     * @param {?} directives\n     * @param {?} events\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._assertAllEventsPublishedByDirectives = function (directives, events) {\n        var _this = this;\n        var /** @type {?} */ allDirectiveEvents = new Set();\n        directives.forEach(function (directive) {\n            Object.keys(directive.directive.outputs).forEach(function (k) {\n                var /** @type {?} */ eventName = directive.directive.outputs[k];\n                allDirectiveEvents.add(eventName);\n            });\n        });\n        events.forEach(function (event) {\n            if (event.target != null || !allDirectiveEvents.has(event.name)) {\n                _this._reportError(\"Event binding \" + event.fullName + \" not emitted by any directive on an embedded template. Make sure that the event name is spelled correctly and all directives are listed in the \\\"@NgModule.declarations\\\".\", event.sourceSpan);\n            }\n        });\n    };\n    /**\n     * @param {?} elementName\n     * @param {?} boundProps\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._checkPropertiesInSchema = function (elementName, boundProps) {\n        var _this = this;\n        // Note: We can't filter out empty expressions before this method,\n        // as we still want to validate them!\n        return boundProps.filter(function (boundProp) {\n            if (boundProp.type === PropertyBindingType.Property &&\n                !_this._schemaRegistry.hasProperty(elementName, boundProp.name, _this._schemas)) {\n                var /** @type {?} */ errorMsg = \"Can't bind to '\" + boundProp.name + \"' since it isn't a known property of '\" + elementName + \"'.\";\n                if (elementName.startsWith('ng-')) {\n                    errorMsg +=\n                        \"\\n1. If '\" + boundProp.name + \"' is an Angular directive, then add 'CommonModule' to the '@NgModule.imports' of this component.\" +\n                            \"\\n2. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.\";\n                }\n                else if (elementName.indexOf('-') > -1) {\n                    errorMsg +=\n                        \"\\n1. If '\" + elementName + \"' is an Angular component and it has '\" + boundProp.name + \"' input, then verify that it is part of this module.\" +\n                            (\"\\n2. If '\" + elementName + \"' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.\") +\n                            \"\\n3. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.\";\n                }\n                _this._reportError(errorMsg, boundProp.sourceSpan);\n            }\n            return !isEmptyExpression(boundProp.value);\n        });\n    };\n    /**\n     * @param {?} message\n     * @param {?} sourceSpan\n     * @param {?=} level\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._reportError = function (message, sourceSpan, level) {\n        if (level === void 0) { level = ParseErrorLevel.ERROR; }\n        this._targetErrors.push(new ParseError(sourceSpan, message, level));\n    };\n    return TemplateParseVisitor;\n}());\nvar NonBindableVisitor = (function () {\n    function NonBindableVisitor() {\n    }\n    /**\n     * @param {?} ast\n     * @param {?} parent\n     * @return {?}\n     */\n    NonBindableVisitor.prototype.visitElement = function (ast, parent) {\n        var /** @type {?} */ preparsedElement = preparseElement(ast);\n        if (preparsedElement.type === PreparsedElementType.SCRIPT ||\n            preparsedElement.type === PreparsedElementType.STYLE ||\n            preparsedElement.type === PreparsedElementType.STYLESHEET) {\n            // Skipping <script> for security reasons\n            // Skipping <style> and stylesheets as we already processed them\n            // in the StyleCompiler\n            return null;\n        }\n        var /** @type {?} */ attrNameAndValues = ast.attrs.map(function (attr) { return [attr.name, attr.value]; });\n        var /** @type {?} */ selector = createElementCssSelector(ast.name, attrNameAndValues);\n        var /** @type {?} */ ngContentIndex = parent.findNgContentIndex(selector);\n        var /** @type {?} */ children = visitAll(this, ast.children, EMPTY_ELEMENT_CONTEXT);\n        return new ElementAst(ast.name, visitAll(this, ast.attrs), [], [], [], [], [], false, [], children, ngContentIndex, ast.sourceSpan, ast.endSourceSpan);\n    };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    NonBindableVisitor.prototype.visitComment = function (comment, context) { return null; };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    NonBindableVisitor.prototype.visitAttribute = function (attribute, context) {\n        return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);\n    };\n    /**\n     * @param {?} text\n     * @param {?} parent\n     * @return {?}\n     */\n    NonBindableVisitor.prototype.visitText = function (text, parent) {\n        var /** @type {?} */ ngContentIndex = ((parent.findNgContentIndex(TEXT_CSS_SELECTOR)));\n        return new TextAst(text.value, ngContentIndex, /** @type {?} */ ((text.sourceSpan)));\n    };\n    /**\n     * @param {?} expansion\n     * @param {?} context\n     * @return {?}\n     */\n    NonBindableVisitor.prototype.visitExpansion = function (expansion, context) { return expansion; };\n    /**\n     * @param {?} expansionCase\n     * @param {?} context\n     * @return {?}\n     */\n    NonBindableVisitor.prototype.visitExpansionCase = function (expansionCase, context) { return expansionCase; };\n    return NonBindableVisitor;\n}());\nvar ElementOrDirectiveRef = (function () {\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    function ElementOrDirectiveRef(name, value, sourceSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    return ElementOrDirectiveRef;\n}());\n/**\n * @param {?} classAttrValue\n * @return {?}\n */\nfunction splitClasses(classAttrValue) {\n    return classAttrValue.trim().split(/\\s+/g);\n}\nvar ElementContext = (function () {\n    /**\n     * @param {?} isTemplateElement\n     * @param {?} _ngContentIndexMatcher\n     * @param {?} _wildcardNgContentIndex\n     * @param {?} providerContext\n     */\n    function ElementContext(isTemplateElement, _ngContentIndexMatcher, _wildcardNgContentIndex, providerContext) {\n        this.isTemplateElement = isTemplateElement;\n        this._ngContentIndexMatcher = _ngContentIndexMatcher;\n        this._wildcardNgContentIndex = _wildcardNgContentIndex;\n        this.providerContext = providerContext;\n    }\n    /**\n     * @param {?} isTemplateElement\n     * @param {?} directives\n     * @param {?} providerContext\n     * @return {?}\n     */\n    ElementContext.create = function (isTemplateElement, directives, providerContext) {\n        var /** @type {?} */ matcher = new SelectorMatcher();\n        var /** @type {?} */ wildcardNgContentIndex = ((null));\n        var /** @type {?} */ component = directives.find(function (directive) { return directive.directive.isComponent; });\n        if (component) {\n            var /** @type {?} */ ngContentSelectors = ((component.directive.template)).ngContentSelectors;\n            for (var /** @type {?} */ i = 0; i < ngContentSelectors.length; i++) {\n                var /** @type {?} */ selector = ngContentSelectors[i];\n                if (selector === '*') {\n                    wildcardNgContentIndex = i;\n                }\n                else {\n                    matcher.addSelectables(CssSelector.parse(ngContentSelectors[i]), i);\n                }\n            }\n        }\n        return new ElementContext(isTemplateElement, matcher, wildcardNgContentIndex, providerContext);\n    };\n    /**\n     * @param {?} selector\n     * @return {?}\n     */\n    ElementContext.prototype.findNgContentIndex = function (selector) {\n        var /** @type {?} */ ngContentIndices = [];\n        this._ngContentIndexMatcher.match(selector, function (selector, ngContentIndex) { ngContentIndices.push(ngContentIndex); });\n        ngContentIndices.sort();\n        if (this._wildcardNgContentIndex != null) {\n            ngContentIndices.push(this._wildcardNgContentIndex);\n        }\n        return ngContentIndices.length > 0 ? ngContentIndices[0] : null;\n    };\n    return ElementContext;\n}());\n/**\n * @param {?} elementName\n * @param {?} attributes\n * @return {?}\n */\nfunction createElementCssSelector(elementName, attributes) {\n    var /** @type {?} */ cssSelector = new CssSelector();\n    var /** @type {?} */ elNameNoNs = splitNsName(elementName)[1];\n    cssSelector.setElement(elNameNoNs);\n    for (var /** @type {?} */ i = 0; i < attributes.length; i++) {\n        var /** @type {?} */ attrName = attributes[i][0];\n        var /** @type {?} */ attrNameNoNs = splitNsName(attrName)[1];\n        var /** @type {?} */ attrValue = attributes[i][1];\n        cssSelector.addAttribute(attrNameNoNs, attrValue);\n        if (attrName.toLowerCase() == CLASS_ATTR) {\n            var /** @type {?} */ classes = splitClasses(attrValue);\n            classes.forEach(function (className) { return cssSelector.addClassName(className); });\n        }\n    }\n    return cssSelector;\n}\nvar EMPTY_ELEMENT_CONTEXT = new ElementContext(true, new SelectorMatcher(), null, null);\nvar NON_BINDABLE_VISITOR = new NonBindableVisitor();\n/**\n * @param {?} node\n * @return {?}\n */\nfunction _isEmptyTextNode(node) {\n    return node instanceof Text && node.value.trim().length == 0;\n}\n/**\n * @template T\n * @param {?} items\n * @return {?}\n */\nfunction removeSummaryDuplicates(items) {\n    var /** @type {?} */ map = new Map();\n    items.forEach(function (item) {\n        if (!map.get(item.type.reference)) {\n            map.set(item.type.reference, item);\n        }\n    });\n    return Array.from(map.values());\n}\n/**\n * @param {?} ast\n * @return {?}\n */\nfunction isEmptyExpression(ast) {\n    if (ast instanceof ASTWithSource) {\n        ast = ast.ast;\n    }\n    return ast instanceof EmptyExpr;\n}\n/**\n * @param {?} el\n * @param {?} enableLegacyTemplate\n * @param {?} reportDeprecation\n * @return {?}\n */\nfunction isTemplate(el, enableLegacyTemplate, reportDeprecation) {\n    if (isNgTemplate(el.name))\n        return true;\n    var /** @type {?} */ tagNoNs = splitNsName(el.name)[1];\n    // `<template>` is HTML and case insensitive\n    if (tagNoNs.toLowerCase() === TEMPLATE_ELEMENT) {\n        if (enableLegacyTemplate && tagNoNs.toLowerCase() === TEMPLATE_ELEMENT) {\n            reportDeprecation(TEMPLATE_ELEMENT_DEPRECATION_WARNING, /** @type {?} */ ((el.sourceSpan)));\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * An interface for retrieving documents by URL that the compiler uses\n * to load templates.\n */\nvar ResourceLoader = (function () {\n    function ResourceLoader() {\n    }\n    /**\n     * @param {?} url\n     * @return {?}\n     */\n    ResourceLoader.prototype.get = function (url) { return ''; };\n    return ResourceLoader;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Create a {\\@link UrlResolver} with no package prefix.\n * @return {?}\n */\nfunction createUrlResolverWithoutPackagePrefix() {\n    return new UrlResolver();\n}\n/**\n * @return {?}\n */\nfunction createOfflineCompileUrlResolver() {\n    return new UrlResolver('.');\n}\n/**\n * A default provider for {\\@link PACKAGE_ROOT_URL} that maps to '/'.\n */\nvar DEFAULT_PACKAGE_URL_PROVIDER = {\n    provide: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"PACKAGE_ROOT_URL\"],\n    useValue: '/'\n};\n/**\n * Used by the {\\@link Compiler} when resolving HTML and CSS template URLs.\n *\n * This class can be overridden by the application developer to create custom behavior.\n *\n * See {\\@link Compiler}\n *\n * ## Example\n *\n * {\\@example compiler/ts/url_resolver/url_resolver.ts region='url_resolver'}\n *\n * \\@security When compiling templates at runtime, you must\n * ensure that the entire template comes from a trusted source.\n * Attacker-controlled data introduced by a template could expose your\n * application to XSS risks. For more detail, see the [Security Guide](http://g.co/ng/security).\n */\nvar UrlResolver = (function () {\n    /**\n     * @param {?=} _packagePrefix\n     */\n    function UrlResolver(_packagePrefix) {\n        if (_packagePrefix === void 0) { _packagePrefix = null; }\n        this._packagePrefix = _packagePrefix;\n    }\n    /**\n     * Resolves the `url` given the `baseUrl`:\n     * - when the `url` is null, the `baseUrl` is returned,\n     * - if `url` is relative ('path/to/here', './path/to/here'), the resolved url is a combination of\n     * `baseUrl` and `url`,\n     * - if `url` is absolute (it has a scheme: 'http://', 'https://' or start with '/'), the `url` is\n     * returned as is (ignoring the `baseUrl`)\n     * @param {?} baseUrl\n     * @param {?} url\n     * @return {?}\n     */\n    UrlResolver.prototype.resolve = function (baseUrl, url) {\n        var /** @type {?} */ resolvedUrl = url;\n        if (baseUrl != null && baseUrl.length > 0) {\n            resolvedUrl = _resolveUrl(baseUrl, resolvedUrl);\n        }\n        var /** @type {?} */ resolvedParts = _split(resolvedUrl);\n        var /** @type {?} */ prefix = this._packagePrefix;\n        if (prefix != null && resolvedParts != null &&\n            resolvedParts[_ComponentIndex.Scheme] == 'package') {\n            var /** @type {?} */ path = resolvedParts[_ComponentIndex.Path];\n            prefix = prefix.replace(/\\/+$/, '');\n            path = path.replace(/^\\/+/, '');\n            return prefix + \"/\" + path;\n        }\n        return resolvedUrl;\n    };\n    return UrlResolver;\n}());\nUrlResolver.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nUrlResolver.ctorParameters = function () { return [\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"PACKAGE_ROOT_URL\"],] },] },\n]; };\n/**\n * Extract the scheme of a URL.\n * @param {?} url\n * @return {?}\n */\nfunction getUrlScheme(url) {\n    var /** @type {?} */ match = _split(url);\n    return (match && match[_ComponentIndex.Scheme]) || '';\n}\n/**\n * Builds a URI string from already-encoded parts.\n *\n * No encoding is performed.  Any component may be omitted as either null or\n * undefined.\n *\n * @param {?=} opt_scheme The scheme such as 'http'.\n * @param {?=} opt_userInfo The user name before the '\\@'.\n * @param {?=} opt_domain The domain such as 'www.google.com', already\n *     URI-encoded.\n * @param {?=} opt_port The port number.\n * @param {?=} opt_path The path, already URI-encoded.  If it is not\n *     empty, it must begin with a slash.\n * @param {?=} opt_queryData The URI-encoded query data.\n * @param {?=} opt_fragment The URI-encoded fragment identifier.\n * @return {?} The fully combined URI.\n */\nfunction _buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {\n    var /** @type {?} */ out = [];\n    if (opt_scheme != null) {\n        out.push(opt_scheme + ':');\n    }\n    if (opt_domain != null) {\n        out.push('//');\n        if (opt_userInfo != null) {\n            out.push(opt_userInfo + '@');\n        }\n        out.push(opt_domain);\n        if (opt_port != null) {\n            out.push(':' + opt_port);\n        }\n    }\n    if (opt_path != null) {\n        out.push(opt_path);\n    }\n    if (opt_queryData != null) {\n        out.push('?' + opt_queryData);\n    }\n    if (opt_fragment != null) {\n        out.push('#' + opt_fragment);\n    }\n    return out.join('');\n}\n/**\n * A regular expression for breaking a URI into its component parts.\n *\n * {\\@link http://www.gbiv.com/protocols/uri/rfc/rfc3986.html#RFC2234} says\n * As the \"first-match-wins\" algorithm is identical to the \"greedy\"\n * disambiguation method used by POSIX regular expressions, it is natural and\n * commonplace to use a regular expression for parsing the potential five\n * components of a URI reference.\n *\n * The following line is the regular expression for breaking-down a\n * well-formed URI reference into its components.\n *\n * <pre>\n * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?\n *  12            3  4          5       6  7        8 9\n * </pre>\n *\n * The numbers in the second line above are only to assist readability; they\n * indicate the reference points for each subexpression (i.e., each paired\n * parenthesis). We refer to the value matched for subexpression <n> as $<n>.\n * For example, matching the above expression to\n * <pre>\n *     http://www.ics.uci.edu/pub/ietf/uri/#Related\n * </pre>\n * results in the following subexpression matches:\n * <pre>\n *    $1 = http:\n *    $2 = http\n *    $3 = //www.ics.uci.edu\n *    $4 = www.ics.uci.edu\n *    $5 = /pub/ietf/uri/\n *    $6 = <undefined>\n *    $7 = <undefined>\n *    $8 = #Related\n *    $9 = Related\n * </pre>\n * where <undefined> indicates that the component is not present, as is the\n * case for the query component in the above example. Therefore, we can\n * determine the value of the five components as\n * <pre>\n *    scheme    = $2\n *    authority = $4\n *    path      = $5\n *    query     = $7\n *    fragment  = $9\n * </pre>\n *\n * The regular expression has been modified slightly to expose the\n * userInfo, domain, and port separately from the authority.\n * The modified version yields\n * <pre>\n *    $1 = http              scheme\n *    $2 = <undefined>       userInfo -\\\n *    $3 = www.ics.uci.edu   domain     | authority\n *    $4 = <undefined>       port     -/\n *    $5 = /pub/ietf/uri/    path\n *    $6 = <undefined>       query without ?\n *    $7 = Related           fragment without #\n * </pre>\n * \\@internal\n */\nvar _splitRe = new RegExp('^' +\n    '(?:' +\n    '([^:/?#.]+)' +\n    // used by other URL parts such as :,\n    // ?, /, #, and .\n    ':)?' +\n    '(?://' +\n    '(?:([^/?#]*)@)?' +\n    '([\\\\w\\\\d\\\\-\\\\u0100-\\\\uffff.%]*)' +\n    // digits, dashes, dots, percent\n    // escapes, and unicode characters.\n    '(?::([0-9]+))?' +\n    ')?' +\n    '([^?#]+)?' +\n    '(?:\\\\?([^#]*))?' +\n    '(?:#(.*))?' +\n    '$');\nvar _ComponentIndex = {};\n_ComponentIndex.Scheme = 1;\n_ComponentIndex.UserInfo = 2;\n_ComponentIndex.Domain = 3;\n_ComponentIndex.Port = 4;\n_ComponentIndex.Path = 5;\n_ComponentIndex.QueryData = 6;\n_ComponentIndex.Fragment = 7;\n_ComponentIndex[_ComponentIndex.Scheme] = \"Scheme\";\n_ComponentIndex[_ComponentIndex.UserInfo] = \"UserInfo\";\n_ComponentIndex[_ComponentIndex.Domain] = \"Domain\";\n_ComponentIndex[_ComponentIndex.Port] = \"Port\";\n_ComponentIndex[_ComponentIndex.Path] = \"Path\";\n_ComponentIndex[_ComponentIndex.QueryData] = \"QueryData\";\n_ComponentIndex[_ComponentIndex.Fragment] = \"Fragment\";\n/**\n * Splits a URI into its component parts.\n *\n * Each component can be accessed via the component indices; for example:\n * <pre>\n * goog.uri.utils.split(someStr)[goog.uri.utils.CompontentIndex.QUERY_DATA];\n * </pre>\n *\n * @param {?} uri The URI string to examine.\n * @return {?} Each component still URI-encoded.\n *     Each component that is present will contain the encoded value, whereas\n *     components that are not present will be undefined or empty, depending\n *     on the browser's regular expression implementation.  Never null, since\n *     arbitrary strings may still look like path names.\n */\nfunction _split(uri) {\n    return ((uri.match(_splitRe)));\n}\n/**\n * Removes dot segments in given path component, as described in\n * RFC 3986, section 5.2.4.\n *\n * @param {?} path A non-empty path component.\n * @return {?} Path component with removed dot segments.\n */\nfunction _removeDotSegments(path) {\n    if (path == '/')\n        return '/';\n    var /** @type {?} */ leadingSlash = path[0] == '/' ? '/' : '';\n    var /** @type {?} */ trailingSlash = path[path.length - 1] === '/' ? '/' : '';\n    var /** @type {?} */ segments = path.split('/');\n    var /** @type {?} */ out = [];\n    var /** @type {?} */ up = 0;\n    for (var /** @type {?} */ pos = 0; pos < segments.length; pos++) {\n        var /** @type {?} */ segment = segments[pos];\n        switch (segment) {\n            case '':\n            case '.':\n                break;\n            case '..':\n                if (out.length > 0) {\n                    out.pop();\n                }\n                else {\n                    up++;\n                }\n                break;\n            default:\n                out.push(segment);\n        }\n    }\n    if (leadingSlash == '') {\n        while (up-- > 0) {\n            out.unshift('..');\n        }\n        if (out.length === 0)\n            out.push('.');\n    }\n    return leadingSlash + out.join('/') + trailingSlash;\n}\n/**\n * Takes an array of the parts from split and canonicalizes the path part\n * and then joins all the parts.\n * @param {?} parts\n * @return {?}\n */\nfunction _joinAndCanonicalizePath(parts) {\n    var /** @type {?} */ path = parts[_ComponentIndex.Path];\n    path = path == null ? '' : _removeDotSegments(path);\n    parts[_ComponentIndex.Path] = path;\n    return _buildFromEncodedParts(parts[_ComponentIndex.Scheme], parts[_ComponentIndex.UserInfo], parts[_ComponentIndex.Domain], parts[_ComponentIndex.Port], path, parts[_ComponentIndex.QueryData], parts[_ComponentIndex.Fragment]);\n}\n/**\n * Resolves a URL.\n * @param {?} base The URL acting as the base URL.\n * @param {?} url\n * @return {?}\n */\nfunction _resolveUrl(base, url) {\n    var /** @type {?} */ parts = _split(encodeURI(url));\n    var /** @type {?} */ baseParts = _split(base);\n    if (parts[_ComponentIndex.Scheme] != null) {\n        return _joinAndCanonicalizePath(parts);\n    }\n    else {\n        parts[_ComponentIndex.Scheme] = baseParts[_ComponentIndex.Scheme];\n    }\n    for (var /** @type {?} */ i = _ComponentIndex.Scheme; i <= _ComponentIndex.Port; i++) {\n        if (parts[i] == null) {\n            parts[i] = baseParts[i];\n        }\n    }\n    if (parts[_ComponentIndex.Path][0] == '/') {\n        return _joinAndCanonicalizePath(parts);\n    }\n    var /** @type {?} */ path = baseParts[_ComponentIndex.Path];\n    if (path == null)\n        path = '/';\n    var /** @type {?} */ index = path.lastIndexOf('/');\n    path = path.substring(0, index + 1) + parts[_ComponentIndex.Path];\n    parts[_ComponentIndex.Path] = path;\n    return _joinAndCanonicalizePath(parts);\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar DirectiveNormalizer = (function () {\n    /**\n     * @param {?} _resourceLoader\n     * @param {?} _urlResolver\n     * @param {?} _htmlParser\n     * @param {?} _config\n     */\n    function DirectiveNormalizer(_resourceLoader, _urlResolver, _htmlParser, _config) {\n        this._resourceLoader = _resourceLoader;\n        this._urlResolver = _urlResolver;\n        this._htmlParser = _htmlParser;\n        this._config = _config;\n        this._resourceLoaderCache = new Map();\n    }\n    /**\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype.clearCache = function () { this._resourceLoaderCache.clear(); };\n    /**\n     * @param {?} normalizedDirective\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype.clearCacheFor = function (normalizedDirective) {\n        var _this = this;\n        if (!normalizedDirective.isComponent) {\n            return;\n        }\n        var /** @type {?} */ template = ((normalizedDirective.template));\n        this._resourceLoaderCache.delete(/** @type {?} */ ((template.templateUrl)));\n        template.externalStylesheets.forEach(function (stylesheet) { _this._resourceLoaderCache.delete(/** @type {?} */ ((stylesheet.moduleUrl))); });\n    };\n    /**\n     * @param {?} url\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype._fetch = function (url) {\n        var /** @type {?} */ result = this._resourceLoaderCache.get(url);\n        if (!result) {\n            result = this._resourceLoader.get(url);\n            this._resourceLoaderCache.set(url, result);\n        }\n        return result;\n    };\n    /**\n     * @param {?} prenormData\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype.normalizeTemplate = function (prenormData) {\n        var _this = this;\n        if (isDefined(prenormData.template)) {\n            if (isDefined(prenormData.templateUrl)) {\n                throw syntaxError(\"'\" + Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"stringify\"])(prenormData.componentType) + \"' component cannot define both template and templateUrl\");\n            }\n            if (typeof prenormData.template !== 'string') {\n                throw syntaxError(\"The template specified for component \" + Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"stringify\"])(prenormData.componentType) + \" is not a string\");\n            }\n        }\n        else if (isDefined(prenormData.templateUrl)) {\n            if (typeof prenormData.templateUrl !== 'string') {\n                throw syntaxError(\"The templateUrl specified for component \" + Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"stringify\"])(prenormData.componentType) + \" is not a string\");\n            }\n        }\n        else {\n            throw syntaxError(\"No template specified for component \" + Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"stringify\"])(prenormData.componentType));\n        }\n        return SyncAsync.then(this.normalizeTemplateOnly(prenormData), function (result) { return _this.normalizeExternalStylesheets(result); });\n    };\n    /**\n     * @param {?} prenomData\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype.normalizeTemplateOnly = function (prenomData) {\n        var _this = this;\n        var /** @type {?} */ template;\n        var /** @type {?} */ templateUrl;\n        if (prenomData.template != null) {\n            template = prenomData.template;\n            templateUrl = prenomData.moduleUrl;\n        }\n        else {\n            templateUrl = this._urlResolver.resolve(prenomData.moduleUrl, /** @type {?} */ ((prenomData.templateUrl)));\n            template = this._fetch(templateUrl);\n        }\n        return SyncAsync.then(template, function (template) { return _this.normalizeLoadedTemplate(prenomData, template, templateUrl); });\n    };\n    /**\n     * @param {?} prenormData\n     * @param {?} template\n     * @param {?} templateAbsUrl\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype.normalizeLoadedTemplate = function (prenormData, template, templateAbsUrl) {\n        var /** @type {?} */ isInline = !!prenormData.template;\n        var /** @type {?} */ interpolationConfig = InterpolationConfig.fromArray(/** @type {?} */ ((prenormData.interpolation)));\n        var /** @type {?} */ rootNodesAndErrors = this._htmlParser.parse(template, templateSourceUrl({ reference: prenormData.ngModuleType }, { type: { reference: prenormData.componentType } }, { isInline: isInline, templateUrl: templateAbsUrl }), true, interpolationConfig);\n        if (rootNodesAndErrors.errors.length > 0) {\n            var /** @type {?} */ errorString = rootNodesAndErrors.errors.join('\\n');\n            throw syntaxError(\"Template parse errors:\\n\" + errorString);\n        }\n        var /** @type {?} */ templateMetadataStyles = this.normalizeStylesheet(new CompileStylesheetMetadata({\n            styles: prenormData.styles,\n            styleUrls: prenormData.styleUrls,\n            moduleUrl: prenormData.moduleUrl\n        }));\n        var /** @type {?} */ visitor = new TemplatePreparseVisitor();\n        visitAll(visitor, rootNodesAndErrors.rootNodes);\n        var /** @type {?} */ templateStyles = this.normalizeStylesheet(new CompileStylesheetMetadata({ styles: visitor.styles, styleUrls: visitor.styleUrls, moduleUrl: templateAbsUrl }));\n        var /** @type {?} */ encapsulation = prenormData.encapsulation;\n        if (encapsulation == null) {\n            encapsulation = this._config.defaultEncapsulation;\n        }\n        var /** @type {?} */ styles = templateMetadataStyles.styles.concat(templateStyles.styles);\n        var /** @type {?} */ styleUrls = templateMetadataStyles.styleUrls.concat(templateStyles.styleUrls);\n        if (encapsulation === __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].Emulated && styles.length === 0 &&\n            styleUrls.length === 0) {\n            encapsulation = __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None;\n        }\n        return new CompileTemplateMetadata({\n            encapsulation: encapsulation,\n            template: template,\n            templateUrl: templateAbsUrl, styles: styles, styleUrls: styleUrls,\n            ngContentSelectors: visitor.ngContentSelectors,\n            animations: prenormData.animations,\n            interpolation: prenormData.interpolation, isInline: isInline,\n            externalStylesheets: []\n        });\n    };\n    /**\n     * @param {?} templateMeta\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype.normalizeExternalStylesheets = function (templateMeta) {\n        return SyncAsync.then(this._loadMissingExternalStylesheets(templateMeta.styleUrls), function (externalStylesheets) { return new CompileTemplateMetadata({\n            encapsulation: templateMeta.encapsulation,\n            template: templateMeta.template,\n            templateUrl: templateMeta.templateUrl,\n            styles: templateMeta.styles,\n            styleUrls: templateMeta.styleUrls,\n            externalStylesheets: externalStylesheets,\n            ngContentSelectors: templateMeta.ngContentSelectors,\n            animations: templateMeta.animations,\n            interpolation: templateMeta.interpolation,\n            isInline: templateMeta.isInline,\n        }); });\n    };\n    /**\n     * @param {?} styleUrls\n     * @param {?=} loadedStylesheets\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype._loadMissingExternalStylesheets = function (styleUrls, loadedStylesheets) {\n        var _this = this;\n        if (loadedStylesheets === void 0) { loadedStylesheets = new Map(); }\n        return SyncAsync.then(SyncAsync.all(styleUrls.filter(function (styleUrl) { return !loadedStylesheets.has(styleUrl); })\n            .map(function (styleUrl) { return SyncAsync.then(_this._fetch(styleUrl), function (loadedStyle) {\n            var /** @type {?} */ stylesheet = _this.normalizeStylesheet(new CompileStylesheetMetadata({ styles: [loadedStyle], moduleUrl: styleUrl }));\n            loadedStylesheets.set(styleUrl, stylesheet);\n            return _this._loadMissingExternalStylesheets(stylesheet.styleUrls, loadedStylesheets);\n        }); })), function (_) { return Array.from(loadedStylesheets.values()); });\n    };\n    /**\n     * @param {?} stylesheet\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype.normalizeStylesheet = function (stylesheet) {\n        var _this = this;\n        var /** @type {?} */ moduleUrl = ((stylesheet.moduleUrl));\n        var /** @type {?} */ allStyleUrls = stylesheet.styleUrls.filter(isStyleUrlResolvable)\n            .map(function (url) { return _this._urlResolver.resolve(moduleUrl, url); });\n        var /** @type {?} */ allStyles = stylesheet.styles.map(function (style$$1) {\n            var /** @type {?} */ styleWithImports = extractStyleUrls(_this._urlResolver, moduleUrl, style$$1);\n            allStyleUrls.push.apply(allStyleUrls, styleWithImports.styleUrls);\n            return styleWithImports.style;\n        });\n        return new CompileStylesheetMetadata({ styles: allStyles, styleUrls: allStyleUrls, moduleUrl: moduleUrl });\n    };\n    return DirectiveNormalizer;\n}());\nDirectiveNormalizer.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nDirectiveNormalizer.ctorParameters = function () { return [\n    { type: ResourceLoader, },\n    { type: UrlResolver, },\n    { type: HtmlParser, },\n    { type: CompilerConfig, },\n]; };\nvar TemplatePreparseVisitor = (function () {\n    function TemplatePreparseVisitor() {\n        this.ngContentSelectors = [];\n        this.styles = [];\n        this.styleUrls = [];\n        this.ngNonBindableStackCount = 0;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    TemplatePreparseVisitor.prototype.visitElement = function (ast, context) {\n        var /** @type {?} */ preparsedElement = preparseElement(ast);\n        switch (preparsedElement.type) {\n            case PreparsedElementType.NG_CONTENT:\n                if (this.ngNonBindableStackCount === 0) {\n                    this.ngContentSelectors.push(preparsedElement.selectAttr);\n                }\n                break;\n            case PreparsedElementType.STYLE:\n                var /** @type {?} */ textContent_1 = '';\n                ast.children.forEach(function (child) {\n                    if (child instanceof Text) {\n                        textContent_1 += child.value;\n                    }\n                });\n                this.styles.push(textContent_1);\n                break;\n            case PreparsedElementType.STYLESHEET:\n                this.styleUrls.push(preparsedElement.hrefAttr);\n                break;\n            default:\n                break;\n        }\n        if (preparsedElement.nonBindable) {\n            this.ngNonBindableStackCount++;\n        }\n        visitAll(this, ast.children);\n        if (preparsedElement.nonBindable) {\n            this.ngNonBindableStackCount--;\n        }\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    TemplatePreparseVisitor.prototype.visitExpansion = function (ast, context) { visitAll(this, ast.cases); };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    TemplatePreparseVisitor.prototype.visitExpansionCase = function (ast, context) {\n        visitAll(this, ast.expression);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    TemplatePreparseVisitor.prototype.visitComment = function (ast, context) { return null; };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    TemplatePreparseVisitor.prototype.visitAttribute = function (ast, context) { return null; };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    TemplatePreparseVisitor.prototype.visitText = function (ast, context) { return null; };\n    return TemplatePreparseVisitor;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar DirectiveResolver = (function () {\n    /**\n     * @param {?} _reflector\n     */\n    function DirectiveResolver(_reflector) {\n        this._reflector = _reflector;\n    }\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    DirectiveResolver.prototype.isDirective = function (type) {\n        var /** @type {?} */ typeMetadata = this._reflector.annotations(Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"resolveForwardRef\"])(type));\n        return typeMetadata && typeMetadata.some(isDirectiveMetadata);\n    };\n    /**\n     * @param {?} type\n     * @param {?=} throwIfNotFound\n     * @return {?}\n     */\n    DirectiveResolver.prototype.resolve = function (type, throwIfNotFound) {\n        if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n        var /** @type {?} */ typeMetadata = this._reflector.annotations(Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"resolveForwardRef\"])(type));\n        if (typeMetadata) {\n            var /** @type {?} */ metadata = findLast(typeMetadata, isDirectiveMetadata);\n            if (metadata) {\n                var /** @type {?} */ propertyMetadata = this._reflector.propMetadata(type);\n                return this._mergeWithPropertyMetadata(metadata, propertyMetadata, type);\n            }\n        }\n        if (throwIfNotFound) {\n            throw new Error(\"No Directive annotation found on \" + Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"stringify\"])(type));\n        }\n        return null;\n    };\n    /**\n     * @param {?} dm\n     * @param {?} propertyMetadata\n     * @param {?} directiveType\n     * @return {?}\n     */\n    DirectiveResolver.prototype._mergeWithPropertyMetadata = function (dm, propertyMetadata, directiveType) {\n        var /** @type {?} */ inputs = [];\n        var /** @type {?} */ outputs = [];\n        var /** @type {?} */ host = {};\n        var /** @type {?} */ queries = {};\n        Object.keys(propertyMetadata).forEach(function (propName) {\n            var /** @type {?} */ input = findLast(propertyMetadata[propName], function (a) { return a instanceof __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"]; });\n            if (input) {\n                if (input.bindingPropertyName) {\n                    inputs.push(propName + \": \" + input.bindingPropertyName);\n                }\n                else {\n                    inputs.push(propName);\n                }\n            }\n            var /** @type {?} */ output = findLast(propertyMetadata[propName], function (a) { return a instanceof __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"]; });\n            if (output) {\n                if (output.bindingPropertyName) {\n                    outputs.push(propName + \": \" + output.bindingPropertyName);\n                }\n                else {\n                    outputs.push(propName);\n                }\n            }\n            var /** @type {?} */ hostBindings = propertyMetadata[propName].filter(function (a) { return a && a instanceof __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"HostBinding\"]; });\n            hostBindings.forEach(function (hostBinding) {\n                if (hostBinding.hostPropertyName) {\n                    var /** @type {?} */ startWith = hostBinding.hostPropertyName[0];\n                    if (startWith === '(') {\n                        throw new Error(\"@HostBinding can not bind to events. Use @HostListener instead.\");\n                    }\n                    else if (startWith === '[') {\n                        throw new Error(\"@HostBinding parameter should be a property name, 'class.<name>', or 'attr.<name>'.\");\n                    }\n                    host[\"[\" + hostBinding.hostPropertyName + \"]\"] = propName;\n                }\n                else {\n                    host[\"[\" + propName + \"]\"] = propName;\n                }\n            });\n            var /** @type {?} */ hostListeners = propertyMetadata[propName].filter(function (a) { return a && a instanceof __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"HostListener\"]; });\n            hostListeners.forEach(function (hostListener) {\n                var /** @type {?} */ args = hostListener.args || [];\n                host[\"(\" + hostListener.eventName + \")\"] = propName + \"(\" + args.join(',') + \")\";\n            });\n            var /** @type {?} */ query = findLast(propertyMetadata[propName], function (a) { return a instanceof __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Query\"]; });\n            if (query) {\n                queries[propName] = query;\n            }\n        });\n        return this._merge(dm, inputs, outputs, host, queries, directiveType);\n    };\n    /**\n     * @param {?} def\n     * @return {?}\n     */\n    DirectiveResolver.prototype._extractPublicName = function (def) { return splitAtColon(def, [/** @type {?} */ ((null)), def])[1].trim(); };\n    /**\n     * @param {?} bindings\n     * @return {?}\n     */\n    DirectiveResolver.prototype._dedupeBindings = function (bindings) {\n        var /** @type {?} */ names = new Set();\n        var /** @type {?} */ reversedResult = [];\n        // go last to first to allow later entries to overwrite previous entries\n        for (var /** @type {?} */ i = bindings.length - 1; i >= 0; i--) {\n            var /** @type {?} */ binding = bindings[i];\n            var /** @type {?} */ name = this._extractPublicName(binding);\n            if (!names.has(name)) {\n                names.add(name);\n                reversedResult.push(binding);\n            }\n        }\n        return reversedResult.reverse();\n    };\n    /**\n     * @param {?} directive\n     * @param {?} inputs\n     * @param {?} outputs\n     * @param {?} host\n     * @param {?} queries\n     * @param {?} directiveType\n     * @return {?}\n     */\n    DirectiveResolver.prototype._merge = function (directive, inputs, outputs, host, queries, directiveType) {\n        var /** @type {?} */ mergedInputs = this._dedupeBindings(directive.inputs ? directive.inputs.concat(inputs) : inputs);\n        var /** @type {?} */ mergedOutputs = this._dedupeBindings(directive.outputs ? directive.outputs.concat(outputs) : outputs);\n        var /** @type {?} */ mergedHost = directive.host ? Object.assign({}, directive.host, host) : host;\n        var /** @type {?} */ mergedQueries = directive.queries ? Object.assign({}, directive.queries, queries) : queries;\n        if (directive instanceof __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"]) {\n            return new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"]({\n                selector: directive.selector,\n                inputs: mergedInputs,\n                outputs: mergedOutputs,\n                host: mergedHost,\n                exportAs: directive.exportAs,\n                moduleId: directive.moduleId,\n                queries: mergedQueries,\n                changeDetection: directive.changeDetection,\n                providers: directive.providers,\n                viewProviders: directive.viewProviders,\n                entryComponents: directive.entryComponents,\n                template: directive.template,\n                templateUrl: directive.templateUrl,\n                styles: directive.styles,\n                styleUrls: directive.styleUrls,\n                encapsulation: directive.encapsulation,\n                animations: directive.animations,\n                interpolation: directive.interpolation\n            });\n        }\n        else {\n            return new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"]({\n                selector: directive.selector,\n                inputs: mergedInputs,\n                outputs: mergedOutputs,\n                host: mergedHost,\n                exportAs: directive.exportAs,\n                queries: mergedQueries,\n                providers: directive.providers\n            });\n        }\n    };\n    return DirectiveResolver;\n}());\nDirectiveResolver.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nDirectiveResolver.ctorParameters = function () { return [\n    { type: CompileReflector, },\n]; };\n/**\n * @param {?} type\n * @return {?}\n */\nfunction isDirectiveMetadata(type) {\n    return type instanceof __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"];\n}\n/**\n * @template T\n * @param {?} arr\n * @param {?} condition\n * @return {?}\n */\nfunction findLast(arr, condition) {\n    for (var /** @type {?} */ i = arr.length - 1; i >= 0; i--) {\n        if (condition(arr[i])) {\n            return arr[i];\n        }\n    }\n    return null;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar STRIP_SRC_FILE_SUFFIXES = /(\\.ts|\\.d\\.ts|\\.js|\\.jsx|\\.tsx)$/;\nvar GENERATED_FILE = /\\.ngfactory\\.|\\.ngsummary\\./;\nvar JIT_SUMMARY_FILE = /\\.ngsummary\\./;\nvar JIT_SUMMARY_NAME = /NgSummary$/;\n/**\n * @param {?} filePath\n * @param {?=} forceSourceFile\n * @return {?}\n */\nfunction ngfactoryFilePath(filePath, forceSourceFile) {\n    if (forceSourceFile === void 0) { forceSourceFile = false; }\n    var /** @type {?} */ urlWithSuffix = splitTypescriptSuffix(filePath, forceSourceFile);\n    return urlWithSuffix[0] + \".ngfactory\" + urlWithSuffix[1];\n}\n/**\n * @param {?} filePath\n * @return {?}\n */\nfunction stripGeneratedFileSuffix(filePath) {\n    return filePath.replace(GENERATED_FILE, '.');\n}\n/**\n * @param {?} filePath\n * @return {?}\n */\nfunction isGeneratedFile(filePath) {\n    return GENERATED_FILE.test(filePath);\n}\n/**\n * @param {?} path\n * @param {?=} forceSourceFile\n * @return {?}\n */\nfunction splitTypescriptSuffix(path, forceSourceFile) {\n    if (forceSourceFile === void 0) { forceSourceFile = false; }\n    if (path.endsWith('.d.ts')) {\n        return [path.slice(0, -5), forceSourceFile ? '.ts' : '.d.ts'];\n    }\n    var /** @type {?} */ lastDot = path.lastIndexOf('.');\n    if (lastDot !== -1) {\n        return [path.substring(0, lastDot), path.substring(lastDot)];\n    }\n    return [path, ''];\n}\n/**\n * @param {?} fileName\n * @return {?}\n */\nfunction summaryFileName(fileName) {\n    var /** @type {?} */ fileNameWithoutSuffix = fileName.replace(STRIP_SRC_FILE_SUFFIXES, '');\n    return fileNameWithoutSuffix + \".ngsummary.json\";\n}\n/**\n * @param {?} fileName\n * @param {?=} forceSourceFile\n * @return {?}\n */\nfunction summaryForJitFileName(fileName, forceSourceFile) {\n    if (forceSourceFile === void 0) { forceSourceFile = false; }\n    var /** @type {?} */ urlWithSuffix = splitTypescriptSuffix(stripGeneratedFileSuffix(fileName), forceSourceFile);\n    return urlWithSuffix[0] + \".ngsummary\" + urlWithSuffix[1];\n}\n/**\n * @param {?} filePath\n * @return {?}\n */\nfunction stripSummaryForJitFileSuffix(filePath) {\n    return filePath.replace(JIT_SUMMARY_FILE, '.');\n}\n/**\n * @param {?} symbolName\n * @return {?}\n */\nfunction summaryForJitName(symbolName) {\n    return symbolName + \"NgSummary\";\n}\n/**\n * @param {?} symbolName\n * @return {?}\n */\nfunction stripSummaryForJitNameSuffix(symbolName) {\n    return symbolName.replace(JIT_SUMMARY_NAME, '');\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar LifecycleHooks = {};\nLifecycleHooks.OnInit = 0;\nLifecycleHooks.OnDestroy = 1;\nLifecycleHooks.DoCheck = 2;\nLifecycleHooks.OnChanges = 3;\nLifecycleHooks.AfterContentInit = 4;\nLifecycleHooks.AfterContentChecked = 5;\nLifecycleHooks.AfterViewInit = 6;\nLifecycleHooks.AfterViewChecked = 7;\nLifecycleHooks[LifecycleHooks.OnInit] = \"OnInit\";\nLifecycleHooks[LifecycleHooks.OnDestroy] = \"OnDestroy\";\nLifecycleHooks[LifecycleHooks.DoCheck] = \"DoCheck\";\nLifecycleHooks[LifecycleHooks.OnChanges] = \"OnChanges\";\nLifecycleHooks[LifecycleHooks.AfterContentInit] = \"AfterContentInit\";\nLifecycleHooks[LifecycleHooks.AfterContentChecked] = \"AfterContentChecked\";\nLifecycleHooks[LifecycleHooks.AfterViewInit] = \"AfterViewInit\";\nLifecycleHooks[LifecycleHooks.AfterViewChecked] = \"AfterViewChecked\";\nvar LIFECYCLE_HOOKS_VALUES = [\n    LifecycleHooks.OnInit, LifecycleHooks.OnDestroy, LifecycleHooks.DoCheck, LifecycleHooks.OnChanges,\n    LifecycleHooks.AfterContentInit, LifecycleHooks.AfterContentChecked, LifecycleHooks.AfterViewInit,\n    LifecycleHooks.AfterViewChecked\n];\n/**\n * @param {?} reflector\n * @param {?} hook\n * @param {?} token\n * @return {?}\n */\nfunction hasLifecycleHook(reflector, hook, token) {\n    return reflector.hasLifecycleHook(token, getHookName(hook));\n}\n/**\n * @param {?} reflector\n * @param {?} token\n * @return {?}\n */\nfunction getAllLifecycleHooks(reflector, token) {\n    return LIFECYCLE_HOOKS_VALUES.filter(function (hook) { return hasLifecycleHook(reflector, hook, token); });\n}\n/**\n * @param {?} hook\n * @return {?}\n */\nfunction getHookName(hook) {\n    switch (hook) {\n        case LifecycleHooks.OnInit:\n            return 'ngOnInit';\n        case LifecycleHooks.OnDestroy:\n            return 'ngOnDestroy';\n        case LifecycleHooks.DoCheck:\n            return 'ngDoCheck';\n        case LifecycleHooks.OnChanges:\n            return 'ngOnChanges';\n        case LifecycleHooks.AfterContentInit:\n            return 'ngAfterContentInit';\n        case LifecycleHooks.AfterContentChecked:\n            return 'ngAfterContentChecked';\n        case LifecycleHooks.AfterViewInit:\n            return 'ngAfterViewInit';\n        case LifecycleHooks.AfterViewChecked:\n            return 'ngAfterViewChecked';\n    }\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} obj\n * @return {?}\n */\nfunction _isNgModuleMetadata(obj) {\n    return obj instanceof __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"];\n}\n/**\n * Resolves types to {\\@link NgModule}.\n */\nvar NgModuleResolver = (function () {\n    /**\n     * @param {?} _reflector\n     */\n    function NgModuleResolver(_reflector) {\n        this._reflector = _reflector;\n    }\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    NgModuleResolver.prototype.isNgModule = function (type) { return this._reflector.annotations(type).some(_isNgModuleMetadata); };\n    /**\n     * @param {?} type\n     * @param {?=} throwIfNotFound\n     * @return {?}\n     */\n    NgModuleResolver.prototype.resolve = function (type, throwIfNotFound) {\n        if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n        var /** @type {?} */ ngModuleMeta = findLast(this._reflector.annotations(type), _isNgModuleMetadata);\n        if (ngModuleMeta) {\n            return ngModuleMeta;\n        }\n        else {\n            if (throwIfNotFound) {\n                throw new Error(\"No NgModule metadata found for '\" + Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"stringify\"])(type) + \"'.\");\n            }\n            return null;\n        }\n    };\n    return NgModuleResolver;\n}());\nNgModuleResolver.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nNgModuleResolver.ctorParameters = function () { return [\n    { type: CompileReflector, },\n]; };\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} type\n * @return {?}\n */\nfunction _isPipeMetadata(type) {\n    return type instanceof __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Pipe\"];\n}\n/**\n * Resolve a `Type` for {\\@link Pipe}.\n *\n * This interface can be overridden by the application developer to create custom behavior.\n *\n * See {\\@link Compiler}\n */\nvar PipeResolver = (function () {\n    /**\n     * @param {?} _reflector\n     */\n    function PipeResolver(_reflector) {\n        this._reflector = _reflector;\n    }\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    PipeResolver.prototype.isPipe = function (type) {\n        var /** @type {?} */ typeMetadata = this._reflector.annotations(Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"resolveForwardRef\"])(type));\n        return typeMetadata && typeMetadata.some(_isPipeMetadata);\n    };\n    /**\n     * Return {\\@link Pipe} for a given `Type`.\n     * @param {?} type\n     * @param {?=} throwIfNotFound\n     * @return {?}\n     */\n    PipeResolver.prototype.resolve = function (type, throwIfNotFound) {\n        if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n        var /** @type {?} */ metas = this._reflector.annotations(Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"resolveForwardRef\"])(type));\n        if (metas) {\n            var /** @type {?} */ annotation = findLast(metas, _isPipeMetadata);\n            if (annotation) {\n                return annotation;\n            }\n        }\n        if (throwIfNotFound) {\n            throw new Error(\"No Pipe decorator found on \" + Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"stringify\"])(type));\n        }\n        return null;\n    };\n    return PipeResolver;\n}());\nPipeResolver.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nPipeResolver.ctorParameters = function () { return [\n    { type: CompileReflector, },\n]; };\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @abstract\n */\nvar SummaryResolver = (function () {\n    function SummaryResolver() {\n    }\n    /**\n     * @abstract\n     * @param {?} fileName\n     * @return {?}\n     */\n    SummaryResolver.prototype.isLibraryFile = function (fileName) { };\n    /**\n     * @abstract\n     * @param {?} fileName\n     * @return {?}\n     */\n    SummaryResolver.prototype.getLibraryFileName = function (fileName) { };\n    /**\n     * @abstract\n     * @param {?} reference\n     * @return {?}\n     */\n    SummaryResolver.prototype.resolveSummary = function (reference) { };\n    /**\n     * @abstract\n     * @param {?} filePath\n     * @return {?}\n     */\n    SummaryResolver.prototype.getSymbolsOf = function (filePath) { };\n    /**\n     * @abstract\n     * @param {?} reference\n     * @return {?}\n     */\n    SummaryResolver.prototype.getImportAs = function (reference) { };\n    /**\n     * @abstract\n     * @param {?} summary\n     * @return {?}\n     */\n    SummaryResolver.prototype.addSummary = function (summary) { };\n    return SummaryResolver;\n}());\nvar JitSummaryResolver = (function () {\n    function JitSummaryResolver() {\n        this._summaries = new Map();\n    }\n    /**\n     * @param {?} fileName\n     * @return {?}\n     */\n    JitSummaryResolver.prototype.isLibraryFile = function (fileName) { return false; };\n    ;\n    /**\n     * @param {?} fileName\n     * @return {?}\n     */\n    JitSummaryResolver.prototype.getLibraryFileName = function (fileName) { return null; };\n    /**\n     * @param {?} reference\n     * @return {?}\n     */\n    JitSummaryResolver.prototype.resolveSummary = function (reference) {\n        return this._summaries.get(reference) || null;\n    };\n    ;\n    /**\n     * @param {?} filePath\n     * @return {?}\n     */\n    JitSummaryResolver.prototype.getSymbolsOf = function (filePath) { return []; };\n    /**\n     * @param {?} reference\n     * @return {?}\n     */\n    JitSummaryResolver.prototype.getImportAs = function (reference) { return reference; };\n    /**\n     * @param {?} summary\n     * @return {?}\n     */\n    JitSummaryResolver.prototype.addSummary = function (summary) { this._summaries.set(summary.symbol, summary); };\n    ;\n    return JitSummaryResolver;\n}());\nJitSummaryResolver.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nJitSummaryResolver.ctorParameters = function () { return []; };\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ERROR_COLLECTOR_TOKEN = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"InjectionToken\"]('ErrorCollector');\nvar CompileMetadataResolver = (function () {\n    /**\n     * @param {?} _config\n     * @param {?} _ngModuleResolver\n     * @param {?} _directiveResolver\n     * @param {?} _pipeResolver\n     * @param {?} _summaryResolver\n     * @param {?} _schemaRegistry\n     * @param {?} _directiveNormalizer\n     * @param {?} _console\n     * @param {?} _staticSymbolCache\n     * @param {?} _reflector\n     * @param {?=} _errorCollector\n     */\n    function CompileMetadataResolver(_config, _ngModuleResolver, _directiveResolver, _pipeResolver, _summaryResolver, _schemaRegistry, _directiveNormalizer, _console, _staticSymbolCache, _reflector, _errorCollector) {\n        this._config = _config;\n        this._ngModuleResolver = _ngModuleResolver;\n        this._directiveResolver = _directiveResolver;\n        this._pipeResolver = _pipeResolver;\n        this._summaryResolver = _summaryResolver;\n        this._schemaRegistry = _schemaRegistry;\n        this._directiveNormalizer = _directiveNormalizer;\n        this._console = _console;\n        this._staticSymbolCache = _staticSymbolCache;\n        this._reflector = _reflector;\n        this._errorCollector = _errorCollector;\n        this._nonNormalizedDirectiveCache = new Map();\n        this._directiveCache = new Map();\n        this._summaryCache = new Map();\n        this._pipeCache = new Map();\n        this._ngModuleCache = new Map();\n        this._ngModuleOfTypes = new Map();\n    }\n    /**\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getReflector = function () { return this._reflector; };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.clearCacheFor = function (type) {\n        var /** @type {?} */ dirMeta = this._directiveCache.get(type);\n        this._directiveCache.delete(type);\n        this._nonNormalizedDirectiveCache.delete(type);\n        this._summaryCache.delete(type);\n        this._pipeCache.delete(type);\n        this._ngModuleOfTypes.delete(type);\n        // Clear all of the NgModule as they contain transitive information!\n        this._ngModuleCache.clear();\n        if (dirMeta) {\n            this._directiveNormalizer.clearCacheFor(dirMeta);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.clearCache = function () {\n        this._directiveCache.clear();\n        this._nonNormalizedDirectiveCache.clear();\n        this._summaryCache.clear();\n        this._pipeCache.clear();\n        this._ngModuleCache.clear();\n        this._ngModuleOfTypes.clear();\n        this._directiveNormalizer.clearCache();\n    };\n    /**\n     * @param {?} baseType\n     * @param {?} name\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._createProxyClass = function (baseType, name) {\n        var /** @type {?} */ delegate = null;\n        var /** @type {?} */ proxyClass = (function () {\n            if (!delegate) {\n                throw new Error(\"Illegal state: Class \" + name + \" for type \" + Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"stringify\"])(baseType) + \" is not compiled yet!\");\n            }\n            return delegate.apply(this, arguments);\n        });\n        proxyClass.setDelegate = function (d) {\n            delegate = d;\n            ((proxyClass)).prototype = d.prototype;\n        };\n        // Make stringify work correctly\n        ((proxyClass)).overriddenName = name;\n        return proxyClass;\n    };\n    /**\n     * @param {?} dirType\n     * @param {?} name\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getGeneratedClass = function (dirType, name) {\n        if (dirType instanceof StaticSymbol) {\n            return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), name);\n        }\n        else {\n            return this._createProxyClass(dirType, name);\n        }\n    };\n    /**\n     * @param {?} dirType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getComponentViewClass = function (dirType) {\n        return this.getGeneratedClass(dirType, viewClassName(dirType, 0));\n    };\n    /**\n     * @param {?} dirType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getHostComponentViewClass = function (dirType) {\n        return this.getGeneratedClass(dirType, hostViewClassName(dirType));\n    };\n    /**\n     * @param {?} dirType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getHostComponentType = function (dirType) {\n        var /** @type {?} */ name = identifierName({ reference: dirType }) + \"_Host\";\n        if (dirType instanceof StaticSymbol) {\n            return this._staticSymbolCache.get(dirType.filePath, name);\n        }\n        else {\n            var /** @type {?} */ HostClass = (function HostClass() { });\n            HostClass.overriddenName = name;\n            return HostClass;\n        }\n    };\n    /**\n     * @param {?} dirType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getRendererType = function (dirType) {\n        if (dirType instanceof StaticSymbol) {\n            return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), rendererTypeName(dirType));\n        }\n        else {\n            // returning an object as proxy,\n            // that we fill later during runtime compilation.\n            return ({});\n        }\n    };\n    /**\n     * @param {?} selector\n     * @param {?} dirType\n     * @param {?} inputs\n     * @param {?} outputs\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getComponentFactory = function (selector, dirType, inputs, outputs) {\n        if (dirType instanceof StaticSymbol) {\n            return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), componentFactoryName(dirType));\n        }\n        else {\n            var /** @type {?} */ hostView = this.getHostComponentViewClass(dirType);\n            // Note: ngContentSelectors will be filled later once the template is\n            // loaded.\n            return Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ccf\"])(selector, dirType, /** @type {?} */ (hostView), inputs, outputs, []);\n        }\n    };\n    /**\n     * @param {?} factory\n     * @param {?} ngContentSelectors\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.initComponentFactory = function (factory, ngContentSelectors) {\n        if (!(factory instanceof StaticSymbol)) {\n            (_a = factory.ngContentSelectors).push.apply(_a, ngContentSelectors);\n        }\n        var _a;\n    };\n    /**\n     * @param {?} type\n     * @param {?} kind\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._loadSummary = function (type, kind) {\n        var /** @type {?} */ typeSummary = this._summaryCache.get(type);\n        if (!typeSummary) {\n            var /** @type {?} */ summary = this._summaryResolver.resolveSummary(type);\n            typeSummary = summary ? summary.type : null;\n            this._summaryCache.set(type, typeSummary || null);\n        }\n        return typeSummary && typeSummary.summaryKind === kind ? typeSummary : null;\n    };\n    /**\n     * @param {?} ngModuleType\n     * @param {?} directiveType\n     * @param {?} isSync\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.loadDirectiveMetadata = function (ngModuleType, directiveType, isSync) {\n        var _this = this;\n        if (this._directiveCache.has(directiveType)) {\n            return null;\n        }\n        directiveType = Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"resolveForwardRef\"])(directiveType);\n        var _a = ((this.getNonNormalizedDirectiveMetadata(directiveType))), annotation = _a.annotation, metadata = _a.metadata;\n        var /** @type {?} */ createDirectiveMetadata = function (templateMetadata) {\n            var /** @type {?} */ normalizedDirMeta = new CompileDirectiveMetadata({\n                isHost: false,\n                type: metadata.type,\n                isComponent: metadata.isComponent,\n                selector: metadata.selector,\n                exportAs: metadata.exportAs,\n                changeDetection: metadata.changeDetection,\n                inputs: metadata.inputs,\n                outputs: metadata.outputs,\n                hostListeners: metadata.hostListeners,\n                hostProperties: metadata.hostProperties,\n                hostAttributes: metadata.hostAttributes,\n                providers: metadata.providers,\n                viewProviders: metadata.viewProviders,\n                queries: metadata.queries,\n                viewQueries: metadata.viewQueries,\n                entryComponents: metadata.entryComponents,\n                componentViewType: metadata.componentViewType,\n                rendererType: metadata.rendererType,\n                componentFactory: metadata.componentFactory,\n                template: templateMetadata\n            });\n            if (templateMetadata) {\n                _this.initComponentFactory(/** @type {?} */ ((metadata.componentFactory)), templateMetadata.ngContentSelectors);\n            }\n            _this._directiveCache.set(directiveType, normalizedDirMeta);\n            _this._summaryCache.set(directiveType, normalizedDirMeta.toSummary());\n            return null;\n        };\n        if (metadata.isComponent) {\n            var /** @type {?} */ template = ((metadata.template));\n            var /** @type {?} */ templateMeta = this._directiveNormalizer.normalizeTemplate({\n                ngModuleType: ngModuleType,\n                componentType: directiveType,\n                moduleUrl: this._reflector.componentModuleUrl(directiveType, annotation),\n                encapsulation: template.encapsulation,\n                template: template.template,\n                templateUrl: template.templateUrl,\n                styles: template.styles,\n                styleUrls: template.styleUrls,\n                animations: template.animations,\n                interpolation: template.interpolation\n            });\n            if (Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"isPromise\"])(templateMeta) && isSync) {\n                this._reportError(componentStillLoadingError(directiveType), directiveType);\n                return null;\n            }\n            return SyncAsync.then(templateMeta, createDirectiveMetadata);\n        }\n        else {\n            // directive\n            createDirectiveMetadata(null);\n            return null;\n        }\n    };\n    /**\n     * @param {?} directiveType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getNonNormalizedDirectiveMetadata = function (directiveType) {\n        var _this = this;\n        directiveType = Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"resolveForwardRef\"])(directiveType);\n        if (!directiveType) {\n            return null;\n        }\n        var /** @type {?} */ cacheEntry = this._nonNormalizedDirectiveCache.get(directiveType);\n        if (cacheEntry) {\n            return cacheEntry;\n        }\n        var /** @type {?} */ dirMeta = this._directiveResolver.resolve(directiveType, false);\n        if (!dirMeta) {\n            return null;\n        }\n        var /** @type {?} */ nonNormalizedTemplateMetadata = ((undefined));\n        if (dirMeta instanceof __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"]) {\n            // component\n            assertArrayOfStrings('styles', dirMeta.styles);\n            assertArrayOfStrings('styleUrls', dirMeta.styleUrls);\n            assertInterpolationSymbols('interpolation', dirMeta.interpolation);\n            var /** @type {?} */ animations = dirMeta.animations;\n            nonNormalizedTemplateMetadata = new CompileTemplateMetadata({\n                encapsulation: noUndefined(dirMeta.encapsulation),\n                template: noUndefined(dirMeta.template),\n                templateUrl: noUndefined(dirMeta.templateUrl),\n                styles: dirMeta.styles || [],\n                styleUrls: dirMeta.styleUrls || [],\n                animations: animations || [],\n                interpolation: noUndefined(dirMeta.interpolation),\n                isInline: !!dirMeta.template,\n                externalStylesheets: [],\n                ngContentSelectors: []\n            });\n        }\n        var /** @type {?} */ changeDetectionStrategy = ((null));\n        var /** @type {?} */ viewProviders = [];\n        var /** @type {?} */ entryComponentMetadata = [];\n        var /** @type {?} */ selector = dirMeta.selector;\n        if (dirMeta instanceof __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"]) {\n            // Component\n            changeDetectionStrategy = ((dirMeta.changeDetection));\n            if (dirMeta.viewProviders) {\n                viewProviders = this._getProvidersMetadata(dirMeta.viewProviders, entryComponentMetadata, \"viewProviders for \\\"\" + stringifyType(directiveType) + \"\\\"\", [], directiveType);\n            }\n            if (dirMeta.entryComponents) {\n                entryComponentMetadata = flattenAndDedupeArray(dirMeta.entryComponents)\n                    .map(function (type) { return ((_this._getEntryComponentMetadata(type))); })\n                    .concat(entryComponentMetadata);\n            }\n            if (!selector) {\n                selector = this._schemaRegistry.getDefaultComponentElementName();\n            }\n        }\n        else {\n            // Directive\n            if (!selector) {\n                this._reportError(syntaxError(\"Directive \" + stringifyType(directiveType) + \" has no selector, please add it!\"), directiveType);\n                selector = 'error';\n            }\n        }\n        var /** @type {?} */ providers = [];\n        if (dirMeta.providers != null) {\n            providers = this._getProvidersMetadata(dirMeta.providers, entryComponentMetadata, \"providers for \\\"\" + stringifyType(directiveType) + \"\\\"\", [], directiveType);\n        }\n        var /** @type {?} */ queries = [];\n        var /** @type {?} */ viewQueries = [];\n        if (dirMeta.queries != null) {\n            queries = this._getQueriesMetadata(dirMeta.queries, false, directiveType);\n            viewQueries = this._getQueriesMetadata(dirMeta.queries, true, directiveType);\n        }\n        var /** @type {?} */ metadata = CompileDirectiveMetadata.create({\n            isHost: false,\n            selector: selector,\n            exportAs: noUndefined(dirMeta.exportAs),\n            isComponent: !!nonNormalizedTemplateMetadata,\n            type: this._getTypeMetadata(directiveType),\n            template: nonNormalizedTemplateMetadata,\n            changeDetection: changeDetectionStrategy,\n            inputs: dirMeta.inputs || [],\n            outputs: dirMeta.outputs || [],\n            host: dirMeta.host || {},\n            providers: providers || [],\n            viewProviders: viewProviders || [],\n            queries: queries || [],\n            viewQueries: viewQueries || [],\n            entryComponents: entryComponentMetadata,\n            componentViewType: nonNormalizedTemplateMetadata ? this.getComponentViewClass(directiveType) :\n                null,\n            rendererType: nonNormalizedTemplateMetadata ? this.getRendererType(directiveType) : null,\n            componentFactory: null\n        });\n        if (nonNormalizedTemplateMetadata) {\n            metadata.componentFactory =\n                this.getComponentFactory(selector, directiveType, metadata.inputs, metadata.outputs);\n        }\n        cacheEntry = { metadata: metadata, annotation: dirMeta };\n        this._nonNormalizedDirectiveCache.set(directiveType, cacheEntry);\n        return cacheEntry;\n    };\n    /**\n     * Gets the metadata for the given directive.\n     * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.\n     * @param {?} directiveType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getDirectiveMetadata = function (directiveType) {\n        var /** @type {?} */ dirMeta = ((this._directiveCache.get(directiveType)));\n        if (!dirMeta) {\n            this._reportError(syntaxError(\"Illegal state: getDirectiveMetadata can only be called after loadNgModuleDirectiveAndPipeMetadata for a module that declares it. Directive \" + stringifyType(directiveType) + \".\"), directiveType);\n        }\n        return dirMeta;\n    };\n    /**\n     * @param {?} dirType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getDirectiveSummary = function (dirType) {\n        var /** @type {?} */ dirSummary = (this._loadSummary(dirType, CompileSummaryKind.Directive));\n        if (!dirSummary) {\n            this._reportError(syntaxError(\"Illegal state: Could not load the summary for directive \" + stringifyType(dirType) + \".\"), dirType);\n        }\n        return dirSummary;\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.isDirective = function (type) {\n        return !!this._loadSummary(type, CompileSummaryKind.Directive) ||\n            this._directiveResolver.isDirective(type);\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.isPipe = function (type) {\n        return !!this._loadSummary(type, CompileSummaryKind.Pipe) ||\n            this._pipeResolver.isPipe(type);\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.isNgModule = function (type) {\n        return !!this._loadSummary(type, CompileSummaryKind.NgModule) ||\n            this._ngModuleResolver.isNgModule(type);\n    };\n    /**\n     * @param {?} moduleType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getNgModuleSummary = function (moduleType) {\n        var /** @type {?} */ moduleSummary = (this._loadSummary(moduleType, CompileSummaryKind.NgModule));\n        if (!moduleSummary) {\n            var /** @type {?} */ moduleMeta = this.getNgModuleMetadata(moduleType, false);\n            moduleSummary = moduleMeta ? moduleMeta.toSummary() : null;\n            if (moduleSummary) {\n                this._summaryCache.set(moduleType, moduleSummary);\n            }\n        }\n        return moduleSummary;\n    };\n    /**\n     * Loads the declared directives and pipes of an NgModule.\n     * @param {?} moduleType\n     * @param {?} isSync\n     * @param {?=} throwIfNotFound\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.loadNgModuleDirectiveAndPipeMetadata = function (moduleType, isSync, throwIfNotFound) {\n        var _this = this;\n        if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n        var /** @type {?} */ ngModule = this.getNgModuleMetadata(moduleType, throwIfNotFound);\n        var /** @type {?} */ loading = [];\n        if (ngModule) {\n            ngModule.declaredDirectives.forEach(function (id) {\n                var /** @type {?} */ promise = _this.loadDirectiveMetadata(moduleType, id.reference, isSync);\n                if (promise) {\n                    loading.push(promise);\n                }\n            });\n            ngModule.declaredPipes.forEach(function (id) { return _this._loadPipeMetadata(id.reference); });\n        }\n        return Promise.all(loading);\n    };\n    /**\n     * @param {?} moduleType\n     * @param {?=} throwIfNotFound\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getNgModuleMetadata = function (moduleType, throwIfNotFound) {\n        var _this = this;\n        if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n        moduleType = Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"resolveForwardRef\"])(moduleType);\n        var /** @type {?} */ compileMeta = this._ngModuleCache.get(moduleType);\n        if (compileMeta) {\n            return compileMeta;\n        }\n        var /** @type {?} */ meta = this._ngModuleResolver.resolve(moduleType, throwIfNotFound);\n        if (!meta) {\n            return null;\n        }\n        var /** @type {?} */ declaredDirectives = [];\n        var /** @type {?} */ exportedNonModuleIdentifiers = [];\n        var /** @type {?} */ declaredPipes = [];\n        var /** @type {?} */ importedModules = [];\n        var /** @type {?} */ exportedModules = [];\n        var /** @type {?} */ providers = [];\n        var /** @type {?} */ entryComponents = [];\n        var /** @type {?} */ bootstrapComponents = [];\n        var /** @type {?} */ schemas = [];\n        if (meta.imports) {\n            flattenAndDedupeArray(meta.imports).forEach(function (importedType) {\n                var /** @type {?} */ importedModuleType = ((undefined));\n                if (isValidType(importedType)) {\n                    importedModuleType = importedType;\n                }\n                else if (importedType && importedType.ngModule) {\n                    var /** @type {?} */ moduleWithProviders = importedType;\n                    importedModuleType = moduleWithProviders.ngModule;\n                    if (moduleWithProviders.providers) {\n                        providers.push.apply(providers, _this._getProvidersMetadata(moduleWithProviders.providers, entryComponents, \"provider for the NgModule '\" + stringifyType(importedModuleType) + \"'\", [], importedType));\n                    }\n                }\n                if (importedModuleType) {\n                    if (_this._checkSelfImport(moduleType, importedModuleType))\n                        return;\n                    var /** @type {?} */ importedModuleSummary = _this.getNgModuleSummary(importedModuleType);\n                    if (!importedModuleSummary) {\n                        _this._reportError(syntaxError(\"Unexpected \" + _this._getTypeDescriptor(importedType) + \" '\" + stringifyType(importedType) + \"' imported by the module '\" + stringifyType(moduleType) + \"'. Please add a @NgModule annotation.\"), moduleType);\n                        return;\n                    }\n                    importedModules.push(importedModuleSummary);\n                }\n                else {\n                    _this._reportError(syntaxError(\"Unexpected value '\" + stringifyType(importedType) + \"' imported by the module '\" + stringifyType(moduleType) + \"'\"), moduleType);\n                    return;\n                }\n            });\n        }\n        if (meta.exports) {\n            flattenAndDedupeArray(meta.exports).forEach(function (exportedType) {\n                if (!isValidType(exportedType)) {\n                    _this._reportError(syntaxError(\"Unexpected value '\" + stringifyType(exportedType) + \"' exported by the module '\" + stringifyType(moduleType) + \"'\"), moduleType);\n                    return;\n                }\n                var /** @type {?} */ exportedModuleSummary = _this.getNgModuleSummary(exportedType);\n                if (exportedModuleSummary) {\n                    exportedModules.push(exportedModuleSummary);\n                }\n                else {\n                    exportedNonModuleIdentifiers.push(_this._getIdentifierMetadata(exportedType));\n                }\n            });\n        }\n        // Note: This will be modified later, so we rely on\n        // getting a new instance every time!\n        var /** @type {?} */ transitiveModule = this._getTransitiveNgModuleMetadata(importedModules, exportedModules);\n        if (meta.declarations) {\n            flattenAndDedupeArray(meta.declarations).forEach(function (declaredType) {\n                if (!isValidType(declaredType)) {\n                    _this._reportError(syntaxError(\"Unexpected value '\" + stringifyType(declaredType) + \"' declared by the module '\" + stringifyType(moduleType) + \"'\"), moduleType);\n                    return;\n                }\n                var /** @type {?} */ declaredIdentifier = _this._getIdentifierMetadata(declaredType);\n                if (_this.isDirective(declaredType)) {\n                    transitiveModule.addDirective(declaredIdentifier);\n                    declaredDirectives.push(declaredIdentifier);\n                    _this._addTypeToModule(declaredType, moduleType);\n                }\n                else if (_this.isPipe(declaredType)) {\n                    transitiveModule.addPipe(declaredIdentifier);\n                    transitiveModule.pipes.push(declaredIdentifier);\n                    declaredPipes.push(declaredIdentifier);\n                    _this._addTypeToModule(declaredType, moduleType);\n                }\n                else {\n                    _this._reportError(syntaxError(\"Unexpected \" + _this._getTypeDescriptor(declaredType) + \" '\" + stringifyType(declaredType) + \"' declared by the module '\" + stringifyType(moduleType) + \"'. Please add a @Pipe/@Directive/@Component annotation.\"), moduleType);\n                    return;\n                }\n            });\n        }\n        var /** @type {?} */ exportedDirectives = [];\n        var /** @type {?} */ exportedPipes = [];\n        exportedNonModuleIdentifiers.forEach(function (exportedId) {\n            if (transitiveModule.directivesSet.has(exportedId.reference)) {\n                exportedDirectives.push(exportedId);\n                transitiveModule.addExportedDirective(exportedId);\n            }\n            else if (transitiveModule.pipesSet.has(exportedId.reference)) {\n                exportedPipes.push(exportedId);\n                transitiveModule.addExportedPipe(exportedId);\n            }\n            else {\n                _this._reportError(syntaxError(\"Can't export \" + _this._getTypeDescriptor(exportedId.reference) + \" \" + stringifyType(exportedId.reference) + \" from \" + stringifyType(moduleType) + \" as it was neither declared nor imported!\"), moduleType);\n                return;\n            }\n        });\n        // The providers of the module have to go last\n        // so that they overwrite any other provider we already added.\n        if (meta.providers) {\n            providers.push.apply(providers, this._getProvidersMetadata(meta.providers, entryComponents, \"provider for the NgModule '\" + stringifyType(moduleType) + \"'\", [], moduleType));\n        }\n        if (meta.entryComponents) {\n            entryComponents.push.apply(entryComponents, flattenAndDedupeArray(meta.entryComponents)\n                .map(function (type) { return ((_this._getEntryComponentMetadata(type))); }));\n        }\n        if (meta.bootstrap) {\n            flattenAndDedupeArray(meta.bootstrap).forEach(function (type) {\n                if (!isValidType(type)) {\n                    _this._reportError(syntaxError(\"Unexpected value '\" + stringifyType(type) + \"' used in the bootstrap property of module '\" + stringifyType(moduleType) + \"'\"), moduleType);\n                    return;\n                }\n                bootstrapComponents.push(_this._getIdentifierMetadata(type));\n            });\n        }\n        entryComponents.push.apply(entryComponents, bootstrapComponents.map(function (type) { return ((_this._getEntryComponentMetadata(type.reference))); }));\n        if (meta.schemas) {\n            schemas.push.apply(schemas, flattenAndDedupeArray(meta.schemas));\n        }\n        compileMeta = new CompileNgModuleMetadata({\n            type: this._getTypeMetadata(moduleType),\n            providers: providers,\n            entryComponents: entryComponents,\n            bootstrapComponents: bootstrapComponents,\n            schemas: schemas,\n            declaredDirectives: declaredDirectives,\n            exportedDirectives: exportedDirectives,\n            declaredPipes: declaredPipes,\n            exportedPipes: exportedPipes,\n            importedModules: importedModules,\n            exportedModules: exportedModules,\n            transitiveModule: transitiveModule,\n            id: meta.id || null,\n        });\n        entryComponents.forEach(function (id) { return transitiveModule.addEntryComponent(id); });\n        providers.forEach(function (provider) { return transitiveModule.addProvider(provider, /** @type {?} */ ((compileMeta)).type); });\n        transitiveModule.addModule(compileMeta.type);\n        this._ngModuleCache.set(moduleType, compileMeta);\n        return compileMeta;\n    };\n    /**\n     * @param {?} moduleType\n     * @param {?} importedModuleType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._checkSelfImport = function (moduleType, importedModuleType) {\n        if (moduleType === importedModuleType) {\n            this._reportError(syntaxError(\"'\" + stringifyType(moduleType) + \"' module can't import itself\"), moduleType);\n            return true;\n        }\n        return false;\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getTypeDescriptor = function (type) {\n        if (this.isDirective(type)) {\n            return 'directive';\n        }\n        if (this.isPipe(type)) {\n            return 'pipe';\n        }\n        if (this.isNgModule(type)) {\n            return 'module';\n        }\n        if (((type)).provide) {\n            return 'provider';\n        }\n        return 'value';\n    };\n    /**\n     * @param {?} type\n     * @param {?} moduleType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._addTypeToModule = function (type, moduleType) {\n        var /** @type {?} */ oldModule = this._ngModuleOfTypes.get(type);\n        if (oldModule && oldModule !== moduleType) {\n            this._reportError(syntaxError(\"Type \" + stringifyType(type) + \" is part of the declarations of 2 modules: \" + stringifyType(oldModule) + \" and \" + stringifyType(moduleType) + \"! \" +\n                (\"Please consider moving \" + stringifyType(type) + \" to a higher module that imports \" + stringifyType(oldModule) + \" and \" + stringifyType(moduleType) + \". \") +\n                (\"You can also create a new NgModule that exports and includes \" + stringifyType(type) + \" then import that NgModule in \" + stringifyType(oldModule) + \" and \" + stringifyType(moduleType) + \".\")), moduleType);\n            return;\n        }\n        this._ngModuleOfTypes.set(type, moduleType);\n    };\n    /**\n     * @param {?} importedModules\n     * @param {?} exportedModules\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getTransitiveNgModuleMetadata = function (importedModules, exportedModules) {\n        // collect `providers` / `entryComponents` from all imported and all exported modules\n        var /** @type {?} */ result = new TransitiveCompileNgModuleMetadata();\n        var /** @type {?} */ modulesByToken = new Map();\n        importedModules.concat(exportedModules).forEach(function (modSummary) {\n            modSummary.modules.forEach(function (mod) { return result.addModule(mod); });\n            modSummary.entryComponents.forEach(function (comp) { return result.addEntryComponent(comp); });\n            var /** @type {?} */ addedTokens = new Set();\n            modSummary.providers.forEach(function (entry) {\n                var /** @type {?} */ tokenRef = tokenReference(entry.provider.token);\n                var /** @type {?} */ prevModules = modulesByToken.get(tokenRef);\n                if (!prevModules) {\n                    prevModules = new Set();\n                    modulesByToken.set(tokenRef, prevModules);\n                }\n                var /** @type {?} */ moduleRef = entry.module.reference;\n                // Note: the providers of one module may still contain multiple providers\n                // per token (e.g. for multi providers), and we need to preserve these.\n                if (addedTokens.has(tokenRef) || !prevModules.has(moduleRef)) {\n                    prevModules.add(moduleRef);\n                    addedTokens.add(tokenRef);\n                    result.addProvider(entry.provider, entry.module);\n                }\n            });\n        });\n        exportedModules.forEach(function (modSummary) {\n            modSummary.exportedDirectives.forEach(function (id) { return result.addExportedDirective(id); });\n            modSummary.exportedPipes.forEach(function (id) { return result.addExportedPipe(id); });\n        });\n        importedModules.forEach(function (modSummary) {\n            modSummary.exportedDirectives.forEach(function (id) { return result.addDirective(id); });\n            modSummary.exportedPipes.forEach(function (id) { return result.addPipe(id); });\n        });\n        return result;\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getIdentifierMetadata = function (type) {\n        type = Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"resolveForwardRef\"])(type);\n        return { reference: type };\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.isInjectable = function (type) {\n        var /** @type {?} */ annotations = this._reflector.annotations(type);\n        // Note: We need an exact check here as @Component / @Directive / ... inherit\n        // from @CompilerInjectable!\n        return annotations.some(function (ann) { return ann.constructor === __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"]; });\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getInjectableSummary = function (type) {\n        return {\n            summaryKind: CompileSummaryKind.Injectable,\n            type: this._getTypeMetadata(type, null, false)\n        };\n    };\n    /**\n     * @param {?} type\n     * @param {?=} dependencies\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getInjectableMetadata = function (type, dependencies) {\n        if (dependencies === void 0) { dependencies = null; }\n        var /** @type {?} */ typeSummary = this._loadSummary(type, CompileSummaryKind.Injectable);\n        if (typeSummary) {\n            return typeSummary.type;\n        }\n        return this._getTypeMetadata(type, dependencies);\n    };\n    /**\n     * @param {?} type\n     * @param {?=} dependencies\n     * @param {?=} throwOnUnknownDeps\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getTypeMetadata = function (type, dependencies, throwOnUnknownDeps) {\n        if (dependencies === void 0) { dependencies = null; }\n        if (throwOnUnknownDeps === void 0) { throwOnUnknownDeps = true; }\n        var /** @type {?} */ identifier = this._getIdentifierMetadata(type);\n        return {\n            reference: identifier.reference,\n            diDeps: this._getDependenciesMetadata(identifier.reference, dependencies, throwOnUnknownDeps),\n            lifecycleHooks: getAllLifecycleHooks(this._reflector, identifier.reference),\n        };\n    };\n    /**\n     * @param {?} factory\n     * @param {?=} dependencies\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getFactoryMetadata = function (factory, dependencies) {\n        if (dependencies === void 0) { dependencies = null; }\n        factory = Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"resolveForwardRef\"])(factory);\n        return { reference: factory, diDeps: this._getDependenciesMetadata(factory, dependencies) };\n    };\n    /**\n     * Gets the metadata for the given pipe.\n     * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.\n     * @param {?} pipeType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getPipeMetadata = function (pipeType) {\n        var /** @type {?} */ pipeMeta = this._pipeCache.get(pipeType);\n        if (!pipeMeta) {\n            this._reportError(syntaxError(\"Illegal state: getPipeMetadata can only be called after loadNgModuleDirectiveAndPipeMetadata for a module that declares it. Pipe \" + stringifyType(pipeType) + \".\"), pipeType);\n        }\n        return pipeMeta || null;\n    };\n    /**\n     * @param {?} pipeType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getPipeSummary = function (pipeType) {\n        var /** @type {?} */ pipeSummary = (this._loadSummary(pipeType, CompileSummaryKind.Pipe));\n        if (!pipeSummary) {\n            this._reportError(syntaxError(\"Illegal state: Could not load the summary for pipe \" + stringifyType(pipeType) + \".\"), pipeType);\n        }\n        return pipeSummary;\n    };\n    /**\n     * @param {?} pipeType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getOrLoadPipeMetadata = function (pipeType) {\n        var /** @type {?} */ pipeMeta = this._pipeCache.get(pipeType);\n        if (!pipeMeta) {\n            pipeMeta = this._loadPipeMetadata(pipeType);\n        }\n        return pipeMeta;\n    };\n    /**\n     * @param {?} pipeType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._loadPipeMetadata = function (pipeType) {\n        pipeType = Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"resolveForwardRef\"])(pipeType);\n        var /** @type {?} */ pipeAnnotation = ((this._pipeResolver.resolve(pipeType)));\n        var /** @type {?} */ pipeMeta = new CompilePipeMetadata({\n            type: this._getTypeMetadata(pipeType),\n            name: pipeAnnotation.name,\n            pure: !!pipeAnnotation.pure\n        });\n        this._pipeCache.set(pipeType, pipeMeta);\n        this._summaryCache.set(pipeType, pipeMeta.toSummary());\n        return pipeMeta;\n    };\n    /**\n     * @param {?} typeOrFunc\n     * @param {?} dependencies\n     * @param {?=} throwOnUnknownDeps\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getDependenciesMetadata = function (typeOrFunc, dependencies, throwOnUnknownDeps) {\n        var _this = this;\n        if (throwOnUnknownDeps === void 0) { throwOnUnknownDeps = true; }\n        var /** @type {?} */ hasUnknownDeps = false;\n        var /** @type {?} */ params = dependencies || this._reflector.parameters(typeOrFunc) || [];\n        var /** @type {?} */ dependenciesMetadata = params.map(function (param) {\n            var /** @type {?} */ isAttribute = false;\n            var /** @type {?} */ isHost = false;\n            var /** @type {?} */ isSelf = false;\n            var /** @type {?} */ isSkipSelf = false;\n            var /** @type {?} */ isOptional = false;\n            var /** @type {?} */ token = null;\n            if (Array.isArray(param)) {\n                param.forEach(function (paramEntry) {\n                    if (paramEntry instanceof __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Host\"]) {\n                        isHost = true;\n                    }\n                    else if (paramEntry instanceof __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Self\"]) {\n                        isSelf = true;\n                    }\n                    else if (paramEntry instanceof __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SkipSelf\"]) {\n                        isSkipSelf = true;\n                    }\n                    else if (paramEntry instanceof __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"]) {\n                        isOptional = true;\n                    }\n                    else if (paramEntry instanceof __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Attribute\"]) {\n                        isAttribute = true;\n                        token = paramEntry.attributeName;\n                    }\n                    else if (paramEntry instanceof __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"]) {\n                        token = paramEntry.token;\n                    }\n                    else if (paramEntry instanceof __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"InjectionToken\"]) {\n                        token = paramEntry;\n                    }\n                    else if (isValidType(paramEntry) && token == null) {\n                        token = paramEntry;\n                    }\n                });\n            }\n            else {\n                token = param;\n            }\n            if (token == null) {\n                hasUnknownDeps = true;\n                return ((null));\n            }\n            return {\n                isAttribute: isAttribute,\n                isHost: isHost,\n                isSelf: isSelf,\n                isSkipSelf: isSkipSelf,\n                isOptional: isOptional,\n                token: _this._getTokenMetadata(token)\n            };\n        });\n        if (hasUnknownDeps) {\n            var /** @type {?} */ depsTokens = dependenciesMetadata.map(function (dep) { return dep ? stringifyType(dep.token) : '?'; }).join(', ');\n            var /** @type {?} */ message = \"Can't resolve all parameters for \" + stringifyType(typeOrFunc) + \": (\" + depsTokens + \").\";\n            if (throwOnUnknownDeps) {\n                this._reportError(syntaxError(message), typeOrFunc);\n            }\n            else {\n                this._console.warn(\"Warning: \" + message + \" This will become an error in Angular v5.x\");\n            }\n        }\n        return dependenciesMetadata;\n    };\n    /**\n     * @param {?} token\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getTokenMetadata = function (token) {\n        token = Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"resolveForwardRef\"])(token);\n        var /** @type {?} */ compileToken;\n        if (typeof token === 'string') {\n            compileToken = { value: token };\n        }\n        else {\n            compileToken = { identifier: { reference: token } };\n        }\n        return compileToken;\n    };\n    /**\n     * @param {?} providers\n     * @param {?} targetEntryComponents\n     * @param {?=} debugInfo\n     * @param {?=} compileProviders\n     * @param {?=} type\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getProvidersMetadata = function (providers, targetEntryComponents, debugInfo, compileProviders, type) {\n        var _this = this;\n        if (compileProviders === void 0) { compileProviders = []; }\n        providers.forEach(function (provider, providerIdx) {\n            if (Array.isArray(provider)) {\n                _this._getProvidersMetadata(provider, targetEntryComponents, debugInfo, compileProviders);\n            }\n            else {\n                provider = Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"resolveForwardRef\"])(provider);\n                var /** @type {?} */ providerMeta = ((undefined));\n                if (provider && typeof provider === 'object' && provider.hasOwnProperty('provide')) {\n                    _this._validateProvider(provider);\n                    providerMeta = new ProviderMeta(provider.provide, provider);\n                }\n                else if (isValidType(provider)) {\n                    providerMeta = new ProviderMeta(provider, { useClass: provider });\n                }\n                else if (provider === void 0) {\n                    _this._reportError(syntaxError(\"Encountered undefined provider! Usually this means you have a circular dependencies (might be caused by using 'barrel' index.ts files.\"));\n                    return;\n                }\n                else {\n                    var /** @type {?} */ providersInfo = ((providers.reduce(function (soFar, seenProvider, seenProviderIdx) {\n                        if (seenProviderIdx < providerIdx) {\n                            soFar.push(\"\" + stringifyType(seenProvider));\n                        }\n                        else if (seenProviderIdx == providerIdx) {\n                            soFar.push(\"?\" + stringifyType(seenProvider) + \"?\");\n                        }\n                        else if (seenProviderIdx == providerIdx + 1) {\n                            soFar.push('...');\n                        }\n                        return soFar;\n                    }, [])))\n                        .join(', ');\n                    _this._reportError(syntaxError(\"Invalid \" + (debugInfo ? debugInfo : 'provider') + \" - only instances of Provider and Type are allowed, got: [\" + providersInfo + \"]\"), type);\n                    return;\n                }\n                if (providerMeta.token ===\n                    _this._reflector.resolveExternalReference(Identifiers.ANALYZE_FOR_ENTRY_COMPONENTS)) {\n                    targetEntryComponents.push.apply(targetEntryComponents, _this._getEntryComponentsFromProvider(providerMeta, type));\n                }\n                else {\n                    compileProviders.push(_this.getProviderMetadata(providerMeta));\n                }\n            }\n        });\n        return compileProviders;\n    };\n    /**\n     * @param {?} provider\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._validateProvider = function (provider) {\n        if (provider.hasOwnProperty('useClass') && provider.useClass == null) {\n            this._reportError(syntaxError(\"Invalid provider for \" + stringifyType(provider.provide) + \". useClass cannot be \" + provider.useClass + \".\\n           Usually it happens when:\\n           1. There's a circular dependency (might be caused by using index.ts (barrel) files).\\n           2. Class was used before it was declared. Use forwardRef in this case.\"));\n        }\n    };\n    /**\n     * @param {?} provider\n     * @param {?=} type\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getEntryComponentsFromProvider = function (provider, type) {\n        var _this = this;\n        var /** @type {?} */ components = [];\n        var /** @type {?} */ collectedIdentifiers = [];\n        if (provider.useFactory || provider.useExisting || provider.useClass) {\n            this._reportError(syntaxError(\"The ANALYZE_FOR_ENTRY_COMPONENTS token only supports useValue!\"), type);\n            return [];\n        }\n        if (!provider.multi) {\n            this._reportError(syntaxError(\"The ANALYZE_FOR_ENTRY_COMPONENTS token only supports 'multi = true'!\"), type);\n            return [];\n        }\n        extractIdentifiers(provider.useValue, collectedIdentifiers);\n        collectedIdentifiers.forEach(function (identifier) {\n            var /** @type {?} */ entry = _this._getEntryComponentMetadata(identifier.reference, false);\n            if (entry) {\n                components.push(entry);\n            }\n        });\n        return components;\n    };\n    /**\n     * @param {?} dirType\n     * @param {?=} throwIfNotFound\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getEntryComponentMetadata = function (dirType, throwIfNotFound) {\n        if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n        var /** @type {?} */ dirMeta = this.getNonNormalizedDirectiveMetadata(dirType);\n        if (dirMeta && dirMeta.metadata.isComponent) {\n            return { componentType: dirType, componentFactory: /** @type {?} */ ((dirMeta.metadata.componentFactory)) };\n        }\n        var /** @type {?} */ dirSummary = (this._loadSummary(dirType, CompileSummaryKind.Directive));\n        if (dirSummary && dirSummary.isComponent) {\n            return { componentType: dirType, componentFactory: /** @type {?} */ ((dirSummary.componentFactory)) };\n        }\n        if (throwIfNotFound) {\n            throw syntaxError(dirType.name + \" cannot be used as an entry component.\");\n        }\n        return null;\n    };\n    /**\n     * @param {?} provider\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getProviderMetadata = function (provider) {\n        var /** @type {?} */ compileDeps = ((undefined));\n        var /** @type {?} */ compileTypeMetadata = ((null));\n        var /** @type {?} */ compileFactoryMetadata = ((null));\n        var /** @type {?} */ token = this._getTokenMetadata(provider.token);\n        if (provider.useClass) {\n            compileTypeMetadata = this._getInjectableMetadata(provider.useClass, provider.dependencies);\n            compileDeps = compileTypeMetadata.diDeps;\n            if (provider.token === provider.useClass) {\n                // use the compileTypeMetadata as it contains information about lifecycleHooks...\n                token = { identifier: compileTypeMetadata };\n            }\n        }\n        else if (provider.useFactory) {\n            compileFactoryMetadata = this._getFactoryMetadata(provider.useFactory, provider.dependencies);\n            compileDeps = compileFactoryMetadata.diDeps;\n        }\n        return {\n            token: token,\n            useClass: compileTypeMetadata,\n            useValue: provider.useValue,\n            useFactory: compileFactoryMetadata,\n            useExisting: provider.useExisting ? this._getTokenMetadata(provider.useExisting) : undefined,\n            deps: compileDeps,\n            multi: provider.multi\n        };\n    };\n    /**\n     * @param {?} queries\n     * @param {?} isViewQuery\n     * @param {?} directiveType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getQueriesMetadata = function (queries, isViewQuery, directiveType) {\n        var _this = this;\n        var /** @type {?} */ res = [];\n        Object.keys(queries).forEach(function (propertyName) {\n            var /** @type {?} */ query = queries[propertyName];\n            if (query.isViewQuery === isViewQuery) {\n                res.push(_this._getQueryMetadata(query, propertyName, directiveType));\n            }\n        });\n        return res;\n    };\n    /**\n     * @param {?} selector\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._queryVarBindings = function (selector) { return selector.split(/\\s*,\\s*/); };\n    /**\n     * @param {?} q\n     * @param {?} propertyName\n     * @param {?} typeOrFunc\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getQueryMetadata = function (q, propertyName, typeOrFunc) {\n        var _this = this;\n        var /** @type {?} */ selectors;\n        if (typeof q.selector === 'string') {\n            selectors =\n                this._queryVarBindings(q.selector).map(function (varName) { return _this._getTokenMetadata(varName); });\n        }\n        else {\n            if (!q.selector) {\n                this._reportError(syntaxError(\"Can't construct a query for the property \\\"\" + propertyName + \"\\\" of \\\"\" + stringifyType(typeOrFunc) + \"\\\" since the query selector wasn't defined.\"), typeOrFunc);\n                selectors = [];\n            }\n            else {\n                selectors = [this._getTokenMetadata(q.selector)];\n            }\n        }\n        return {\n            selectors: selectors,\n            first: q.first,\n            descendants: q.descendants, propertyName: propertyName,\n            read: q.read ? this._getTokenMetadata(q.read) : ((null))\n        };\n    };\n    /**\n     * @param {?} error\n     * @param {?=} type\n     * @param {?=} otherType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._reportError = function (error, type, otherType) {\n        if (this._errorCollector) {\n            this._errorCollector(error, type);\n            if (otherType) {\n                this._errorCollector(error, otherType);\n            }\n        }\n        else {\n            throw error;\n        }\n    };\n    return CompileMetadataResolver;\n}());\nCompileMetadataResolver.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nCompileMetadataResolver.ctorParameters = function () { return [\n    { type: CompilerConfig, },\n    { type: NgModuleResolver, },\n    { type: DirectiveResolver, },\n    { type: PipeResolver, },\n    { type: SummaryResolver, },\n    { type: ElementSchemaRegistry, },\n    { type: DirectiveNormalizer, },\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Console\"], },\n    { type: StaticSymbolCache, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\n    { type: CompileReflector, },\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [ERROR_COLLECTOR_TOKEN,] },] },\n]; };\n/**\n * @param {?} tree\n * @param {?=} out\n * @return {?}\n */\nfunction flattenArray(tree, out) {\n    if (out === void 0) { out = []; }\n    if (tree) {\n        for (var /** @type {?} */ i = 0; i < tree.length; i++) {\n            var /** @type {?} */ item = Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"resolveForwardRef\"])(tree[i]);\n            if (Array.isArray(item)) {\n                flattenArray(item, out);\n            }\n            else {\n                out.push(item);\n            }\n        }\n    }\n    return out;\n}\n/**\n * @param {?} array\n * @return {?}\n */\nfunction dedupeArray(array) {\n    if (array) {\n        return Array.from(new Set(array));\n    }\n    return [];\n}\n/**\n * @param {?} tree\n * @return {?}\n */\nfunction flattenAndDedupeArray(tree) {\n    return dedupeArray(flattenArray(tree));\n}\n/**\n * @param {?} value\n * @return {?}\n */\nfunction isValidType(value) {\n    return (value instanceof StaticSymbol) || (value instanceof __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Type\"]);\n}\n/**\n * @param {?} value\n * @param {?} targetIdentifiers\n * @return {?}\n */\nfunction extractIdentifiers(value, targetIdentifiers) {\n    visitValue(value, new _CompileValueConverter(), targetIdentifiers);\n}\nvar _CompileValueConverter = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](_CompileValueConverter, _super);\n    function _CompileValueConverter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} value\n     * @param {?} targetIdentifiers\n     * @return {?}\n     */\n    _CompileValueConverter.prototype.visitOther = function (value, targetIdentifiers) {\n        targetIdentifiers.push({ reference: value });\n    };\n    return _CompileValueConverter;\n}(ValueTransformer));\n/**\n * @param {?} type\n * @return {?}\n */\nfunction stringifyType(type) {\n    if (type instanceof StaticSymbol) {\n        return type.name + \" in \" + type.filePath;\n    }\n    else {\n        return Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"stringify\"])(type);\n    }\n}\n/**\n * Indicates that a component is still being loaded in a synchronous compile.\n * @param {?} compType\n * @return {?}\n */\nfunction componentStillLoadingError(compType) {\n    var /** @type {?} */ error = Error(\"Can't compile synchronously as \" + Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"stringify\"])(compType) + \" is still being loaded!\");\n    ((error))[__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ERROR_COMPONENT_TYPE\"]] = compType;\n    return error;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TypeModifier = {};\nTypeModifier.Const = 0;\nTypeModifier[TypeModifier.Const] = \"Const\";\n/**\n * @abstract\n */\nvar Type$1 = (function () {\n    /**\n     * @param {?=} modifiers\n     */\n    function Type$1(modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        this.modifiers = modifiers;\n        if (!modifiers) {\n            this.modifiers = [];\n        }\n    }\n    /**\n     * @abstract\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    Type$1.prototype.visitType = function (visitor, context) { };\n    /**\n     * @param {?} modifier\n     * @return {?}\n     */\n    Type$1.prototype.hasModifier = function (modifier) { return ((this.modifiers)).indexOf(modifier) !== -1; };\n    return Type$1;\n}());\nvar BuiltinTypeName = {};\nBuiltinTypeName.Dynamic = 0;\nBuiltinTypeName.Bool = 1;\nBuiltinTypeName.String = 2;\nBuiltinTypeName.Int = 3;\nBuiltinTypeName.Number = 4;\nBuiltinTypeName.Function = 5;\nBuiltinTypeName.Inferred = 6;\nBuiltinTypeName[BuiltinTypeName.Dynamic] = \"Dynamic\";\nBuiltinTypeName[BuiltinTypeName.Bool] = \"Bool\";\nBuiltinTypeName[BuiltinTypeName.String] = \"String\";\nBuiltinTypeName[BuiltinTypeName.Int] = \"Int\";\nBuiltinTypeName[BuiltinTypeName.Number] = \"Number\";\nBuiltinTypeName[BuiltinTypeName.Function] = \"Function\";\nBuiltinTypeName[BuiltinTypeName.Inferred] = \"Inferred\";\nvar BuiltinType = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](BuiltinType, _super);\n    /**\n     * @param {?} name\n     * @param {?=} modifiers\n     */\n    function BuiltinType(name, modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers) || this;\n        _this.name = name;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    BuiltinType.prototype.visitType = function (visitor, context) {\n        return visitor.visitBuiltintType(this, context);\n    };\n    return BuiltinType;\n}(Type$1));\nvar ExpressionType = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](ExpressionType, _super);\n    /**\n     * @param {?} value\n     * @param {?=} modifiers\n     */\n    function ExpressionType(value, modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers) || this;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ExpressionType.prototype.visitType = function (visitor, context) {\n        return visitor.visitExpressionType(this, context);\n    };\n    return ExpressionType;\n}(Type$1));\nvar ArrayType = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](ArrayType, _super);\n    /**\n     * @param {?} of\n     * @param {?=} modifiers\n     */\n    function ArrayType(of, modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers) || this;\n        _this.of = of;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ArrayType.prototype.visitType = function (visitor, context) {\n        return visitor.visitArrayType(this, context);\n    };\n    return ArrayType;\n}(Type$1));\nvar MapType = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MapType, _super);\n    /**\n     * @param {?} valueType\n     * @param {?=} modifiers\n     */\n    function MapType(valueType, modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers) || this;\n        _this.valueType = valueType || null;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    MapType.prototype.visitType = function (visitor, context) { return visitor.visitMapType(this, context); };\n    return MapType;\n}(Type$1));\nvar DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);\nvar INFERRED_TYPE = new BuiltinType(BuiltinTypeName.Inferred);\nvar BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);\nvar INT_TYPE = new BuiltinType(BuiltinTypeName.Int);\nvar NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);\nvar STRING_TYPE = new BuiltinType(BuiltinTypeName.String);\nvar FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);\nvar BinaryOperator = {};\nBinaryOperator.Equals = 0;\nBinaryOperator.NotEquals = 1;\nBinaryOperator.Identical = 2;\nBinaryOperator.NotIdentical = 3;\nBinaryOperator.Minus = 4;\nBinaryOperator.Plus = 5;\nBinaryOperator.Divide = 6;\nBinaryOperator.Multiply = 7;\nBinaryOperator.Modulo = 8;\nBinaryOperator.And = 9;\nBinaryOperator.Or = 10;\nBinaryOperator.Lower = 11;\nBinaryOperator.LowerEquals = 12;\nBinaryOperator.Bigger = 13;\nBinaryOperator.BiggerEquals = 14;\nBinaryOperator[BinaryOperator.Equals] = \"Equals\";\nBinaryOperator[BinaryOperator.NotEquals] = \"NotEquals\";\nBinaryOperator[BinaryOperator.Identical] = \"Identical\";\nBinaryOperator[BinaryOperator.NotIdentical] = \"NotIdentical\";\nBinaryOperator[BinaryOperator.Minus] = \"Minus\";\nBinaryOperator[BinaryOperator.Plus] = \"Plus\";\nBinaryOperator[BinaryOperator.Divide] = \"Divide\";\nBinaryOperator[BinaryOperator.Multiply] = \"Multiply\";\nBinaryOperator[BinaryOperator.Modulo] = \"Modulo\";\nBinaryOperator[BinaryOperator.And] = \"And\";\nBinaryOperator[BinaryOperator.Or] = \"Or\";\nBinaryOperator[BinaryOperator.Lower] = \"Lower\";\nBinaryOperator[BinaryOperator.LowerEquals] = \"LowerEquals\";\nBinaryOperator[BinaryOperator.Bigger] = \"Bigger\";\nBinaryOperator[BinaryOperator.BiggerEquals] = \"BiggerEquals\";\n/**\n * @abstract\n */\nvar Expression = (function () {\n    /**\n     * @param {?} type\n     * @param {?=} sourceSpan\n     */\n    function Expression(type, sourceSpan) {\n        this.type = type || null;\n        this.sourceSpan = sourceSpan || null;\n    }\n    /**\n     * @abstract\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    Expression.prototype.visitExpression = function (visitor, context) { };\n    /**\n     * @param {?} name\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.prop = function (name, sourceSpan) {\n        return new ReadPropExpr(this, name, null, sourceSpan);\n    };\n    /**\n     * @param {?} index\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.key = function (index, type, sourceSpan) {\n        return new ReadKeyExpr(this, index, type, sourceSpan);\n    };\n    /**\n     * @param {?} name\n     * @param {?} params\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.callMethod = function (name, params, sourceSpan) {\n        return new InvokeMethodExpr(this, name, params, null, sourceSpan);\n    };\n    /**\n     * @param {?} params\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.callFn = function (params, sourceSpan) {\n        return new InvokeFunctionExpr(this, params, null, sourceSpan);\n    };\n    /**\n     * @param {?} params\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.instantiate = function (params, type, sourceSpan) {\n        return new InstantiateExpr(this, params, type, sourceSpan);\n    };\n    /**\n     * @param {?} trueCase\n     * @param {?=} falseCase\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.conditional = function (trueCase, falseCase, sourceSpan) {\n        if (falseCase === void 0) { falseCase = null; }\n        return new ConditionalExpr(this, trueCase, falseCase, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.equals = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.notEquals = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.identical = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.notIdentical = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.minus = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.plus = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.divide = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.multiply = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.modulo = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.and = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.And, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.or = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.lower = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.lowerEquals = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.bigger = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.biggerEquals = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.isBlank = function (sourceSpan) {\n        // Note: We use equals by purpose here to compare to null and undefined in JS.\n        // We use the typed null to allow strictNullChecks to narrow types.\n        return this.equals(TYPED_NULL_EXPR, sourceSpan);\n    };\n    /**\n     * @param {?} type\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.cast = function (type, sourceSpan) {\n        return new CastExpr(this, type, sourceSpan);\n    };\n    /**\n     * @return {?}\n     */\n    Expression.prototype.toStmt = function () { return new ExpressionStatement(this, null); };\n    return Expression;\n}());\nvar BuiltinVar = {};\nBuiltinVar.This = 0;\nBuiltinVar.Super = 1;\nBuiltinVar.CatchError = 2;\nBuiltinVar.CatchStack = 3;\nBuiltinVar[BuiltinVar.This] = \"This\";\nBuiltinVar[BuiltinVar.Super] = \"Super\";\nBuiltinVar[BuiltinVar.CatchError] = \"CatchError\";\nBuiltinVar[BuiltinVar.CatchStack] = \"CatchStack\";\nvar ReadVarExpr = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](ReadVarExpr, _super);\n    /**\n     * @param {?} name\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function ReadVarExpr(name, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        if (typeof name === 'string') {\n            _this.name = name;\n            _this.builtin = null;\n        }\n        else {\n            _this.name = null;\n            _this.builtin = name;\n        }\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ReadVarExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitReadVarExpr(this, context);\n    };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ReadVarExpr.prototype.set = function (value) {\n        if (!this.name) {\n            throw new Error(\"Built in variable \" + this.builtin + \" can not be assigned to.\");\n        }\n        return new WriteVarExpr(this.name, value, null, this.sourceSpan);\n    };\n    return ReadVarExpr;\n}(Expression));\nvar WriteVarExpr = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](WriteVarExpr, _super);\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function WriteVarExpr(name, value, type, sourceSpan) {\n        var _this = _super.call(this, type || value.type, sourceSpan) || this;\n        _this.name = name;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    WriteVarExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitWriteVarExpr(this, context);\n    };\n    /**\n     * @param {?=} type\n     * @param {?=} modifiers\n     * @return {?}\n     */\n    WriteVarExpr.prototype.toDeclStmt = function (type, modifiers) {\n        return new DeclareVarStmt(this.name, this.value, type, modifiers, this.sourceSpan);\n    };\n    return WriteVarExpr;\n}(Expression));\nvar WriteKeyExpr = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](WriteKeyExpr, _super);\n    /**\n     * @param {?} receiver\n     * @param {?} index\n     * @param {?} value\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function WriteKeyExpr(receiver, index, value, type, sourceSpan) {\n        var _this = _super.call(this, type || value.type, sourceSpan) || this;\n        _this.receiver = receiver;\n        _this.index = index;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    WriteKeyExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitWriteKeyExpr(this, context);\n    };\n    return WriteKeyExpr;\n}(Expression));\nvar WritePropExpr = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](WritePropExpr, _super);\n    /**\n     * @param {?} receiver\n     * @param {?} name\n     * @param {?} value\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function WritePropExpr(receiver, name, value, type, sourceSpan) {\n        var _this = _super.call(this, type || value.type, sourceSpan) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    WritePropExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitWritePropExpr(this, context);\n    };\n    return WritePropExpr;\n}(Expression));\nvar BuiltinMethod = {};\nBuiltinMethod.ConcatArray = 0;\nBuiltinMethod.SubscribeObservable = 1;\nBuiltinMethod.Bind = 2;\nBuiltinMethod[BuiltinMethod.ConcatArray] = \"ConcatArray\";\nBuiltinMethod[BuiltinMethod.SubscribeObservable] = \"SubscribeObservable\";\nBuiltinMethod[BuiltinMethod.Bind] = \"Bind\";\nvar InvokeMethodExpr = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](InvokeMethodExpr, _super);\n    /**\n     * @param {?} receiver\n     * @param {?} method\n     * @param {?} args\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function InvokeMethodExpr(receiver, method, args, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.receiver = receiver;\n        _this.args = args;\n        if (typeof method === 'string') {\n            _this.name = method;\n            _this.builtin = null;\n        }\n        else {\n            _this.name = null;\n            _this.builtin = method;\n        }\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    InvokeMethodExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitInvokeMethodExpr(this, context);\n    };\n    return InvokeMethodExpr;\n}(Expression));\nvar InvokeFunctionExpr = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](InvokeFunctionExpr, _super);\n    /**\n     * @param {?} fn\n     * @param {?} args\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function InvokeFunctionExpr(fn, args, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.fn = fn;\n        _this.args = args;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    InvokeFunctionExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitInvokeFunctionExpr(this, context);\n    };\n    return InvokeFunctionExpr;\n}(Expression));\nvar InstantiateExpr = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](InstantiateExpr, _super);\n    /**\n     * @param {?} classExpr\n     * @param {?} args\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function InstantiateExpr(classExpr, args, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.classExpr = classExpr;\n        _this.args = args;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    InstantiateExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitInstantiateExpr(this, context);\n    };\n    return InstantiateExpr;\n}(Expression));\nvar LiteralExpr = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](LiteralExpr, _super);\n    /**\n     * @param {?} value\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function LiteralExpr(value, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    LiteralExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitLiteralExpr(this, context);\n    };\n    return LiteralExpr;\n}(Expression));\nvar ExternalExpr = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](ExternalExpr, _super);\n    /**\n     * @param {?} value\n     * @param {?=} type\n     * @param {?=} typeParams\n     * @param {?=} sourceSpan\n     */\n    function ExternalExpr(value, type, typeParams, sourceSpan) {\n        if (typeParams === void 0) { typeParams = null; }\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.value = value;\n        _this.typeParams = typeParams;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ExternalExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitExternalExpr(this, context);\n    };\n    return ExternalExpr;\n}(Expression));\nvar ExternalReference = (function () {\n    /**\n     * @param {?} moduleName\n     * @param {?} name\n     * @param {?} runtime\n     */\n    function ExternalReference(moduleName, name, runtime) {\n        this.moduleName = moduleName;\n        this.name = name;\n        this.runtime = runtime;\n    }\n    return ExternalReference;\n}());\nvar ConditionalExpr = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](ConditionalExpr, _super);\n    /**\n     * @param {?} condition\n     * @param {?} trueCase\n     * @param {?=} falseCase\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function ConditionalExpr(condition, trueCase, falseCase, type, sourceSpan) {\n        if (falseCase === void 0) { falseCase = null; }\n        var _this = _super.call(this, type || trueCase.type, sourceSpan) || this;\n        _this.condition = condition;\n        _this.falseCase = falseCase;\n        _this.trueCase = trueCase;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ConditionalExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitConditionalExpr(this, context);\n    };\n    return ConditionalExpr;\n}(Expression));\nvar NotExpr = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](NotExpr, _super);\n    /**\n     * @param {?} condition\n     * @param {?=} sourceSpan\n     */\n    function NotExpr(condition, sourceSpan) {\n        var _this = _super.call(this, BOOL_TYPE, sourceSpan) || this;\n        _this.condition = condition;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    NotExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitNotExpr(this, context);\n    };\n    return NotExpr;\n}(Expression));\nvar AssertNotNull = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](AssertNotNull, _super);\n    /**\n     * @param {?} condition\n     * @param {?=} sourceSpan\n     */\n    function AssertNotNull(condition, sourceSpan) {\n        var _this = _super.call(this, condition.type, sourceSpan) || this;\n        _this.condition = condition;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    AssertNotNull.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitAssertNotNullExpr(this, context);\n    };\n    return AssertNotNull;\n}(Expression));\nvar CastExpr = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](CastExpr, _super);\n    /**\n     * @param {?} value\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function CastExpr(value, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    CastExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitCastExpr(this, context);\n    };\n    return CastExpr;\n}(Expression));\nvar FnParam = (function () {\n    /**\n     * @param {?} name\n     * @param {?=} type\n     */\n    function FnParam(name, type) {\n        if (type === void 0) { type = null; }\n        this.name = name;\n        this.type = type;\n    }\n    return FnParam;\n}());\nvar FunctionExpr = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](FunctionExpr, _super);\n    /**\n     * @param {?} params\n     * @param {?} statements\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function FunctionExpr(params, statements, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.params = params;\n        _this.statements = statements;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    FunctionExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitFunctionExpr(this, context);\n    };\n    /**\n     * @param {?} name\n     * @param {?=} modifiers\n     * @return {?}\n     */\n    FunctionExpr.prototype.toDeclStmt = function (name, modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        return new DeclareFunctionStmt(name, this.params, this.statements, this.type, modifiers, this.sourceSpan);\n    };\n    return FunctionExpr;\n}(Expression));\nvar BinaryOperatorExpr = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](BinaryOperatorExpr, _super);\n    /**\n     * @param {?} operator\n     * @param {?} lhs\n     * @param {?} rhs\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function BinaryOperatorExpr(operator, lhs, rhs, type, sourceSpan) {\n        var _this = _super.call(this, type || lhs.type, sourceSpan) || this;\n        _this.operator = operator;\n        _this.rhs = rhs;\n        _this.lhs = lhs;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    BinaryOperatorExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitBinaryOperatorExpr(this, context);\n    };\n    return BinaryOperatorExpr;\n}(Expression));\nvar ReadPropExpr = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](ReadPropExpr, _super);\n    /**\n     * @param {?} receiver\n     * @param {?} name\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function ReadPropExpr(receiver, name, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ReadPropExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitReadPropExpr(this, context);\n    };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ReadPropExpr.prototype.set = function (value) {\n        return new WritePropExpr(this.receiver, this.name, value, null, this.sourceSpan);\n    };\n    return ReadPropExpr;\n}(Expression));\nvar ReadKeyExpr = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](ReadKeyExpr, _super);\n    /**\n     * @param {?} receiver\n     * @param {?} index\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function ReadKeyExpr(receiver, index, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.receiver = receiver;\n        _this.index = index;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ReadKeyExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitReadKeyExpr(this, context);\n    };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ReadKeyExpr.prototype.set = function (value) {\n        return new WriteKeyExpr(this.receiver, this.index, value, null, this.sourceSpan);\n    };\n    return ReadKeyExpr;\n}(Expression));\nvar LiteralArrayExpr = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](LiteralArrayExpr, _super);\n    /**\n     * @param {?} entries\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function LiteralArrayExpr(entries, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.entries = entries;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    LiteralArrayExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitLiteralArrayExpr(this, context);\n    };\n    return LiteralArrayExpr;\n}(Expression));\nvar LiteralMapEntry = (function () {\n    /**\n     * @param {?} key\n     * @param {?} value\n     * @param {?} quoted\n     */\n    function LiteralMapEntry(key, value, quoted) {\n        this.key = key;\n        this.value = value;\n        this.quoted = quoted;\n    }\n    return LiteralMapEntry;\n}());\nvar LiteralMapExpr = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](LiteralMapExpr, _super);\n    /**\n     * @param {?} entries\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function LiteralMapExpr(entries, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.entries = entries;\n        _this.valueType = null;\n        if (type) {\n            _this.valueType = type.valueType;\n        }\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    LiteralMapExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitLiteralMapExpr(this, context);\n    };\n    return LiteralMapExpr;\n}(Expression));\nvar CommaExpr = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](CommaExpr, _super);\n    /**\n     * @param {?} parts\n     * @param {?=} sourceSpan\n     */\n    function CommaExpr(parts, sourceSpan) {\n        var _this = _super.call(this, parts[parts.length - 1].type, sourceSpan) || this;\n        _this.parts = parts;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    CommaExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitCommaExpr(this, context);\n    };\n    return CommaExpr;\n}(Expression));\nvar THIS_EXPR = new ReadVarExpr(BuiltinVar.This, null, null);\nvar SUPER_EXPR = new ReadVarExpr(BuiltinVar.Super, null, null);\nvar CATCH_ERROR_VAR = new ReadVarExpr(BuiltinVar.CatchError, null, null);\nvar CATCH_STACK_VAR = new ReadVarExpr(BuiltinVar.CatchStack, null, null);\nvar NULL_EXPR = new LiteralExpr(null, null, null);\nvar TYPED_NULL_EXPR = new LiteralExpr(null, INFERRED_TYPE, null);\nvar StmtModifier = {};\nStmtModifier.Final = 0;\nStmtModifier.Private = 1;\nStmtModifier.Exported = 2;\nStmtModifier[StmtModifier.Final] = \"Final\";\nStmtModifier[StmtModifier.Private] = \"Private\";\nStmtModifier[StmtModifier.Exported] = \"Exported\";\n/**\n * @abstract\n */\nvar Statement = (function () {\n    /**\n     * @param {?=} modifiers\n     * @param {?=} sourceSpan\n     */\n    function Statement(modifiers, sourceSpan) {\n        this.modifiers = modifiers || [];\n        this.sourceSpan = sourceSpan || null;\n    }\n    /**\n     * @abstract\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    Statement.prototype.visitStatement = function (visitor, context) { };\n    /**\n     * @param {?} modifier\n     * @return {?}\n     */\n    Statement.prototype.hasModifier = function (modifier) { return ((this.modifiers)).indexOf(modifier) !== -1; };\n    return Statement;\n}());\nvar DeclareVarStmt = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](DeclareVarStmt, _super);\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?=} type\n     * @param {?=} modifiers\n     * @param {?=} sourceSpan\n     */\n    function DeclareVarStmt(name, value, type, modifiers, sourceSpan) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers, sourceSpan) || this;\n        _this.name = name;\n        _this.value = value;\n        _this.type = type || value.type;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    DeclareVarStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitDeclareVarStmt(this, context);\n    };\n    return DeclareVarStmt;\n}(Statement));\nvar DeclareFunctionStmt = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](DeclareFunctionStmt, _super);\n    /**\n     * @param {?} name\n     * @param {?} params\n     * @param {?} statements\n     * @param {?=} type\n     * @param {?=} modifiers\n     * @param {?=} sourceSpan\n     */\n    function DeclareFunctionStmt(name, params, statements, type, modifiers, sourceSpan) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers, sourceSpan) || this;\n        _this.name = name;\n        _this.params = params;\n        _this.statements = statements;\n        _this.type = type || null;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    DeclareFunctionStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitDeclareFunctionStmt(this, context);\n    };\n    return DeclareFunctionStmt;\n}(Statement));\nvar ExpressionStatement = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](ExpressionStatement, _super);\n    /**\n     * @param {?} expr\n     * @param {?=} sourceSpan\n     */\n    function ExpressionStatement(expr, sourceSpan) {\n        var _this = _super.call(this, null, sourceSpan) || this;\n        _this.expr = expr;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ExpressionStatement.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitExpressionStmt(this, context);\n    };\n    return ExpressionStatement;\n}(Statement));\nvar ReturnStatement = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](ReturnStatement, _super);\n    /**\n     * @param {?} value\n     * @param {?=} sourceSpan\n     */\n    function ReturnStatement(value, sourceSpan) {\n        var _this = _super.call(this, null, sourceSpan) || this;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ReturnStatement.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitReturnStmt(this, context);\n    };\n    return ReturnStatement;\n}(Statement));\nvar AbstractClassPart = (function () {\n    /**\n     * @param {?} type\n     * @param {?} modifiers\n     */\n    function AbstractClassPart(type, modifiers) {\n        this.modifiers = modifiers;\n        if (!modifiers) {\n            this.modifiers = [];\n        }\n        this.type = type || null;\n    }\n    /**\n     * @param {?} modifier\n     * @return {?}\n     */\n    AbstractClassPart.prototype.hasModifier = function (modifier) { return ((this.modifiers)).indexOf(modifier) !== -1; };\n    return AbstractClassPart;\n}());\nvar ClassMethod = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](ClassMethod, _super);\n    /**\n     * @param {?} name\n     * @param {?} params\n     * @param {?} body\n     * @param {?=} type\n     * @param {?=} modifiers\n     */\n    function ClassMethod(name, params, body, type, modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, type, modifiers) || this;\n        _this.name = name;\n        _this.params = params;\n        _this.body = body;\n        return _this;\n    }\n    return ClassMethod;\n}(AbstractClassPart));\nvar ClassGetter = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](ClassGetter, _super);\n    /**\n     * @param {?} name\n     * @param {?} body\n     * @param {?=} type\n     * @param {?=} modifiers\n     */\n    function ClassGetter(name, body, type, modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, type, modifiers) || this;\n        _this.name = name;\n        _this.body = body;\n        return _this;\n    }\n    return ClassGetter;\n}(AbstractClassPart));\nvar ClassStmt = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](ClassStmt, _super);\n    /**\n     * @param {?} name\n     * @param {?} parent\n     * @param {?} fields\n     * @param {?} getters\n     * @param {?} constructorMethod\n     * @param {?} methods\n     * @param {?=} modifiers\n     * @param {?=} sourceSpan\n     */\n    function ClassStmt(name, parent, fields, getters, constructorMethod, methods, modifiers, sourceSpan) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers, sourceSpan) || this;\n        _this.name = name;\n        _this.parent = parent;\n        _this.fields = fields;\n        _this.getters = getters;\n        _this.constructorMethod = constructorMethod;\n        _this.methods = methods;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ClassStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitDeclareClassStmt(this, context);\n    };\n    return ClassStmt;\n}(Statement));\nvar IfStmt = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](IfStmt, _super);\n    /**\n     * @param {?} condition\n     * @param {?} trueCase\n     * @param {?=} falseCase\n     * @param {?=} sourceSpan\n     */\n    function IfStmt(condition, trueCase, falseCase, sourceSpan) {\n        if (falseCase === void 0) { falseCase = []; }\n        var _this = _super.call(this, null, sourceSpan) || this;\n        _this.condition = condition;\n        _this.trueCase = trueCase;\n        _this.falseCase = falseCase;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    IfStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitIfStmt(this, context);\n    };\n    return IfStmt;\n}(Statement));\nvar CommentStmt = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](CommentStmt, _super);\n    /**\n     * @param {?} comment\n     * @param {?=} sourceSpan\n     */\n    function CommentStmt(comment, sourceSpan) {\n        var _this = _super.call(this, null, sourceSpan) || this;\n        _this.comment = comment;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    CommentStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitCommentStmt(this, context);\n    };\n    return CommentStmt;\n}(Statement));\nvar TryCatchStmt = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](TryCatchStmt, _super);\n    /**\n     * @param {?} bodyStmts\n     * @param {?} catchStmts\n     * @param {?=} sourceSpan\n     */\n    function TryCatchStmt(bodyStmts, catchStmts, sourceSpan) {\n        var _this = _super.call(this, null, sourceSpan) || this;\n        _this.bodyStmts = bodyStmts;\n        _this.catchStmts = catchStmts;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    TryCatchStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitTryCatchStmt(this, context);\n    };\n    return TryCatchStmt;\n}(Statement));\nvar ThrowStmt = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](ThrowStmt, _super);\n    /**\n     * @param {?} error\n     * @param {?=} sourceSpan\n     */\n    function ThrowStmt(error, sourceSpan) {\n        var _this = _super.call(this, null, sourceSpan) || this;\n        _this.error = error;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ThrowStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitThrowStmt(this, context);\n    };\n    return ThrowStmt;\n}(Statement));\nvar AstTransformer$1 = (function () {\n    function AstTransformer$1() {\n    }\n    /**\n     * @param {?} expr\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.transformExpr = function (expr, context) { return expr; };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.transformStmt = function (stmt, context) { return stmt; };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitReadVarExpr = function (ast, context) { return this.transformExpr(ast, context); };\n    /**\n     * @param {?} expr\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitWriteVarExpr = function (expr, context) {\n        return this.transformExpr(new WriteVarExpr(expr.name, expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);\n    };\n    /**\n     * @param {?} expr\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitWriteKeyExpr = function (expr, context) {\n        return this.transformExpr(new WriteKeyExpr(expr.receiver.visitExpression(this, context), expr.index.visitExpression(this, context), expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);\n    };\n    /**\n     * @param {?} expr\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitWritePropExpr = function (expr, context) {\n        return this.transformExpr(new WritePropExpr(expr.receiver.visitExpression(this, context), expr.name, expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitInvokeMethodExpr = function (ast, context) {\n        var /** @type {?} */ method = ast.builtin || ast.name;\n        return this.transformExpr(new InvokeMethodExpr(ast.receiver.visitExpression(this, context), /** @type {?} */ ((method)), this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitInvokeFunctionExpr = function (ast, context) {\n        return this.transformExpr(new InvokeFunctionExpr(ast.fn.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitInstantiateExpr = function (ast, context) {\n        return this.transformExpr(new InstantiateExpr(ast.classExpr.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitLiteralExpr = function (ast, context) { return this.transformExpr(ast, context); };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitExternalExpr = function (ast, context) {\n        return this.transformExpr(ast, context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitConditionalExpr = function (ast, context) {\n        return this.transformExpr(new ConditionalExpr(ast.condition.visitExpression(this, context), ast.trueCase.visitExpression(this, context), /** @type {?} */ ((ast.falseCase)).visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitNotExpr = function (ast, context) {\n        return this.transformExpr(new NotExpr(ast.condition.visitExpression(this, context), ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitAssertNotNullExpr = function (ast, context) {\n        return this.transformExpr(new AssertNotNull(ast.condition.visitExpression(this, context), ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitCastExpr = function (ast, context) {\n        return this.transformExpr(new CastExpr(ast.value.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitFunctionExpr = function (ast, context) {\n        return this.transformExpr(new FunctionExpr(ast.params, this.visitAllStatements(ast.statements, context), ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitBinaryOperatorExpr = function (ast, context) {\n        return this.transformExpr(new BinaryOperatorExpr(ast.operator, ast.lhs.visitExpression(this, context), ast.rhs.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitReadPropExpr = function (ast, context) {\n        return this.transformExpr(new ReadPropExpr(ast.receiver.visitExpression(this, context), ast.name, ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitReadKeyExpr = function (ast, context) {\n        return this.transformExpr(new ReadKeyExpr(ast.receiver.visitExpression(this, context), ast.index.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitLiteralArrayExpr = function (ast, context) {\n        return this.transformExpr(new LiteralArrayExpr(this.visitAllExpressions(ast.entries, context), ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitLiteralMapExpr = function (ast, context) {\n        var _this = this;\n        var /** @type {?} */ entries = ast.entries.map(function (entry) { return new LiteralMapEntry(entry.key, entry.value.visitExpression(_this, context), entry.quoted); });\n        var /** @type {?} */ mapType = new MapType(ast.valueType, null);\n        return this.transformExpr(new LiteralMapExpr(entries, mapType, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitCommaExpr = function (ast, context) {\n        return this.transformExpr(new CommaExpr(this.visitAllExpressions(ast.parts, context), ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} exprs\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitAllExpressions = function (exprs, context) {\n        var _this = this;\n        return exprs.map(function (expr) { return expr.visitExpression(_this, context); });\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitDeclareVarStmt = function (stmt, context) {\n        return this.transformStmt(new DeclareVarStmt(stmt.name, stmt.value.visitExpression(this, context), stmt.type, stmt.modifiers, stmt.sourceSpan), context);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitDeclareFunctionStmt = function (stmt, context) {\n        return this.transformStmt(new DeclareFunctionStmt(stmt.name, stmt.params, this.visitAllStatements(stmt.statements, context), stmt.type, stmt.modifiers, stmt.sourceSpan), context);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitExpressionStmt = function (stmt, context) {\n        return this.transformStmt(new ExpressionStatement(stmt.expr.visitExpression(this, context), stmt.sourceSpan), context);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitReturnStmt = function (stmt, context) {\n        return this.transformStmt(new ReturnStatement(stmt.value.visitExpression(this, context), stmt.sourceSpan), context);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitDeclareClassStmt = function (stmt, context) {\n        var _this = this;\n        var /** @type {?} */ parent = ((stmt.parent)).visitExpression(this, context);\n        var /** @type {?} */ getters = stmt.getters.map(function (getter) { return new ClassGetter(getter.name, _this.visitAllStatements(getter.body, context), getter.type, getter.modifiers); });\n        var /** @type {?} */ ctorMethod = stmt.constructorMethod &&\n            new ClassMethod(stmt.constructorMethod.name, stmt.constructorMethod.params, this.visitAllStatements(stmt.constructorMethod.body, context), stmt.constructorMethod.type, stmt.constructorMethod.modifiers);\n        var /** @type {?} */ methods = stmt.methods.map(function (method) { return new ClassMethod(method.name, method.params, _this.visitAllStatements(method.body, context), method.type, method.modifiers); });\n        return this.transformStmt(new ClassStmt(stmt.name, parent, stmt.fields, getters, ctorMethod, methods, stmt.modifiers, stmt.sourceSpan), context);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitIfStmt = function (stmt, context) {\n        return this.transformStmt(new IfStmt(stmt.condition.visitExpression(this, context), this.visitAllStatements(stmt.trueCase, context), this.visitAllStatements(stmt.falseCase, context), stmt.sourceSpan), context);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitTryCatchStmt = function (stmt, context) {\n        return this.transformStmt(new TryCatchStmt(this.visitAllStatements(stmt.bodyStmts, context), this.visitAllStatements(stmt.catchStmts, context), stmt.sourceSpan), context);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitThrowStmt = function (stmt, context) {\n        return this.transformStmt(new ThrowStmt(stmt.error.visitExpression(this, context), stmt.sourceSpan), context);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitCommentStmt = function (stmt, context) {\n        return this.transformStmt(stmt, context);\n    };\n    /**\n     * @param {?} stmts\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitAllStatements = function (stmts, context) {\n        var _this = this;\n        return stmts.map(function (stmt) { return stmt.visitStatement(_this, context); });\n    };\n    return AstTransformer$1;\n}());\nvar RecursiveAstVisitor$1 = (function () {\n    function RecursiveAstVisitor$1() {\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitReadVarExpr = function (ast, context) { return ast; };\n    /**\n     * @param {?} expr\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitWriteVarExpr = function (expr, context) {\n        expr.value.visitExpression(this, context);\n        return expr;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitWriteKeyExpr = function (expr, context) {\n        expr.receiver.visitExpression(this, context);\n        expr.index.visitExpression(this, context);\n        expr.value.visitExpression(this, context);\n        return expr;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitWritePropExpr = function (expr, context) {\n        expr.receiver.visitExpression(this, context);\n        expr.value.visitExpression(this, context);\n        return expr;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitInvokeMethodExpr = function (ast, context) {\n        ast.receiver.visitExpression(this, context);\n        this.visitAllExpressions(ast.args, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitInvokeFunctionExpr = function (ast, context) {\n        ast.fn.visitExpression(this, context);\n        this.visitAllExpressions(ast.args, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitInstantiateExpr = function (ast, context) {\n        ast.classExpr.visitExpression(this, context);\n        this.visitAllExpressions(ast.args, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitLiteralExpr = function (ast, context) { return ast; };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitExternalExpr = function (ast, context) { return ast; };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitConditionalExpr = function (ast, context) {\n        ast.condition.visitExpression(this, context);\n        ast.trueCase.visitExpression(this, context); /** @type {?} */\n        ((ast.falseCase)).visitExpression(this, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitNotExpr = function (ast, context) {\n        ast.condition.visitExpression(this, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitAssertNotNullExpr = function (ast, context) {\n        ast.condition.visitExpression(this, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitCastExpr = function (ast, context) {\n        ast.value.visitExpression(this, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitFunctionExpr = function (ast, context) {\n        this.visitAllStatements(ast.statements, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitBinaryOperatorExpr = function (ast, context) {\n        ast.lhs.visitExpression(this, context);\n        ast.rhs.visitExpression(this, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitReadPropExpr = function (ast, context) {\n        ast.receiver.visitExpression(this, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitReadKeyExpr = function (ast, context) {\n        ast.receiver.visitExpression(this, context);\n        ast.index.visitExpression(this, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitLiteralArrayExpr = function (ast, context) {\n        this.visitAllExpressions(ast.entries, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitLiteralMapExpr = function (ast, context) {\n        var _this = this;\n        ast.entries.forEach(function (entry) { return entry.value.visitExpression(_this, context); });\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitCommaExpr = function (ast, context) {\n        this.visitAllExpressions(ast.parts, context);\n    };\n    /**\n     * @param {?} exprs\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitAllExpressions = function (exprs, context) {\n        var _this = this;\n        exprs.forEach(function (expr) { return expr.visitExpression(_this, context); });\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitDeclareVarStmt = function (stmt, context) {\n        stmt.value.visitExpression(this, context);\n        return stmt;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitDeclareFunctionStmt = function (stmt, context) {\n        this.visitAllStatements(stmt.statements, context);\n        return stmt;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitExpressionStmt = function (stmt, context) {\n        stmt.expr.visitExpression(this, context);\n        return stmt;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitReturnStmt = function (stmt, context) {\n        stmt.value.visitExpression(this, context);\n        return stmt;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitDeclareClassStmt = function (stmt, context) {\n        var _this = this;\n        ((stmt.parent)).visitExpression(this, context);\n        stmt.getters.forEach(function (getter) { return _this.visitAllStatements(getter.body, context); });\n        if (stmt.constructorMethod) {\n            this.visitAllStatements(stmt.constructorMethod.body, context);\n        }\n        stmt.methods.forEach(function (method) { return _this.visitAllStatements(method.body, context); });\n        return stmt;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitIfStmt = function (stmt, context) {\n        stmt.condition.visitExpression(this, context);\n        this.visitAllStatements(stmt.trueCase, context);\n        this.visitAllStatements(stmt.falseCase, context);\n        return stmt;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitTryCatchStmt = function (stmt, context) {\n        this.visitAllStatements(stmt.bodyStmts, context);\n        this.visitAllStatements(stmt.catchStmts, context);\n        return stmt;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitThrowStmt = function (stmt, context) {\n        stmt.error.visitExpression(this, context);\n        return stmt;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitCommentStmt = function (stmt, context) { return stmt; };\n    /**\n     * @param {?} stmts\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitAllStatements = function (stmts, context) {\n        var _this = this;\n        stmts.forEach(function (stmt) { return stmt.visitStatement(_this, context); });\n    };\n    return RecursiveAstVisitor$1;\n}());\n/**\n * @param {?} stmts\n * @return {?}\n */\nfunction findReadVarNames(stmts) {\n    var /** @type {?} */ visitor = new _ReadVarVisitor();\n    visitor.visitAllStatements(stmts, null);\n    return visitor.varNames;\n}\nvar _ReadVarVisitor = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](_ReadVarVisitor, _super);\n    function _ReadVarVisitor() {\n        var _this = _super.apply(this, arguments) || this;\n        _this.varNames = new Set();\n        return _this;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    _ReadVarVisitor.prototype.visitDeclareFunctionStmt = function (stmt, context) {\n        // Don't descend into nested functions\n        return stmt;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    _ReadVarVisitor.prototype.visitDeclareClassStmt = function (stmt, context) {\n        // Don't descend into nested classes\n        return stmt;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    _ReadVarVisitor.prototype.visitReadVarExpr = function (ast, context) {\n        if (ast.name) {\n            this.varNames.add(ast.name);\n        }\n        return null;\n    };\n    return _ReadVarVisitor;\n}(RecursiveAstVisitor$1));\n/**\n * @param {?} stmt\n * @param {?} sourceSpan\n * @return {?}\n */\nfunction applySourceSpanToStatementIfNeeded(stmt, sourceSpan) {\n    if (!sourceSpan) {\n        return stmt;\n    }\n    var /** @type {?} */ transformer = new _ApplySourceSpanTransformer(sourceSpan);\n    return stmt.visitStatement(transformer, null);\n}\n/**\n * @param {?} expr\n * @param {?} sourceSpan\n * @return {?}\n */\nfunction applySourceSpanToExpressionIfNeeded(expr, sourceSpan) {\n    if (!sourceSpan) {\n        return expr;\n    }\n    var /** @type {?} */ transformer = new _ApplySourceSpanTransformer(sourceSpan);\n    return expr.visitExpression(transformer, null);\n}\nvar _ApplySourceSpanTransformer = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](_ApplySourceSpanTransformer, _super);\n    /**\n     * @param {?} sourceSpan\n     */\n    function _ApplySourceSpanTransformer(sourceSpan) {\n        var _this = _super.call(this) || this;\n        _this.sourceSpan = sourceSpan;\n        return _this;\n    }\n    /**\n     * @param {?} obj\n     * @return {?}\n     */\n    _ApplySourceSpanTransformer.prototype._clone = function (obj) {\n        var /** @type {?} */ clone = Object.create(obj.constructor.prototype);\n        for (var /** @type {?} */ prop in obj) {\n            clone[prop] = obj[prop];\n        }\n        return clone;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} context\n     * @return {?}\n     */\n    _ApplySourceSpanTransformer.prototype.transformExpr = function (expr, context) {\n        if (!expr.sourceSpan) {\n            expr = this._clone(expr);\n            expr.sourceSpan = this.sourceSpan;\n        }\n        return expr;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    _ApplySourceSpanTransformer.prototype.transformStmt = function (stmt, context) {\n        if (!stmt.sourceSpan) {\n            stmt = this._clone(stmt);\n            stmt.sourceSpan = this.sourceSpan;\n        }\n        return stmt;\n    };\n    return _ApplySourceSpanTransformer;\n}(AstTransformer$1));\n/**\n * @param {?} name\n * @param {?=} type\n * @param {?=} sourceSpan\n * @return {?}\n */\nfunction variable(name, type, sourceSpan) {\n    return new ReadVarExpr(name, type, sourceSpan);\n}\n/**\n * @param {?} id\n * @param {?=} typeParams\n * @param {?=} sourceSpan\n * @return {?}\n */\nfunction importExpr(id, typeParams, sourceSpan) {\n    if (typeParams === void 0) { typeParams = null; }\n    return new ExternalExpr(id, null, typeParams, sourceSpan);\n}\n/**\n * @param {?} id\n * @param {?=} typeParams\n * @param {?=} typeModifiers\n * @return {?}\n */\nfunction importType(id, typeParams, typeModifiers) {\n    if (typeParams === void 0) { typeParams = null; }\n    if (typeModifiers === void 0) { typeModifiers = null; }\n    return id != null ? expressionType(importExpr(id, typeParams, null), typeModifiers) : null;\n}\n/**\n * @param {?} expr\n * @param {?=} typeModifiers\n * @return {?}\n */\nfunction expressionType(expr, typeModifiers) {\n    if (typeModifiers === void 0) { typeModifiers = null; }\n    return expr != null ? ((new ExpressionType(expr, typeModifiers))) : null;\n}\n/**\n * @param {?} values\n * @param {?=} type\n * @param {?=} sourceSpan\n * @return {?}\n */\nfunction literalArr(values, type, sourceSpan) {\n    return new LiteralArrayExpr(values, type, sourceSpan);\n}\n/**\n * @param {?} values\n * @param {?=} type\n * @return {?}\n */\nfunction literalMap(values, type) {\n    if (type === void 0) { type = null; }\n    return new LiteralMapExpr(values.map(function (e) { return new LiteralMapEntry(e.key, e.value, e.quoted); }), type, null);\n}\n/**\n * @param {?} expr\n * @param {?=} sourceSpan\n * @return {?}\n */\nfunction not(expr, sourceSpan) {\n    return new NotExpr(expr, sourceSpan);\n}\n/**\n * @param {?} expr\n * @param {?=} sourceSpan\n * @return {?}\n */\nfunction assertNotNull(expr, sourceSpan) {\n    return new AssertNotNull(expr, sourceSpan);\n}\n/**\n * @param {?} params\n * @param {?} body\n * @param {?=} type\n * @param {?=} sourceSpan\n * @return {?}\n */\nfunction fn(params, body, type, sourceSpan) {\n    return new FunctionExpr(params, body, type, sourceSpan);\n}\n/**\n * @param {?} value\n * @param {?=} type\n * @param {?=} sourceSpan\n * @return {?}\n */\nfunction literal(value, type, sourceSpan) {\n    return new LiteralExpr(value, type, sourceSpan);\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar QUOTED_KEYS = '$quoted$';\n/**\n * @param {?} ctx\n * @param {?} value\n * @param {?=} type\n * @return {?}\n */\nfunction convertValueToOutputAst(ctx, value, type) {\n    if (type === void 0) { type = null; }\n    return visitValue(value, new _ValueOutputAstTransformer(ctx), type);\n}\nvar _ValueOutputAstTransformer = (function () {\n    /**\n     * @param {?} ctx\n     */\n    function _ValueOutputAstTransformer(ctx) {\n        this.ctx = ctx;\n    }\n    /**\n     * @param {?} arr\n     * @param {?} type\n     * @return {?}\n     */\n    _ValueOutputAstTransformer.prototype.visitArray = function (arr, type) {\n        var _this = this;\n        return literalArr(arr.map(function (value) { return visitValue(value, _this, null); }), type);\n    };\n    /**\n     * @param {?} map\n     * @param {?} type\n     * @return {?}\n     */\n    _ValueOutputAstTransformer.prototype.visitStringMap = function (map, type) {\n        var _this = this;\n        var /** @type {?} */ entries = [];\n        var /** @type {?} */ quotedSet = new Set(map && map[QUOTED_KEYS]);\n        Object.keys(map).forEach(function (key) {\n            entries.push(new LiteralMapEntry(key, visitValue(map[key], _this, null), quotedSet.has(key)));\n        });\n        return new LiteralMapExpr(entries, type);\n    };\n    /**\n     * @param {?} value\n     * @param {?} type\n     * @return {?}\n     */\n    _ValueOutputAstTransformer.prototype.visitPrimitive = function (value, type) { return literal(value, type); };\n    /**\n     * @param {?} value\n     * @param {?} type\n     * @return {?}\n     */\n    _ValueOutputAstTransformer.prototype.visitOther = function (value, type) {\n        if (value instanceof Expression) {\n            return value;\n        }\n        else {\n            return this.ctx.importExpr(value);\n        }\n    };\n    return _ValueOutputAstTransformer;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} ctx\n * @param {?} providerAst\n * @return {?}\n */\nfunction providerDef(ctx, providerAst) {\n    var /** @type {?} */ flags = 0;\n    if (!providerAst.eager) {\n        flags |= 4096 /* LazyProvider */;\n    }\n    if (providerAst.providerType === ProviderAstType.PrivateService) {\n        flags |= 8192 /* PrivateProvider */;\n    }\n    providerAst.lifecycleHooks.forEach(function (lifecycleHook) {\n        // for regular providers, we only support ngOnDestroy\n        if (lifecycleHook === LifecycleHooks.OnDestroy ||\n            providerAst.providerType === ProviderAstType.Directive ||\n            providerAst.providerType === ProviderAstType.Component) {\n            flags |= lifecycleHookToNodeFlag(lifecycleHook);\n        }\n    });\n    var _a = providerAst.multiProvider ?\n        multiProviderDef(ctx, flags, providerAst.providers) :\n        singleProviderDef(ctx, flags, providerAst.providerType, providerAst.providers[0]), providerExpr = _a.providerExpr, providerFlags = _a.flags, depsExpr = _a.depsExpr;\n    return {\n        providerExpr: providerExpr,\n        flags: providerFlags, depsExpr: depsExpr,\n        tokenExpr: tokenExpr(ctx, providerAst.token),\n    };\n}\n/**\n * @param {?} ctx\n * @param {?} flags\n * @param {?} providers\n * @return {?}\n */\nfunction multiProviderDef(ctx, flags, providers) {\n    var /** @type {?} */ allDepDefs = [];\n    var /** @type {?} */ allParams = [];\n    var /** @type {?} */ exprs = providers.map(function (provider, providerIndex) {\n        var /** @type {?} */ expr;\n        if (provider.useClass) {\n            var /** @type {?} */ depExprs = convertDeps(providerIndex, provider.deps || provider.useClass.diDeps);\n            expr = ctx.importExpr(provider.useClass.reference).instantiate(depExprs);\n        }\n        else if (provider.useFactory) {\n            var /** @type {?} */ depExprs = convertDeps(providerIndex, provider.deps || provider.useFactory.diDeps);\n            expr = ctx.importExpr(provider.useFactory.reference).callFn(depExprs);\n        }\n        else if (provider.useExisting) {\n            var /** @type {?} */ depExprs = convertDeps(providerIndex, [{ token: provider.useExisting }]);\n            expr = depExprs[0];\n        }\n        else {\n            expr = convertValueToOutputAst(ctx, provider.useValue);\n        }\n        return expr;\n    });\n    var /** @type {?} */ providerExpr = fn(allParams, [new ReturnStatement(literalArr(exprs))], INFERRED_TYPE);\n    return {\n        providerExpr: providerExpr,\n        flags: flags | 1024 /* TypeFactoryProvider */,\n        depsExpr: literalArr(allDepDefs)\n    };\n    /**\n     * @param {?} providerIndex\n     * @param {?} deps\n     * @return {?}\n     */\n    function convertDeps(providerIndex, deps) {\n        return deps.map(function (dep, depIndex) {\n            var /** @type {?} */ paramName = \"p\" + providerIndex + \"_\" + depIndex;\n            allParams.push(new FnParam(paramName, DYNAMIC_TYPE));\n            allDepDefs.push(depDef(ctx, dep));\n            return variable(paramName);\n        });\n    }\n}\n/**\n * @param {?} ctx\n * @param {?} flags\n * @param {?} providerType\n * @param {?} providerMeta\n * @return {?}\n */\nfunction singleProviderDef(ctx, flags, providerType, providerMeta) {\n    var /** @type {?} */ providerExpr;\n    var /** @type {?} */ deps;\n    if (providerType === ProviderAstType.Directive || providerType === ProviderAstType.Component) {\n        providerExpr = ctx.importExpr(/** @type {?} */ ((providerMeta.useClass)).reference);\n        flags |= 16384 /* TypeDirective */;\n        deps = providerMeta.deps || ((providerMeta.useClass)).diDeps;\n    }\n    else {\n        if (providerMeta.useClass) {\n            providerExpr = ctx.importExpr(providerMeta.useClass.reference);\n            flags |= 512 /* TypeClassProvider */;\n            deps = providerMeta.deps || providerMeta.useClass.diDeps;\n        }\n        else if (providerMeta.useFactory) {\n            providerExpr = ctx.importExpr(providerMeta.useFactory.reference);\n            flags |= 1024 /* TypeFactoryProvider */;\n            deps = providerMeta.deps || providerMeta.useFactory.diDeps;\n        }\n        else if (providerMeta.useExisting) {\n            providerExpr = NULL_EXPR;\n            flags |= 2048 /* TypeUseExistingProvider */;\n            deps = [{ token: providerMeta.useExisting }];\n        }\n        else {\n            providerExpr = convertValueToOutputAst(ctx, providerMeta.useValue);\n            flags |= 256 /* TypeValueProvider */;\n            deps = [];\n        }\n    }\n    var /** @type {?} */ depsExpr = literalArr(deps.map(function (dep) { return depDef(ctx, dep); }));\n    return { providerExpr: providerExpr, flags: flags, depsExpr: depsExpr };\n}\n/**\n * @param {?} ctx\n * @param {?} tokenMeta\n * @return {?}\n */\nfunction tokenExpr(ctx, tokenMeta) {\n    return tokenMeta.identifier ? ctx.importExpr(tokenMeta.identifier.reference) :\n        literal(tokenMeta.value);\n}\n/**\n * @param {?} ctx\n * @param {?} dep\n * @return {?}\n */\nfunction depDef(ctx, dep) {\n    // Note: the following fields have already been normalized out by provider_analyzer:\n    // - isAttribute, isSelf, isHost\n    var /** @type {?} */ expr = dep.isValue ? convertValueToOutputAst(ctx, dep.value) : tokenExpr(ctx, /** @type {?} */ ((dep.token)));\n    var /** @type {?} */ flags = 0;\n    if (dep.isSkipSelf) {\n        flags |= 1 /* SkipSelf */;\n    }\n    if (dep.isOptional) {\n        flags |= 2 /* Optional */;\n    }\n    if (dep.isValue) {\n        flags |= 8 /* Value */;\n    }\n    return flags === 0 /* None */ ? expr : literalArr([literal(flags), expr]);\n}\n/**\n * @param {?} lifecycleHook\n * @return {?}\n */\nfunction lifecycleHookToNodeFlag(lifecycleHook) {\n    var /** @type {?} */ nodeFlag = 0;\n    switch (lifecycleHook) {\n        case LifecycleHooks.AfterContentChecked:\n            nodeFlag = 2097152 /* AfterContentChecked */;\n            break;\n        case LifecycleHooks.AfterContentInit:\n            nodeFlag = 1048576 /* AfterContentInit */;\n            break;\n        case LifecycleHooks.AfterViewChecked:\n            nodeFlag = 8388608 /* AfterViewChecked */;\n            break;\n        case LifecycleHooks.AfterViewInit:\n            nodeFlag = 4194304 /* AfterViewInit */;\n            break;\n        case LifecycleHooks.DoCheck:\n            nodeFlag = 262144 /* DoCheck */;\n            break;\n        case LifecycleHooks.OnChanges:\n            nodeFlag = 524288 /* OnChanges */;\n            break;\n        case LifecycleHooks.OnDestroy:\n            nodeFlag = 131072 /* OnDestroy */;\n            break;\n        case LifecycleHooks.OnInit:\n            nodeFlag = 65536 /* OnInit */;\n            break;\n    }\n    return nodeFlag;\n}\n/**\n * @param {?} reflector\n * @param {?} ctx\n * @param {?} flags\n * @param {?} entryComponents\n * @return {?}\n */\nfunction componentFactoryResolverProviderDef(reflector, ctx, flags, entryComponents) {\n    var /** @type {?} */ entryComponentFactories = entryComponents.map(function (entryComponent) { return ctx.importExpr(entryComponent.componentFactory); });\n    var /** @type {?} */ token = createTokenForExternalReference(reflector, Identifiers.ComponentFactoryResolver);\n    var /** @type {?} */ classMeta = {\n        diDeps: [\n            { isValue: true, value: literalArr(entryComponentFactories) },\n            { token: token, isSkipSelf: true, isOptional: true },\n            { token: createTokenForExternalReference(reflector, Identifiers.NgModuleRef) },\n        ],\n        lifecycleHooks: [],\n        reference: reflector.resolveExternalReference(Identifiers.CodegenComponentFactoryResolver)\n    };\n    var _a = singleProviderDef(ctx, flags, ProviderAstType.PrivateService, {\n        token: token,\n        multi: false,\n        useClass: classMeta,\n    }), providerExpr = _a.providerExpr, providerFlags = _a.flags, depsExpr = _a.depsExpr;\n    return { providerExpr: providerExpr, flags: providerFlags, depsExpr: depsExpr, tokenExpr: tokenExpr(ctx, token) };\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar NgModuleCompileResult = (function () {\n    /**\n     * @param {?} ngModuleFactoryVar\n     */\n    function NgModuleCompileResult(ngModuleFactoryVar) {\n        this.ngModuleFactoryVar = ngModuleFactoryVar;\n    }\n    return NgModuleCompileResult;\n}());\nvar LOG_VAR = variable('_l');\nvar NgModuleCompiler = (function () {\n    /**\n     * @param {?} reflector\n     */\n    function NgModuleCompiler(reflector) {\n        this.reflector = reflector;\n    }\n    /**\n     * @param {?} ctx\n     * @param {?} ngModuleMeta\n     * @param {?} extraProviders\n     * @return {?}\n     */\n    NgModuleCompiler.prototype.compile = function (ctx, ngModuleMeta, extraProviders) {\n        var /** @type {?} */ sourceSpan = typeSourceSpan('NgModule', ngModuleMeta.type);\n        var /** @type {?} */ entryComponentFactories = ngModuleMeta.transitiveModule.entryComponents;\n        var /** @type {?} */ bootstrapComponents = ngModuleMeta.bootstrapComponents;\n        var /** @type {?} */ providerParser = new NgModuleProviderAnalyzer(this.reflector, ngModuleMeta, extraProviders, sourceSpan);\n        var /** @type {?} */ providerDefs = [componentFactoryResolverProviderDef(this.reflector, ctx, 0 /* None */, entryComponentFactories)]\n            .concat(providerParser.parse().map(function (provider) { return providerDef(ctx, provider); }))\n            .map(function (_a) {\n            var providerExpr = _a.providerExpr, depsExpr = _a.depsExpr, flags = _a.flags, tokenExpr = _a.tokenExpr;\n            return importExpr(Identifiers.moduleProviderDef).callFn([\n                literal(flags), tokenExpr, providerExpr, depsExpr\n            ]);\n        });\n        var /** @type {?} */ ngModuleDef = importExpr(Identifiers.moduleDef).callFn([literalArr(providerDefs)]);\n        var /** @type {?} */ ngModuleDefFactory = fn([new FnParam(/** @type {?} */ ((LOG_VAR.name)))], [new ReturnStatement(ngModuleDef)], INFERRED_TYPE);\n        var /** @type {?} */ ngModuleFactoryVar = identifierName(ngModuleMeta.type) + \"NgFactory\";\n        this._createNgModuleFactory(ctx, ngModuleMeta.type.reference, importExpr(Identifiers.createModuleFactory).callFn([\n            ctx.importExpr(ngModuleMeta.type.reference),\n            literalArr(bootstrapComponents.map(function (id) { return ctx.importExpr(id.reference); })),\n            ngModuleDefFactory\n        ]));\n        if (ngModuleMeta.id) {\n            var /** @type {?} */ registerFactoryStmt = importExpr(Identifiers.RegisterModuleFactoryFn)\n                .callFn([literal(ngModuleMeta.id), variable(ngModuleFactoryVar)])\n                .toStmt();\n            ctx.statements.push(registerFactoryStmt);\n        }\n        return new NgModuleCompileResult(ngModuleFactoryVar);\n    };\n    /**\n     * @param {?} ctx\n     * @param {?} ngModuleReference\n     * @return {?}\n     */\n    NgModuleCompiler.prototype.createStub = function (ctx, ngModuleReference) {\n        this._createNgModuleFactory(ctx, ngModuleReference, NULL_EXPR);\n    };\n    /**\n     * @param {?} ctx\n     * @param {?} reference\n     * @param {?} value\n     * @return {?}\n     */\n    NgModuleCompiler.prototype._createNgModuleFactory = function (ctx, reference, value) {\n        var /** @type {?} */ ngModuleFactoryVar = identifierName({ reference: reference }) + \"NgFactory\";\n        var /** @type {?} */ ngModuleFactoryStmt = variable(ngModuleFactoryVar)\n            .set(value)\n            .toDeclStmt(importType(Identifiers.NgModuleFactory, [/** @type {?} */ ((expressionType(ctx.importExpr(reference))))], [TypeModifier.Const]), [StmtModifier.Final, StmtModifier.Exported]);\n        ctx.statements.push(ngModuleFactoryStmt);\n    };\n    return NgModuleCompiler;\n}());\nNgModuleCompiler.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nNgModuleCompiler.ctorParameters = function () { return [\n    { type: CompileReflector, },\n]; };\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit\nvar VERSION$1 = 3;\nvar JS_B64_PREFIX = '# sourceMappingURL=data:application/json;base64,';\nvar SourceMapGenerator = (function () {\n    /**\n     * @param {?=} file\n     */\n    function SourceMapGenerator(file) {\n        if (file === void 0) { file = null; }\n        this.file = file;\n        this.sourcesContent = new Map();\n        this.lines = [];\n        this.lastCol0 = 0;\n        this.hasMappings = false;\n    }\n    /**\n     * @param {?} url\n     * @param {?=} content\n     * @return {?}\n     */\n    SourceMapGenerator.prototype.addSource = function (url, content) {\n        if (content === void 0) { content = null; }\n        if (!this.sourcesContent.has(url)) {\n            this.sourcesContent.set(url, content);\n        }\n        return this;\n    };\n    /**\n     * @return {?}\n     */\n    SourceMapGenerator.prototype.addLine = function () {\n        this.lines.push([]);\n        this.lastCol0 = 0;\n        return this;\n    };\n    /**\n     * @param {?} col0\n     * @param {?=} sourceUrl\n     * @param {?=} sourceLine0\n     * @param {?=} sourceCol0\n     * @return {?}\n     */\n    SourceMapGenerator.prototype.addMapping = function (col0, sourceUrl, sourceLine0, sourceCol0) {\n        if (!this.currentLine) {\n            throw new Error(\"A line must be added before mappings can be added\");\n        }\n        if (sourceUrl != null && !this.sourcesContent.has(sourceUrl)) {\n            throw new Error(\"Unknown source file \\\"\" + sourceUrl + \"\\\"\");\n        }\n        if (col0 == null) {\n            throw new Error(\"The column in the generated code must be provided\");\n        }\n        if (col0 < this.lastCol0) {\n            throw new Error(\"Mapping should be added in output order\");\n        }\n        if (sourceUrl && (sourceLine0 == null || sourceCol0 == null)) {\n            throw new Error(\"The source location must be provided when a source url is provided\");\n        }\n        this.hasMappings = true;\n        this.lastCol0 = col0;\n        this.currentLine.push({ col0: col0, sourceUrl: sourceUrl, sourceLine0: sourceLine0, sourceCol0: sourceCol0 });\n        return this;\n    };\n    Object.defineProperty(SourceMapGenerator.prototype, \"currentLine\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this.lines.slice(-1)[0]; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    SourceMapGenerator.prototype.toJSON = function () {\n        var _this = this;\n        if (!this.hasMappings) {\n            return null;\n        }\n        var /** @type {?} */ sourcesIndex = new Map();\n        var /** @type {?} */ sources = [];\n        var /** @type {?} */ sourcesContent = [];\n        Array.from(this.sourcesContent.keys()).forEach(function (url, i) {\n            sourcesIndex.set(url, i);\n            sources.push(url);\n            sourcesContent.push(_this.sourcesContent.get(url) || null);\n        });\n        var /** @type {?} */ mappings = '';\n        var /** @type {?} */ lastCol0 = 0;\n        var /** @type {?} */ lastSourceIndex = 0;\n        var /** @type {?} */ lastSourceLine0 = 0;\n        var /** @type {?} */ lastSourceCol0 = 0;\n        this.lines.forEach(function (segments) {\n            lastCol0 = 0;\n            mappings += segments\n                .map(function (segment) {\n                // zero-based starting column of the line in the generated code\n                var /** @type {?} */ segAsStr = toBase64VLQ(segment.col0 - lastCol0);\n                lastCol0 = segment.col0;\n                if (segment.sourceUrl != null) {\n                    // zero-based index into the sources list\n                    segAsStr +=\n                        toBase64VLQ(/** @type {?} */ ((sourcesIndex.get(segment.sourceUrl))) - lastSourceIndex);\n                    lastSourceIndex = ((sourcesIndex.get(segment.sourceUrl)));\n                    // the zero-based starting line in the original source\n                    segAsStr += toBase64VLQ(/** @type {?} */ ((segment.sourceLine0)) - lastSourceLine0);\n                    lastSourceLine0 = ((segment.sourceLine0));\n                    // the zero-based starting column in the original source\n                    segAsStr += toBase64VLQ(/** @type {?} */ ((segment.sourceCol0)) - lastSourceCol0);\n                    lastSourceCol0 = ((segment.sourceCol0));\n                }\n                return segAsStr;\n            })\n                .join(',');\n            mappings += ';';\n        });\n        mappings = mappings.slice(0, -1);\n        return {\n            'file': this.file || '',\n            'version': VERSION$1,\n            'sourceRoot': '',\n            'sources': sources,\n            'sourcesContent': sourcesContent,\n            'mappings': mappings,\n        };\n    };\n    /**\n     * @return {?}\n     */\n    SourceMapGenerator.prototype.toJsComment = function () {\n        return this.hasMappings ? '//' + JS_B64_PREFIX + toBase64String(JSON.stringify(this, null, 0)) :\n            '';\n    };\n    return SourceMapGenerator;\n}());\n/**\n * @param {?} value\n * @return {?}\n */\nfunction toBase64String(value) {\n    var /** @type {?} */ b64 = '';\n    value = utf8Encode(value);\n    for (var /** @type {?} */ i = 0; i < value.length;) {\n        var /** @type {?} */ i1 = value.charCodeAt(i++);\n        var /** @type {?} */ i2 = value.charCodeAt(i++);\n        var /** @type {?} */ i3 = value.charCodeAt(i++);\n        b64 += toBase64Digit(i1 >> 2);\n        b64 += toBase64Digit(((i1 & 3) << 4) | (isNaN(i2) ? 0 : i2 >> 4));\n        b64 += isNaN(i2) ? '=' : toBase64Digit(((i2 & 15) << 2) | (i3 >> 6));\n        b64 += isNaN(i2) || isNaN(i3) ? '=' : toBase64Digit(i3 & 63);\n    }\n    return b64;\n}\n/**\n * @param {?} value\n * @return {?}\n */\nfunction toBase64VLQ(value) {\n    value = value < 0 ? ((-value) << 1) + 1 : value << 1;\n    var /** @type {?} */ out = '';\n    do {\n        var /** @type {?} */ digit = value & 31;\n        value = value >> 5;\n        if (value > 0) {\n            digit = digit | 32;\n        }\n        out += toBase64Digit(digit);\n    } while (value > 0);\n    return out;\n}\nvar B64_DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n/**\n * @param {?} value\n * @return {?}\n */\nfunction toBase64Digit(value) {\n    if (value < 0 || value >= 64) {\n        throw new Error(\"Can only encode value in the range [0, 63]\");\n    }\n    return B64_DIGITS[value];\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\\\|\\n|\\r|\\$/g;\nvar _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;\nvar _INDENT_WITH = '  ';\nvar CATCH_ERROR_VAR$1 = variable('error', null, null);\nvar CATCH_STACK_VAR$1 = variable('stack', null, null);\n/**\n * @abstract\n */\nvar _EmittedLine = (function () {\n    /**\n     * @param {?} indent\n     */\n    function _EmittedLine(indent) {\n        this.indent = indent;\n        this.partsLength = 0;\n        this.parts = [];\n        this.srcSpans = [];\n    }\n    return _EmittedLine;\n}());\nvar EmitterVisitorContext = (function () {\n    /**\n     * @param {?} _indent\n     */\n    function EmitterVisitorContext(_indent) {\n        this._indent = _indent;\n        this._classes = [];\n        this._preambleLineCount = 0;\n        this._lines = [new _EmittedLine(_indent)];\n    }\n    /**\n     * @return {?}\n     */\n    EmitterVisitorContext.createRoot = function () { return new EmitterVisitorContext(0); };\n    Object.defineProperty(EmitterVisitorContext.prototype, \"_currentLine\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this._lines[this._lines.length - 1]; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?=} from\n     * @param {?=} lastPart\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.println = function (from, lastPart) {\n        if (lastPart === void 0) { lastPart = ''; }\n        this.print(from || null, lastPart, true);\n    };\n    /**\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.lineIsEmpty = function () { return this._currentLine.parts.length === 0; };\n    /**\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.lineLength = function () {\n        return this._currentLine.indent * _INDENT_WITH.length + this._currentLine.partsLength;\n    };\n    /**\n     * @param {?} from\n     * @param {?} part\n     * @param {?=} newLine\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.print = function (from, part, newLine) {\n        if (newLine === void 0) { newLine = false; }\n        if (part.length > 0) {\n            this._currentLine.parts.push(part);\n            this._currentLine.partsLength += part.length;\n            this._currentLine.srcSpans.push(from && from.sourceSpan || null);\n        }\n        if (newLine) {\n            this._lines.push(new _EmittedLine(this._indent));\n        }\n    };\n    /**\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.removeEmptyLastLine = function () {\n        if (this.lineIsEmpty()) {\n            this._lines.pop();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.incIndent = function () {\n        this._indent++;\n        if (this.lineIsEmpty()) {\n            this._currentLine.indent = this._indent;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.decIndent = function () {\n        this._indent--;\n        if (this.lineIsEmpty()) {\n            this._currentLine.indent = this._indent;\n        }\n    };\n    /**\n     * @param {?} clazz\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.pushClass = function (clazz) { this._classes.push(clazz); };\n    /**\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.popClass = function () { return ((this._classes.pop())); };\n    Object.defineProperty(EmitterVisitorContext.prototype, \"currentClass\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return this._classes.length > 0 ? this._classes[this._classes.length - 1] : null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.toSource = function () {\n        return this.sourceLines\n            .map(function (l) { return l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join('') : ''; })\n            .join('\\n');\n    };\n    /**\n     * @param {?} sourceFilePath\n     * @param {?} genFilePath\n     * @param {?=} startsAtLine\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.toSourceMapGenerator = function (sourceFilePath, genFilePath, startsAtLine) {\n        if (startsAtLine === void 0) { startsAtLine = 0; }\n        var /** @type {?} */ map = new SourceMapGenerator(genFilePath);\n        var /** @type {?} */ firstOffsetMapped = false;\n        var /** @type {?} */ mapFirstOffsetIfNeeded = function () {\n            if (!firstOffsetMapped) {\n                // Add a single space so that tools won't try to load the file from disk.\n                // Note: We are using virtual urls like `ng:///`, so we have to\n                // provide a content here.\n                map.addSource(sourceFilePath, ' ').addMapping(0, sourceFilePath, 0, 0);\n                firstOffsetMapped = true;\n            }\n        };\n        for (var /** @type {?} */ i = 0; i < startsAtLine; i++) {\n            map.addLine();\n            mapFirstOffsetIfNeeded();\n        }\n        this.sourceLines.forEach(function (line, lineIdx) {\n            map.addLine();\n            var /** @type {?} */ spans = line.srcSpans;\n            var /** @type {?} */ parts = line.parts;\n            var /** @type {?} */ col0 = line.indent * _INDENT_WITH.length;\n            var /** @type {?} */ spanIdx = 0;\n            // skip leading parts without source spans\n            while (spanIdx < spans.length && !spans[spanIdx]) {\n                col0 += parts[spanIdx].length;\n                spanIdx++;\n            }\n            if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {\n                firstOffsetMapped = true;\n            }\n            else {\n                mapFirstOffsetIfNeeded();\n            }\n            while (spanIdx < spans.length) {\n                var /** @type {?} */ span = ((spans[spanIdx]));\n                var /** @type {?} */ source = span.start.file;\n                var /** @type {?} */ sourceLine = span.start.line;\n                var /** @type {?} */ sourceCol = span.start.col;\n                map.addSource(source.url, source.content)\n                    .addMapping(col0, source.url, sourceLine, sourceCol);\n                col0 += parts[spanIdx].length;\n                spanIdx++;\n                // assign parts without span or the same span to the previous segment\n                while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {\n                    col0 += parts[spanIdx].length;\n                    spanIdx++;\n                }\n            }\n        });\n        return map;\n    };\n    /**\n     * @param {?} count\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.setPreambleLineCount = function (count) { return this._preambleLineCount = count; };\n    /**\n     * @param {?} line\n     * @param {?} column\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.spanOf = function (line, column) {\n        var /** @type {?} */ emittedLine = this._lines[line - this._preambleLineCount];\n        if (emittedLine) {\n            var /** @type {?} */ columnsLeft = column - emittedLine.indent;\n            for (var /** @type {?} */ partIndex = 0; partIndex < emittedLine.parts.length; partIndex++) {\n                var /** @type {?} */ part = emittedLine.parts[partIndex];\n                if (part.length > columnsLeft) {\n                    return emittedLine.srcSpans[partIndex];\n                }\n                columnsLeft -= part.length;\n            }\n        }\n        return null;\n    };\n    Object.defineProperty(EmitterVisitorContext.prototype, \"sourceLines\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {\n                return this._lines.slice(0, -1);\n            }\n            return this._lines;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return EmitterVisitorContext;\n}());\n/**\n * @abstract\n */\nvar AbstractEmitterVisitor = (function () {\n    /**\n     * @param {?} _escapeDollarInStrings\n     */\n    function AbstractEmitterVisitor(_escapeDollarInStrings) {\n        this._escapeDollarInStrings = _escapeDollarInStrings;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitExpressionStmt = function (stmt, ctx) {\n        stmt.expr.visitExpression(this, ctx);\n        ctx.println(stmt, ';');\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitReturnStmt = function (stmt, ctx) {\n        ctx.print(stmt, \"return \");\n        stmt.value.visitExpression(this, ctx);\n        ctx.println(stmt, ';');\n        return null;\n    };\n    /**\n     * @abstract\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitCastExpr = function (ast, context) { };\n    /**\n     * @abstract\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitDeclareClassStmt = function (stmt, ctx) { };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitIfStmt = function (stmt, ctx) {\n        ctx.print(stmt, \"if (\");\n        stmt.condition.visitExpression(this, ctx);\n        ctx.print(stmt, \") {\");\n        var /** @type {?} */ hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;\n        if (stmt.trueCase.length <= 1 && !hasElseCase) {\n            ctx.print(stmt, \" \");\n            this.visitAllStatements(stmt.trueCase, ctx);\n            ctx.removeEmptyLastLine();\n            ctx.print(stmt, \" \");\n        }\n        else {\n            ctx.println();\n            ctx.incIndent();\n            this.visitAllStatements(stmt.trueCase, ctx);\n            ctx.decIndent();\n            if (hasElseCase) {\n                ctx.println(stmt, \"} else {\");\n                ctx.incIndent();\n                this.visitAllStatements(stmt.falseCase, ctx);\n                ctx.decIndent();\n            }\n        }\n        ctx.println(stmt, \"}\");\n        return null;\n    };\n    /**\n     * @abstract\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitTryCatchStmt = function (stmt, ctx) { };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitThrowStmt = function (stmt, ctx) {\n        ctx.print(stmt, \"throw \");\n        stmt.error.visitExpression(this, ctx);\n        ctx.println(stmt, \";\");\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitCommentStmt = function (stmt, ctx) {\n        var /** @type {?} */ lines = stmt.comment.split('\\n');\n        lines.forEach(function (line) { ctx.println(stmt, \"// \" + line); });\n        return null;\n    };\n    /**\n     * @abstract\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitDeclareVarStmt = function (stmt, ctx) { };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitWriteVarExpr = function (expr, ctx) {\n        var /** @type {?} */ lineWasEmpty = ctx.lineIsEmpty();\n        if (!lineWasEmpty) {\n            ctx.print(expr, '(');\n        }\n        ctx.print(expr, expr.name + \" = \");\n        expr.value.visitExpression(this, ctx);\n        if (!lineWasEmpty) {\n            ctx.print(expr, ')');\n        }\n        return null;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitWriteKeyExpr = function (expr, ctx) {\n        var /** @type {?} */ lineWasEmpty = ctx.lineIsEmpty();\n        if (!lineWasEmpty) {\n            ctx.print(expr, '(');\n        }\n        expr.receiver.visitExpression(this, ctx);\n        ctx.print(expr, \"[\");\n        expr.index.visitExpression(this, ctx);\n        ctx.print(expr, \"] = \");\n        expr.value.visitExpression(this, ctx);\n        if (!lineWasEmpty) {\n            ctx.print(expr, ')');\n        }\n        return null;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitWritePropExpr = function (expr, ctx) {\n        var /** @type {?} */ lineWasEmpty = ctx.lineIsEmpty();\n        if (!lineWasEmpty) {\n            ctx.print(expr, '(');\n        }\n        expr.receiver.visitExpression(this, ctx);\n        ctx.print(expr, \".\" + expr.name + \" = \");\n        expr.value.visitExpression(this, ctx);\n        if (!lineWasEmpty) {\n            ctx.print(expr, ')');\n        }\n        return null;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitInvokeMethodExpr = function (expr, ctx) {\n        expr.receiver.visitExpression(this, ctx);\n        var /** @type {?} */ name = expr.name;\n        if (expr.builtin != null) {\n            name = this.getBuiltinMethodName(expr.builtin);\n            if (name == null) {\n                // some builtins just mean to skip the call.\n                return null;\n            }\n        }\n        ctx.print(expr, \".\" + name + \"(\");\n        this.visitAllExpressions(expr.args, ctx, \",\");\n        ctx.print(expr, \")\");\n        return null;\n    };\n    /**\n     * @abstract\n     * @param {?} method\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.getBuiltinMethodName = function (method) { };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitInvokeFunctionExpr = function (expr, ctx) {\n        expr.fn.visitExpression(this, ctx);\n        ctx.print(expr, \"(\");\n        this.visitAllExpressions(expr.args, ctx, ',');\n        ctx.print(expr, \")\");\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitReadVarExpr = function (ast, ctx) {\n        var /** @type {?} */ varName = ((ast.name));\n        if (ast.builtin != null) {\n            switch (ast.builtin) {\n                case BuiltinVar.Super:\n                    varName = 'super';\n                    break;\n                case BuiltinVar.This:\n                    varName = 'this';\n                    break;\n                case BuiltinVar.CatchError:\n                    varName = ((CATCH_ERROR_VAR$1.name));\n                    break;\n                case BuiltinVar.CatchStack:\n                    varName = ((CATCH_STACK_VAR$1.name));\n                    break;\n                default:\n                    throw new Error(\"Unknown builtin variable \" + ast.builtin);\n            }\n        }\n        ctx.print(ast, varName);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitInstantiateExpr = function (ast, ctx) {\n        ctx.print(ast, \"new \");\n        ast.classExpr.visitExpression(this, ctx);\n        ctx.print(ast, \"(\");\n        this.visitAllExpressions(ast.args, ctx, ',');\n        ctx.print(ast, \")\");\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitLiteralExpr = function (ast, ctx) {\n        var /** @type {?} */ value = ast.value;\n        if (typeof value === 'string') {\n            ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));\n        }\n        else {\n            ctx.print(ast, \"\" + value);\n        }\n        return null;\n    };\n    /**\n     * @abstract\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitExternalExpr = function (ast, ctx) { };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitConditionalExpr = function (ast, ctx) {\n        ctx.print(ast, \"(\");\n        ast.condition.visitExpression(this, ctx);\n        ctx.print(ast, '? ');\n        ast.trueCase.visitExpression(this, ctx);\n        ctx.print(ast, ': '); /** @type {?} */\n        ((ast.falseCase)).visitExpression(this, ctx);\n        ctx.print(ast, \")\");\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitNotExpr = function (ast, ctx) {\n        ctx.print(ast, '!');\n        ast.condition.visitExpression(this, ctx);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitAssertNotNullExpr = function (ast, ctx) {\n        ast.condition.visitExpression(this, ctx);\n        return null;\n    };\n    /**\n     * @abstract\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitFunctionExpr = function (ast, ctx) { };\n    /**\n     * @abstract\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitDeclareFunctionStmt = function (stmt, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitBinaryOperatorExpr = function (ast, ctx) {\n        var /** @type {?} */ opStr;\n        switch (ast.operator) {\n            case BinaryOperator.Equals:\n                opStr = '==';\n                break;\n            case BinaryOperator.Identical:\n                opStr = '===';\n                break;\n            case BinaryOperator.NotEquals:\n                opStr = '!=';\n                break;\n            case BinaryOperator.NotIdentical:\n                opStr = '!==';\n                break;\n            case BinaryOperator.And:\n                opStr = '&&';\n                break;\n            case BinaryOperator.Or:\n                opStr = '||';\n                break;\n            case BinaryOperator.Plus:\n                opStr = '+';\n                break;\n            case BinaryOperator.Minus:\n                opStr = '-';\n                break;\n            case BinaryOperator.Divide:\n                opStr = '/';\n                break;\n            case BinaryOperator.Multiply:\n                opStr = '*';\n                break;\n            case BinaryOperator.Modulo:\n                opStr = '%';\n                break;\n            case BinaryOperator.Lower:\n                opStr = '<';\n                break;\n            case BinaryOperator.LowerEquals:\n                opStr = '<=';\n                break;\n            case BinaryOperator.Bigger:\n                opStr = '>';\n                break;\n            case BinaryOperator.BiggerEquals:\n                opStr = '>=';\n                break;\n            default:\n                throw new Error(\"Unknown operator \" + ast.operator);\n        }\n        ctx.print(ast, \"(\");\n        ast.lhs.visitExpression(this, ctx);\n        ctx.print(ast, \" \" + opStr + \" \");\n        ast.rhs.visitExpression(this, ctx);\n        ctx.print(ast, \")\");\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitReadPropExpr = function (ast, ctx) {\n        ast.receiver.visitExpression(this, ctx);\n        ctx.print(ast, \".\");\n        ctx.print(ast, ast.name);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitReadKeyExpr = function (ast, ctx) {\n        ast.receiver.visitExpression(this, ctx);\n        ctx.print(ast, \"[\");\n        ast.index.visitExpression(this, ctx);\n        ctx.print(ast, \"]\");\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitLiteralArrayExpr = function (ast, ctx) {\n        ctx.print(ast, \"[\");\n        this.visitAllExpressions(ast.entries, ctx, ',');\n        ctx.print(ast, \"]\");\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitLiteralMapExpr = function (ast, ctx) {\n        var _this = this;\n        ctx.print(ast, \"{\");\n        this.visitAllObjects(function (entry) {\n            ctx.print(ast, escapeIdentifier(entry.key, _this._escapeDollarInStrings, entry.quoted) + \":\");\n            entry.value.visitExpression(_this, ctx);\n        }, ast.entries, ctx, ',');\n        ctx.print(ast, \"}\");\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitCommaExpr = function (ast, ctx) {\n        ctx.print(ast, '(');\n        this.visitAllExpressions(ast.parts, ctx, ',');\n        ctx.print(ast, ')');\n        return null;\n    };\n    /**\n     * @param {?} expressions\n     * @param {?} ctx\n     * @param {?} separator\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitAllExpressions = function (expressions, ctx, separator) {\n        var _this = this;\n        this.visitAllObjects(function (expr) { return expr.visitExpression(_this, ctx); }, expressions, ctx, separator);\n    };\n    /**\n     * @template T\n     * @param {?} handler\n     * @param {?} expressions\n     * @param {?} ctx\n     * @param {?} separator\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitAllObjects = function (handler, expressions, ctx, separator) {\n        var /** @type {?} */ incrementedIndent = false;\n        for (var /** @type {?} */ i = 0; i < expressions.length; i++) {\n            if (i > 0) {\n                if (ctx.lineLength() > 80) {\n                    ctx.print(null, separator, true);\n                    if (!incrementedIndent) {\n                        // continuation are marked with double indent.\n                        ctx.incIndent();\n                        ctx.incIndent();\n                        incrementedIndent = true;\n                    }\n                }\n                else {\n                    ctx.print(null, separator, false);\n                }\n            }\n            handler(expressions[i]);\n        }\n        if (incrementedIndent) {\n            // continuation are marked with double indent.\n            ctx.decIndent();\n            ctx.decIndent();\n        }\n    };\n    /**\n     * @param {?} statements\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitAllStatements = function (statements, ctx) {\n        var _this = this;\n        statements.forEach(function (stmt) { return stmt.visitStatement(_this, ctx); });\n    };\n    return AbstractEmitterVisitor;\n}());\n/**\n * @param {?} input\n * @param {?} escapeDollar\n * @param {?=} alwaysQuote\n * @return {?}\n */\nfunction escapeIdentifier(input, escapeDollar, alwaysQuote) {\n    if (alwaysQuote === void 0) { alwaysQuote = true; }\n    if (input == null) {\n        return null;\n    }\n    var /** @type {?} */ body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, function () {\n        var match = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            match[_i] = arguments[_i];\n        }\n        if (match[0] == '$') {\n            return escapeDollar ? '\\\\$' : '$';\n        }\n        else if (match[0] == '\\n') {\n            return '\\\\n';\n        }\n        else if (match[0] == '\\r') {\n            return '\\\\r';\n        }\n        else {\n            return \"\\\\\" + match[0];\n        }\n    });\n    var /** @type {?} */ requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);\n    return requiresQuotes ? \"'\" + body + \"'\" : body;\n}\n/**\n * @param {?} count\n * @return {?}\n */\nfunction _createIndent(count) {\n    var /** @type {?} */ res = '';\n    for (var /** @type {?} */ i = 0; i < count; i++) {\n        res += _INDENT_WITH;\n    }\n    return res;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} ast\n * @return {?}\n */\nfunction debugOutputAstAsTypeScript(ast) {\n    var /** @type {?} */ converter = new _TsEmitterVisitor();\n    var /** @type {?} */ ctx = EmitterVisitorContext.createRoot();\n    var /** @type {?} */ asts = Array.isArray(ast) ? ast : [ast];\n    asts.forEach(function (ast) {\n        if (ast instanceof Statement) {\n            ast.visitStatement(converter, ctx);\n        }\n        else if (ast instanceof Expression) {\n            ast.visitExpression(converter, ctx);\n        }\n        else if (ast instanceof Type$1) {\n            ast.visitType(converter, ctx);\n        }\n        else {\n            throw new Error(\"Don't know how to print debug info for \" + ast);\n        }\n    });\n    return ctx.toSource();\n}\nvar TypeScriptEmitter = (function () {\n    function TypeScriptEmitter() {\n    }\n    /**\n     * @param {?} srcFilePath\n     * @param {?} genFilePath\n     * @param {?} stmts\n     * @param {?=} preamble\n     * @param {?=} emitSourceMaps\n     * @return {?}\n     */\n    TypeScriptEmitter.prototype.emitStatementsAndContext = function (srcFilePath, genFilePath, stmts, preamble, emitSourceMaps) {\n        if (preamble === void 0) { preamble = ''; }\n        if (emitSourceMaps === void 0) { emitSourceMaps = true; }\n        var /** @type {?} */ converter = new _TsEmitterVisitor();\n        var /** @type {?} */ ctx = EmitterVisitorContext.createRoot();\n        converter.visitAllStatements(stmts, ctx);\n        var /** @type {?} */ preambleLines = preamble ? preamble.split('\\n') : [];\n        converter.reexports.forEach(function (reexports, exportedModuleName) {\n            var /** @type {?} */ reexportsCode = reexports.map(function (reexport) { return reexport.name + \" as \" + reexport.as; }).join(',');\n            preambleLines.push(\"export {\" + reexportsCode + \"} from '\" + exportedModuleName + \"';\");\n        });\n        converter.importsWithPrefixes.forEach(function (prefix, importedModuleName) {\n            // Note: can't write the real word for import as it screws up system.js auto detection...\n            preambleLines.push(\"imp\" +\n                (\"ort * as \" + prefix + \" from '\" + importedModuleName + \"';\"));\n        });\n        var /** @type {?} */ sm = emitSourceMaps ?\n            ctx.toSourceMapGenerator(srcFilePath, genFilePath, preambleLines.length).toJsComment() :\n            '';\n        var /** @type {?} */ lines = preambleLines.concat([ctx.toSource(), sm]);\n        if (sm) {\n            // always add a newline at the end, as some tools have bugs without it.\n            lines.push('');\n        }\n        ctx.setPreambleLineCount(preambleLines.length);\n        return { sourceText: lines.join('\\n'), context: ctx };\n    };\n    /**\n     * @param {?} srcFilePath\n     * @param {?} genFilePath\n     * @param {?} stmts\n     * @param {?=} preamble\n     * @return {?}\n     */\n    TypeScriptEmitter.prototype.emitStatements = function (srcFilePath, genFilePath, stmts, preamble) {\n        if (preamble === void 0) { preamble = ''; }\n        return this.emitStatementsAndContext(srcFilePath, genFilePath, stmts, preamble).sourceText;\n    };\n    return TypeScriptEmitter;\n}());\nvar _TsEmitterVisitor = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](_TsEmitterVisitor, _super);\n    function _TsEmitterVisitor() {\n        var _this = _super.call(this, false) || this;\n        _this.typeExpression = 0;\n        _this.importsWithPrefixes = new Map();\n        _this.reexports = new Map();\n        return _this;\n    }\n    /**\n     * @param {?} t\n     * @param {?} ctx\n     * @param {?=} defaultType\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitType = function (t, ctx, defaultType) {\n        if (defaultType === void 0) { defaultType = 'any'; }\n        if (t) {\n            this.typeExpression++;\n            t.visitType(this, ctx);\n            this.typeExpression--;\n        }\n        else {\n            ctx.print(null, defaultType);\n        }\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitLiteralExpr = function (ast, ctx) {\n        var /** @type {?} */ value = ast.value;\n        if (value == null && ast.type != INFERRED_TYPE) {\n            ctx.print(ast, \"(\" + value + \" as any)\");\n            return null;\n        }\n        return _super.prototype.visitLiteralExpr.call(this, ast, ctx);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitLiteralArrayExpr = function (ast, ctx) {\n        if (ast.entries.length === 0) {\n            ctx.print(ast, '(');\n        }\n        var /** @type {?} */ result = _super.prototype.visitLiteralArrayExpr.call(this, ast, ctx);\n        if (ast.entries.length === 0) {\n            ctx.print(ast, ' as any[])');\n        }\n        return result;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitExternalExpr = function (ast, ctx) {\n        this._visitIdentifier(ast.value, ast.typeParams, ctx);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitAssertNotNullExpr = function (ast, ctx) {\n        var /** @type {?} */ result = _super.prototype.visitAssertNotNullExpr.call(this, ast, ctx);\n        ctx.print(ast, '!');\n        return result;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitDeclareVarStmt = function (stmt, ctx) {\n        if (stmt.hasModifier(StmtModifier.Exported) && stmt.value instanceof ExternalExpr &&\n            !stmt.type) {\n            // check for a reexport\n            var _a = stmt.value.value, name = _a.name, moduleName = _a.moduleName;\n            if (moduleName) {\n                var /** @type {?} */ reexports = this.reexports.get(moduleName);\n                if (!reexports) {\n                    reexports = [];\n                    this.reexports.set(moduleName, reexports);\n                }\n                reexports.push({ name: /** @type {?} */ ((name)), as: stmt.name });\n                return null;\n            }\n        }\n        if (stmt.hasModifier(StmtModifier.Exported)) {\n            ctx.print(stmt, \"export \");\n        }\n        if (stmt.hasModifier(StmtModifier.Final)) {\n            ctx.print(stmt, \"const\");\n        }\n        else {\n            ctx.print(stmt, \"var\");\n        }\n        ctx.print(stmt, \" \" + stmt.name);\n        this._printColonType(stmt.type, ctx);\n        ctx.print(stmt, \" = \");\n        stmt.value.visitExpression(this, ctx);\n        ctx.println(stmt, \";\");\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitCastExpr = function (ast, ctx) {\n        ctx.print(ast, \"(<\"); /** @type {?} */\n        ((ast.type)).visitType(this, ctx);\n        ctx.print(ast, \">\");\n        ast.value.visitExpression(this, ctx);\n        ctx.print(ast, \")\");\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitInstantiateExpr = function (ast, ctx) {\n        ctx.print(ast, \"new \");\n        this.typeExpression++;\n        ast.classExpr.visitExpression(this, ctx);\n        this.typeExpression--;\n        ctx.print(ast, \"(\");\n        this.visitAllExpressions(ast.args, ctx, ',');\n        ctx.print(ast, \")\");\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitDeclareClassStmt = function (stmt, ctx) {\n        var _this = this;\n        ctx.pushClass(stmt);\n        if (stmt.hasModifier(StmtModifier.Exported)) {\n            ctx.print(stmt, \"export \");\n        }\n        ctx.print(stmt, \"class \" + stmt.name);\n        if (stmt.parent != null) {\n            ctx.print(stmt, \" extends \");\n            this.typeExpression++;\n            stmt.parent.visitExpression(this, ctx);\n            this.typeExpression--;\n        }\n        ctx.println(stmt, \" {\");\n        ctx.incIndent();\n        stmt.fields.forEach(function (field) { return _this._visitClassField(field, ctx); });\n        if (stmt.constructorMethod != null) {\n            this._visitClassConstructor(stmt, ctx);\n        }\n        stmt.getters.forEach(function (getter) { return _this._visitClassGetter(getter, ctx); });\n        stmt.methods.forEach(function (method) { return _this._visitClassMethod(method, ctx); });\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n        ctx.popClass();\n        return null;\n    };\n    /**\n     * @param {?} field\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype._visitClassField = function (field, ctx) {\n        if (field.hasModifier(StmtModifier.Private)) {\n            // comment out as a workaround for #10967\n            ctx.print(null, \"/*private*/ \");\n        }\n        ctx.print(null, field.name);\n        this._printColonType(field.type, ctx);\n        ctx.println(null, \";\");\n    };\n    /**\n     * @param {?} getter\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype._visitClassGetter = function (getter, ctx) {\n        if (getter.hasModifier(StmtModifier.Private)) {\n            ctx.print(null, \"private \");\n        }\n        ctx.print(null, \"get \" + getter.name + \"()\");\n        this._printColonType(getter.type, ctx);\n        ctx.println(null, \" {\");\n        ctx.incIndent();\n        this.visitAllStatements(getter.body, ctx);\n        ctx.decIndent();\n        ctx.println(null, \"}\");\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype._visitClassConstructor = function (stmt, ctx) {\n        ctx.print(stmt, \"constructor(\");\n        this._visitParams(stmt.constructorMethod.params, ctx);\n        ctx.println(stmt, \") {\");\n        ctx.incIndent();\n        this.visitAllStatements(stmt.constructorMethod.body, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n    };\n    /**\n     * @param {?} method\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype._visitClassMethod = function (method, ctx) {\n        if (method.hasModifier(StmtModifier.Private)) {\n            ctx.print(null, \"private \");\n        }\n        ctx.print(null, method.name + \"(\");\n        this._visitParams(method.params, ctx);\n        ctx.print(null, \")\");\n        this._printColonType(method.type, ctx, 'void');\n        ctx.println(null, \" {\");\n        ctx.incIndent();\n        this.visitAllStatements(method.body, ctx);\n        ctx.decIndent();\n        ctx.println(null, \"}\");\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitFunctionExpr = function (ast, ctx) {\n        ctx.print(ast, \"(\");\n        this._visitParams(ast.params, ctx);\n        ctx.print(ast, \")\");\n        this._printColonType(ast.type, ctx, 'void');\n        ctx.println(ast, \" => {\");\n        ctx.incIndent();\n        this.visitAllStatements(ast.statements, ctx);\n        ctx.decIndent();\n        ctx.print(ast, \"}\");\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {\n        if (stmt.hasModifier(StmtModifier.Exported)) {\n            ctx.print(stmt, \"export \");\n        }\n        ctx.print(stmt, \"function \" + stmt.name + \"(\");\n        this._visitParams(stmt.params, ctx);\n        ctx.print(stmt, \")\");\n        this._printColonType(stmt.type, ctx, 'void');\n        ctx.println(stmt, \" {\");\n        ctx.incIndent();\n        this.visitAllStatements(stmt.statements, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitTryCatchStmt = function (stmt, ctx) {\n        ctx.println(stmt, \"try {\");\n        ctx.incIndent();\n        this.visitAllStatements(stmt.bodyStmts, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"} catch (\" + CATCH_ERROR_VAR$1.name + \") {\");\n        ctx.incIndent();\n        var /** @type {?} */ catchStmts = [/** @type {?} */ (CATCH_STACK_VAR$1.set(CATCH_ERROR_VAR$1.prop('stack', null)).toDeclStmt(null, [\n                StmtModifier.Final\n            ]))].concat(stmt.catchStmts);\n        this.visitAllStatements(catchStmts, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n        return null;\n    };\n    /**\n     * @param {?} type\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitBuiltintType = function (type, ctx) {\n        var /** @type {?} */ typeStr;\n        switch (type.name) {\n            case BuiltinTypeName.Bool:\n                typeStr = 'boolean';\n                break;\n            case BuiltinTypeName.Dynamic:\n                typeStr = 'any';\n                break;\n            case BuiltinTypeName.Function:\n                typeStr = 'Function';\n                break;\n            case BuiltinTypeName.Number:\n                typeStr = 'number';\n                break;\n            case BuiltinTypeName.Int:\n                typeStr = 'number';\n                break;\n            case BuiltinTypeName.String:\n                typeStr = 'string';\n                break;\n            default:\n                throw new Error(\"Unsupported builtin type \" + type.name);\n        }\n        ctx.print(null, typeStr);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitExpressionType = function (ast, ctx) {\n        ast.value.visitExpression(this, ctx);\n        return null;\n    };\n    /**\n     * @param {?} type\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitArrayType = function (type, ctx) {\n        this.visitType(type.of, ctx);\n        ctx.print(null, \"[]\");\n        return null;\n    };\n    /**\n     * @param {?} type\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitMapType = function (type, ctx) {\n        ctx.print(null, \"{[key: string]:\");\n        this.visitType(type.valueType, ctx);\n        ctx.print(null, \"}\");\n        return null;\n    };\n    /**\n     * @param {?} method\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.getBuiltinMethodName = function (method) {\n        var /** @type {?} */ name;\n        switch (method) {\n            case BuiltinMethod.ConcatArray:\n                name = 'concat';\n                break;\n            case BuiltinMethod.SubscribeObservable:\n                name = 'subscribe';\n                break;\n            case BuiltinMethod.Bind:\n                name = 'bind';\n                break;\n            default:\n                throw new Error(\"Unknown builtin method: \" + method);\n        }\n        return name;\n    };\n    /**\n     * @param {?} params\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype._visitParams = function (params, ctx) {\n        var _this = this;\n        this.visitAllObjects(function (param) {\n            ctx.print(null, param.name);\n            _this._printColonType(param.type, ctx);\n        }, params, ctx, ',');\n    };\n    /**\n     * @param {?} value\n     * @param {?} typeParams\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype._visitIdentifier = function (value, typeParams, ctx) {\n        var _this = this;\n        var name = value.name, moduleName = value.moduleName;\n        if (moduleName) {\n            var /** @type {?} */ prefix = this.importsWithPrefixes.get(moduleName);\n            if (prefix == null) {\n                prefix = \"i\" + this.importsWithPrefixes.size;\n                this.importsWithPrefixes.set(moduleName, prefix);\n            }\n            ctx.print(null, prefix + \".\");\n        }\n        ctx.print(null, /** @type {?} */ ((name)));\n        if (this.typeExpression > 0) {\n            // If we are in a type expression that refers to a generic type then supply\n            // the required type parameters. If there were not enough type parameters\n            // supplied, supply any as the type. Outside a type expression the reference\n            // should not supply type parameters and be treated as a simple value reference\n            // to the constructor function itself.\n            var /** @type {?} */ suppliedParameters = typeParams || [];\n            if (suppliedParameters.length > 0) {\n                ctx.print(null, \"<\");\n                this.visitAllObjects(function (type) { return type.visitType(_this, ctx); }, /** @type {?} */ ((typeParams)), ctx, ',');\n                ctx.print(null, \">\");\n            }\n        }\n    };\n    /**\n     * @param {?} type\n     * @param {?} ctx\n     * @param {?=} defaultType\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype._printColonType = function (type, ctx, defaultType) {\n        if (type !== INFERRED_TYPE) {\n            ctx.print(null, ':');\n            this.visitType(type, ctx, defaultType);\n        }\n    };\n    return _TsEmitterVisitor;\n}(AbstractEmitterVisitor));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Map from tagName|propertyName SecurityContext. Properties applying to all tags use '*'.\n */\nvar SECURITY_SCHEMA = {};\n/**\n * @param {?} ctx\n * @param {?} specs\n * @return {?}\n */\nfunction registerContext(ctx, specs) {\n    for (var _i = 0, specs_1 = specs; _i < specs_1.length; _i++) {\n        var spec = specs_1[_i];\n        SECURITY_SCHEMA[spec.toLowerCase()] = ctx;\n    }\n}\n// Case is insignificant below, all element and attribute names are lower-cased for lookup.\nregisterContext(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SecurityContext\"].HTML, [\n    'iframe|srcdoc',\n    '*|innerHTML',\n    '*|outerHTML',\n]);\nregisterContext(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SecurityContext\"].STYLE, ['*|style']);\n// NB: no SCRIPT contexts here, they are never allowed due to the parser stripping them.\nregisterContext(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SecurityContext\"].URL, [\n    '*|formAction', 'area|href', 'area|ping', 'audio|src', 'a|href',\n    'a|ping', 'blockquote|cite', 'body|background', 'del|cite', 'form|action',\n    'img|src', 'img|srcset', 'input|src', 'ins|cite', 'q|cite',\n    'source|src', 'source|srcset', 'track|src', 'video|poster', 'video|src',\n]);\nregisterContext(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SecurityContext\"].RESOURCE_URL, [\n    'applet|code',\n    'applet|codebase',\n    'base|href',\n    'embed|src',\n    'frame|src',\n    'head|profile',\n    'html|manifest',\n    'iframe|src',\n    'link|href',\n    'media|src',\n    'object|codebase',\n    'object|data',\n    'script|src',\n]);\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar BOOLEAN = 'boolean';\nvar NUMBER = 'number';\nvar STRING = 'string';\nvar OBJECT = 'object';\n/**\n * This array represents the DOM schema. It encodes inheritance, properties, and events.\n *\n * ## Overview\n *\n * Each line represents one kind of element. The `element_inheritance` and properties are joined\n * using `element_inheritance|properties` syntax.\n *\n * ## Element Inheritance\n *\n * The `element_inheritance` can be further subdivided as `element1,element2,...^parentElement`.\n * Here the individual elements are separated by `,` (commas). Every element in the list\n * has identical properties.\n *\n * An `element` may inherit additional properties from `parentElement` If no `^parentElement` is\n * specified then `\"\"` (blank) element is assumed.\n *\n * NOTE: The blank element inherits from root `[Element]` element, the super element of all\n * elements.\n *\n * NOTE an element prefix such as `:svg:` has no special meaning to the schema.\n *\n * ## Properties\n *\n * Each element has a set of properties separated by `,` (commas). Each property can be prefixed\n * by a special character designating its type:\n *\n * - (no prefix): property is a string.\n * - `*`: property represents an event.\n * - `!`: property is a boolean.\n * - `#`: property is a number.\n * - `%`: property is an object.\n *\n * ## Query\n *\n * The class creates an internal squas representation which allows to easily answer the query of\n * if a given property exist on a given element.\n *\n * NOTE: We don't yet support querying for types or events.\n * NOTE: This schema is auto extracted from `schema_extractor.ts` located in the test folder,\n *       see dom_element_schema_registry_spec.ts\n */\n// =================================================================================================\n// =================================================================================================\n// =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========\n// =================================================================================================\n// =================================================================================================\n//\n//                       DO NOT EDIT THIS DOM SCHEMA WITHOUT A SECURITY REVIEW!\n//\n// Newly added properties must be security reviewed and assigned an appropriate SecurityContext in\n// dom_security_schema.ts. Reach out to mprobst & rjamet for details.\n//\n// =================================================================================================\nvar SCHEMA = [\n    '[Element]|textContent,%classList,className,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*copy,*cut,*paste,*search,*selectstart,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerHTML,#scrollLeft,#scrollTop,slot' +\n        /* added manually to avoid breaking changes */\n        ',*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored',\n    '[HTMLElement]^[Element]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate',\n    'abbr,address,article,aside,b,bdi,bdo,cite,code,dd,dfn,dt,em,figcaption,figure,footer,header,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate',\n    'media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,src,%srcObject,#volume',\n    ':svg:^[HTMLElement]|*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,%style,#tabIndex',\n    ':svg:graphics^:svg:|',\n    ':svg:animation^:svg:|*begin,*end,*repeat',\n    ':svg:geometry^:svg:|',\n    ':svg:componentTransferFunction^:svg:|',\n    ':svg:gradient^:svg:|',\n    ':svg:textContent^:svg:graphics|',\n    ':svg:textPositioning^:svg:textContent|',\n    'a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,rev,search,shape,target,text,type,username',\n    'area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,search,shape,target,username',\n    'audio^media|',\n    'br^[HTMLElement]|clear',\n    'base^[HTMLElement]|href,target',\n    'body^[HTMLElement]|aLink,background,bgColor,link,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink',\n    'button^[HTMLElement]|!autofocus,!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value',\n    'canvas^[HTMLElement]|#height,#width',\n    'content^[HTMLElement]|select',\n    'dl^[HTMLElement]|!compact',\n    'datalist^[HTMLElement]|',\n    'details^[HTMLElement]|!open',\n    'dialog^[HTMLElement]|!open,returnValue',\n    'dir^[HTMLElement]|!compact',\n    'div^[HTMLElement]|align',\n    'embed^[HTMLElement]|align,height,name,src,type,width',\n    'fieldset^[HTMLElement]|!disabled,name',\n    'font^[HTMLElement]|color,face,size',\n    'form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target',\n    'frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src',\n    'frameset^[HTMLElement]|cols,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows',\n    'hr^[HTMLElement]|align,color,!noShade,size,width',\n    'head^[HTMLElement]|',\n    'h1,h2,h3,h4,h5,h6^[HTMLElement]|align',\n    'html^[HTMLElement]|version',\n    'iframe^[HTMLElement]|align,!allowFullscreen,frameBorder,height,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width',\n    'img^[HTMLElement]|align,alt,border,%crossOrigin,#height,#hspace,!isMap,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width',\n    'input^[HTMLElement]|accept,align,alt,autocapitalize,autocomplete,!autofocus,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width',\n    'li^[HTMLElement]|type,#value',\n    'label^[HTMLElement]|htmlFor',\n    'legend^[HTMLElement]|align',\n    'link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type',\n    'map^[HTMLElement]|name',\n    'marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width',\n    'menu^[HTMLElement]|!compact',\n    'meta^[HTMLElement]|content,httpEquiv,name,scheme',\n    'meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value',\n    'ins,del^[HTMLElement]|cite,dateTime',\n    'ol^[HTMLElement]|!compact,!reversed,#start,type',\n    'object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width',\n    'optgroup^[HTMLElement]|!disabled,label',\n    'option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value',\n    'output^[HTMLElement]|defaultValue,%htmlFor,name,value',\n    'p^[HTMLElement]|align',\n    'param^[HTMLElement]|name,type,value,valueType',\n    'picture^[HTMLElement]|',\n    'pre^[HTMLElement]|#width',\n    'progress^[HTMLElement]|#max,#value',\n    'q,blockquote,cite^[HTMLElement]|',\n    'script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,src,text,type',\n    'select^[HTMLElement]|!autofocus,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value',\n    'shadow^[HTMLElement]|',\n    'slot^[HTMLElement]|name',\n    'source^[HTMLElement]|media,sizes,src,srcset,type',\n    'span^[HTMLElement]|',\n    'style^[HTMLElement]|!disabled,media,type',\n    'caption^[HTMLElement]|align',\n    'th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width',\n    'col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width',\n    'table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width',\n    'tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign',\n    'tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign',\n    'template^[HTMLElement]|',\n    'textarea^[HTMLElement]|autocapitalize,!autofocus,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap',\n    'title^[HTMLElement]|text',\n    'track^[HTMLElement]|!default,kind,label,src,srclang',\n    'ul^[HTMLElement]|!compact,type',\n    'unknown^[HTMLElement]|',\n    'video^media|#height,poster,#width',\n    ':svg:a^:svg:graphics|',\n    ':svg:animate^:svg:animation|',\n    ':svg:animateMotion^:svg:animation|',\n    ':svg:animateTransform^:svg:animation|',\n    ':svg:circle^:svg:geometry|',\n    ':svg:clipPath^:svg:graphics|',\n    ':svg:defs^:svg:graphics|',\n    ':svg:desc^:svg:|',\n    ':svg:discard^:svg:|',\n    ':svg:ellipse^:svg:geometry|',\n    ':svg:feBlend^:svg:|',\n    ':svg:feColorMatrix^:svg:|',\n    ':svg:feComponentTransfer^:svg:|',\n    ':svg:feComposite^:svg:|',\n    ':svg:feConvolveMatrix^:svg:|',\n    ':svg:feDiffuseLighting^:svg:|',\n    ':svg:feDisplacementMap^:svg:|',\n    ':svg:feDistantLight^:svg:|',\n    ':svg:feDropShadow^:svg:|',\n    ':svg:feFlood^:svg:|',\n    ':svg:feFuncA^:svg:componentTransferFunction|',\n    ':svg:feFuncB^:svg:componentTransferFunction|',\n    ':svg:feFuncG^:svg:componentTransferFunction|',\n    ':svg:feFuncR^:svg:componentTransferFunction|',\n    ':svg:feGaussianBlur^:svg:|',\n    ':svg:feImage^:svg:|',\n    ':svg:feMerge^:svg:|',\n    ':svg:feMergeNode^:svg:|',\n    ':svg:feMorphology^:svg:|',\n    ':svg:feOffset^:svg:|',\n    ':svg:fePointLight^:svg:|',\n    ':svg:feSpecularLighting^:svg:|',\n    ':svg:feSpotLight^:svg:|',\n    ':svg:feTile^:svg:|',\n    ':svg:feTurbulence^:svg:|',\n    ':svg:filter^:svg:|',\n    ':svg:foreignObject^:svg:graphics|',\n    ':svg:g^:svg:graphics|',\n    ':svg:image^:svg:graphics|',\n    ':svg:line^:svg:geometry|',\n    ':svg:linearGradient^:svg:gradient|',\n    ':svg:mpath^:svg:|',\n    ':svg:marker^:svg:|',\n    ':svg:mask^:svg:|',\n    ':svg:metadata^:svg:|',\n    ':svg:path^:svg:geometry|',\n    ':svg:pattern^:svg:|',\n    ':svg:polygon^:svg:geometry|',\n    ':svg:polyline^:svg:geometry|',\n    ':svg:radialGradient^:svg:gradient|',\n    ':svg:rect^:svg:geometry|',\n    ':svg:svg^:svg:graphics|#currentScale,#zoomAndPan',\n    ':svg:script^:svg:|type',\n    ':svg:set^:svg:animation|',\n    ':svg:stop^:svg:|',\n    ':svg:style^:svg:|!disabled,media,title,type',\n    ':svg:switch^:svg:graphics|',\n    ':svg:symbol^:svg:|',\n    ':svg:tspan^:svg:textPositioning|',\n    ':svg:text^:svg:textPositioning|',\n    ':svg:textPath^:svg:textContent|',\n    ':svg:title^:svg:|',\n    ':svg:use^:svg:graphics|',\n    ':svg:view^:svg:|#zoomAndPan',\n    'data^[HTMLElement]|value',\n    'keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name',\n    'menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default',\n    'summary^[HTMLElement]|',\n    'time^[HTMLElement]|dateTime',\n    ':svg:cursor^:svg:|',\n];\nvar _ATTR_TO_PROP = {\n    'class': 'className',\n    'for': 'htmlFor',\n    'formaction': 'formAction',\n    'innerHtml': 'innerHTML',\n    'readonly': 'readOnly',\n    'tabindex': 'tabIndex',\n};\nvar DomElementSchemaRegistry = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](DomElementSchemaRegistry, _super);\n    function DomElementSchemaRegistry() {\n        var _this = _super.call(this) || this;\n        _this._schema = {};\n        SCHEMA.forEach(function (encodedType) {\n            var type = {};\n            var _a = encodedType.split('|'), strType = _a[0], strProperties = _a[1];\n            var properties = strProperties.split(',');\n            var _b = strType.split('^'), typeNames = _b[0], superName = _b[1];\n            typeNames.split(',').forEach(function (tag) { return _this._schema[tag.toLowerCase()] = type; });\n            var superType = superName && _this._schema[superName.toLowerCase()];\n            if (superType) {\n                Object.keys(superType).forEach(function (prop) { type[prop] = superType[prop]; });\n            }\n            properties.forEach(function (property) {\n                if (property.length > 0) {\n                    switch (property[0]) {\n                        case '*':\n                            // We don't yet support events.\n                            // If ever allowing to bind to events, GO THROUGH A SECURITY REVIEW, allowing events\n                            // will\n                            // almost certainly introduce bad XSS vulnerabilities.\n                            // type[property.substring(1)] = EVENT;\n                            break;\n                        case '!':\n                            type[property.substring(1)] = BOOLEAN;\n                            break;\n                        case '#':\n                            type[property.substring(1)] = NUMBER;\n                            break;\n                        case '%':\n                            type[property.substring(1)] = OBJECT;\n                            break;\n                        default:\n                            type[property] = STRING;\n                    }\n                }\n            });\n        });\n        return _this;\n    }\n    /**\n     * @param {?} tagName\n     * @param {?} propName\n     * @param {?} schemaMetas\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.hasProperty = function (tagName, propName, schemaMetas) {\n        if (schemaMetas.some(function (schema) { return schema.name === __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NO_ERRORS_SCHEMA\"].name; })) {\n            return true;\n        }\n        if (tagName.indexOf('-') > -1) {\n            if (isNgContainer(tagName) || isNgContent(tagName)) {\n                return false;\n            }\n            if (schemaMetas.some(function (schema) { return schema.name === __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"CUSTOM_ELEMENTS_SCHEMA\"].name; })) {\n                // Can't tell now as we don't know which properties a custom element will get\n                // once it is instantiated\n                return true;\n            }\n        }\n        var /** @type {?} */ elementProperties = this._schema[tagName.toLowerCase()] || this._schema['unknown'];\n        return !!elementProperties[propName];\n    };\n    /**\n     * @param {?} tagName\n     * @param {?} schemaMetas\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.hasElement = function (tagName, schemaMetas) {\n        if (schemaMetas.some(function (schema) { return schema.name === __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NO_ERRORS_SCHEMA\"].name; })) {\n            return true;\n        }\n        if (tagName.indexOf('-') > -1) {\n            if (isNgContainer(tagName) || isNgContent(tagName)) {\n                return true;\n            }\n            if (schemaMetas.some(function (schema) { return schema.name === __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"CUSTOM_ELEMENTS_SCHEMA\"].name; })) {\n                // Allow any custom elements\n                return true;\n            }\n        }\n        return !!this._schema[tagName.toLowerCase()];\n    };\n    /**\n     * securityContext returns the security context for the given property on the given DOM tag.\n     *\n     * Tag and property name are statically known and cannot change at runtime, i.e. it is not\n     * possible to bind a value into a changing attribute or tag name.\n     *\n     * The filtering is white list based. All attributes in the schema above are assumed to have the\n     * 'NONE' security context, i.e. that they are safe inert string values. Only specific well known\n     * attack vectors are assigned their appropriate context.\n     * @param {?} tagName\n     * @param {?} propName\n     * @param {?} isAttribute\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.securityContext = function (tagName, propName, isAttribute) {\n        if (isAttribute) {\n            // NB: For security purposes, use the mapped property name, not the attribute name.\n            propName = this.getMappedPropName(propName);\n        }\n        // Make sure comparisons are case insensitive, so that case differences between attribute and\n        // property names do not have a security impact.\n        tagName = tagName.toLowerCase();\n        propName = propName.toLowerCase();\n        var /** @type {?} */ ctx = SECURITY_SCHEMA[tagName + '|' + propName];\n        if (ctx) {\n            return ctx;\n        }\n        ctx = SECURITY_SCHEMA['*|' + propName];\n        return ctx ? ctx : __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SecurityContext\"].NONE;\n    };\n    /**\n     * @param {?} propName\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.getMappedPropName = function (propName) { return _ATTR_TO_PROP[propName] || propName; };\n    /**\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.getDefaultComponentElementName = function () { return 'ng-component'; };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.validateProperty = function (name) {\n        if (name.toLowerCase().startsWith('on')) {\n            var /** @type {?} */ msg = \"Binding to event property '\" + name + \"' is disallowed for security reasons, \" +\n                (\"please use (\" + name.slice(2) + \")=...\") +\n                (\"\\nIf '\" + name + \"' is a directive input, make sure the directive is imported by the\") +\n                \" current module.\";\n            return { error: true, msg: msg };\n        }\n        else {\n            return { error: false };\n        }\n    };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.validateAttribute = function (name) {\n        if (name.toLowerCase().startsWith('on')) {\n            var /** @type {?} */ msg = \"Binding to event attribute '\" + name + \"' is disallowed for security reasons, \" +\n                (\"please use (\" + name.slice(2) + \")=...\");\n            return { error: true, msg: msg };\n        }\n        else {\n            return { error: false };\n        }\n    };\n    /**\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.allKnownElementNames = function () { return Object.keys(this._schema); };\n    /**\n     * @param {?} propName\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.normalizeAnimationStyleProperty = function (propName) {\n        return dashCaseToCamelCase(propName);\n    };\n    /**\n     * @param {?} camelCaseProp\n     * @param {?} userProvidedProp\n     * @param {?} val\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.normalizeAnimationStyleValue = function (camelCaseProp, userProvidedProp, val) {\n        var /** @type {?} */ unit = '';\n        var /** @type {?} */ strVal = val.toString().trim();\n        var /** @type {?} */ errorMsg = ((null));\n        if (_isPixelDimensionStyle(camelCaseProp) && val !== 0 && val !== '0') {\n            if (typeof val === 'number') {\n                unit = 'px';\n            }\n            else {\n                var /** @type {?} */ valAndSuffixMatch = val.match(/^[+-]?[\\d\\.]+([a-z]*)$/);\n                if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {\n                    errorMsg = \"Please provide a CSS unit value for \" + userProvidedProp + \":\" + val;\n                }\n            }\n        }\n        return { error: errorMsg, value: strVal + unit };\n    };\n    return DomElementSchemaRegistry;\n}(ElementSchemaRegistry));\nDomElementSchemaRegistry.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nDomElementSchemaRegistry.ctorParameters = function () { return []; };\n/**\n * @param {?} prop\n * @return {?}\n */\nfunction _isPixelDimensionStyle(prop) {\n    switch (prop) {\n        case 'width':\n        case 'height':\n        case 'minWidth':\n        case 'minHeight':\n        case 'maxWidth':\n        case 'maxHeight':\n        case 'left':\n        case 'top':\n        case 'bottom':\n        case 'right':\n        case 'fontSize':\n        case 'outlineWidth':\n        case 'outlineOffset':\n        case 'paddingTop':\n        case 'paddingLeft':\n        case 'paddingBottom':\n        case 'paddingRight':\n        case 'marginTop':\n        case 'marginLeft':\n        case 'marginBottom':\n        case 'marginRight':\n        case 'borderRadius':\n        case 'borderWidth':\n        case 'borderTopWidth':\n        case 'borderLeftWidth':\n        case 'borderRightWidth':\n        case 'borderBottomWidth':\n        case 'textIndent':\n            return true;\n        default:\n            return false;\n    }\n}\nvar ShadowCss = (function () {\n    function ShadowCss() {\n        this.strictStyling = true;\n    }\n    /**\n     * @param {?} cssText\n     * @param {?} selector\n     * @param {?=} hostSelector\n     * @return {?}\n     */\n    ShadowCss.prototype.shimCssText = function (cssText, selector, hostSelector) {\n        if (hostSelector === void 0) { hostSelector = ''; }\n        var /** @type {?} */ sourceMappingUrl = extractSourceMappingUrl(cssText);\n        cssText = stripComments(cssText);\n        cssText = this._insertDirectives(cssText);\n        return this._scopeCssText(cssText, selector, hostSelector) + sourceMappingUrl;\n    };\n    /**\n     * @param {?} cssText\n     * @return {?}\n     */\n    ShadowCss.prototype._insertDirectives = function (cssText) {\n        cssText = this._insertPolyfillDirectivesInCssText(cssText);\n        return this._insertPolyfillRulesInCssText(cssText);\n    };\n    /**\n     * @param {?} cssText\n     * @return {?}\n     */\n    ShadowCss.prototype._insertPolyfillDirectivesInCssText = function (cssText) {\n        // Difference with webcomponents.js: does not handle comments\n        return cssText.replace(_cssContentNextSelectorRe, function () {\n            var m = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                m[_i] = arguments[_i];\n            }\n            return m[2] + '{';\n        });\n    };\n    /**\n     * @param {?} cssText\n     * @return {?}\n     */\n    ShadowCss.prototype._insertPolyfillRulesInCssText = function (cssText) {\n        // Difference with webcomponents.js: does not handle comments\n        return cssText.replace(_cssContentRuleRe, function () {\n            var m = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                m[_i] = arguments[_i];\n            }\n            var /** @type {?} */ rule = m[0].replace(m[1], '').replace(m[2], '');\n            return m[4] + rule;\n        });\n    };\n    /**\n     * @param {?} cssText\n     * @param {?} scopeSelector\n     * @param {?} hostSelector\n     * @return {?}\n     */\n    ShadowCss.prototype._scopeCssText = function (cssText, scopeSelector, hostSelector) {\n        var /** @type {?} */ unscopedRules = this._extractUnscopedRulesFromCssText(cssText);\n        // replace :host and :host-context -shadowcsshost and -shadowcsshost respectively\n        cssText = this._insertPolyfillHostInCssText(cssText);\n        cssText = this._convertColonHost(cssText);\n        cssText = this._convertColonHostContext(cssText);\n        cssText = this._convertShadowDOMSelectors(cssText);\n        if (scopeSelector) {\n            cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);\n        }\n        cssText = cssText + '\\n' + unscopedRules;\n        return cssText.trim();\n    };\n    /**\n     * @param {?} cssText\n     * @return {?}\n     */\n    ShadowCss.prototype._extractUnscopedRulesFromCssText = function (cssText) {\n        // Difference with webcomponents.js: does not handle comments\n        var /** @type {?} */ r = '';\n        var /** @type {?} */ m;\n        _cssContentUnscopedRuleRe.lastIndex = 0;\n        while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {\n            var /** @type {?} */ rule = m[0].replace(m[2], '').replace(m[1], m[4]);\n            r += rule + '\\n\\n';\n        }\n        return r;\n    };\n    /**\n     * @param {?} cssText\n     * @return {?}\n     */\n    ShadowCss.prototype._convertColonHost = function (cssText) {\n        return this._convertColonRule(cssText, _cssColonHostRe, this._colonHostPartReplacer);\n    };\n    /**\n     * @param {?} cssText\n     * @return {?}\n     */\n    ShadowCss.prototype._convertColonHostContext = function (cssText) {\n        return this._convertColonRule(cssText, _cssColonHostContextRe, this._colonHostContextPartReplacer);\n    };\n    /**\n     * @param {?} cssText\n     * @param {?} regExp\n     * @param {?} partReplacer\n     * @return {?}\n     */\n    ShadowCss.prototype._convertColonRule = function (cssText, regExp, partReplacer) {\n        // m[1] = :host(-context), m[2] = contents of (), m[3] rest of rule\n        return cssText.replace(regExp, function () {\n            var m = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                m[_i] = arguments[_i];\n            }\n            if (m[2]) {\n                var /** @type {?} */ parts = m[2].split(',');\n                var /** @type {?} */ r = [];\n                for (var /** @type {?} */ i = 0; i < parts.length; i++) {\n                    var /** @type {?} */ p = parts[i].trim();\n                    if (!p)\n                        break;\n                    r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));\n                }\n                return r.join(',');\n            }\n            else {\n                return _polyfillHostNoCombinator + m[3];\n            }\n        });\n    };\n    /**\n     * @param {?} host\n     * @param {?} part\n     * @param {?} suffix\n     * @return {?}\n     */\n    ShadowCss.prototype._colonHostContextPartReplacer = function (host, part, suffix) {\n        if (part.indexOf(_polyfillHost) > -1) {\n            return this._colonHostPartReplacer(host, part, suffix);\n        }\n        else {\n            return host + part + suffix + ', ' + part + ' ' + host + suffix;\n        }\n    };\n    /**\n     * @param {?} host\n     * @param {?} part\n     * @param {?} suffix\n     * @return {?}\n     */\n    ShadowCss.prototype._colonHostPartReplacer = function (host, part, suffix) {\n        return host + part.replace(_polyfillHost, '') + suffix;\n    };\n    /**\n     * @param {?} cssText\n     * @return {?}\n     */\n    ShadowCss.prototype._convertShadowDOMSelectors = function (cssText) {\n        return _shadowDOMSelectorsRe.reduce(function (result, pattern) { return result.replace(pattern, ' '); }, cssText);\n    };\n    /**\n     * @param {?} cssText\n     * @param {?} scopeSelector\n     * @param {?} hostSelector\n     * @return {?}\n     */\n    ShadowCss.prototype._scopeSelectors = function (cssText, scopeSelector, hostSelector) {\n        var _this = this;\n        return processRules(cssText, function (rule) {\n            var /** @type {?} */ selector = rule.selector;\n            var /** @type {?} */ content = rule.content;\n            if (rule.selector[0] != '@') {\n                selector =\n                    _this._scopeSelector(rule.selector, scopeSelector, hostSelector, _this.strictStyling);\n            }\n            else if (rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') ||\n                rule.selector.startsWith('@page') || rule.selector.startsWith('@document')) {\n                content = _this._scopeSelectors(rule.content, scopeSelector, hostSelector);\n            }\n            return new CssRule(selector, content);\n        });\n    };\n    /**\n     * @param {?} selector\n     * @param {?} scopeSelector\n     * @param {?} hostSelector\n     * @param {?} strict\n     * @return {?}\n     */\n    ShadowCss.prototype._scopeSelector = function (selector, scopeSelector, hostSelector, strict) {\n        var _this = this;\n        return selector.split(',')\n            .map(function (part) { return part.trim().split(_shadowDeepSelectors); })\n            .map(function (deepParts) {\n            var shallowPart = deepParts[0], otherParts = deepParts.slice(1);\n            var /** @type {?} */ applyScope = function (shallowPart) {\n                if (_this._selectorNeedsScoping(shallowPart, scopeSelector)) {\n                    return strict ?\n                        _this._applyStrictSelectorScope(shallowPart, scopeSelector, hostSelector) :\n                        _this._applySelectorScope(shallowPart, scopeSelector, hostSelector);\n                }\n                else {\n                    return shallowPart;\n                }\n            };\n            return [applyScope(shallowPart)].concat(otherParts).join(' ');\n        })\n            .join(', ');\n    };\n    /**\n     * @param {?} selector\n     * @param {?} scopeSelector\n     * @return {?}\n     */\n    ShadowCss.prototype._selectorNeedsScoping = function (selector, scopeSelector) {\n        var /** @type {?} */ re = this._makeScopeMatcher(scopeSelector);\n        return !re.test(selector);\n    };\n    /**\n     * @param {?} scopeSelector\n     * @return {?}\n     */\n    ShadowCss.prototype._makeScopeMatcher = function (scopeSelector) {\n        var /** @type {?} */ lre = /\\[/g;\n        var /** @type {?} */ rre = /\\]/g;\n        scopeSelector = scopeSelector.replace(lre, '\\\\[').replace(rre, '\\\\]');\n        return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');\n    };\n    /**\n     * @param {?} selector\n     * @param {?} scopeSelector\n     * @param {?} hostSelector\n     * @return {?}\n     */\n    ShadowCss.prototype._applySelectorScope = function (selector, scopeSelector, hostSelector) {\n        // Difference from webcomponents.js: scopeSelector could not be an array\n        return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);\n    };\n    /**\n     * @param {?} selector\n     * @param {?} scopeSelector\n     * @param {?} hostSelector\n     * @return {?}\n     */\n    ShadowCss.prototype._applySimpleSelectorScope = function (selector, scopeSelector, hostSelector) {\n        // In Android browser, the lastIndex is not reset when the regex is used in String.replace()\n        _polyfillHostRe.lastIndex = 0;\n        if (_polyfillHostRe.test(selector)) {\n            var /** @type {?} */ replaceBy_1 = this.strictStyling ? \"[\" + hostSelector + \"]\" : scopeSelector;\n            return selector\n                .replace(_polyfillHostNoCombinatorRe, function (hnc, selector) {\n                return selector.replace(/([^:]*)(:*)(.*)/, function (_, before, colon, after) {\n                    return before + replaceBy_1 + colon + after;\n                });\n            })\n                .replace(_polyfillHostRe, replaceBy_1 + ' ');\n        }\n        return scopeSelector + ' ' + selector;\n    };\n    /**\n     * @param {?} selector\n     * @param {?} scopeSelector\n     * @param {?} hostSelector\n     * @return {?}\n     */\n    ShadowCss.prototype._applyStrictSelectorScope = function (selector, scopeSelector, hostSelector) {\n        var _this = this;\n        var /** @type {?} */ isRe = /\\[is=([^\\]]*)\\]/g;\n        scopeSelector = scopeSelector.replace(isRe, function (_) {\n            var parts = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                parts[_i - 1] = arguments[_i];\n            }\n            return parts[0];\n        });\n        var /** @type {?} */ attrName = '[' + scopeSelector + ']';\n        var /** @type {?} */ _scopeSelectorPart = function (p) {\n            var /** @type {?} */ scopedP = p.trim();\n            if (!scopedP) {\n                return '';\n            }\n            if (p.indexOf(_polyfillHostNoCombinator) > -1) {\n                scopedP = _this._applySimpleSelectorScope(p, scopeSelector, hostSelector);\n            }\n            else {\n                // remove :host since it should be unnecessary\n                var /** @type {?} */ t = p.replace(_polyfillHostRe, '');\n                if (t.length > 0) {\n                    var /** @type {?} */ matches = t.match(/([^:]*)(:*)(.*)/);\n                    if (matches) {\n                        scopedP = matches[1] + attrName + matches[2] + matches[3];\n                    }\n                }\n            }\n            return scopedP;\n        };\n        var /** @type {?} */ safeContent = new SafeSelector(selector);\n        selector = safeContent.content();\n        var /** @type {?} */ scopedSelector = '';\n        var /** @type {?} */ startIndex = 0;\n        var /** @type {?} */ res;\n        var /** @type {?} */ sep = /( |>|\\+|~(?!=))\\s*/g;\n        var /** @type {?} */ scopeAfter = selector.indexOf(_polyfillHostNoCombinator);\n        while ((res = sep.exec(selector)) !== null) {\n            var /** @type {?} */ separator = res[1];\n            var /** @type {?} */ part = selector.slice(startIndex, res.index).trim();\n            // if a selector appears before :host-context it should not be shimmed as it\n            // matches on ancestor elements and not on elements in the host's shadow\n            var /** @type {?} */ scopedPart = startIndex >= scopeAfter ? _scopeSelectorPart(part) : part;\n            scopedSelector += scopedPart + \" \" + separator + \" \";\n            startIndex = sep.lastIndex;\n        }\n        scopedSelector += _scopeSelectorPart(selector.substring(startIndex));\n        // replace the placeholders with their original values\n        return safeContent.restore(scopedSelector);\n    };\n    /**\n     * @param {?} selector\n     * @return {?}\n     */\n    ShadowCss.prototype._insertPolyfillHostInCssText = function (selector) {\n        return selector.replace(_colonHostContextRe, _polyfillHostContext)\n            .replace(_colonHostRe, _polyfillHost);\n    };\n    return ShadowCss;\n}());\nvar SafeSelector = (function () {\n    /**\n     * @param {?} selector\n     */\n    function SafeSelector(selector) {\n        var _this = this;\n        this.placeholders = [];\n        this.index = 0;\n        // Replaces attribute selectors with placeholders.\n        // The WS in [attr=\"va lue\"] would otherwise be interpreted as a selector separator.\n        selector = selector.replace(/(\\[[^\\]]*\\])/g, function (_, keep) {\n            var replaceBy = \"__ph-\" + _this.index + \"__\";\n            _this.placeholders.push(keep);\n            _this.index++;\n            return replaceBy;\n        });\n        // Replaces the expression in `:nth-child(2n + 1)` with a placeholder.\n        // WS and \"+\" would otherwise be interpreted as selector separators.\n        this._content = selector.replace(/(:nth-[-\\w]+)(\\([^)]+\\))/g, function (_, pseudo, exp) {\n            var replaceBy = \"__ph-\" + _this.index + \"__\";\n            _this.placeholders.push(exp);\n            _this.index++;\n            return pseudo + replaceBy;\n        });\n    }\n    ;\n    /**\n     * @param {?} content\n     * @return {?}\n     */\n    SafeSelector.prototype.restore = function (content) {\n        var _this = this;\n        return content.replace(/__ph-(\\d+)__/g, function (ph, index) { return _this.placeholders[+index]; });\n    };\n    /**\n     * @return {?}\n     */\n    SafeSelector.prototype.content = function () { return this._content; };\n    return SafeSelector;\n}());\nvar _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\\s]*?(['\"])(.*?)\\1[;\\s]*}([^{]*?){/gim;\nvar _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nvar _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nvar _polyfillHost = '-shadowcsshost';\n// note: :host-context pre-processed to -shadowcsshostcontext.\nvar _polyfillHostContext = '-shadowcsscontext';\nvar _parenSuffix = ')(?:\\\\((' +\n    '(?:\\\\([^)(]*\\\\)|[^)(]*)+?' +\n    ')\\\\))?([^,{]*)';\nvar _cssColonHostRe = new RegExp('(' + _polyfillHost + _parenSuffix, 'gim');\nvar _cssColonHostContextRe = new RegExp('(' + _polyfillHostContext + _parenSuffix, 'gim');\nvar _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';\nvar _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\\s]*)/;\nvar _shadowDOMSelectorsRe = [\n    /::shadow/g,\n    /::content/g,\n    // Deprecated selectors\n    /\\/shadow-deep\\//g,\n    /\\/shadow\\//g,\n];\n// The deep combinator is deprecated in the CSS spec\n// Support for `>>>`, `deep`, `::ng-deep` is then also deprecated and will be removed in the future.\n// see https://github.com/angular/angular/pull/17677\nvar _shadowDeepSelectors = /(?:>>>)|(?:\\/deep\\/)|(?:::ng-deep)/g;\nvar _selectorReSuffix = '([>\\\\s~+\\[.,{:][\\\\s\\\\S]*)?$';\nvar _polyfillHostRe = /-shadowcsshost/gim;\nvar _colonHostRe = /:host/gim;\nvar _colonHostContextRe = /:host-context/gim;\nvar _commentRe = /\\/\\*\\s*[\\s\\S]*?\\*\\//g;\n/**\n * @param {?} input\n * @return {?}\n */\nfunction stripComments(input) {\n    return input.replace(_commentRe, '');\n}\n// all comments except inline source mapping\nvar _sourceMappingUrlRe = /\\/\\*\\s*#\\s*sourceMappingURL=[\\s\\S]+?\\*\\//;\n/**\n * @param {?} input\n * @return {?}\n */\nfunction extractSourceMappingUrl(input) {\n    var /** @type {?} */ matcher = input.match(_sourceMappingUrlRe);\n    return matcher ? matcher[0] : '';\n}\nvar _ruleRe = /(\\s*)([^;\\{\\}]+?)(\\s*)((?:{%BLOCK%}?\\s*;?)|(?:\\s*;))/g;\nvar _curlyRe = /([{}])/g;\nvar OPEN_CURLY = '{';\nvar CLOSE_CURLY = '}';\nvar BLOCK_PLACEHOLDER = '%BLOCK%';\nvar CssRule = (function () {\n    /**\n     * @param {?} selector\n     * @param {?} content\n     */\n    function CssRule(selector, content) {\n        this.selector = selector;\n        this.content = content;\n    }\n    return CssRule;\n}());\n/**\n * @param {?} input\n * @param {?} ruleCallback\n * @return {?}\n */\nfunction processRules(input, ruleCallback) {\n    var /** @type {?} */ inputWithEscapedBlocks = escapeBlocks(input);\n    var /** @type {?} */ nextBlockIndex = 0;\n    return inputWithEscapedBlocks.escapedString.replace(_ruleRe, function () {\n        var m = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            m[_i] = arguments[_i];\n        }\n        var /** @type {?} */ selector = m[2];\n        var /** @type {?} */ content = '';\n        var /** @type {?} */ suffix = m[4];\n        var /** @type {?} */ contentPrefix = '';\n        if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {\n            content = inputWithEscapedBlocks.blocks[nextBlockIndex++];\n            suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);\n            contentPrefix = '{';\n        }\n        var /** @type {?} */ rule = ruleCallback(new CssRule(selector, content));\n        return \"\" + m[1] + rule.selector + m[3] + contentPrefix + rule.content + suffix;\n    });\n}\nvar StringWithEscapedBlocks = (function () {\n    /**\n     * @param {?} escapedString\n     * @param {?} blocks\n     */\n    function StringWithEscapedBlocks(escapedString, blocks) {\n        this.escapedString = escapedString;\n        this.blocks = blocks;\n    }\n    return StringWithEscapedBlocks;\n}());\n/**\n * @param {?} input\n * @return {?}\n */\nfunction escapeBlocks(input) {\n    var /** @type {?} */ inputParts = input.split(_curlyRe);\n    var /** @type {?} */ resultParts = [];\n    var /** @type {?} */ escapedBlocks = [];\n    var /** @type {?} */ bracketCount = 0;\n    var /** @type {?} */ currentBlockParts = [];\n    for (var /** @type {?} */ partIndex = 0; partIndex < inputParts.length; partIndex++) {\n        var /** @type {?} */ part = inputParts[partIndex];\n        if (part == CLOSE_CURLY) {\n            bracketCount--;\n        }\n        if (bracketCount > 0) {\n            currentBlockParts.push(part);\n        }\n        else {\n            if (currentBlockParts.length > 0) {\n                escapedBlocks.push(currentBlockParts.join(''));\n                resultParts.push(BLOCK_PLACEHOLDER);\n                currentBlockParts = [];\n            }\n            resultParts.push(part);\n        }\n        if (part == OPEN_CURLY) {\n            bracketCount++;\n        }\n    }\n    if (currentBlockParts.length > 0) {\n        escapedBlocks.push(currentBlockParts.join(''));\n        resultParts.push(BLOCK_PLACEHOLDER);\n    }\n    return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar COMPONENT_VARIABLE = '%COMP%';\nvar HOST_ATTR = \"_nghost-\" + COMPONENT_VARIABLE;\nvar CONTENT_ATTR = \"_ngcontent-\" + COMPONENT_VARIABLE;\nvar StylesCompileDependency = (function () {\n    /**\n     * @param {?} name\n     * @param {?} moduleUrl\n     * @param {?} setValue\n     */\n    function StylesCompileDependency(name, moduleUrl, setValue) {\n        this.name = name;\n        this.moduleUrl = moduleUrl;\n        this.setValue = setValue;\n    }\n    return StylesCompileDependency;\n}());\nvar CompiledStylesheet = (function () {\n    /**\n     * @param {?} outputCtx\n     * @param {?} stylesVar\n     * @param {?} dependencies\n     * @param {?} isShimmed\n     * @param {?} meta\n     */\n    function CompiledStylesheet(outputCtx, stylesVar, dependencies, isShimmed, meta) {\n        this.outputCtx = outputCtx;\n        this.stylesVar = stylesVar;\n        this.dependencies = dependencies;\n        this.isShimmed = isShimmed;\n        this.meta = meta;\n    }\n    return CompiledStylesheet;\n}());\nvar StyleCompiler = (function () {\n    /**\n     * @param {?} _urlResolver\n     */\n    function StyleCompiler(_urlResolver) {\n        this._urlResolver = _urlResolver;\n        this._shadowCss = new ShadowCss();\n    }\n    /**\n     * @param {?} outputCtx\n     * @param {?} comp\n     * @return {?}\n     */\n    StyleCompiler.prototype.compileComponent = function (outputCtx, comp) {\n        var /** @type {?} */ template = ((comp.template));\n        return this._compileStyles(outputCtx, comp, new CompileStylesheetMetadata({\n            styles: template.styles,\n            styleUrls: template.styleUrls,\n            moduleUrl: identifierModuleUrl(comp.type)\n        }), true);\n    };\n    /**\n     * @param {?} outputCtx\n     * @param {?} comp\n     * @param {?} stylesheet\n     * @return {?}\n     */\n    StyleCompiler.prototype.compileStyles = function (outputCtx, comp, stylesheet) {\n        return this._compileStyles(outputCtx, comp, stylesheet, false);\n    };\n    /**\n     * @param {?} comp\n     * @return {?}\n     */\n    StyleCompiler.prototype.needsStyleShim = function (comp) {\n        return ((comp.template)).encapsulation === __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].Emulated;\n    };\n    /**\n     * @param {?} outputCtx\n     * @param {?} comp\n     * @param {?} stylesheet\n     * @param {?} isComponentStylesheet\n     * @return {?}\n     */\n    StyleCompiler.prototype._compileStyles = function (outputCtx, comp, stylesheet, isComponentStylesheet) {\n        var _this = this;\n        var /** @type {?} */ shim = this.needsStyleShim(comp);\n        var /** @type {?} */ styleExpressions = stylesheet.styles.map(function (plainStyle) { return literal(_this._shimIfNeeded(plainStyle, shim)); });\n        var /** @type {?} */ dependencies = [];\n        stylesheet.styleUrls.forEach(function (styleUrl) {\n            var /** @type {?} */ exprIndex = styleExpressions.length;\n            // Note: This placeholder will be filled later.\n            styleExpressions.push(/** @type {?} */ ((null)));\n            dependencies.push(new StylesCompileDependency(getStylesVarName(null), styleUrl, function (value) { return styleExpressions[exprIndex] = outputCtx.importExpr(value); }));\n        });\n        // styles variable contains plain strings and arrays of other styles arrays (recursive),\n        // so we set its type to dynamic.\n        var /** @type {?} */ stylesVar = getStylesVarName(isComponentStylesheet ? comp : null);\n        var /** @type {?} */ stmt = variable(stylesVar)\n            .set(literalArr(styleExpressions, new ArrayType(DYNAMIC_TYPE, [TypeModifier.Const])))\n            .toDeclStmt(null, isComponentStylesheet ? [StmtModifier.Final] : [\n            StmtModifier.Final, StmtModifier.Exported\n        ]);\n        outputCtx.statements.push(stmt);\n        return new CompiledStylesheet(outputCtx, stylesVar, dependencies, shim, stylesheet);\n    };\n    /**\n     * @param {?} style\n     * @param {?} shim\n     * @return {?}\n     */\n    StyleCompiler.prototype._shimIfNeeded = function (style$$1, shim) {\n        return shim ? this._shadowCss.shimCssText(style$$1, CONTENT_ATTR, HOST_ATTR) : style$$1;\n    };\n    return StyleCompiler;\n}());\nStyleCompiler.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nStyleCompiler.ctorParameters = function () { return [\n    { type: UrlResolver, },\n]; };\n/**\n * @param {?} component\n * @return {?}\n */\nfunction getStylesVarName(component) {\n    var /** @type {?} */ result = \"styles\";\n    if (component) {\n        result += \"_\" + identifierName(component.type);\n    }\n    return result;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar EventHandlerVars = (function () {\n    function EventHandlerVars() {\n    }\n    return EventHandlerVars;\n}());\nEventHandlerVars.event = variable('$event');\nvar ConvertActionBindingResult = (function () {\n    /**\n     * @param {?} stmts\n     * @param {?} allowDefault\n     */\n    function ConvertActionBindingResult(stmts, allowDefault) {\n        this.stmts = stmts;\n        this.allowDefault = allowDefault;\n    }\n    return ConvertActionBindingResult;\n}());\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression is\n * used in an action binding (e.g. an event handler).\n * @param {?} localResolver\n * @param {?} implicitReceiver\n * @param {?} action\n * @param {?} bindingId\n * @return {?}\n */\nfunction convertActionBinding(localResolver, implicitReceiver, action, bindingId) {\n    if (!localResolver) {\n        localResolver = new DefaultLocalResolver();\n    }\n    var /** @type {?} */ actionWithoutBuiltins = convertPropertyBindingBuiltins({\n        createLiteralArrayConverter: function (argCount) {\n            // Note: no caching for literal arrays in actions.\n            return function (args) { return literalArr(args); };\n        },\n        createLiteralMapConverter: function (keys) {\n            // Note: no caching for literal maps in actions.\n            return function (values) {\n                var /** @type {?} */ entries = keys.map(function (k, i) { return ({\n                    key: k.key,\n                    value: values[i],\n                    quoted: k.quoted,\n                }); });\n                return literalMap(entries);\n            };\n        },\n        createPipeConverter: function (name) {\n            throw new Error(\"Illegal State: Actions are not allowed to contain pipes. Pipe: \" + name);\n        }\n    }, action);\n    var /** @type {?} */ visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId);\n    var /** @type {?} */ actionStmts = [];\n    flattenStatements(actionWithoutBuiltins.visit(visitor, _Mode.Statement), actionStmts);\n    prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);\n    var /** @type {?} */ lastIndex = actionStmts.length - 1;\n    var /** @type {?} */ preventDefaultVar = ((null));\n    if (lastIndex >= 0) {\n        var /** @type {?} */ lastStatement = actionStmts[lastIndex];\n        var /** @type {?} */ returnExpr = convertStmtIntoExpression(lastStatement);\n        if (returnExpr) {\n            // Note: We need to cast the result of the method call to dynamic,\n            // as it might be a void method!\n            preventDefaultVar = createPreventDefaultVar(bindingId);\n            actionStmts[lastIndex] =\n                preventDefaultVar.set(returnExpr.cast(DYNAMIC_TYPE).notIdentical(literal(false)))\n                    .toDeclStmt(null, [StmtModifier.Final]);\n        }\n    }\n    return new ConvertActionBindingResult(actionStmts, preventDefaultVar);\n}\n/**\n * @param {?} converterFactory\n * @param {?} ast\n * @return {?}\n */\nfunction convertPropertyBindingBuiltins(converterFactory, ast) {\n    return convertBuiltins(converterFactory, ast);\n}\nvar ConvertPropertyBindingResult = (function () {\n    /**\n     * @param {?} stmts\n     * @param {?} currValExpr\n     */\n    function ConvertPropertyBindingResult(stmts, currValExpr) {\n        this.stmts = stmts;\n        this.currValExpr = currValExpr;\n    }\n    return ConvertPropertyBindingResult;\n}());\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression\n * is used in property binding. The expression has to be preprocessed via\n * `convertPropertyBindingBuiltins`.\n * @param {?} localResolver\n * @param {?} implicitReceiver\n * @param {?} expressionWithoutBuiltins\n * @param {?} bindingId\n * @return {?}\n */\nfunction convertPropertyBinding(localResolver, implicitReceiver, expressionWithoutBuiltins, bindingId) {\n    if (!localResolver) {\n        localResolver = new DefaultLocalResolver();\n    }\n    var /** @type {?} */ currValExpr = createCurrValueExpr(bindingId);\n    var /** @type {?} */ stmts = [];\n    var /** @type {?} */ visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId);\n    var /** @type {?} */ outputExpr = expressionWithoutBuiltins.visit(visitor, _Mode.Expression);\n    if (visitor.temporaryCount) {\n        for (var /** @type {?} */ i = 0; i < visitor.temporaryCount; i++) {\n            stmts.push(temporaryDeclaration(bindingId, i));\n        }\n    }\n    stmts.push(currValExpr.set(outputExpr).toDeclStmt(null, [StmtModifier.Final]));\n    return new ConvertPropertyBindingResult(stmts, currValExpr);\n}\n/**\n * @param {?} converterFactory\n * @param {?} ast\n * @return {?}\n */\nfunction convertBuiltins(converterFactory, ast) {\n    var /** @type {?} */ visitor = new _BuiltinAstConverter(converterFactory);\n    return ast.visit(visitor);\n}\n/**\n * @param {?} bindingId\n * @param {?} temporaryNumber\n * @return {?}\n */\nfunction temporaryName(bindingId, temporaryNumber) {\n    return \"tmp_\" + bindingId + \"_\" + temporaryNumber;\n}\n/**\n * @param {?} bindingId\n * @param {?} temporaryNumber\n * @return {?}\n */\nfunction temporaryDeclaration(bindingId, temporaryNumber) {\n    return new DeclareVarStmt(temporaryName(bindingId, temporaryNumber), NULL_EXPR);\n}\n/**\n * @param {?} temporaryCount\n * @param {?} bindingId\n * @param {?} statements\n * @return {?}\n */\nfunction prependTemporaryDecls(temporaryCount, bindingId, statements) {\n    for (var /** @type {?} */ i = temporaryCount - 1; i >= 0; i--) {\n        statements.unshift(temporaryDeclaration(bindingId, i));\n    }\n}\nvar _Mode = {};\n_Mode.Statement = 0;\n_Mode.Expression = 1;\n_Mode[_Mode.Statement] = \"Statement\";\n_Mode[_Mode.Expression] = \"Expression\";\n/**\n * @param {?} mode\n * @param {?} ast\n * @return {?}\n */\nfunction ensureStatementMode(mode, ast) {\n    if (mode !== _Mode.Statement) {\n        throw new Error(\"Expected a statement, but saw \" + ast);\n    }\n}\n/**\n * @param {?} mode\n * @param {?} ast\n * @return {?}\n */\nfunction ensureExpressionMode(mode, ast) {\n    if (mode !== _Mode.Expression) {\n        throw new Error(\"Expected an expression, but saw \" + ast);\n    }\n}\n/**\n * @param {?} mode\n * @param {?} expr\n * @return {?}\n */\nfunction convertToStatementIfNeeded(mode, expr) {\n    if (mode === _Mode.Statement) {\n        return expr.toStmt();\n    }\n    else {\n        return expr;\n    }\n}\nvar _BuiltinAstConverter = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](_BuiltinAstConverter, _super);\n    /**\n     * @param {?} _converterFactory\n     */\n    function _BuiltinAstConverter(_converterFactory) {\n        var _this = _super.call(this) || this;\n        _this._converterFactory = _converterFactory;\n        return _this;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    _BuiltinAstConverter.prototype.visitPipe = function (ast, context) {\n        var _this = this;\n        var /** @type {?} */ args = [ast.exp].concat(ast.args).map(function (ast) { return ast.visit(_this, context); });\n        return new BuiltinFunctionCall(ast.span, args, this._converterFactory.createPipeConverter(ast.name, args.length));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    _BuiltinAstConverter.prototype.visitLiteralArray = function (ast, context) {\n        var _this = this;\n        var /** @type {?} */ args = ast.expressions.map(function (ast) { return ast.visit(_this, context); });\n        return new BuiltinFunctionCall(ast.span, args, this._converterFactory.createLiteralArrayConverter(ast.expressions.length));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    _BuiltinAstConverter.prototype.visitLiteralMap = function (ast, context) {\n        var _this = this;\n        var /** @type {?} */ args = ast.values.map(function (ast) { return ast.visit(_this, context); });\n        return new BuiltinFunctionCall(ast.span, args, this._converterFactory.createLiteralMapConverter(ast.keys));\n    };\n    return _BuiltinAstConverter;\n}(AstTransformer));\nvar _AstToIrVisitor = (function () {\n    /**\n     * @param {?} _localResolver\n     * @param {?} _implicitReceiver\n     * @param {?} bindingId\n     */\n    function _AstToIrVisitor(_localResolver, _implicitReceiver, bindingId) {\n        this._localResolver = _localResolver;\n        this._implicitReceiver = _implicitReceiver;\n        this.bindingId = bindingId;\n        this._nodeMap = new Map();\n        this._resultMap = new Map();\n        this._currentTemporary = 0;\n        this.temporaryCount = 0;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitBinary = function (ast, mode) {\n        var /** @type {?} */ op;\n        switch (ast.operation) {\n            case '+':\n                op = BinaryOperator.Plus;\n                break;\n            case '-':\n                op = BinaryOperator.Minus;\n                break;\n            case '*':\n                op = BinaryOperator.Multiply;\n                break;\n            case '/':\n                op = BinaryOperator.Divide;\n                break;\n            case '%':\n                op = BinaryOperator.Modulo;\n                break;\n            case '&&':\n                op = BinaryOperator.And;\n                break;\n            case '||':\n                op = BinaryOperator.Or;\n                break;\n            case '==':\n                op = BinaryOperator.Equals;\n                break;\n            case '!=':\n                op = BinaryOperator.NotEquals;\n                break;\n            case '===':\n                op = BinaryOperator.Identical;\n                break;\n            case '!==':\n                op = BinaryOperator.NotIdentical;\n                break;\n            case '<':\n                op = BinaryOperator.Lower;\n                break;\n            case '>':\n                op = BinaryOperator.Bigger;\n                break;\n            case '<=':\n                op = BinaryOperator.LowerEquals;\n                break;\n            case '>=':\n                op = BinaryOperator.BiggerEquals;\n                break;\n            default:\n                throw new Error(\"Unsupported operation \" + ast.operation);\n        }\n        return convertToStatementIfNeeded(mode, new BinaryOperatorExpr(op, this._visit(ast.left, _Mode.Expression), this._visit(ast.right, _Mode.Expression)));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitChain = function (ast, mode) {\n        ensureStatementMode(mode, ast);\n        return this.visitAll(ast.expressions, mode);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitConditional = function (ast, mode) {\n        var /** @type {?} */ value = this._visit(ast.condition, _Mode.Expression);\n        return convertToStatementIfNeeded(mode, value.conditional(this._visit(ast.trueExp, _Mode.Expression), this._visit(ast.falseExp, _Mode.Expression)));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitPipe = function (ast, mode) {\n        throw new Error(\"Illegal state: Pipes should have been converted into functions. Pipe: \" + ast.name);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitFunctionCall = function (ast, mode) {\n        var /** @type {?} */ convertedArgs = this.visitAll(ast.args, _Mode.Expression);\n        var /** @type {?} */ fnResult;\n        if (ast instanceof BuiltinFunctionCall) {\n            fnResult = ast.converter(convertedArgs);\n        }\n        else {\n            fnResult = this._visit(/** @type {?} */ ((ast.target)), _Mode.Expression).callFn(convertedArgs);\n        }\n        return convertToStatementIfNeeded(mode, fnResult);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitImplicitReceiver = function (ast, mode) {\n        ensureExpressionMode(mode, ast);\n        return this._implicitReceiver;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitInterpolation = function (ast, mode) {\n        ensureExpressionMode(mode, ast);\n        var /** @type {?} */ args = [literal(ast.expressions.length)];\n        for (var /** @type {?} */ i = 0; i < ast.strings.length - 1; i++) {\n            args.push(literal(ast.strings[i]));\n            args.push(this._visit(ast.expressions[i], _Mode.Expression));\n        }\n        args.push(literal(ast.strings[ast.strings.length - 1]));\n        return ast.expressions.length <= 9 ?\n            importExpr(Identifiers.inlineInterpolate).callFn(args) :\n            importExpr(Identifiers.interpolate).callFn([args[0], literalArr(args.slice(1))]);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitKeyedRead = function (ast, mode) {\n        var /** @type {?} */ leftMostSafe = this.leftMostSafeNode(ast);\n        if (leftMostSafe) {\n            return this.convertSafeAccess(ast, leftMostSafe, mode);\n        }\n        else {\n            return convertToStatementIfNeeded(mode, this._visit(ast.obj, _Mode.Expression).key(this._visit(ast.key, _Mode.Expression)));\n        }\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitKeyedWrite = function (ast, mode) {\n        var /** @type {?} */ obj = this._visit(ast.obj, _Mode.Expression);\n        var /** @type {?} */ key = this._visit(ast.key, _Mode.Expression);\n        var /** @type {?} */ value = this._visit(ast.value, _Mode.Expression);\n        return convertToStatementIfNeeded(mode, obj.key(key).set(value));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitLiteralArray = function (ast, mode) {\n        throw new Error(\"Illegal State: literal arrays should have been converted into functions\");\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitLiteralMap = function (ast, mode) {\n        throw new Error(\"Illegal State: literal maps should have been converted into functions\");\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitLiteralPrimitive = function (ast, mode) {\n        return convertToStatementIfNeeded(mode, literal(ast.value));\n    };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype._getLocal = function (name) { return this._localResolver.getLocal(name); };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitMethodCall = function (ast, mode) {\n        var /** @type {?} */ leftMostSafe = this.leftMostSafeNode(ast);\n        if (leftMostSafe) {\n            return this.convertSafeAccess(ast, leftMostSafe, mode);\n        }\n        else {\n            var /** @type {?} */ args = this.visitAll(ast.args, _Mode.Expression);\n            var /** @type {?} */ result = null;\n            var /** @type {?} */ receiver = this._visit(ast.receiver, _Mode.Expression);\n            if (receiver === this._implicitReceiver) {\n                var /** @type {?} */ varExpr = this._getLocal(ast.name);\n                if (varExpr) {\n                    result = varExpr.callFn(args);\n                }\n            }\n            if (result == null) {\n                result = receiver.callMethod(ast.name, args);\n            }\n            return convertToStatementIfNeeded(mode, result);\n        }\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitPrefixNot = function (ast, mode) {\n        return convertToStatementIfNeeded(mode, not(this._visit(ast.expression, _Mode.Expression)));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitNonNullAssert = function (ast, mode) {\n        return convertToStatementIfNeeded(mode, assertNotNull(this._visit(ast.expression, _Mode.Expression)));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitPropertyRead = function (ast, mode) {\n        var /** @type {?} */ leftMostSafe = this.leftMostSafeNode(ast);\n        if (leftMostSafe) {\n            return this.convertSafeAccess(ast, leftMostSafe, mode);\n        }\n        else {\n            var /** @type {?} */ result = null;\n            var /** @type {?} */ receiver = this._visit(ast.receiver, _Mode.Expression);\n            if (receiver === this._implicitReceiver) {\n                result = this._getLocal(ast.name);\n            }\n            if (result == null) {\n                result = receiver.prop(ast.name);\n            }\n            return convertToStatementIfNeeded(mode, result);\n        }\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitPropertyWrite = function (ast, mode) {\n        var /** @type {?} */ receiver = this._visit(ast.receiver, _Mode.Expression);\n        if (receiver === this._implicitReceiver) {\n            var /** @type {?} */ varExpr = this._getLocal(ast.name);\n            if (varExpr) {\n                throw new Error('Cannot assign to a reference or variable!');\n            }\n        }\n        return convertToStatementIfNeeded(mode, receiver.prop(ast.name).set(this._visit(ast.value, _Mode.Expression)));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitSafePropertyRead = function (ast, mode) {\n        return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitSafeMethodCall = function (ast, mode) {\n        return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n    };\n    /**\n     * @param {?} asts\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitAll = function (asts, mode) {\n        var _this = this;\n        return asts.map(function (ast) { return _this._visit(ast, mode); });\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitQuote = function (ast, mode) {\n        throw new Error(\"Quotes are not supported for evaluation!\\n        Statement: \" + ast.uninterpretedExpression + \" located at \" + ast.location);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype._visit = function (ast, mode) {\n        var /** @type {?} */ result = this._resultMap.get(ast);\n        if (result)\n            return result;\n        return (this._nodeMap.get(ast) || ast).visit(this, mode);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} leftMostSafe\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.convertSafeAccess = function (ast, leftMostSafe, mode) {\n        // If the expression contains a safe access node on the left it needs to be converted to\n        // an expression that guards the access to the member by checking the receiver for blank. As\n        // execution proceeds from left to right, the left most part of the expression must be guarded\n        // first but, because member access is left associative, the right side of the expression is at\n        // the top of the AST. The desired result requires lifting a copy of the the left part of the\n        // expression up to test it for blank before generating the unguarded version.\n        // Consider, for example the following expression: a?.b.c?.d.e\n        // This results in the ast:\n        //         .\n        //        / \\\n        //       ?.   e\n        //      /  \\\n        //     .    d\n        //    / \\\n        //   ?.  c\n        //  /  \\\n        // a    b\n        // The following tree should be generated:\n        //\n        //        /---- ? ----\\\n        //       /      |      \\\n        //     a   /--- ? ---\\  null\n        //        /     |     \\\n        //       .      .     null\n        //      / \\    / \\\n        //     .  c   .   e\n        //    / \\    / \\\n        //   a   b  ,   d\n        //         / \\\n        //        .   c\n        //       / \\\n        //      a   b\n        //\n        // Notice that the first guard condition is the left hand of the left most safe access node\n        // which comes in as leftMostSafe to this routine.\n        var /** @type {?} */ guardedExpression = this._visit(leftMostSafe.receiver, _Mode.Expression);\n        var /** @type {?} */ temporary = ((undefined));\n        if (this.needsTemporary(leftMostSafe.receiver)) {\n            // If the expression has method calls or pipes then we need to save the result into a\n            // temporary variable to avoid calling stateful or impure code more than once.\n            temporary = this.allocateTemporary();\n            // Preserve the result in the temporary variable\n            guardedExpression = temporary.set(guardedExpression);\n            // Ensure all further references to the guarded expression refer to the temporary instead.\n            this._resultMap.set(leftMostSafe.receiver, temporary);\n        }\n        var /** @type {?} */ condition = guardedExpression.isBlank();\n        // Convert the ast to an unguarded access to the receiver's member. The map will substitute\n        // leftMostNode with its unguarded version in the call to `this.visit()`.\n        if (leftMostSafe instanceof SafeMethodCall) {\n            this._nodeMap.set(leftMostSafe, new MethodCall(leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name, leftMostSafe.args));\n        }\n        else {\n            this._nodeMap.set(leftMostSafe, new PropertyRead(leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name));\n        }\n        // Recursively convert the node now without the guarded member access.\n        var /** @type {?} */ access = this._visit(ast, _Mode.Expression);\n        // Remove the mapping. This is not strictly required as the converter only traverses each node\n        // once but is safer if the conversion is changed to traverse the nodes more than once.\n        this._nodeMap.delete(leftMostSafe);\n        // If we allocated a temporary, release it.\n        if (temporary) {\n            this.releaseTemporary(temporary);\n        }\n        // Produce the conditional\n        return convertToStatementIfNeeded(mode, condition.conditional(literal(null), access));\n    };\n    /**\n     * @param {?} ast\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.leftMostSafeNode = function (ast) {\n        var _this = this;\n        var /** @type {?} */ visit = function (visitor, ast) {\n            return (_this._nodeMap.get(ast) || ast).visit(visitor);\n        };\n        return ast.visit({\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitBinary: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitChain: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitConditional: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitFunctionCall: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitImplicitReceiver: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitInterpolation: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitKeyedRead: function (ast) { return visit(this, ast.obj); },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitKeyedWrite: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitLiteralArray: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitLiteralMap: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitLiteralPrimitive: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitMethodCall: function (ast) { return visit(this, ast.receiver); },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPipe: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPrefixNot: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitNonNullAssert: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPropertyRead: function (ast) { return visit(this, ast.receiver); },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPropertyWrite: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitQuote: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitSafeMethodCall: function (ast) { return visit(this, ast.receiver) || ast; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitSafePropertyRead: function (ast) {\n                return visit(this, ast.receiver) || ast;\n            }\n        });\n    };\n    /**\n     * @param {?} ast\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.needsTemporary = function (ast) {\n        var _this = this;\n        var /** @type {?} */ visit = function (visitor, ast) {\n            return ast && (_this._nodeMap.get(ast) || ast).visit(visitor);\n        };\n        var /** @type {?} */ visitSome = function (visitor, ast) {\n            return ast.some(function (ast) { return visit(visitor, ast); });\n        };\n        return ast.visit({\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitBinary: function (ast) { return visit(this, ast.left) || visit(this, ast.right); },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitChain: function (ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitConditional: function (ast) {\n                return visit(this, ast.condition) || visit(this, ast.trueExp) ||\n                    visit(this, ast.falseExp);\n            },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitFunctionCall: function (ast) { return true; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitImplicitReceiver: function (ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitInterpolation: function (ast) { return visitSome(this, ast.expressions); },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitKeyedRead: function (ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitKeyedWrite: function (ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitLiteralArray: function (ast) { return true; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitLiteralMap: function (ast) { return true; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitLiteralPrimitive: function (ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitMethodCall: function (ast) { return true; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPipe: function (ast) { return true; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPrefixNot: function (ast) { return visit(this, ast.expression); },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitNonNullAssert: function (ast) { return visit(this, ast.expression); },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPropertyRead: function (ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPropertyWrite: function (ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitQuote: function (ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitSafeMethodCall: function (ast) { return true; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitSafePropertyRead: function (ast) { return false; }\n        });\n    };\n    /**\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.allocateTemporary = function () {\n        var /** @type {?} */ tempNumber = this._currentTemporary++;\n        this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);\n        return new ReadVarExpr(temporaryName(this.bindingId, tempNumber));\n    };\n    /**\n     * @param {?} temporary\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.releaseTemporary = function (temporary) {\n        this._currentTemporary--;\n        if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {\n            throw new Error(\"Temporary \" + temporary.name + \" released out of order\");\n        }\n    };\n    return _AstToIrVisitor;\n}());\n/**\n * @param {?} arg\n * @param {?} output\n * @return {?}\n */\nfunction flattenStatements(arg, output) {\n    if (Array.isArray(arg)) {\n        ((arg)).forEach(function (entry) { return flattenStatements(entry, output); });\n    }\n    else {\n        output.push(arg);\n    }\n}\nvar DefaultLocalResolver = (function () {\n    function DefaultLocalResolver() {\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    DefaultLocalResolver.prototype.getLocal = function (name) {\n        if (name === EventHandlerVars.event.name) {\n            return EventHandlerVars.event;\n        }\n        return null;\n    };\n    return DefaultLocalResolver;\n}());\n/**\n * @param {?} bindingId\n * @return {?}\n */\nfunction createCurrValueExpr(bindingId) {\n    return variable(\"currVal_\" + bindingId); // fix syntax highlighting: `\n}\n/**\n * @param {?} bindingId\n * @return {?}\n */\nfunction createPreventDefaultVar(bindingId) {\n    return variable(\"pd_\" + bindingId);\n}\n/**\n * @param {?} stmt\n * @return {?}\n */\nfunction convertStmtIntoExpression(stmt) {\n    if (stmt instanceof ExpressionStatement) {\n        return stmt.expr;\n    }\n    else if (stmt instanceof ReturnStatement) {\n        return stmt.value;\n    }\n    return null;\n}\nvar BuiltinFunctionCall = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](BuiltinFunctionCall, _super);\n    /**\n     * @param {?} span\n     * @param {?} args\n     * @param {?} converter\n     */\n    function BuiltinFunctionCall(span, args, converter) {\n        var _this = _super.call(this, span, null, args) || this;\n        _this.args = args;\n        _this.converter = converter;\n        return _this;\n    }\n    return BuiltinFunctionCall;\n}(FunctionCall));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar CLASS_ATTR$1 = 'class';\nvar STYLE_ATTR = 'style';\nvar IMPLICIT_TEMPLATE_VAR = '\\$implicit';\nvar ViewCompileResult = (function () {\n    /**\n     * @param {?} viewClassVar\n     * @param {?} rendererTypeVar\n     */\n    function ViewCompileResult(viewClassVar, rendererTypeVar) {\n        this.viewClassVar = viewClassVar;\n        this.rendererTypeVar = rendererTypeVar;\n    }\n    return ViewCompileResult;\n}());\nvar ViewCompiler = (function () {\n    /**\n     * @param {?} _config\n     * @param {?} _reflector\n     * @param {?} _schemaRegistry\n     */\n    function ViewCompiler(_config, _reflector, _schemaRegistry) {\n        this._config = _config;\n        this._reflector = _reflector;\n        this._schemaRegistry = _schemaRegistry;\n    }\n    /**\n     * @param {?} outputCtx\n     * @param {?} component\n     * @param {?} template\n     * @param {?} styles\n     * @param {?} usedPipes\n     * @return {?}\n     */\n    ViewCompiler.prototype.compileComponent = function (outputCtx, component, template, styles, usedPipes) {\n        var _this = this;\n        var /** @type {?} */ embeddedViewCount = 0;\n        var /** @type {?} */ staticQueryIds = findStaticQueryIds(template);\n        var /** @type {?} */ renderComponentVarName = ((undefined));\n        if (!component.isHost) {\n            var /** @type {?} */ template_1 = ((component.template));\n            var /** @type {?} */ customRenderData = [];\n            if (template_1.animations && template_1.animations.length) {\n                customRenderData.push(new LiteralMapEntry('animation', convertValueToOutputAst(outputCtx, template_1.animations), true));\n            }\n            var /** @type {?} */ renderComponentVar = variable(rendererTypeName(component.type.reference));\n            renderComponentVarName = ((renderComponentVar.name));\n            outputCtx.statements.push(renderComponentVar\n                .set(importExpr(Identifiers.createRendererType2).callFn([new LiteralMapExpr([\n                    new LiteralMapEntry('encapsulation', literal(template_1.encapsulation), false),\n                    new LiteralMapEntry('styles', styles, false),\n                    new LiteralMapEntry('data', new LiteralMapExpr(customRenderData), false)\n                ])]))\n                .toDeclStmt(importType(Identifiers.RendererType2), [StmtModifier.Final, StmtModifier.Exported]));\n        }\n        var /** @type {?} */ viewBuilderFactory = function (parent) {\n            var /** @type {?} */ embeddedViewIndex = embeddedViewCount++;\n            return new ViewBuilder(_this._reflector, outputCtx, parent, component, embeddedViewIndex, usedPipes, staticQueryIds, viewBuilderFactory);\n        };\n        var /** @type {?} */ visitor = viewBuilderFactory(null);\n        visitor.visitAll([], template);\n        (_a = outputCtx.statements).push.apply(_a, visitor.build());\n        return new ViewCompileResult(visitor.viewName, renderComponentVarName);\n        var _a;\n    };\n    return ViewCompiler;\n}());\nViewCompiler.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nViewCompiler.ctorParameters = function () { return [\n    { type: CompilerConfig, },\n    { type: CompileReflector, },\n    { type: ElementSchemaRegistry, },\n]; };\nvar LOG_VAR$1 = variable('_l');\nvar VIEW_VAR = variable('_v');\nvar CHECK_VAR = variable('_ck');\nvar COMP_VAR = variable('_co');\nvar EVENT_NAME_VAR = variable('en');\nvar ALLOW_DEFAULT_VAR = variable(\"ad\");\nvar ViewBuilder = (function () {\n    /**\n     * @param {?} reflector\n     * @param {?} outputCtx\n     * @param {?} parent\n     * @param {?} component\n     * @param {?} embeddedViewIndex\n     * @param {?} usedPipes\n     * @param {?} staticQueryIds\n     * @param {?} viewBuilderFactory\n     */\n    function ViewBuilder(reflector, outputCtx, parent, component, embeddedViewIndex, usedPipes, staticQueryIds, viewBuilderFactory) {\n        this.reflector = reflector;\n        this.outputCtx = outputCtx;\n        this.parent = parent;\n        this.component = component;\n        this.embeddedViewIndex = embeddedViewIndex;\n        this.usedPipes = usedPipes;\n        this.staticQueryIds = staticQueryIds;\n        this.viewBuilderFactory = viewBuilderFactory;\n        this.nodes = [];\n        this.purePipeNodeIndices = Object.create(null);\n        this.refNodeIndices = Object.create(null);\n        this.variables = [];\n        this.children = [];\n        // TODO(tbosch): The old view compiler used to use an `any` type\n        // for the context in any embedded view. We keep this behaivor for now\n        // to be able to introduce the new view compiler without too many errors.\n        this.compType = this.embeddedViewIndex > 0 ?\n            DYNAMIC_TYPE :\n            expressionType(outputCtx.importExpr(this.component.type.reference));\n    }\n    Object.defineProperty(ViewBuilder.prototype, \"viewName\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return viewClassName(this.component.type.reference, this.embeddedViewIndex);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} variables\n     * @param {?} astNodes\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitAll = function (variables, astNodes) {\n        var _this = this;\n        this.variables = variables;\n        // create the pipes for the pure pipes immediately, so that we know their indices.\n        if (!this.parent) {\n            this.usedPipes.forEach(function (pipe) {\n                if (pipe.pure) {\n                    _this.purePipeNodeIndices[pipe.name] = _this._createPipe(null, pipe);\n                }\n            });\n        }\n        if (!this.parent) {\n            var /** @type {?} */ queryIds_1 = staticViewQueryIds(this.staticQueryIds);\n            this.component.viewQueries.forEach(function (query, queryIndex) {\n                // Note: queries start with id 1 so we can use the number in a Bloom filter!\n                var /** @type {?} */ queryId = queryIndex + 1;\n                var /** @type {?} */ bindingType = query.first ? 0 /* First */ : 1;\n                var /** @type {?} */ flags = 134217728 /* TypeViewQuery */ | calcStaticDynamicQueryFlags(queryIds_1, queryId, query.first);\n                _this.nodes.push(function () { return ({\n                    sourceSpan: null,\n                    nodeFlags: flags,\n                    nodeDef: importExpr(Identifiers.queryDef).callFn([\n                        literal(flags), literal(queryId),\n                        new LiteralMapExpr([new LiteralMapEntry(query.propertyName, literal(bindingType), false)])\n                    ])\n                }); });\n            });\n        }\n        templateVisitAll(this, astNodes);\n        if (this.parent && (astNodes.length === 0 || needsAdditionalRootNode(astNodes))) {\n            // if the view is an embedded view, then we need to add an additional root node in some cases\n            this.nodes.push(function () { return ({\n                sourceSpan: null,\n                nodeFlags: 1 /* TypeElement */,\n                nodeDef: importExpr(Identifiers.anchorDef).callFn([\n                    literal(0 /* None */), NULL_EXPR, NULL_EXPR, literal(0)\n                ])\n            }); });\n        }\n    };\n    /**\n     * @param {?=} targetStatements\n     * @return {?}\n     */\n    ViewBuilder.prototype.build = function (targetStatements) {\n        if (targetStatements === void 0) { targetStatements = []; }\n        this.children.forEach(function (child) { return child.build(targetStatements); });\n        var _a = this._createNodeExpressions(), updateRendererStmts = _a.updateRendererStmts, updateDirectivesStmts = _a.updateDirectivesStmts, nodeDefExprs = _a.nodeDefExprs;\n        var /** @type {?} */ updateRendererFn = this._createUpdateFn(updateRendererStmts);\n        var /** @type {?} */ updateDirectivesFn = this._createUpdateFn(updateDirectivesStmts);\n        var /** @type {?} */ viewFlags = 0;\n        if (!this.parent && this.component.changeDetection === __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush) {\n            viewFlags |= 2 /* OnPush */;\n        }\n        var /** @type {?} */ viewFactory = new DeclareFunctionStmt(this.viewName, [new FnParam(/** @type {?} */ ((LOG_VAR$1.name)))], [new ReturnStatement(importExpr(Identifiers.viewDef).callFn([\n                literal(viewFlags),\n                literalArr(nodeDefExprs),\n                updateDirectivesFn,\n                updateRendererFn,\n            ]))], importType(Identifiers.ViewDefinition), this.embeddedViewIndex === 0 ? [StmtModifier.Exported] : []);\n        targetStatements.push(viewFactory);\n        return targetStatements;\n    };\n    /**\n     * @param {?} updateStmts\n     * @return {?}\n     */\n    ViewBuilder.prototype._createUpdateFn = function (updateStmts) {\n        var /** @type {?} */ updateFn;\n        if (updateStmts.length > 0) {\n            var /** @type {?} */ preStmts = [];\n            if (!this.component.isHost && findReadVarNames(updateStmts).has(/** @type {?} */ ((COMP_VAR.name)))) {\n                preStmts.push(COMP_VAR.set(VIEW_VAR.prop('component')).toDeclStmt(this.compType));\n            }\n            updateFn = fn([\n                new FnParam(/** @type {?} */ ((CHECK_VAR.name)), INFERRED_TYPE),\n                new FnParam(/** @type {?} */ ((VIEW_VAR.name)), INFERRED_TYPE)\n            ], preStmts.concat(updateStmts), INFERRED_TYPE);\n        }\n        else {\n            updateFn = NULL_EXPR;\n        }\n        return updateFn;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitNgContent = function (ast, context) {\n        // ngContentDef(ngContentIndex: number, index: number): NodeDef;\n        this.nodes.push(function () { return ({\n            sourceSpan: ast.sourceSpan,\n            nodeFlags: 8 /* TypeNgContent */,\n            nodeDef: importExpr(Identifiers.ngContentDef).callFn([\n                literal(ast.ngContentIndex), literal(ast.index)\n            ])\n        }); });\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitText = function (ast, context) {\n        // textDef(ngContentIndex: number, constants: string[]): NodeDef;\n        this.nodes.push(function () { return ({\n            sourceSpan: ast.sourceSpan,\n            nodeFlags: 2 /* TypeText */,\n            nodeDef: importExpr(Identifiers.textDef).callFn([\n                literal(ast.ngContentIndex), literalArr([literal(ast.value)])\n            ])\n        }); });\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitBoundText = function (ast, context) {\n        var _this = this;\n        var /** @type {?} */ nodeIndex = this.nodes.length;\n        // reserve the space in the nodeDefs array\n        this.nodes.push(/** @type {?} */ ((null)));\n        var /** @type {?} */ astWithSource = (ast.value);\n        var /** @type {?} */ inter = (astWithSource.ast);\n        var /** @type {?} */ updateRendererExpressions = inter.expressions.map(function (expr, bindingIndex) { return _this._preprocessUpdateExpression({ nodeIndex: nodeIndex, bindingIndex: bindingIndex, sourceSpan: ast.sourceSpan, context: COMP_VAR, value: expr }); });\n        // textDef(ngContentIndex: number, constants: string[]): NodeDef;\n        this.nodes[nodeIndex] = function () { return ({\n            sourceSpan: ast.sourceSpan,\n            nodeFlags: 2 /* TypeText */,\n            nodeDef: importExpr(Identifiers.textDef).callFn([\n                literal(ast.ngContentIndex), literalArr(inter.strings.map(function (s) { return literal(s); }))\n            ]),\n            updateRenderer: updateRendererExpressions\n        }); };\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitEmbeddedTemplate = function (ast, context) {\n        var _this = this;\n        var /** @type {?} */ nodeIndex = this.nodes.length;\n        // reserve the space in the nodeDefs array\n        this.nodes.push(/** @type {?} */ ((null)));\n        var _a = this._visitElementOrTemplate(nodeIndex, ast), flags = _a.flags, queryMatchesExpr = _a.queryMatchesExpr, hostEvents = _a.hostEvents;\n        var /** @type {?} */ childVisitor = this.viewBuilderFactory(this);\n        this.children.push(childVisitor);\n        childVisitor.visitAll(ast.variables, ast.children);\n        var /** @type {?} */ childCount = this.nodes.length - nodeIndex - 1;\n        // anchorDef(\n        //   flags: NodeFlags, matchedQueries: [string, QueryValueType][], ngContentIndex: number,\n        //   childCount: number, handleEventFn?: ElementHandleEventFn, templateFactory?:\n        //   ViewDefinitionFactory): NodeDef;\n        this.nodes[nodeIndex] = function () { return ({\n            sourceSpan: ast.sourceSpan,\n            nodeFlags: 1 /* TypeElement */ | flags,\n            nodeDef: importExpr(Identifiers.anchorDef).callFn([\n                literal(flags),\n                queryMatchesExpr,\n                literal(ast.ngContentIndex),\n                literal(childCount),\n                _this._createElementHandleEventFn(nodeIndex, hostEvents),\n                variable(childVisitor.viewName),\n            ])\n        }); };\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitElement = function (ast, context) {\n        var _this = this;\n        var /** @type {?} */ nodeIndex = this.nodes.length;\n        // reserve the space in the nodeDefs array so we can add children\n        this.nodes.push(/** @type {?} */ ((null)));\n        // Using a null element name creates an anchor.\n        var /** @type {?} */ elName = isNgContainer(ast.name) ? null : ast.name;\n        var _a = this._visitElementOrTemplate(nodeIndex, ast), flags = _a.flags, usedEvents = _a.usedEvents, queryMatchesExpr = _a.queryMatchesExpr, dirHostBindings = _a.hostBindings, hostEvents = _a.hostEvents;\n        var /** @type {?} */ inputDefs = [];\n        var /** @type {?} */ updateRendererExpressions = [];\n        var /** @type {?} */ outputDefs = [];\n        if (elName) {\n            var /** @type {?} */ hostBindings = ast.inputs\n                .map(function (inputAst) { return ({\n                context: /** @type {?} */ (COMP_VAR),\n                inputAst: inputAst,\n                dirAst: /** @type {?} */ (null),\n            }); })\n                .concat(dirHostBindings);\n            if (hostBindings.length) {\n                updateRendererExpressions =\n                    hostBindings.map(function (hostBinding, bindingIndex) { return _this._preprocessUpdateExpression({\n                        context: hostBinding.context,\n                        nodeIndex: nodeIndex,\n                        bindingIndex: bindingIndex,\n                        sourceSpan: hostBinding.inputAst.sourceSpan,\n                        value: hostBinding.inputAst.value\n                    }); });\n                inputDefs = hostBindings.map(function (hostBinding) { return elementBindingDef(hostBinding.inputAst, hostBinding.dirAst); });\n            }\n            outputDefs = usedEvents.map(function (_a) {\n                var target = _a[0], eventName = _a[1];\n                return literalArr([literal(target), literal(eventName)]);\n            });\n        }\n        templateVisitAll(this, ast.children);\n        var /** @type {?} */ childCount = this.nodes.length - nodeIndex - 1;\n        var /** @type {?} */ compAst = ast.directives.find(function (dirAst) { return dirAst.directive.isComponent; });\n        var /** @type {?} */ compRendererType = (NULL_EXPR);\n        var /** @type {?} */ compView = (NULL_EXPR);\n        if (compAst) {\n            compView = this.outputCtx.importExpr(compAst.directive.componentViewType);\n            compRendererType = this.outputCtx.importExpr(compAst.directive.rendererType);\n        }\n        // elementDef(\n        //   flags: NodeFlags, matchedQueriesDsl: [string | number, QueryValueType][],\n        //   ngContentIndex: number, childCount: number, namespaceAndName: string,\n        //   fixedAttrs: [string, string][] = [],\n        //   bindings?: [BindingFlags, string, string | SecurityContext][],\n        //   outputs?: ([OutputType.ElementOutput | OutputType.DirectiveHostOutput, string, string])[],\n        //   handleEvent?: ElementHandleEventFn,\n        //   componentView?: () => ViewDefinition, componentRendererType?: RendererType2): NodeDef;\n        this.nodes[nodeIndex] = function () { return ({\n            sourceSpan: ast.sourceSpan,\n            nodeFlags: 1 /* TypeElement */ | flags,\n            nodeDef: importExpr(Identifiers.elementDef).callFn([\n                literal(flags),\n                queryMatchesExpr,\n                literal(ast.ngContentIndex),\n                literal(childCount),\n                literal(elName),\n                elName ? fixedAttrsDef(ast) : NULL_EXPR,\n                inputDefs.length ? literalArr(inputDefs) : NULL_EXPR,\n                outputDefs.length ? literalArr(outputDefs) : NULL_EXPR,\n                _this._createElementHandleEventFn(nodeIndex, hostEvents),\n                compView,\n                compRendererType,\n            ]),\n            updateRenderer: updateRendererExpressions\n        }); };\n    };\n    /**\n     * @param {?} nodeIndex\n     * @param {?} ast\n     * @return {?}\n     */\n    ViewBuilder.prototype._visitElementOrTemplate = function (nodeIndex, ast) {\n        var _this = this;\n        var /** @type {?} */ flags = 0;\n        if (ast.hasViewContainer) {\n            flags |= 16777216 /* EmbeddedViews */;\n        }\n        var /** @type {?} */ usedEvents = new Map();\n        ast.outputs.forEach(function (event) {\n            var _a = elementEventNameAndTarget(event, null), name = _a.name, target = _a.target;\n            usedEvents.set(Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"elementEventFullName\"])(target, name), [target, name]);\n        });\n        ast.directives.forEach(function (dirAst) {\n            dirAst.hostEvents.forEach(function (event) {\n                var _a = elementEventNameAndTarget(event, dirAst), name = _a.name, target = _a.target;\n                usedEvents.set(Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"elementEventFullName\"])(target, name), [target, name]);\n            });\n        });\n        var /** @type {?} */ hostBindings = [];\n        var /** @type {?} */ hostEvents = [];\n        this._visitComponentFactoryResolverProvider(ast.directives);\n        ast.providers.forEach(function (providerAst, providerIndex) {\n            var /** @type {?} */ dirAst = ((undefined));\n            var /** @type {?} */ dirIndex = ((undefined));\n            ast.directives.forEach(function (localDirAst, i) {\n                if (localDirAst.directive.type.reference === tokenReference(providerAst.token)) {\n                    dirAst = localDirAst;\n                    dirIndex = i;\n                }\n            });\n            if (dirAst) {\n                var _a = _this._visitDirective(providerAst, dirAst, dirIndex, nodeIndex, ast.references, ast.queryMatches, usedEvents, /** @type {?} */ ((_this.staticQueryIds.get(/** @type {?} */ (ast))))), dirHostBindings = _a.hostBindings, dirHostEvents = _a.hostEvents;\n                hostBindings.push.apply(hostBindings, dirHostBindings);\n                hostEvents.push.apply(hostEvents, dirHostEvents);\n            }\n            else {\n                _this._visitProvider(providerAst, ast.queryMatches);\n            }\n        });\n        var /** @type {?} */ queryMatchExprs = [];\n        ast.queryMatches.forEach(function (match) {\n            var /** @type {?} */ valueType = ((undefined));\n            if (tokenReference(match.value) ===\n                _this.reflector.resolveExternalReference(Identifiers.ElementRef)) {\n                valueType = 0 /* ElementRef */;\n            }\n            else if (tokenReference(match.value) ===\n                _this.reflector.resolveExternalReference(Identifiers.ViewContainerRef)) {\n                valueType = 3 /* ViewContainerRef */;\n            }\n            else if (tokenReference(match.value) ===\n                _this.reflector.resolveExternalReference(Identifiers.TemplateRef)) {\n                valueType = 2 /* TemplateRef */;\n            }\n            if (valueType != null) {\n                queryMatchExprs.push(literalArr([literal(match.queryId), literal(valueType)]));\n            }\n        });\n        ast.references.forEach(function (ref) {\n            var /** @type {?} */ valueType = ((undefined));\n            if (!ref.value) {\n                valueType = 1 /* RenderElement */;\n            }\n            else if (tokenReference(ref.value) ===\n                _this.reflector.resolveExternalReference(Identifiers.TemplateRef)) {\n                valueType = 2 /* TemplateRef */;\n            }\n            if (valueType != null) {\n                _this.refNodeIndices[ref.name] = nodeIndex;\n                queryMatchExprs.push(literalArr([literal(ref.name), literal(valueType)]));\n            }\n        });\n        ast.outputs.forEach(function (outputAst) {\n            hostEvents.push({ context: COMP_VAR, eventAst: outputAst, dirAst: /** @type {?} */ ((null)) });\n        });\n        return {\n            flags: flags,\n            usedEvents: Array.from(usedEvents.values()),\n            queryMatchesExpr: queryMatchExprs.length ? literalArr(queryMatchExprs) : NULL_EXPR,\n            hostBindings: hostBindings,\n            hostEvents: hostEvents\n        };\n    };\n    /**\n     * @param {?} providerAst\n     * @param {?} dirAst\n     * @param {?} directiveIndex\n     * @param {?} elementNodeIndex\n     * @param {?} refs\n     * @param {?} queryMatches\n     * @param {?} usedEvents\n     * @param {?} queryIds\n     * @return {?}\n     */\n    ViewBuilder.prototype._visitDirective = function (providerAst, dirAst, directiveIndex, elementNodeIndex, refs, queryMatches, usedEvents, queryIds) {\n        var _this = this;\n        var /** @type {?} */ nodeIndex = this.nodes.length;\n        // reserve the space in the nodeDefs array so we can add children\n        this.nodes.push(/** @type {?} */ ((null)));\n        dirAst.directive.queries.forEach(function (query, queryIndex) {\n            var /** @type {?} */ queryId = dirAst.contentQueryStartId + queryIndex;\n            var /** @type {?} */ flags = 67108864 /* TypeContentQuery */ | calcStaticDynamicQueryFlags(queryIds, queryId, query.first);\n            var /** @type {?} */ bindingType = query.first ? 0 /* First */ : 1;\n            _this.nodes.push(function () { return ({\n                sourceSpan: dirAst.sourceSpan,\n                nodeFlags: flags,\n                nodeDef: importExpr(Identifiers.queryDef).callFn([\n                    literal(flags), literal(queryId),\n                    new LiteralMapExpr([new LiteralMapEntry(query.propertyName, literal(bindingType), false)])\n                ]),\n            }); });\n        });\n        // Note: the operation below might also create new nodeDefs,\n        // but we don't want them to be a child of a directive,\n        // as they might be a provider/pipe on their own.\n        // I.e. we only allow queries as children of directives nodes.\n        var /** @type {?} */ childCount = this.nodes.length - nodeIndex - 1;\n        var _a = this._visitProviderOrDirective(providerAst, queryMatches), flags = _a.flags, queryMatchExprs = _a.queryMatchExprs, providerExpr = _a.providerExpr, depsExpr = _a.depsExpr;\n        refs.forEach(function (ref) {\n            if (ref.value && tokenReference(ref.value) === tokenReference(providerAst.token)) {\n                _this.refNodeIndices[ref.name] = nodeIndex;\n                queryMatchExprs.push(literalArr([literal(ref.name), literal(4 /* Provider */)]));\n            }\n        });\n        if (dirAst.directive.isComponent) {\n            flags |= 32768 /* Component */;\n        }\n        var /** @type {?} */ inputDefs = dirAst.inputs.map(function (inputAst, inputIndex) {\n            var /** @type {?} */ mapValue = literalArr([literal(inputIndex), literal(inputAst.directiveName)]);\n            // Note: it's important to not quote the key so that we can capture renames by minifiers!\n            return new LiteralMapEntry(inputAst.directiveName, mapValue, false);\n        });\n        var /** @type {?} */ outputDefs = [];\n        var /** @type {?} */ dirMeta = dirAst.directive;\n        Object.keys(dirMeta.outputs).forEach(function (propName) {\n            var /** @type {?} */ eventName = dirMeta.outputs[propName];\n            if (usedEvents.has(eventName)) {\n                // Note: it's important to not quote the key so that we can capture renames by minifiers!\n                outputDefs.push(new LiteralMapEntry(propName, literal(eventName), false));\n            }\n        });\n        var /** @type {?} */ updateDirectiveExpressions = [];\n        if (dirAst.inputs.length || (flags & (262144 /* DoCheck */ | 65536 /* OnInit */)) > 0) {\n            updateDirectiveExpressions =\n                dirAst.inputs.map(function (input, bindingIndex) { return _this._preprocessUpdateExpression({\n                    nodeIndex: nodeIndex,\n                    bindingIndex: bindingIndex,\n                    sourceSpan: input.sourceSpan,\n                    context: COMP_VAR,\n                    value: input.value\n                }); });\n        }\n        var /** @type {?} */ dirContextExpr = importExpr(Identifiers.nodeValue).callFn([VIEW_VAR, literal(nodeIndex)]);\n        var /** @type {?} */ hostBindings = dirAst.hostProperties.map(function (inputAst) { return ({\n            context: dirContextExpr,\n            dirAst: dirAst,\n            inputAst: inputAst,\n        }); });\n        var /** @type {?} */ hostEvents = dirAst.hostEvents.map(function (hostEventAst) { return ({\n            context: dirContextExpr,\n            eventAst: hostEventAst, dirAst: dirAst,\n        }); });\n        // directiveDef(\n        //   flags: NodeFlags, matchedQueries: [string, QueryValueType][], childCount: number, ctor:\n        //   any,\n        //   deps: ([DepFlags, any] | any)[], props?: {[name: string]: [number, string]},\n        //   outputs?: {[name: string]: string}, component?: () => ViewDefinition): NodeDef;\n        this.nodes[nodeIndex] = function () { return ({\n            sourceSpan: dirAst.sourceSpan,\n            nodeFlags: 16384 /* TypeDirective */ | flags,\n            nodeDef: importExpr(Identifiers.directiveDef).callFn([\n                literal(flags), queryMatchExprs.length ? literalArr(queryMatchExprs) : NULL_EXPR,\n                literal(childCount), providerExpr, depsExpr,\n                inputDefs.length ? new LiteralMapExpr(inputDefs) : NULL_EXPR,\n                outputDefs.length ? new LiteralMapExpr(outputDefs) : NULL_EXPR\n            ]),\n            updateDirectives: updateDirectiveExpressions,\n            directive: dirAst.directive.type,\n        }); };\n        return { hostBindings: hostBindings, hostEvents: hostEvents };\n    };\n    /**\n     * @param {?} providerAst\n     * @param {?} queryMatches\n     * @return {?}\n     */\n    ViewBuilder.prototype._visitProvider = function (providerAst, queryMatches) {\n        this._addProviderNode(this._visitProviderOrDirective(providerAst, queryMatches));\n    };\n    /**\n     * @param {?} directives\n     * @return {?}\n     */\n    ViewBuilder.prototype._visitComponentFactoryResolverProvider = function (directives) {\n        var /** @type {?} */ componentDirMeta = directives.find(function (dirAst) { return dirAst.directive.isComponent; });\n        if (componentDirMeta && componentDirMeta.directive.entryComponents.length) {\n            var _a = componentFactoryResolverProviderDef(this.reflector, this.outputCtx, 8192 /* PrivateProvider */, componentDirMeta.directive.entryComponents), providerExpr = _a.providerExpr, depsExpr = _a.depsExpr, flags = _a.flags, tokenExpr_1 = _a.tokenExpr;\n            this._addProviderNode({\n                providerExpr: providerExpr,\n                depsExpr: depsExpr,\n                flags: flags,\n                tokenExpr: tokenExpr_1,\n                queryMatchExprs: [],\n                sourceSpan: componentDirMeta.sourceSpan\n            });\n        }\n    };\n    /**\n     * @param {?} data\n     * @return {?}\n     */\n    ViewBuilder.prototype._addProviderNode = function (data) {\n        var /** @type {?} */ nodeIndex = this.nodes.length;\n        // providerDef(\n        //   flags: NodeFlags, matchedQueries: [string, QueryValueType][], token:any,\n        //   value: any, deps: ([DepFlags, any] | any)[]): NodeDef;\n        this.nodes.push(function () { return ({\n            sourceSpan: data.sourceSpan,\n            nodeFlags: data.flags,\n            nodeDef: importExpr(Identifiers.providerDef).callFn([\n                literal(data.flags),\n                data.queryMatchExprs.length ? literalArr(data.queryMatchExprs) : NULL_EXPR,\n                data.tokenExpr, data.providerExpr, data.depsExpr\n            ])\n        }); });\n    };\n    /**\n     * @param {?} providerAst\n     * @param {?} queryMatches\n     * @return {?}\n     */\n    ViewBuilder.prototype._visitProviderOrDirective = function (providerAst, queryMatches) {\n        var /** @type {?} */ flags = 0;\n        var /** @type {?} */ queryMatchExprs = [];\n        queryMatches.forEach(function (match) {\n            if (tokenReference(match.value) === tokenReference(providerAst.token)) {\n                queryMatchExprs.push(literalArr([literal(match.queryId), literal(4 /* Provider */)]));\n            }\n        });\n        var _a = providerDef(this.outputCtx, providerAst), providerExpr = _a.providerExpr, depsExpr = _a.depsExpr, providerFlags = _a.flags, tokenExpr = _a.tokenExpr;\n        return {\n            flags: flags | providerFlags,\n            queryMatchExprs: queryMatchExprs,\n            providerExpr: providerExpr,\n            depsExpr: depsExpr,\n            tokenExpr: tokenExpr,\n            sourceSpan: providerAst.sourceSpan\n        };\n    };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    ViewBuilder.prototype.getLocal = function (name) {\n        if (name == EventHandlerVars.event.name) {\n            return EventHandlerVars.event;\n        }\n        var /** @type {?} */ currViewExpr = VIEW_VAR;\n        for (var /** @type {?} */ currBuilder = this; currBuilder; currBuilder = currBuilder.parent,\n            currViewExpr = currViewExpr.prop('parent').cast(DYNAMIC_TYPE)) {\n            // check references\n            var /** @type {?} */ refNodeIndex = currBuilder.refNodeIndices[name];\n            if (refNodeIndex != null) {\n                return importExpr(Identifiers.nodeValue).callFn([currViewExpr, literal(refNodeIndex)]);\n            }\n            // check variables\n            var /** @type {?} */ varAst = currBuilder.variables.find(function (varAst) { return varAst.name === name; });\n            if (varAst) {\n                var /** @type {?} */ varValue = varAst.value || IMPLICIT_TEMPLATE_VAR;\n                return currViewExpr.prop('context').prop(varValue);\n            }\n        }\n        return null;\n    };\n    /**\n     * @param {?} sourceSpan\n     * @param {?} argCount\n     * @return {?}\n     */\n    ViewBuilder.prototype.createLiteralArrayConverter = function (sourceSpan, argCount) {\n        if (argCount === 0) {\n            var /** @type {?} */ valueExpr_1 = importExpr(Identifiers.EMPTY_ARRAY);\n            return function () { return valueExpr_1; };\n        }\n        var /** @type {?} */ nodeIndex = this.nodes.length;\n        // pureArrayDef(argCount: number): NodeDef;\n        this.nodes.push(function () { return ({\n            sourceSpan: sourceSpan,\n            nodeFlags: 32 /* TypePureArray */,\n            nodeDef: importExpr(Identifiers.pureArrayDef).callFn([literal(argCount)])\n        }); });\n        return function (args) { return callCheckStmt(nodeIndex, args); };\n    };\n    /**\n     * @param {?} sourceSpan\n     * @param {?} keys\n     * @return {?}\n     */\n    ViewBuilder.prototype.createLiteralMapConverter = function (sourceSpan, keys) {\n        if (keys.length === 0) {\n            var /** @type {?} */ valueExpr_2 = importExpr(Identifiers.EMPTY_MAP);\n            return function () { return valueExpr_2; };\n        }\n        // function pureObjectDef(propToIndex: {[p: string]: number}): NodeDef\n        var /** @type {?} */ map = literalMap(keys.map(function (e, i) { return (Object.assign({}, e, { value: literal(i) })); }));\n        var /** @type {?} */ nodeIndex = this.nodes.length;\n        this.nodes.push(function () { return ({\n            sourceSpan: sourceSpan,\n            nodeFlags: 64 /* TypePureObject */,\n            nodeDef: importExpr(Identifiers.pureObjectDef).callFn([map])\n        }); });\n        return function (args) { return callCheckStmt(nodeIndex, args); };\n    };\n    /**\n     * @param {?} expression\n     * @param {?} name\n     * @param {?} argCount\n     * @return {?}\n     */\n    ViewBuilder.prototype.createPipeConverter = function (expression, name, argCount) {\n        var /** @type {?} */ pipe = ((this.usedPipes.find(function (pipeSummary) { return pipeSummary.name === name; })));\n        if (pipe.pure) {\n            var /** @type {?} */ nodeIndex_1 = this.nodes.length;\n            // function purePipeDef(argCount: number): NodeDef;\n            this.nodes.push(function () { return ({\n                sourceSpan: expression.sourceSpan,\n                nodeFlags: 128 /* TypePurePipe */,\n                nodeDef: importExpr(Identifiers.purePipeDef).callFn([literal(argCount)])\n            }); });\n            // find underlying pipe in the component view\n            var /** @type {?} */ compViewExpr = VIEW_VAR;\n            var /** @type {?} */ compBuilder = this;\n            while (compBuilder.parent) {\n                compBuilder = compBuilder.parent;\n                compViewExpr = compViewExpr.prop('parent').cast(DYNAMIC_TYPE);\n            }\n            var /** @type {?} */ pipeNodeIndex = compBuilder.purePipeNodeIndices[name];\n            var /** @type {?} */ pipeValueExpr_1 = importExpr(Identifiers.nodeValue).callFn([compViewExpr, literal(pipeNodeIndex)]);\n            return function (args) { return callUnwrapValue(expression.nodeIndex, expression.bindingIndex, callCheckStmt(nodeIndex_1, [pipeValueExpr_1].concat(args))); };\n        }\n        else {\n            var /** @type {?} */ nodeIndex = this._createPipe(expression.sourceSpan, pipe);\n            var /** @type {?} */ nodeValueExpr_1 = importExpr(Identifiers.nodeValue).callFn([VIEW_VAR, literal(nodeIndex)]);\n            return function (args) { return callUnwrapValue(expression.nodeIndex, expression.bindingIndex, nodeValueExpr_1.callMethod('transform', args)); };\n        }\n    };\n    /**\n     * @param {?} sourceSpan\n     * @param {?} pipe\n     * @return {?}\n     */\n    ViewBuilder.prototype._createPipe = function (sourceSpan, pipe) {\n        var _this = this;\n        var /** @type {?} */ nodeIndex = this.nodes.length;\n        var /** @type {?} */ flags = 0;\n        pipe.type.lifecycleHooks.forEach(function (lifecycleHook) {\n            // for pipes, we only support ngOnDestroy\n            if (lifecycleHook === LifecycleHooks.OnDestroy) {\n                flags |= lifecycleHookToNodeFlag(lifecycleHook);\n            }\n        });\n        var /** @type {?} */ depExprs = pipe.type.diDeps.map(function (diDep) { return depDef(_this.outputCtx, diDep); });\n        // function pipeDef(\n        //   flags: NodeFlags, ctor: any, deps: ([DepFlags, any] | any)[]): NodeDef\n        this.nodes.push(function () { return ({\n            sourceSpan: sourceSpan,\n            nodeFlags: 16 /* TypePipe */,\n            nodeDef: importExpr(Identifiers.pipeDef).callFn([\n                literal(flags), _this.outputCtx.importExpr(pipe.type.reference), literalArr(depExprs)\n            ])\n        }); });\n        return nodeIndex;\n    };\n    /**\n     * @param {?} expression\n     * @return {?}\n     */\n    ViewBuilder.prototype._preprocessUpdateExpression = function (expression) {\n        var _this = this;\n        return {\n            nodeIndex: expression.nodeIndex,\n            bindingIndex: expression.bindingIndex,\n            sourceSpan: expression.sourceSpan,\n            context: expression.context,\n            value: convertPropertyBindingBuiltins({\n                createLiteralArrayConverter: function (argCount) { return _this.createLiteralArrayConverter(expression.sourceSpan, argCount); },\n                createLiteralMapConverter: function (keys) { return _this.createLiteralMapConverter(expression.sourceSpan, keys); },\n                createPipeConverter: function (name, argCount) { return _this.createPipeConverter(expression, name, argCount); }\n            }, expression.value)\n        };\n    };\n    /**\n     * @return {?}\n     */\n    ViewBuilder.prototype._createNodeExpressions = function () {\n        var /** @type {?} */ self = this;\n        var /** @type {?} */ updateBindingCount = 0;\n        var /** @type {?} */ updateRendererStmts = [];\n        var /** @type {?} */ updateDirectivesStmts = [];\n        var /** @type {?} */ nodeDefExprs = this.nodes.map(function (factory, nodeIndex) {\n            var _a = factory(), nodeDef = _a.nodeDef, nodeFlags = _a.nodeFlags, updateDirectives = _a.updateDirectives, updateRenderer = _a.updateRenderer, sourceSpan = _a.sourceSpan;\n            if (updateRenderer) {\n                updateRendererStmts.push.apply(updateRendererStmts, createUpdateStatements(nodeIndex, sourceSpan, updateRenderer, false));\n            }\n            if (updateDirectives) {\n                updateDirectivesStmts.push.apply(updateDirectivesStmts, createUpdateStatements(nodeIndex, sourceSpan, updateDirectives, (nodeFlags & (262144 /* DoCheck */ | 65536 /* OnInit */)) > 0));\n            }\n            // We use a comma expression to call the log function before\n            // the nodeDef function, but still use the result of the nodeDef function\n            // as the value.\n            // Note: We only add the logger to elements / text nodes,\n            // so we don't generate too much code.\n            var /** @type {?} */ logWithNodeDef = nodeFlags & 3 /* CatRenderNode */ ?\n                new CommaExpr([LOG_VAR$1.callFn([]).callFn([]), nodeDef]) :\n                nodeDef;\n            return applySourceSpanToExpressionIfNeeded(logWithNodeDef, sourceSpan);\n        });\n        return { updateRendererStmts: updateRendererStmts, updateDirectivesStmts: updateDirectivesStmts, nodeDefExprs: nodeDefExprs };\n        /**\n         * @param {?} nodeIndex\n         * @param {?} sourceSpan\n         * @param {?} expressions\n         * @param {?} allowEmptyExprs\n         * @return {?}\n         */\n        function createUpdateStatements(nodeIndex, sourceSpan, expressions, allowEmptyExprs) {\n            var /** @type {?} */ updateStmts = [];\n            var /** @type {?} */ exprs = expressions.map(function (_a) {\n                var sourceSpan = _a.sourceSpan, context = _a.context, value = _a.value;\n                var /** @type {?} */ bindingId = \"\" + updateBindingCount++;\n                var /** @type {?} */ nameResolver = context === COMP_VAR ? self : null;\n                var _b = convertPropertyBinding(nameResolver, context, value, bindingId), stmts = _b.stmts, currValExpr = _b.currValExpr;\n                updateStmts.push.apply(updateStmts, stmts.map(function (stmt) { return applySourceSpanToStatementIfNeeded(stmt, sourceSpan); }));\n                return applySourceSpanToExpressionIfNeeded(currValExpr, sourceSpan);\n            });\n            if (expressions.length || allowEmptyExprs) {\n                updateStmts.push(applySourceSpanToStatementIfNeeded(callCheckStmt(nodeIndex, exprs).toStmt(), sourceSpan));\n            }\n            return updateStmts;\n        }\n    };\n    /**\n     * @param {?} nodeIndex\n     * @param {?} handlers\n     * @return {?}\n     */\n    ViewBuilder.prototype._createElementHandleEventFn = function (nodeIndex, handlers) {\n        var _this = this;\n        var /** @type {?} */ handleEventStmts = [];\n        var /** @type {?} */ handleEventBindingCount = 0;\n        handlers.forEach(function (_a) {\n            var context = _a.context, eventAst = _a.eventAst, dirAst = _a.dirAst;\n            var /** @type {?} */ bindingId = \"\" + handleEventBindingCount++;\n            var /** @type {?} */ nameResolver = context === COMP_VAR ? _this : null;\n            var _b = convertActionBinding(nameResolver, context, eventAst.handler, bindingId), stmts = _b.stmts, allowDefault = _b.allowDefault;\n            var /** @type {?} */ trueStmts = stmts;\n            if (allowDefault) {\n                trueStmts.push(ALLOW_DEFAULT_VAR.set(allowDefault.and(ALLOW_DEFAULT_VAR)).toStmt());\n            }\n            var _c = elementEventNameAndTarget(eventAst, dirAst), eventTarget = _c.target, eventName = _c.name;\n            var /** @type {?} */ fullEventName = Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"elementEventFullName\"])(eventTarget, eventName);\n            handleEventStmts.push(applySourceSpanToStatementIfNeeded(new IfStmt(literal(fullEventName).identical(EVENT_NAME_VAR), trueStmts), eventAst.sourceSpan));\n        });\n        var /** @type {?} */ handleEventFn;\n        if (handleEventStmts.length > 0) {\n            var /** @type {?} */ preStmts = [ALLOW_DEFAULT_VAR.set(literal(true)).toDeclStmt(BOOL_TYPE)];\n            if (!this.component.isHost && findReadVarNames(handleEventStmts).has(/** @type {?} */ ((COMP_VAR.name)))) {\n                preStmts.push(COMP_VAR.set(VIEW_VAR.prop('component')).toDeclStmt(this.compType));\n            }\n            handleEventFn = fn([\n                new FnParam(/** @type {?} */ ((VIEW_VAR.name)), INFERRED_TYPE),\n                new FnParam(/** @type {?} */ ((EVENT_NAME_VAR.name)), INFERRED_TYPE),\n                new FnParam(/** @type {?} */ ((EventHandlerVars.event.name)), INFERRED_TYPE)\n            ], preStmts.concat(handleEventStmts, [new ReturnStatement(ALLOW_DEFAULT_VAR)]), INFERRED_TYPE);\n        }\n        else {\n            handleEventFn = NULL_EXPR;\n        }\n        return handleEventFn;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitDirective = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitDirectiveProperty = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitReference = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitVariable = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitEvent = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitElementProperty = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitAttr = function (ast, context) { };\n    return ViewBuilder;\n}());\n/**\n * @param {?} astNodes\n * @return {?}\n */\nfunction needsAdditionalRootNode(astNodes) {\n    var /** @type {?} */ lastAstNode = astNodes[astNodes.length - 1];\n    if (lastAstNode instanceof EmbeddedTemplateAst) {\n        return lastAstNode.hasViewContainer;\n    }\n    if (lastAstNode instanceof ElementAst) {\n        if (isNgContainer(lastAstNode.name) && lastAstNode.children.length) {\n            return needsAdditionalRootNode(lastAstNode.children);\n        }\n        return lastAstNode.hasViewContainer;\n    }\n    return lastAstNode instanceof NgContentAst;\n}\n/**\n * @param {?} inputAst\n * @param {?} dirAst\n * @return {?}\n */\nfunction elementBindingDef(inputAst, dirAst) {\n    switch (inputAst.type) {\n        case PropertyBindingType.Attribute:\n            return literalArr([\n                literal(1 /* TypeElementAttribute */), literal(inputAst.name),\n                literal(inputAst.securityContext)\n            ]);\n        case PropertyBindingType.Property:\n            return literalArr([\n                literal(8 /* TypeProperty */), literal(inputAst.name),\n                literal(inputAst.securityContext)\n            ]);\n        case PropertyBindingType.Animation:\n            var /** @type {?} */ bindingType = 8 /* TypeProperty */ |\n                (dirAst && dirAst.directive.isComponent ? 32 /* SyntheticHostProperty */ :\n                    16 /* SyntheticProperty */);\n            return literalArr([\n                literal(bindingType), literal('@' + inputAst.name), literal(inputAst.securityContext)\n            ]);\n        case PropertyBindingType.Class:\n            return literalArr([literal(2 /* TypeElementClass */), literal(inputAst.name), NULL_EXPR]);\n        case PropertyBindingType.Style:\n            return literalArr([\n                literal(4 /* TypeElementStyle */), literal(inputAst.name), literal(inputAst.unit)\n            ]);\n    }\n}\n/**\n * @param {?} elementAst\n * @return {?}\n */\nfunction fixedAttrsDef(elementAst) {\n    var /** @type {?} */ mapResult = Object.create(null);\n    elementAst.attrs.forEach(function (attrAst) { mapResult[attrAst.name] = attrAst.value; });\n    elementAst.directives.forEach(function (dirAst) {\n        Object.keys(dirAst.directive.hostAttributes).forEach(function (name) {\n            var /** @type {?} */ value = dirAst.directive.hostAttributes[name];\n            var /** @type {?} */ prevValue = mapResult[name];\n            mapResult[name] = prevValue != null ? mergeAttributeValue(name, prevValue, value) : value;\n        });\n    });\n    // Note: We need to sort to get a defined output order\n    // for tests and for caching generated artifacts...\n    return literalArr(Object.keys(mapResult).sort().map(function (attrName) { return literalArr([literal(attrName), literal(mapResult[attrName])]); }));\n}\n/**\n * @param {?} attrName\n * @param {?} attrValue1\n * @param {?} attrValue2\n * @return {?}\n */\nfunction mergeAttributeValue(attrName, attrValue1, attrValue2) {\n    if (attrName == CLASS_ATTR$1 || attrName == STYLE_ATTR) {\n        return attrValue1 + \" \" + attrValue2;\n    }\n    else {\n        return attrValue2;\n    }\n}\n/**\n * @param {?} nodeIndex\n * @param {?} exprs\n * @return {?}\n */\nfunction callCheckStmt(nodeIndex, exprs) {\n    if (exprs.length > 10) {\n        return CHECK_VAR.callFn([VIEW_VAR, literal(nodeIndex), literal(1 /* Dynamic */), literalArr(exprs)]);\n    }\n    else {\n        return CHECK_VAR.callFn([VIEW_VAR, literal(nodeIndex), literal(0 /* Inline */)].concat(exprs));\n    }\n}\n/**\n * @param {?} nodeIndex\n * @param {?} bindingIdx\n * @param {?} expr\n * @return {?}\n */\nfunction callUnwrapValue(nodeIndex, bindingIdx, expr) {\n    return importExpr(Identifiers.unwrapValue).callFn([\n        VIEW_VAR, literal(nodeIndex), literal(bindingIdx), expr\n    ]);\n}\n/**\n * @param {?} nodes\n * @param {?=} result\n * @return {?}\n */\nfunction findStaticQueryIds(nodes, result) {\n    if (result === void 0) { result = new Map(); }\n    nodes.forEach(function (node) {\n        var /** @type {?} */ staticQueryIds = new Set();\n        var /** @type {?} */ dynamicQueryIds = new Set();\n        var /** @type {?} */ queryMatches = ((undefined));\n        if (node instanceof ElementAst) {\n            findStaticQueryIds(node.children, result);\n            node.children.forEach(function (child) {\n                var /** @type {?} */ childData = ((result.get(child)));\n                childData.staticQueryIds.forEach(function (queryId) { return staticQueryIds.add(queryId); });\n                childData.dynamicQueryIds.forEach(function (queryId) { return dynamicQueryIds.add(queryId); });\n            });\n            queryMatches = node.queryMatches;\n        }\n        else if (node instanceof EmbeddedTemplateAst) {\n            findStaticQueryIds(node.children, result);\n            node.children.forEach(function (child) {\n                var /** @type {?} */ childData = ((result.get(child)));\n                childData.staticQueryIds.forEach(function (queryId) { return dynamicQueryIds.add(queryId); });\n                childData.dynamicQueryIds.forEach(function (queryId) { return dynamicQueryIds.add(queryId); });\n            });\n            queryMatches = node.queryMatches;\n        }\n        if (queryMatches) {\n            queryMatches.forEach(function (match) { return staticQueryIds.add(match.queryId); });\n        }\n        dynamicQueryIds.forEach(function (queryId) { return staticQueryIds.delete(queryId); });\n        result.set(node, { staticQueryIds: staticQueryIds, dynamicQueryIds: dynamicQueryIds });\n    });\n    return result;\n}\n/**\n * @param {?} nodeStaticQueryIds\n * @return {?}\n */\nfunction staticViewQueryIds(nodeStaticQueryIds) {\n    var /** @type {?} */ staticQueryIds = new Set();\n    var /** @type {?} */ dynamicQueryIds = new Set();\n    Array.from(nodeStaticQueryIds.values()).forEach(function (entry) {\n        entry.staticQueryIds.forEach(function (queryId) { return staticQueryIds.add(queryId); });\n        entry.dynamicQueryIds.forEach(function (queryId) { return dynamicQueryIds.add(queryId); });\n    });\n    dynamicQueryIds.forEach(function (queryId) { return staticQueryIds.delete(queryId); });\n    return { staticQueryIds: staticQueryIds, dynamicQueryIds: dynamicQueryIds };\n}\n/**\n * @param {?} eventAst\n * @param {?} dirAst\n * @return {?}\n */\nfunction elementEventNameAndTarget(eventAst, dirAst) {\n    if (eventAst.isAnimation) {\n        return {\n            name: \"@\" + eventAst.name + \".\" + eventAst.phase,\n            target: dirAst && dirAst.directive.isComponent ? 'component' : null\n        };\n    }\n    else {\n        return eventAst;\n    }\n}\n/**\n * @param {?} queryIds\n * @param {?} queryId\n * @param {?} isFirst\n * @return {?}\n */\nfunction calcStaticDynamicQueryFlags(queryIds, queryId, isFirst) {\n    var /** @type {?} */ flags = 0;\n    // Note: We only make queries static that query for a single item.\n    // This is because of backwards compatibility with the old view compiler...\n    if (isFirst && (queryIds.staticQueryIds.has(queryId) || !queryIds.dynamicQueryIds.has(queryId))) {\n        flags |= 268435456 /* StaticQuery */;\n    }\n    else {\n        flags |= 536870912 /* DynamicQuery */;\n    }\n    return flags;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar GeneratedFile = (function () {\n    /**\n     * @param {?} srcFileUrl\n     * @param {?} genFileUrl\n     * @param {?} sourceOrStmts\n     */\n    function GeneratedFile(srcFileUrl, genFileUrl, sourceOrStmts) {\n        this.srcFileUrl = srcFileUrl;\n        this.genFileUrl = genFileUrl;\n        if (typeof sourceOrStmts === 'string') {\n            this.source = sourceOrStmts;\n            this.stmts = null;\n        }\n        else {\n            this.source = null;\n            this.stmts = sourceOrStmts;\n        }\n    }\n    return GeneratedFile;\n}());\n/**\n * @param {?} file\n * @param {?=} preamble\n * @return {?}\n */\nfunction toTypeScript(file, preamble) {\n    if (preamble === void 0) { preamble = ''; }\n    if (!file.stmts) {\n        throw new Error(\"Illegal state: No stmts present on GeneratedFile \" + file.genFileUrl);\n    }\n    return new TypeScriptEmitter().emitStatements(sourceUrl(file.srcFileUrl), file.genFileUrl, file.stmts, preamble);\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} forJitCtx\n * @param {?} summaryResolver\n * @param {?} symbolResolver\n * @param {?} symbols\n * @param {?} types\n * @return {?}\n */\nfunction serializeSummaries(forJitCtx, summaryResolver, symbolResolver, symbols, types) {\n    var /** @type {?} */ toJsonSerializer = new ToJsonSerializer(symbolResolver, summaryResolver);\n    var /** @type {?} */ forJitSerializer = new ForJitSerializer(forJitCtx, symbolResolver);\n    // for symbols, we use everything except for the class metadata itself\n    // (we keep the statics though), as the class metadata is contained in the\n    // CompileTypeSummary.\n    symbols.forEach(function (resolvedSymbol) { return toJsonSerializer.addOrMergeSummary({ symbol: resolvedSymbol.symbol, metadata: resolvedSymbol.metadata }); });\n    // Add summaries that are referenced by the given symbols (transitively)\n    // Note: the serializer.symbols array might be growing while\n    // we execute the loop!\n    for (var /** @type {?} */ processedIndex = 0; processedIndex < toJsonSerializer.symbols.length; processedIndex++) {\n        var /** @type {?} */ symbol = toJsonSerializer.symbols[processedIndex];\n        if (summaryResolver.isLibraryFile(symbol.filePath)) {\n            var /** @type {?} */ summary = summaryResolver.resolveSummary(symbol);\n            if (!summary) {\n                // some symbols might originate from a plain typescript library\n                // that just exported .d.ts and .metadata.json files, i.e. where no summary\n                // files were created.\n                var /** @type {?} */ resolvedSymbol = symbolResolver.resolveSymbol(symbol);\n                if (resolvedSymbol) {\n                    summary = { symbol: resolvedSymbol.symbol, metadata: resolvedSymbol.metadata };\n                }\n            }\n            if (summary) {\n                if (summary.type) {\n                    forJitSerializer.addLibType(summary.type);\n                }\n                toJsonSerializer.addOrMergeSummary(summary);\n            }\n        }\n    }\n    // Add type summaries.\n    // Note: We don't add the summaries of all referenced symbols as for the ResolvedSymbols,\n    // as the type summaries already contain the transitive data that they require\n    // (in a minimal way).\n    types.forEach(function (_a) {\n        var summary = _a.summary, metadata = _a.metadata;\n        forJitSerializer.addSourceType(summary, metadata);\n        toJsonSerializer.addOrMergeSummary({ symbol: summary.type.reference, metadata: null, type: summary });\n        if (summary.summaryKind === CompileSummaryKind.NgModule) {\n            var /** @type {?} */ ngModuleSummary = (summary);\n            ngModuleSummary.exportedDirectives.concat(ngModuleSummary.exportedPipes).forEach(function (id) {\n                var /** @type {?} */ symbol = id.reference;\n                if (summaryResolver.isLibraryFile(symbol.filePath)) {\n                    var /** @type {?} */ summary_1 = summaryResolver.resolveSummary(symbol);\n                    if (summary_1) {\n                        toJsonSerializer.addOrMergeSummary(summary_1);\n                    }\n                }\n            });\n        }\n    });\n    var _a = toJsonSerializer.serialize(), json = _a.json, exportAs = _a.exportAs;\n    forJitSerializer.serialize(exportAs);\n    return { json: json, exportAs: exportAs };\n}\n/**\n * @param {?} symbolCache\n * @param {?} json\n * @return {?}\n */\nfunction deserializeSummaries(symbolCache, json) {\n    var /** @type {?} */ deserializer = new FromJsonDeserializer(symbolCache);\n    return deserializer.deserialize(json);\n}\n/**\n * @param {?} outputCtx\n * @param {?} reference\n * @return {?}\n */\nfunction createForJitStub(outputCtx, reference) {\n    return createSummaryForJitFunction(outputCtx, reference, NULL_EXPR);\n}\n/**\n * @param {?} outputCtx\n * @param {?} reference\n * @param {?} value\n * @return {?}\n */\nfunction createSummaryForJitFunction(outputCtx, reference, value) {\n    var /** @type {?} */ fnName = summaryForJitName(reference.name);\n    outputCtx.statements.push(fn([], [new ReturnStatement(value)], new ArrayType(DYNAMIC_TYPE)).toDeclStmt(fnName, [\n        StmtModifier.Final, StmtModifier.Exported\n    ]));\n}\nvar ToJsonSerializer = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](ToJsonSerializer, _super);\n    /**\n     * @param {?} symbolResolver\n     * @param {?} summaryResolver\n     */\n    function ToJsonSerializer(symbolResolver, summaryResolver) {\n        var _this = _super.call(this) || this;\n        _this.symbolResolver = symbolResolver;\n        _this.summaryResolver = summaryResolver;\n        // Note: This only contains symbols without members.\n        _this.symbols = [];\n        _this.indexBySymbol = new Map();\n        _this.processedSummaryBySymbol = new Map();\n        _this.processedSummaries = [];\n        return _this;\n    }\n    /**\n     * @param {?} summary\n     * @return {?}\n     */\n    ToJsonSerializer.prototype.addOrMergeSummary = function (summary) {\n        var /** @type {?} */ symbolMeta = summary.metadata;\n        if (symbolMeta && symbolMeta.__symbolic === 'class') {\n            // For classes, we keep everything except their class decorators.\n            // We need to keep e.g. the ctor args, method names, method decorators\n            // so that the class can be extended in another compilation unit.\n            // We don't keep the class decorators as\n            // 1) they refer to data\n            //   that should not cause a rebuild of downstream compilation units\n            //   (e.g. inline templates of @Component, or @NgModule.declarations)\n            // 2) their data is already captured in TypeSummaries, e.g. DirectiveSummary.\n            var /** @type {?} */ clone_1 = {};\n            Object.keys(symbolMeta).forEach(function (propName) {\n                if (propName !== 'decorators') {\n                    clone_1[propName] = symbolMeta[propName];\n                }\n            });\n            symbolMeta = clone_1;\n        }\n        var /** @type {?} */ processedSummary = this.processedSummaryBySymbol.get(summary.symbol);\n        if (!processedSummary) {\n            processedSummary = this.processValue({ symbol: summary.symbol });\n            this.processedSummaries.push(processedSummary);\n            this.processedSummaryBySymbol.set(summary.symbol, processedSummary);\n        }\n        // Note: == on purpose to compare with undefined!\n        if (processedSummary.metadata == null && symbolMeta != null) {\n            processedSummary.metadata = this.processValue(symbolMeta);\n        }\n        // Note: == on purpose to compare with undefined!\n        if (processedSummary.type == null && summary.type != null) {\n            processedSummary.type = this.processValue(summary.type);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    ToJsonSerializer.prototype.serialize = function () {\n        var _this = this;\n        var /** @type {?} */ exportAs = [];\n        var /** @type {?} */ json = JSON.stringify({\n            summaries: this.processedSummaries,\n            symbols: this.symbols.map(function (symbol, index) {\n                symbol.assertNoMembers();\n                var /** @type {?} */ importAs = ((undefined));\n                if (_this.summaryResolver.isLibraryFile(symbol.filePath)) {\n                    importAs = symbol.name + \"_\" + index;\n                    exportAs.push({ symbol: symbol, exportAs: importAs });\n                }\n                return {\n                    __symbol: index,\n                    name: symbol.name,\n                    // We convert the source filenames tinto output filenames,\n                    // as the generated summary file will be used when the current\n                    // compilation unit is used as a library\n                    filePath: _this.summaryResolver.getLibraryFileName(symbol.filePath),\n                    importAs: importAs\n                };\n            })\n        });\n        return { json: json, exportAs: exportAs };\n    };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ToJsonSerializer.prototype.processValue = function (value) { return visitValue(value, this, null); };\n    /**\n     * @param {?} value\n     * @param {?} context\n     * @return {?}\n     */\n    ToJsonSerializer.prototype.visitOther = function (value, context) {\n        if (value instanceof StaticSymbol) {\n            var /** @type {?} */ baseSymbol = this.symbolResolver.getStaticSymbol(value.filePath, value.name);\n            var /** @type {?} */ index = this.indexBySymbol.get(baseSymbol);\n            // Note: == on purpose to compare with undefined!\n            if (index == null) {\n                index = this.indexBySymbol.size;\n                this.indexBySymbol.set(baseSymbol, index);\n                this.symbols.push(baseSymbol);\n            }\n            return { __symbol: index, members: value.members };\n        }\n    };\n    return ToJsonSerializer;\n}(ValueTransformer));\nvar ForJitSerializer = (function () {\n    /**\n     * @param {?} outputCtx\n     * @param {?} symbolResolver\n     */\n    function ForJitSerializer(outputCtx, symbolResolver) {\n        this.outputCtx = outputCtx;\n        this.symbolResolver = symbolResolver;\n        this.data = new Map();\n    }\n    /**\n     * @param {?} summary\n     * @param {?} metadata\n     * @return {?}\n     */\n    ForJitSerializer.prototype.addSourceType = function (summary, metadata) {\n        this.data.set(summary.type.reference, { summary: summary, metadata: metadata, isLibrary: false });\n    };\n    /**\n     * @param {?} summary\n     * @return {?}\n     */\n    ForJitSerializer.prototype.addLibType = function (summary) {\n        this.data.set(summary.type.reference, { summary: summary, metadata: null, isLibrary: true });\n    };\n    /**\n     * @param {?} exportAs\n     * @return {?}\n     */\n    ForJitSerializer.prototype.serialize = function (exportAs) {\n        var _this = this;\n        var /** @type {?} */ ngModuleSymbols = new Set();\n        Array.from(this.data.values()).forEach(function (_a) {\n            var summary = _a.summary, metadata = _a.metadata, isLibrary = _a.isLibrary;\n            if (summary.summaryKind === CompileSummaryKind.NgModule) {\n                // collect the symbols that refer to NgModule classes.\n                // Note: we can't just rely on `summary.type.summaryKind` to determine this as\n                // we don't add the summaries of all referenced symbols when we serialize type summaries.\n                // See serializeSummaries for details.\n                ngModuleSymbols.add(summary.type.reference);\n                var /** @type {?} */ modSummary = (summary);\n                modSummary.modules.forEach(function (mod) { ngModuleSymbols.add(mod.reference); });\n            }\n            if (!isLibrary) {\n                var /** @type {?} */ fnName = summaryForJitName(summary.type.reference.name);\n                createSummaryForJitFunction(_this.outputCtx, summary.type.reference, _this.serializeSummaryWithDeps(summary, /** @type {?} */ ((metadata))));\n            }\n        });\n        exportAs.forEach(function (entry) {\n            var /** @type {?} */ symbol = entry.symbol;\n            if (ngModuleSymbols.has(symbol)) {\n                var /** @type {?} */ jitExportAsName = summaryForJitName(entry.exportAs);\n                _this.outputCtx.statements.push(variable(jitExportAsName).set(_this.serializeSummaryRef(symbol)).toDeclStmt(null, [\n                    StmtModifier.Exported\n                ]));\n            }\n        });\n    };\n    /**\n     * @param {?} summary\n     * @param {?} metadata\n     * @return {?}\n     */\n    ForJitSerializer.prototype.serializeSummaryWithDeps = function (summary, metadata) {\n        var _this = this;\n        var /** @type {?} */ expressions = [this.serializeSummary(summary)];\n        var /** @type {?} */ providers = [];\n        if (metadata instanceof CompileNgModuleMetadata) {\n            expressions.push.apply(expressions, \n            // For directives / pipes, we only add the declared ones,\n            // and rely on transitively importing NgModules to get the transitive\n            // summaries.\n            metadata.declaredDirectives.concat(metadata.declaredPipes)\n                .map(function (type) { return type.reference; })\n                .concat(metadata.transitiveModule.modules.map(function (type) { return type.reference; })\n                .filter(function (ref) { return ref !== metadata.type.reference; }))\n                .map(function (ref) { return _this.serializeSummaryRef(ref); }));\n            // Note: We don't use `NgModuleSummary.providers`, as that one is transitive,\n            // and we already have transitive modules.\n            providers = metadata.providers;\n        }\n        else if (summary.summaryKind === CompileSummaryKind.Directive) {\n            var /** @type {?} */ dirSummary = (summary);\n            providers = dirSummary.providers.concat(dirSummary.viewProviders);\n        }\n        // Note: We can't just refer to the `ngsummary.ts` files for `useClass` providers (as we do for\n        // declaredDirectives / declaredPipes), as we allow\n        // providers without ctor arguments to skip the `@Injectable` decorator,\n        // i.e. we didn't generate .ngsummary.ts files for these.\n        expressions.push.apply(expressions, providers.filter(function (provider) { return !!provider.useClass; }).map(function (provider) { return _this.serializeSummary(/** @type {?} */ ({\n            summaryKind: CompileSummaryKind.Injectable, type: provider.useClass\n        })); }));\n        return literalArr(expressions);\n    };\n    /**\n     * @param {?} typeSymbol\n     * @return {?}\n     */\n    ForJitSerializer.prototype.serializeSummaryRef = function (typeSymbol) {\n        var /** @type {?} */ jitImportedSymbol = this.symbolResolver.getStaticSymbol(summaryForJitFileName(typeSymbol.filePath), summaryForJitName(typeSymbol.name));\n        return this.outputCtx.importExpr(jitImportedSymbol);\n    };\n    /**\n     * @param {?} data\n     * @return {?}\n     */\n    ForJitSerializer.prototype.serializeSummary = function (data) {\n        var /** @type {?} */ outputCtx = this.outputCtx;\n        var Transformer = (function () {\n            function Transformer() {\n            }\n            /**\n             * @param {?} arr\n             * @param {?} context\n             * @return {?}\n             */\n            Transformer.prototype.visitArray = function (arr, context) {\n                var _this = this;\n                return literalArr(arr.map(function (entry) { return visitValue(entry, _this, context); }));\n            };\n            /**\n             * @param {?} map\n             * @param {?} context\n             * @return {?}\n             */\n            Transformer.prototype.visitStringMap = function (map, context) {\n                var _this = this;\n                return new LiteralMapExpr(Object.keys(map).map(function (key) { return new LiteralMapEntry(key, visitValue(map[key], _this, context), false); }));\n            };\n            /**\n             * @param {?} value\n             * @param {?} context\n             * @return {?}\n             */\n            Transformer.prototype.visitPrimitive = function (value, context) { return literal(value); };\n            /**\n             * @param {?} value\n             * @param {?} context\n             * @return {?}\n             */\n            Transformer.prototype.visitOther = function (value, context) {\n                if (value instanceof StaticSymbol) {\n                    return outputCtx.importExpr(value);\n                }\n                else {\n                    throw new Error(\"Illegal State: Encountered value \" + value);\n                }\n            };\n            return Transformer;\n        }());\n        return visitValue(data, new Transformer(), null);\n    };\n    return ForJitSerializer;\n}());\nvar FromJsonDeserializer = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](FromJsonDeserializer, _super);\n    /**\n     * @param {?} symbolCache\n     */\n    function FromJsonDeserializer(symbolCache) {\n        var _this = _super.call(this) || this;\n        _this.symbolCache = symbolCache;\n        return _this;\n    }\n    /**\n     * @param {?} json\n     * @return {?}\n     */\n    FromJsonDeserializer.prototype.deserialize = function (json) {\n        var _this = this;\n        var /** @type {?} */ data = JSON.parse(json);\n        var /** @type {?} */ importAs = [];\n        this.symbols = [];\n        data.symbols.forEach(function (serializedSymbol) {\n            var /** @type {?} */ symbol = _this.symbolCache.get(serializedSymbol.filePath, serializedSymbol.name);\n            _this.symbols.push(symbol);\n            if (serializedSymbol.importAs) {\n                importAs.push({ symbol: symbol, importAs: serializedSymbol.importAs });\n            }\n        });\n        var /** @type {?} */ summaries = visitValue(data.summaries, this, null);\n        return { summaries: summaries, importAs: importAs };\n    };\n    /**\n     * @param {?} map\n     * @param {?} context\n     * @return {?}\n     */\n    FromJsonDeserializer.prototype.visitStringMap = function (map, context) {\n        if ('__symbol' in map) {\n            var /** @type {?} */ baseSymbol = this.symbols[map['__symbol']];\n            var /** @type {?} */ members = map['members'];\n            return members.length ? this.symbolCache.get(baseSymbol.filePath, baseSymbol.name, members) :\n                baseSymbol;\n        }\n        else {\n            return _super.prototype.visitStringMap.call(this, map, context);\n        }\n    };\n    return FromJsonDeserializer;\n}(ValueTransformer));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar AotCompiler = (function () {\n    /**\n     * @param {?} _config\n     * @param {?} _host\n     * @param {?} _reflector\n     * @param {?} _metadataResolver\n     * @param {?} _templateParser\n     * @param {?} _styleCompiler\n     * @param {?} _viewCompiler\n     * @param {?} _ngModuleCompiler\n     * @param {?} _outputEmitter\n     * @param {?} _summaryResolver\n     * @param {?} _localeId\n     * @param {?} _translationFormat\n     * @param {?} _enableSummariesForJit\n     * @param {?} _symbolResolver\n     */\n    function AotCompiler(_config, _host, _reflector, _metadataResolver, _templateParser, _styleCompiler, _viewCompiler, _ngModuleCompiler, _outputEmitter, _summaryResolver, _localeId, _translationFormat, _enableSummariesForJit, _symbolResolver) {\n        this._config = _config;\n        this._host = _host;\n        this._reflector = _reflector;\n        this._metadataResolver = _metadataResolver;\n        this._templateParser = _templateParser;\n        this._styleCompiler = _styleCompiler;\n        this._viewCompiler = _viewCompiler;\n        this._ngModuleCompiler = _ngModuleCompiler;\n        this._outputEmitter = _outputEmitter;\n        this._summaryResolver = _summaryResolver;\n        this._localeId = _localeId;\n        this._translationFormat = _translationFormat;\n        this._enableSummariesForJit = _enableSummariesForJit;\n        this._symbolResolver = _symbolResolver;\n    }\n    /**\n     * @return {?}\n     */\n    AotCompiler.prototype.clearCache = function () { this._metadataResolver.clearCache(); };\n    /**\n     * @param {?} rootFiles\n     * @return {?}\n     */\n    AotCompiler.prototype.analyzeModulesSync = function (rootFiles) {\n        var _this = this;\n        var /** @type {?} */ programSymbols = extractProgramSymbols(this._symbolResolver, rootFiles, this._host);\n        var /** @type {?} */ analyzeResult = analyzeAndValidateNgModules(programSymbols, this._host, this._metadataResolver);\n        analyzeResult.ngModules.forEach(function (ngModule) { return _this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, true); });\n        return analyzeResult;\n    };\n    /**\n     * @param {?} rootFiles\n     * @return {?}\n     */\n    AotCompiler.prototype.analyzeModulesAsync = function (rootFiles) {\n        var _this = this;\n        var /** @type {?} */ programSymbols = extractProgramSymbols(this._symbolResolver, rootFiles, this._host);\n        var /** @type {?} */ analyzeResult = analyzeAndValidateNgModules(programSymbols, this._host, this._metadataResolver);\n        return Promise\n            .all(analyzeResult.ngModules.map(function (ngModule) { return _this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, false); }))\n            .then(function () { return analyzeResult; });\n    };\n    /**\n     * @param {?} analyzeResult\n     * @return {?}\n     */\n    AotCompiler.prototype.emitAllStubs = function (analyzeResult) {\n        var _this = this;\n        var files = analyzeResult.files;\n        var /** @type {?} */ sourceModules = files.map(function (file) { return _this._compileStubFile(file.srcUrl, file.directives, file.pipes, file.ngModules, false); });\n        return flatten(sourceModules);\n    };\n    /**\n     * @param {?} analyzeResult\n     * @return {?}\n     */\n    AotCompiler.prototype.emitPartialStubs = function (analyzeResult) {\n        var _this = this;\n        var files = analyzeResult.files;\n        var /** @type {?} */ sourceModules = files.map(function (file) { return _this._compileStubFile(file.srcUrl, file.directives, file.pipes, file.ngModules, true); });\n        return flatten(sourceModules);\n    };\n    /**\n     * @param {?} analyzeResult\n     * @return {?}\n     */\n    AotCompiler.prototype.emitAllImpls = function (analyzeResult) {\n        var _this = this;\n        var ngModuleByPipeOrDirective = analyzeResult.ngModuleByPipeOrDirective, files = analyzeResult.files;\n        var /** @type {?} */ sourceModules = files.map(function (file) { return _this._compileImplFile(file.srcUrl, ngModuleByPipeOrDirective, file.directives, file.pipes, file.ngModules, file.injectables); });\n        return flatten(sourceModules);\n    };\n    /**\n     * @param {?} srcFileUrl\n     * @param {?} directives\n     * @param {?} pipes\n     * @param {?} ngModules\n     * @param {?} partial\n     * @return {?}\n     */\n    AotCompiler.prototype._compileStubFile = function (srcFileUrl, directives, pipes, ngModules, partial) {\n        var _this = this;\n        // partial is true when we only need the files we are certain will produce a factory and/or\n        // summary.\n        // This is the normal case for `ngc` but if we assume libraryies are generating their own\n        // factories\n        // then we might need a factory for a file that re-exports a module or factory which we cannot\n        // know\n        // ahead of time so we need a stub generate for all non-.d.ts files. The .d.ts files do not need\n        // to\n        // be excluded here because they are excluded when the modules are analyzed. If a factory ends\n        // up\n        // not being needed, the factory file is not written in writeFile callback.\n        var /** @type {?} */ fileSuffix = splitTypescriptSuffix(srcFileUrl, true)[1];\n        var /** @type {?} */ generatedFiles = [];\n        var /** @type {?} */ ngFactoryOutputCtx = this._createOutputContext(ngfactoryFilePath(srcFileUrl, true));\n        var /** @type {?} */ jitSummaryOutputCtx = this._createOutputContext(summaryForJitFileName(srcFileUrl, true));\n        // create exports that user code can reference\n        ngModules.forEach(function (ngModuleReference) {\n            _this._ngModuleCompiler.createStub(ngFactoryOutputCtx, ngModuleReference);\n            createForJitStub(jitSummaryOutputCtx, ngModuleReference);\n        });\n        var /** @type {?} */ partialJitStubRequired = false;\n        var /** @type {?} */ partialFactoryStubRequired = false;\n        // create stubs for external stylesheets (always empty, as users should not import anything from\n        // the generated code)\n        directives.forEach(function (dirType) {\n            var /** @type {?} */ compMeta = _this._metadataResolver.getDirectiveMetadata(/** @type {?} */ (dirType));\n            partialJitStubRequired = true;\n            if (!compMeta.isComponent) {\n                return;\n            } /** @type {?} */\n            ((\n            // Note: compMeta is a component and therefore template is non null.\n            compMeta.template)).externalStylesheets.forEach(function (stylesheetMeta) {\n                var /** @type {?} */ styleContext = _this._createOutputContext(_stylesModuleUrl(/** @type {?} */ ((stylesheetMeta.moduleUrl)), _this._styleCompiler.needsStyleShim(compMeta), fileSuffix));\n                _createTypeReferenceStub(styleContext, Identifiers.ComponentFactory);\n                generatedFiles.push(_this._codegenSourceModule(/** @type {?} */ ((stylesheetMeta.moduleUrl)), styleContext));\n            });\n            partialFactoryStubRequired = true;\n        });\n        // If we need all the stubs to be generated then insert an arbitrary reference into the stub\n        if ((partialFactoryStubRequired || !partial) && ngFactoryOutputCtx.statements.length <= 0) {\n            _createTypeReferenceStub(ngFactoryOutputCtx, Identifiers.ComponentFactory);\n        }\n        if ((partialJitStubRequired || !partial || (pipes && pipes.length > 0)) &&\n            jitSummaryOutputCtx.statements.length <= 0) {\n            _createTypeReferenceStub(jitSummaryOutputCtx, Identifiers.ComponentFactory);\n        }\n        // Note: we are creating stub ngfactory/ngsummary for all source files,\n        // as the real calculation requires almost the same logic as producing the real content for\n        // them. Our pipeline will filter out empty ones at the end. Because of this filter, however,\n        // stub references to the reference type needs to be generated even if the user cannot\n        // refer to type from the `.d.ts` file to prevent the file being elided from the emit.\n        generatedFiles.push(this._codegenSourceModule(srcFileUrl, ngFactoryOutputCtx));\n        if (this._enableSummariesForJit) {\n            generatedFiles.push(this._codegenSourceModule(srcFileUrl, jitSummaryOutputCtx));\n        }\n        return generatedFiles;\n    };\n    /**\n     * @param {?} srcFileUrl\n     * @param {?} ngModuleByPipeOrDirective\n     * @param {?} directives\n     * @param {?} pipes\n     * @param {?} ngModules\n     * @param {?} injectables\n     * @return {?}\n     */\n    AotCompiler.prototype._compileImplFile = function (srcFileUrl, ngModuleByPipeOrDirective, directives, pipes, ngModules, injectables) {\n        var _this = this;\n        var /** @type {?} */ fileSuffix = splitTypescriptSuffix(srcFileUrl, true)[1];\n        var /** @type {?} */ generatedFiles = [];\n        var /** @type {?} */ outputCtx = this._createOutputContext(ngfactoryFilePath(srcFileUrl, true));\n        generatedFiles.push.apply(generatedFiles, this._createSummary(srcFileUrl, directives, pipes, ngModules, injectables, outputCtx));\n        // compile all ng modules\n        ngModules.forEach(function (ngModuleType) { return _this._compileModule(outputCtx, ngModuleType); });\n        // compile components\n        directives.forEach(function (dirType) {\n            var /** @type {?} */ compMeta = _this._metadataResolver.getDirectiveMetadata(/** @type {?} */ (dirType));\n            if (!compMeta.isComponent) {\n                return;\n            }\n            var /** @type {?} */ ngModule = ngModuleByPipeOrDirective.get(dirType);\n            if (!ngModule) {\n                throw new Error(\"Internal Error: cannot determine the module for component \" + identifierName(compMeta.type) + \"!\");\n            }\n            // compile styles\n            var /** @type {?} */ componentStylesheet = _this._styleCompiler.compileComponent(outputCtx, compMeta); /** @type {?} */\n            ((\n            // Note: compMeta is a component and therefore template is non null.\n            compMeta.template)).externalStylesheets.forEach(function (stylesheetMeta) {\n                generatedFiles.push(_this._codegenStyles(/** @type {?} */ ((stylesheetMeta.moduleUrl)), compMeta, stylesheetMeta, fileSuffix));\n            });\n            // compile components\n            var /** @type {?} */ compViewVars = _this._compileComponent(outputCtx, compMeta, ngModule, ngModule.transitiveModule.directives, componentStylesheet, fileSuffix);\n            _this._compileComponentFactory(outputCtx, compMeta, ngModule, fileSuffix);\n        });\n        if (outputCtx.statements.length > 0) {\n            var /** @type {?} */ srcModule = this._codegenSourceModule(srcFileUrl, outputCtx);\n            generatedFiles.unshift(srcModule);\n        }\n        return generatedFiles;\n    };\n    /**\n     * @param {?} srcFileUrl\n     * @param {?} directives\n     * @param {?} pipes\n     * @param {?} ngModules\n     * @param {?} injectables\n     * @param {?} ngFactoryCtx\n     * @return {?}\n     */\n    AotCompiler.prototype._createSummary = function (srcFileUrl, directives, pipes, ngModules, injectables, ngFactoryCtx) {\n        var _this = this;\n        var /** @type {?} */ symbolSummaries = this._symbolResolver.getSymbolsOf(srcFileUrl)\n            .map(function (symbol) { return _this._symbolResolver.resolveSymbol(symbol); });\n        var /** @type {?} */ typeData = ngModules.map(function (ref) { return ({\n            summary: /** @type {?} */ ((_this._metadataResolver.getNgModuleSummary(ref))),\n            metadata: /** @type {?} */ ((_this._metadataResolver.getNgModuleMetadata(ref)))\n        }); }).concat(directives.map(function (ref) { return ({\n            summary: /** @type {?} */ ((_this._metadataResolver.getDirectiveSummary(ref))),\n            metadata: /** @type {?} */ ((_this._metadataResolver.getDirectiveMetadata(ref)))\n        }); }), pipes.map(function (ref) { return ({\n            summary: /** @type {?} */ ((_this._metadataResolver.getPipeSummary(ref))),\n            metadata: /** @type {?} */ ((_this._metadataResolver.getPipeMetadata(ref)))\n        }); }), injectables.map(function (ref) { return ({\n            summary: /** @type {?} */ ((_this._metadataResolver.getInjectableSummary(ref))),\n            metadata: /** @type {?} */ ((_this._metadataResolver.getInjectableSummary(ref))).type\n        }); }));\n        var /** @type {?} */ forJitOutputCtx = this._createOutputContext(summaryForJitFileName(srcFileUrl, true));\n        var _a = serializeSummaries(forJitOutputCtx, this._summaryResolver, this._symbolResolver, symbolSummaries, typeData), json = _a.json, exportAs = _a.exportAs;\n        exportAs.forEach(function (entry) {\n            ngFactoryCtx.statements.push(variable(entry.exportAs).set(ngFactoryCtx.importExpr(entry.symbol)).toDeclStmt(null, [\n                StmtModifier.Exported\n            ]));\n        });\n        var /** @type {?} */ summaryJson = new GeneratedFile(srcFileUrl, summaryFileName(srcFileUrl), json);\n        if (this._enableSummariesForJit) {\n            return [summaryJson, this._codegenSourceModule(srcFileUrl, forJitOutputCtx)];\n        }\n        return [summaryJson];\n    };\n    /**\n     * @param {?} outputCtx\n     * @param {?} ngModuleType\n     * @return {?}\n     */\n    AotCompiler.prototype._compileModule = function (outputCtx, ngModuleType) {\n        var /** @type {?} */ ngModule = ((this._metadataResolver.getNgModuleMetadata(ngModuleType)));\n        var /** @type {?} */ providers = [];\n        if (this._localeId) {\n            providers.push({\n                token: createTokenForExternalReference(this._reflector, Identifiers.LOCALE_ID),\n                useValue: this._localeId,\n            });\n        }\n        if (this._translationFormat) {\n            providers.push({\n                token: createTokenForExternalReference(this._reflector, Identifiers.TRANSLATIONS_FORMAT),\n                useValue: this._translationFormat\n            });\n        }\n        this._ngModuleCompiler.compile(outputCtx, ngModule, providers);\n    };\n    /**\n     * @param {?} outputCtx\n     * @param {?} compMeta\n     * @param {?} ngModule\n     * @param {?} fileSuffix\n     * @return {?}\n     */\n    AotCompiler.prototype._compileComponentFactory = function (outputCtx, compMeta, ngModule, fileSuffix) {\n        var /** @type {?} */ hostType = this._metadataResolver.getHostComponentType(compMeta.type.reference);\n        var /** @type {?} */ hostMeta = createHostComponentMeta(hostType, compMeta, this._metadataResolver.getHostComponentViewClass(hostType));\n        var /** @type {?} */ hostViewFactoryVar = this._compileComponent(outputCtx, hostMeta, ngModule, [compMeta.type], null, fileSuffix)\n            .viewClassVar;\n        var /** @type {?} */ compFactoryVar = componentFactoryName(compMeta.type.reference);\n        var /** @type {?} */ inputsExprs = [];\n        for (var /** @type {?} */ propName in compMeta.inputs) {\n            var /** @type {?} */ templateName = compMeta.inputs[propName];\n            // Don't quote so that the key gets minified...\n            inputsExprs.push(new LiteralMapEntry(propName, literal(templateName), false));\n        }\n        var /** @type {?} */ outputsExprs = [];\n        for (var /** @type {?} */ propName in compMeta.outputs) {\n            var /** @type {?} */ templateName = compMeta.outputs[propName];\n            // Don't quote so that the key gets minified...\n            outputsExprs.push(new LiteralMapEntry(propName, literal(templateName), false));\n        }\n        outputCtx.statements.push(variable(compFactoryVar)\n            .set(importExpr(Identifiers.createComponentFactory).callFn([\n            literal(compMeta.selector), outputCtx.importExpr(compMeta.type.reference),\n            variable(hostViewFactoryVar), new LiteralMapExpr(inputsExprs),\n            new LiteralMapExpr(outputsExprs),\n            literalArr(/** @type {?} */ ((compMeta.template)).ngContentSelectors.map(function (selector) { return literal(selector); }))\n        ]))\n            .toDeclStmt(importType(Identifiers.ComponentFactory, [/** @type {?} */ ((expressionType(outputCtx.importExpr(compMeta.type.reference))))], [TypeModifier.Const]), [StmtModifier.Final, StmtModifier.Exported]));\n    };\n    /**\n     * @param {?} outputCtx\n     * @param {?} compMeta\n     * @param {?} ngModule\n     * @param {?} directiveIdentifiers\n     * @param {?} componentStyles\n     * @param {?} fileSuffix\n     * @return {?}\n     */\n    AotCompiler.prototype._compileComponent = function (outputCtx, compMeta, ngModule, directiveIdentifiers, componentStyles, fileSuffix) {\n        var _this = this;\n        var /** @type {?} */ directives = directiveIdentifiers.map(function (dir) { return _this._metadataResolver.getDirectiveSummary(dir.reference); });\n        var /** @type {?} */ pipes = ngModule.transitiveModule.pipes.map(function (pipe) { return _this._metadataResolver.getPipeSummary(pipe.reference); });\n        var _a = this._templateParser.parse(compMeta, /** @type {?} */ ((((compMeta.template)).template)), directives, pipes, ngModule.schemas, templateSourceUrl(ngModule.type, compMeta, /** @type {?} */ ((compMeta.template)))), parsedTemplate = _a.template, usedPipes = _a.pipes;\n        var /** @type {?} */ stylesExpr = componentStyles ? variable(componentStyles.stylesVar) : literalArr([]);\n        var /** @type {?} */ viewResult = this._viewCompiler.compileComponent(outputCtx, compMeta, parsedTemplate, stylesExpr, usedPipes);\n        if (componentStyles) {\n            _resolveStyleStatements(this._symbolResolver, componentStyles, this._styleCompiler.needsStyleShim(compMeta), fileSuffix);\n        }\n        return viewResult;\n    };\n    /**\n     * @param {?} genFilePath\n     * @return {?}\n     */\n    AotCompiler.prototype._createOutputContext = function (genFilePath) {\n        var _this = this;\n        var /** @type {?} */ importExpr$$1 = function (symbol, typeParams) {\n            if (typeParams === void 0) { typeParams = null; }\n            if (!(symbol instanceof StaticSymbol)) {\n                throw new Error(\"Internal error: unknown identifier \" + JSON.stringify(symbol));\n            }\n            var /** @type {?} */ arity = _this._symbolResolver.getTypeArity(symbol) || 0;\n            var _a = _this._symbolResolver.getImportAs(symbol) || symbol, filePath = _a.filePath, name = _a.name, members = _a.members;\n            var /** @type {?} */ importModule = _this._symbolResolver.fileNameToModuleName(filePath, genFilePath);\n            // It should be good enough to compare filePath to genFilePath and if they are equal\n            // there is a self reference. However, ngfactory files generate to .ts but their\n            // symbols have .d.ts so a simple compare is insufficient. They should be canonical\n            // and is tracked by #17705.\n            var /** @type {?} */ selfReference = _this._symbolResolver.fileNameToModuleName(genFilePath, genFilePath);\n            var /** @type {?} */ moduleName = importModule === selfReference ? null : importModule;\n            // If we are in a type expression that refers to a generic type then supply\n            // the required type parameters. If there were not enough type parameters\n            // supplied, supply any as the type. Outside a type expression the reference\n            // should not supply type parameters and be treated as a simple value reference\n            // to the constructor function itself.\n            var /** @type {?} */ suppliedTypeParams = typeParams || [];\n            var /** @type {?} */ missingTypeParamsCount = arity - suppliedTypeParams.length;\n            var /** @type {?} */ allTypeParams = suppliedTypeParams.concat(new Array(missingTypeParamsCount).fill(DYNAMIC_TYPE));\n            return members.reduce(function (expr, memberName) { return expr.prop(memberName); }, /** @type {?} */ (importExpr(new ExternalReference(moduleName, name, null), allTypeParams)));\n        };\n        return { statements: [], genFilePath: genFilePath, importExpr: importExpr$$1 };\n    };\n    /**\n     * @param {?} srcFileUrl\n     * @param {?} compMeta\n     * @param {?} stylesheetMetadata\n     * @param {?} fileSuffix\n     * @return {?}\n     */\n    AotCompiler.prototype._codegenStyles = function (srcFileUrl, compMeta, stylesheetMetadata, fileSuffix) {\n        var /** @type {?} */ outputCtx = this._createOutputContext(_stylesModuleUrl(/** @type {?} */ ((stylesheetMetadata.moduleUrl)), this._styleCompiler.needsStyleShim(compMeta), fileSuffix));\n        var /** @type {?} */ compiledStylesheet = this._styleCompiler.compileStyles(outputCtx, compMeta, stylesheetMetadata);\n        _resolveStyleStatements(this._symbolResolver, compiledStylesheet, this._styleCompiler.needsStyleShim(compMeta), fileSuffix);\n        return this._codegenSourceModule(srcFileUrl, outputCtx);\n    };\n    /**\n     * @param {?} srcFileUrl\n     * @param {?} ctx\n     * @return {?}\n     */\n    AotCompiler.prototype._codegenSourceModule = function (srcFileUrl, ctx) {\n        return new GeneratedFile(srcFileUrl, ctx.genFilePath, ctx.statements);\n    };\n    return AotCompiler;\n}());\n/**\n * @param {?} outputCtx\n * @param {?} reference\n * @return {?}\n */\nfunction _createTypeReferenceStub(outputCtx, reference) {\n    outputCtx.statements.push(importExpr(reference).toStmt());\n}\n/**\n * @param {?} symbolResolver\n * @param {?} compileResult\n * @param {?} needsShim\n * @param {?} fileSuffix\n * @return {?}\n */\nfunction _resolveStyleStatements(symbolResolver, compileResult, needsShim, fileSuffix) {\n    compileResult.dependencies.forEach(function (dep) {\n        dep.setValue(symbolResolver.getStaticSymbol(_stylesModuleUrl(dep.moduleUrl, needsShim, fileSuffix), dep.name));\n    });\n}\n/**\n * @param {?} stylesheetUrl\n * @param {?} shim\n * @param {?} suffix\n * @return {?}\n */\nfunction _stylesModuleUrl(stylesheetUrl, shim, suffix) {\n    return \"\" + stylesheetUrl + (shim ? '.shim' : '') + \".ngstyle\" + suffix;\n}\n/**\n * @param {?} programStaticSymbols\n * @param {?} host\n * @param {?} metadataResolver\n * @return {?}\n */\nfunction analyzeNgModules(programStaticSymbols, host, metadataResolver) {\n    var _a = _createNgModules(programStaticSymbols, host, metadataResolver), ngModules = _a.ngModules, symbolsMissingModule = _a.symbolsMissingModule;\n    return _analyzeNgModules(programStaticSymbols, ngModules, symbolsMissingModule, metadataResolver);\n}\n/**\n * @param {?} programStaticSymbols\n * @param {?} host\n * @param {?} metadataResolver\n * @return {?}\n */\nfunction analyzeAndValidateNgModules(programStaticSymbols, host, metadataResolver) {\n    var /** @type {?} */ result = analyzeNgModules(programStaticSymbols, host, metadataResolver);\n    if (result.symbolsMissingModule && result.symbolsMissingModule.length) {\n        var /** @type {?} */ messages = result.symbolsMissingModule.map(function (s) { return \"Cannot determine the module for class \" + s.name + \" in \" + s.filePath + \"! Add \" + s.name + \" to the NgModule to fix it.\"; });\n        throw syntaxError(messages.join('\\n'));\n    }\n    return result;\n}\n/**\n * @param {?} programSymbols\n * @param {?} ngModuleMetas\n * @param {?} symbolsMissingModule\n * @param {?} metadataResolver\n * @return {?}\n */\nfunction _analyzeNgModules(programSymbols, ngModuleMetas, symbolsMissingModule, metadataResolver) {\n    var /** @type {?} */ moduleMetasByRef = new Map();\n    ngModuleMetas.forEach(function (ngModule) { return moduleMetasByRef.set(ngModule.type.reference, ngModule); });\n    var /** @type {?} */ ngModuleByPipeOrDirective = new Map();\n    var /** @type {?} */ ngModulesByFile = new Map();\n    var /** @type {?} */ ngDirectivesByFile = new Map();\n    var /** @type {?} */ ngPipesByFile = new Map();\n    var /** @type {?} */ ngInjectablesByFile = new Map();\n    var /** @type {?} */ filePaths = new Set();\n    // Make sure we produce an analyzed file for each input file\n    programSymbols.forEach(function (symbol) {\n        var /** @type {?} */ filePath = symbol.filePath;\n        filePaths.add(filePath);\n        if (metadataResolver.isInjectable(symbol)) {\n            ngInjectablesByFile.set(filePath, (ngInjectablesByFile.get(filePath) || []).concat(symbol));\n        }\n    });\n    // Looping over all modules to construct:\n    // - a map from file to modules `ngModulesByFile`,\n    // - a map from file to directives `ngDirectivesByFile`,\n    // - a map from file to pipes `ngPipesByFile`,\n    // - a map from directive/pipe to module `ngModuleByPipeOrDirective`.\n    ngModuleMetas.forEach(function (ngModuleMeta) {\n        var /** @type {?} */ srcFileUrl = ngModuleMeta.type.reference.filePath;\n        filePaths.add(srcFileUrl);\n        ngModulesByFile.set(srcFileUrl, (ngModulesByFile.get(srcFileUrl) || []).concat(ngModuleMeta.type.reference));\n        ngModuleMeta.declaredDirectives.forEach(function (dirIdentifier) {\n            var /** @type {?} */ fileUrl = dirIdentifier.reference.filePath;\n            filePaths.add(fileUrl);\n            ngDirectivesByFile.set(fileUrl, (ngDirectivesByFile.get(fileUrl) || []).concat(dirIdentifier.reference));\n            ngModuleByPipeOrDirective.set(dirIdentifier.reference, ngModuleMeta);\n        });\n        ngModuleMeta.declaredPipes.forEach(function (pipeIdentifier) {\n            var /** @type {?} */ fileUrl = pipeIdentifier.reference.filePath;\n            filePaths.add(fileUrl);\n            ngPipesByFile.set(fileUrl, (ngPipesByFile.get(fileUrl) || []).concat(pipeIdentifier.reference));\n            ngModuleByPipeOrDirective.set(pipeIdentifier.reference, ngModuleMeta);\n        });\n    });\n    var /** @type {?} */ files = [];\n    filePaths.forEach(function (srcUrl) {\n        var /** @type {?} */ directives = ngDirectivesByFile.get(srcUrl) || [];\n        var /** @type {?} */ pipes = ngPipesByFile.get(srcUrl) || [];\n        var /** @type {?} */ ngModules = ngModulesByFile.get(srcUrl) || [];\n        var /** @type {?} */ injectables = ngInjectablesByFile.get(srcUrl) || [];\n        files.push({ srcUrl: srcUrl, directives: directives, pipes: pipes, ngModules: ngModules, injectables: injectables });\n    });\n    return {\n        // map directive/pipe to module\n        ngModuleByPipeOrDirective: ngModuleByPipeOrDirective,\n        // list modules and directives for every source file\n        files: files,\n        ngModules: ngModuleMetas, symbolsMissingModule: symbolsMissingModule\n    };\n}\n/**\n * @param {?} staticSymbolResolver\n * @param {?} files\n * @param {?} host\n * @return {?}\n */\nfunction extractProgramSymbols(staticSymbolResolver, files, host) {\n    var /** @type {?} */ staticSymbols = [];\n    files.filter(function (fileName) { return host.isSourceFile(fileName); }).forEach(function (sourceFile) {\n        staticSymbolResolver.getSymbolsOf(sourceFile).forEach(function (symbol) {\n            var /** @type {?} */ resolvedSymbol = staticSymbolResolver.resolveSymbol(symbol);\n            var /** @type {?} */ symbolMeta = resolvedSymbol.metadata;\n            if (symbolMeta) {\n                if (symbolMeta.__symbolic != 'error') {\n                    // Ignore symbols that are only included to record error information.\n                    staticSymbols.push(resolvedSymbol.symbol);\n                }\n            }\n        });\n    });\n    return staticSymbols;\n}\n/**\n * @param {?} programStaticSymbols\n * @param {?} host\n * @param {?} metadataResolver\n * @return {?}\n */\nfunction _createNgModules(programStaticSymbols, host, metadataResolver) {\n    var /** @type {?} */ ngModules = new Map();\n    var /** @type {?} */ programPipesAndDirectives = [];\n    var /** @type {?} */ ngModulePipesAndDirective = new Set();\n    var /** @type {?} */ addNgModule = function (staticSymbol) {\n        if (ngModules.has(staticSymbol) || !host.isSourceFile(staticSymbol.filePath)) {\n            return false;\n        }\n        var /** @type {?} */ ngModule = metadataResolver.getNgModuleMetadata(staticSymbol, false);\n        if (ngModule) {\n            ngModules.set(ngModule.type.reference, ngModule);\n            ngModule.declaredDirectives.forEach(function (dir) { return ngModulePipesAndDirective.add(dir.reference); });\n            ngModule.declaredPipes.forEach(function (pipe) { return ngModulePipesAndDirective.add(pipe.reference); });\n            // For every input module add the list of transitively included modules\n            ngModule.transitiveModule.modules.forEach(function (modMeta) { return addNgModule(modMeta.reference); });\n        }\n        return !!ngModule;\n    };\n    programStaticSymbols.forEach(function (staticSymbol) {\n        if (!addNgModule(staticSymbol) &&\n            (metadataResolver.isDirective(staticSymbol) || metadataResolver.isPipe(staticSymbol))) {\n            programPipesAndDirectives.push(staticSymbol);\n        }\n    });\n    // Throw an error if any of the program pipe or directives is not declared by a module\n    var /** @type {?} */ symbolsMissingModule = programPipesAndDirectives.filter(function (s) { return !ngModulePipesAndDirective.has(s); });\n    return { ngModules: Array.from(ngModules.values()), symbolsMissingModule: symbolsMissingModule };\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ANGULAR_CORE = '@angular/core';\nvar ANGULAR_ROUTER = '@angular/router';\nvar HIDDEN_KEY = /^\\$.*\\$$/;\nvar IGNORE = {\n    __symbolic: 'ignore'\n};\nvar USE_VALUE = 'useValue';\nvar PROVIDE = 'provide';\nvar REFERENCE_SET = new Set([USE_VALUE, 'useFactory', 'data']);\n/**\n * @param {?} value\n * @return {?}\n */\nfunction shouldIgnore(value) {\n    return value && value.__symbolic == 'ignore';\n}\n/**\n * A static reflector implements enough of the Reflector API that is necessary to compile\n * templates statically.\n */\nvar StaticReflector = (function () {\n    /**\n     * @param {?} summaryResolver\n     * @param {?} symbolResolver\n     * @param {?=} knownMetadataClasses\n     * @param {?=} knownMetadataFunctions\n     * @param {?=} errorRecorder\n     */\n    function StaticReflector(summaryResolver, symbolResolver, knownMetadataClasses, knownMetadataFunctions, errorRecorder) {\n        if (knownMetadataClasses === void 0) { knownMetadataClasses = []; }\n        if (knownMetadataFunctions === void 0) { knownMetadataFunctions = []; }\n        var _this = this;\n        this.summaryResolver = summaryResolver;\n        this.symbolResolver = symbolResolver;\n        this.errorRecorder = errorRecorder;\n        this.annotationCache = new Map();\n        this.propertyCache = new Map();\n        this.parameterCache = new Map();\n        this.methodCache = new Map();\n        this.conversionMap = new Map();\n        this.annotationForParentClassWithSummaryKind = new Map();\n        this.annotationNames = new Map();\n        this.initializeConversionMap();\n        knownMetadataClasses.forEach(function (kc) { return _this._registerDecoratorOrConstructor(_this.getStaticSymbol(kc.filePath, kc.name), kc.ctor); });\n        knownMetadataFunctions.forEach(function (kf) { return _this._registerFunction(_this.getStaticSymbol(kf.filePath, kf.name), kf.fn); });\n        this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Directive, [__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"]]);\n        this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Pipe, [__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Pipe\"]]);\n        this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.NgModule, [__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"]]);\n        this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Injectable, [__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"], __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Pipe\"], __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"]]);\n        this.annotationNames.set(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], 'Directive');\n        this.annotationNames.set(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], 'Component');\n        this.annotationNames.set(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Pipe\"], 'Pipe');\n        this.annotationNames.set(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], 'NgModule');\n        this.annotationNames.set(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"], 'Injectable');\n    }\n    /**\n     * @param {?} typeOrFunc\n     * @return {?}\n     */\n    StaticReflector.prototype.componentModuleUrl = function (typeOrFunc) {\n        var /** @type {?} */ staticSymbol = this.findSymbolDeclaration(typeOrFunc);\n        return this.symbolResolver.getResourcePath(staticSymbol);\n    };\n    /**\n     * @param {?} ref\n     * @return {?}\n     */\n    StaticReflector.prototype.resolveExternalReference = function (ref) {\n        var /** @type {?} */ importSymbol = this.getStaticSymbol(/** @type {?} */ ((ref.moduleName)), /** @type {?} */ ((ref.name)));\n        var /** @type {?} */ rootSymbol = this.findDeclaration(/** @type {?} */ ((ref.moduleName)), /** @type {?} */ ((ref.name)));\n        if (importSymbol != rootSymbol) {\n            this.symbolResolver.recordImportAs(rootSymbol, importSymbol);\n        }\n        return rootSymbol;\n    };\n    /**\n     * @param {?} moduleUrl\n     * @param {?} name\n     * @param {?=} containingFile\n     * @return {?}\n     */\n    StaticReflector.prototype.findDeclaration = function (moduleUrl, name, containingFile) {\n        return this.findSymbolDeclaration(this.symbolResolver.getSymbolByModule(moduleUrl, name, containingFile));\n    };\n    /**\n     * @param {?} moduleUrl\n     * @param {?} name\n     * @return {?}\n     */\n    StaticReflector.prototype.tryFindDeclaration = function (moduleUrl, name) {\n        var _this = this;\n        return this.symbolResolver.ignoreErrorsFor(function () { return _this.findDeclaration(moduleUrl, name); });\n    };\n    /**\n     * @param {?} symbol\n     * @return {?}\n     */\n    StaticReflector.prototype.findSymbolDeclaration = function (symbol) {\n        var /** @type {?} */ resolvedSymbol = this.symbolResolver.resolveSymbol(symbol);\n        if (resolvedSymbol && resolvedSymbol.metadata instanceof StaticSymbol) {\n            return this.findSymbolDeclaration(resolvedSymbol.metadata);\n        }\n        else {\n            return symbol;\n        }\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    StaticReflector.prototype.annotations = function (type) {\n        var _this = this;\n        var /** @type {?} */ annotations = this.annotationCache.get(type);\n        if (!annotations) {\n            annotations = [];\n            var /** @type {?} */ classMetadata = this.getTypeMetadata(type);\n            var /** @type {?} */ parentType = this.findParentType(type, classMetadata);\n            if (parentType) {\n                var /** @type {?} */ parentAnnotations = this.annotations(parentType);\n                annotations.push.apply(annotations, parentAnnotations);\n            }\n            var /** @type {?} */ ownAnnotations_1 = [];\n            if (classMetadata['decorators']) {\n                ownAnnotations_1 = this.simplify(type, classMetadata['decorators']);\n                annotations.push.apply(annotations, ownAnnotations_1);\n            }\n            if (parentType && !this.summaryResolver.isLibraryFile(type.filePath) &&\n                this.summaryResolver.isLibraryFile(parentType.filePath)) {\n                var /** @type {?} */ summary = this.summaryResolver.resolveSummary(parentType);\n                if (summary && summary.type) {\n                    var /** @type {?} */ requiredAnnotationTypes = ((this.annotationForParentClassWithSummaryKind.get(/** @type {?} */ ((summary.type.summaryKind)))));\n                    var /** @type {?} */ typeHasRequiredAnnotation = requiredAnnotationTypes.some(function (requiredType) { return ownAnnotations_1.some(function (ann) { return ann instanceof requiredType; }); });\n                    if (!typeHasRequiredAnnotation) {\n                        this.reportError(syntaxError(\"Class \" + type.name + \" in \" + type.filePath + \" extends from a \" + CompileSummaryKind[((summary.type.summaryKind))] + \" in another compilation unit without duplicating the decorator. \" +\n                            (\"Please add a \" + requiredAnnotationTypes.map(function (type) { return _this.annotationNames.get(type); }).join(' or ') + \" decorator to the class.\")), type);\n                    }\n                }\n            }\n            this.annotationCache.set(type, annotations.filter(function (ann) { return !!ann; }));\n        }\n        return annotations;\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    StaticReflector.prototype.propMetadata = function (type) {\n        var _this = this;\n        var /** @type {?} */ propMetadata = this.propertyCache.get(type);\n        if (!propMetadata) {\n            var /** @type {?} */ classMetadata = this.getTypeMetadata(type);\n            propMetadata = {};\n            var /** @type {?} */ parentType = this.findParentType(type, classMetadata);\n            if (parentType) {\n                var /** @type {?} */ parentPropMetadata_1 = this.propMetadata(parentType);\n                Object.keys(parentPropMetadata_1).forEach(function (parentProp) {\n                    ((propMetadata))[parentProp] = parentPropMetadata_1[parentProp];\n                });\n            }\n            var /** @type {?} */ members_1 = classMetadata['members'] || {};\n            Object.keys(members_1).forEach(function (propName) {\n                var /** @type {?} */ propData = members_1[propName];\n                var /** @type {?} */ prop = ((propData))\n                    .find(function (a) { return a['__symbolic'] == 'property' || a['__symbolic'] == 'method'; });\n                var /** @type {?} */ decorators = [];\n                if (((propMetadata))[propName]) {\n                    decorators.push.apply(decorators, ((propMetadata))[propName]);\n                } /** @type {?} */\n                ((propMetadata))[propName] = decorators;\n                if (prop && prop['decorators']) {\n                    decorators.push.apply(decorators, _this.simplify(type, prop['decorators']));\n                }\n            });\n            this.propertyCache.set(type, propMetadata);\n        }\n        return propMetadata;\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    StaticReflector.prototype.parameters = function (type) {\n        var _this = this;\n        if (!(type instanceof StaticSymbol)) {\n            this.reportError(new Error(\"parameters received \" + JSON.stringify(type) + \" which is not a StaticSymbol\"), type);\n            return [];\n        }\n        try {\n            var /** @type {?} */ parameters_1 = this.parameterCache.get(type);\n            if (!parameters_1) {\n                var /** @type {?} */ classMetadata = this.getTypeMetadata(type);\n                var /** @type {?} */ parentType = this.findParentType(type, classMetadata);\n                var /** @type {?} */ members = classMetadata ? classMetadata['members'] : null;\n                var /** @type {?} */ ctorData = members ? members['__ctor__'] : null;\n                if (ctorData) {\n                    var /** @type {?} */ ctor = ((ctorData)).find(function (a) { return a['__symbolic'] == 'constructor'; });\n                    var /** @type {?} */ rawParameterTypes = (ctor['parameters']) || [];\n                    var /** @type {?} */ parameterDecorators_1 = (this.simplify(type, ctor['parameterDecorators'] || []));\n                    parameters_1 = [];\n                    rawParameterTypes.forEach(function (rawParamType, index) {\n                        var /** @type {?} */ nestedResult = [];\n                        var /** @type {?} */ paramType = _this.trySimplify(type, rawParamType);\n                        if (paramType)\n                            nestedResult.push(paramType);\n                        var /** @type {?} */ decorators = parameterDecorators_1 ? parameterDecorators_1[index] : null;\n                        if (decorators) {\n                            nestedResult.push.apply(nestedResult, decorators);\n                        } /** @type {?} */\n                        ((parameters_1)).push(nestedResult);\n                    });\n                }\n                else if (parentType) {\n                    parameters_1 = this.parameters(parentType);\n                }\n                if (!parameters_1) {\n                    parameters_1 = [];\n                }\n                this.parameterCache.set(type, parameters_1);\n            }\n            return parameters_1;\n        }\n        catch (e) {\n            console.error(\"Failed on type \" + JSON.stringify(type) + \" with error \" + e);\n            throw e;\n        }\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    StaticReflector.prototype._methodNames = function (type) {\n        var /** @type {?} */ methodNames = this.methodCache.get(type);\n        if (!methodNames) {\n            var /** @type {?} */ classMetadata = this.getTypeMetadata(type);\n            methodNames = {};\n            var /** @type {?} */ parentType = this.findParentType(type, classMetadata);\n            if (parentType) {\n                var /** @type {?} */ parentMethodNames_1 = this._methodNames(parentType);\n                Object.keys(parentMethodNames_1).forEach(function (parentProp) {\n                    ((methodNames))[parentProp] = parentMethodNames_1[parentProp];\n                });\n            }\n            var /** @type {?} */ members_2 = classMetadata['members'] || {};\n            Object.keys(members_2).forEach(function (propName) {\n                var /** @type {?} */ propData = members_2[propName];\n                var /** @type {?} */ isMethod = ((propData)).some(function (a) { return a['__symbolic'] == 'method'; }); /** @type {?} */\n                ((methodNames))[propName] = ((methodNames))[propName] || isMethod;\n            });\n            this.methodCache.set(type, methodNames);\n        }\n        return methodNames;\n    };\n    /**\n     * @param {?} type\n     * @param {?} classMetadata\n     * @return {?}\n     */\n    StaticReflector.prototype.findParentType = function (type, classMetadata) {\n        var /** @type {?} */ parentType = this.trySimplify(type, classMetadata['extends']);\n        if (parentType instanceof StaticSymbol) {\n            return parentType;\n        }\n    };\n    /**\n     * @param {?} type\n     * @param {?} lcProperty\n     * @return {?}\n     */\n    StaticReflector.prototype.hasLifecycleHook = function (type, lcProperty) {\n        if (!(type instanceof StaticSymbol)) {\n            this.reportError(new Error(\"hasLifecycleHook received \" + JSON.stringify(type) + \" which is not a StaticSymbol\"), type);\n        }\n        try {\n            return !!this._methodNames(type)[lcProperty];\n        }\n        catch (e) {\n            console.error(\"Failed on type \" + JSON.stringify(type) + \" with error \" + e);\n            throw e;\n        }\n    };\n    /**\n     * @param {?} type\n     * @param {?} ctor\n     * @return {?}\n     */\n    StaticReflector.prototype._registerDecoratorOrConstructor = function (type, ctor) {\n        this.conversionMap.set(type, function (context, args) { return new (ctor.bind.apply(ctor, [void 0].concat(args)))(); });\n    };\n    /**\n     * @param {?} type\n     * @param {?} fn\n     * @return {?}\n     */\n    StaticReflector.prototype._registerFunction = function (type, fn) {\n        this.conversionMap.set(type, function (context, args) { return fn.apply(undefined, args); });\n    };\n    /**\n     * @return {?}\n     */\n    StaticReflector.prototype.initializeConversionMap = function () {\n        this.injectionToken = this.findDeclaration(ANGULAR_CORE, 'InjectionToken');\n        this.opaqueToken = this.findDeclaration(ANGULAR_CORE, 'OpaqueToken');\n        this.ROUTES = this.tryFindDeclaration(ANGULAR_ROUTER, 'ROUTES');\n        this.ANALYZE_FOR_ENTRY_COMPONENTS =\n            this.findDeclaration(ANGULAR_CORE, 'ANALYZE_FOR_ENTRY_COMPONENTS');\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Host'), __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Host\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Injectable'), __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Self'), __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Self\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'SkipSelf'), __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SkipSelf\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Inject'), __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Optional'), __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Attribute'), __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Attribute\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ContentChild'), __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChild\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ContentChildren'), __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ViewChild'), __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ViewChildren'), __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChildren\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Input'), __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Output'), __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Pipe'), __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Pipe\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'HostBinding'), __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"HostBinding\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'HostListener'), __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"HostListener\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Directive'), __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Component'), __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'NgModule'), __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"]);\n        // Note: Some metadata classes can be used directly with Provider.deps.\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Host'), __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Host\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Self'), __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Self\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'SkipSelf'), __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SkipSelf\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Optional'), __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"]);\n        this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'trigger'), __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"trigger\"]);\n        this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'state'), __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"state\"]);\n        this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'transition'), __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"transition\"]);\n        this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'style'), __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"style\"]);\n        this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'animate'), __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"animate\"]);\n        this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'keyframes'), __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"keyframes\"]);\n        this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'sequence'), __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"sequence\"]);\n        this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'group'), __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"group\"]);\n    };\n    /**\n     * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.\n     * All types passed to the StaticResolver should be pseudo-types returned by this method.\n     *\n     * @param {?} declarationFile the absolute path of the file where the symbol is declared\n     * @param {?} name the name of the type.\n     * @param {?=} members\n     * @return {?}\n     */\n    StaticReflector.prototype.getStaticSymbol = function (declarationFile, name, members) {\n        return this.symbolResolver.getStaticSymbol(declarationFile, name, members);\n    };\n    /**\n     * @param {?} error\n     * @param {?} context\n     * @param {?=} path\n     * @return {?}\n     */\n    StaticReflector.prototype.reportError = function (error, context, path) {\n        if (this.errorRecorder) {\n            this.errorRecorder(error, (context && context.filePath) || path);\n        }\n        else {\n            throw error;\n        }\n    };\n    /**\n     * Simplify but discard any errors\n     * @param {?} context\n     * @param {?} value\n     * @return {?}\n     */\n    StaticReflector.prototype.trySimplify = function (context, value) {\n        var /** @type {?} */ originalRecorder = this.errorRecorder;\n        this.errorRecorder = function (error, fileName) { };\n        var /** @type {?} */ result = this.simplify(context, value);\n        this.errorRecorder = originalRecorder;\n        return result;\n    };\n    /**\n     * \\@internal\n     * @param {?} context\n     * @param {?} value\n     * @return {?}\n     */\n    StaticReflector.prototype.simplify = function (context, value) {\n        var _this = this;\n        var /** @type {?} */ self = this;\n        var /** @type {?} */ scope = BindingScope.empty;\n        var /** @type {?} */ calling = new Map();\n        /**\n         * @param {?} context\n         * @param {?} value\n         * @param {?} depth\n         * @param {?} references\n         * @return {?}\n         */\n        function simplifyInContext(context, value, depth, references) {\n            /**\n             * @param {?} staticSymbol\n             * @return {?}\n             */\n            function resolveReferenceValue(staticSymbol) {\n                var /** @type {?} */ resolvedSymbol = self.symbolResolver.resolveSymbol(staticSymbol);\n                return resolvedSymbol ? resolvedSymbol.metadata : null;\n            }\n            /**\n             * @param {?} functionSymbol\n             * @param {?} targetFunction\n             * @param {?} args\n             * @return {?}\n             */\n            function simplifyCall(functionSymbol, targetFunction, args) {\n                if (targetFunction && targetFunction['__symbolic'] == 'function') {\n                    if (calling.get(functionSymbol)) {\n                        throw new Error('Recursion not supported');\n                    }\n                    calling.set(functionSymbol, true);\n                    try {\n                        var /** @type {?} */ value_1 = targetFunction['value'];\n                        if (value_1 && (depth != 0 || value_1.__symbolic != 'error')) {\n                            var /** @type {?} */ parameters = targetFunction['parameters'];\n                            var /** @type {?} */ defaults = targetFunction.defaults;\n                            args = args.map(function (arg) { return simplifyInContext(context, arg, depth + 1, references); })\n                                .map(function (arg) { return shouldIgnore(arg) ? undefined : arg; });\n                            if (defaults && defaults.length > args.length) {\n                                args.push.apply(args, defaults.slice(args.length).map(function (value) { return simplify(value); }));\n                            }\n                            var /** @type {?} */ functionScope = BindingScope.build();\n                            for (var /** @type {?} */ i = 0; i < parameters.length; i++) {\n                                functionScope.define(parameters[i], args[i]);\n                            }\n                            var /** @type {?} */ oldScope = scope;\n                            var /** @type {?} */ result_1;\n                            try {\n                                scope = functionScope.done();\n                                result_1 = simplifyInContext(functionSymbol, value_1, depth + 1, references);\n                            }\n                            finally {\n                                scope = oldScope;\n                            }\n                            return result_1;\n                        }\n                    }\n                    finally {\n                        calling.delete(functionSymbol);\n                    }\n                }\n                if (depth === 0) {\n                    // If depth is 0 we are evaluating the top level expression that is describing element\n                    // decorator. In this case, it is a decorator we don't understand, such as a custom\n                    // non-angular decorator, and we should just ignore it.\n                    return IGNORE;\n                }\n                return simplify({ __symbolic: 'error', message: 'Function call not supported', context: functionSymbol });\n            }\n            /**\n             * @param {?} expression\n             * @return {?}\n             */\n            function simplify(expression) {\n                if (isPrimitive(expression)) {\n                    return expression;\n                }\n                if (expression instanceof Array) {\n                    var /** @type {?} */ result_2 = [];\n                    for (var _i = 0, _a = ((expression)); _i < _a.length; _i++) {\n                        var item = _a[_i];\n                        // Check for a spread expression\n                        if (item && item.__symbolic === 'spread') {\n                            var /** @type {?} */ spreadArray = simplify(item.expression);\n                            if (Array.isArray(spreadArray)) {\n                                for (var _b = 0, spreadArray_1 = spreadArray; _b < spreadArray_1.length; _b++) {\n                                    var spreadItem = spreadArray_1[_b];\n                                    result_2.push(spreadItem);\n                                }\n                                continue;\n                            }\n                        }\n                        var /** @type {?} */ value_2 = simplify(item);\n                        if (shouldIgnore(value_2)) {\n                            continue;\n                        }\n                        result_2.push(value_2);\n                    }\n                    return result_2;\n                }\n                if (expression instanceof StaticSymbol) {\n                    // Stop simplification at builtin symbols or if we are in a reference context\n                    if (expression === self.injectionToken || expression === self.opaqueToken ||\n                        self.conversionMap.has(expression) || references > 0) {\n                        return expression;\n                    }\n                    else {\n                        var /** @type {?} */ staticSymbol = expression;\n                        var /** @type {?} */ declarationValue = resolveReferenceValue(staticSymbol);\n                        if (declarationValue) {\n                            return simplifyInContext(staticSymbol, declarationValue, depth + 1, references);\n                        }\n                        else {\n                            return staticSymbol;\n                        }\n                    }\n                }\n                if (expression) {\n                    if (expression['__symbolic']) {\n                        var /** @type {?} */ staticSymbol = void 0;\n                        switch (expression['__symbolic']) {\n                            case 'binop':\n                                var /** @type {?} */ left = simplify(expression['left']);\n                                if (shouldIgnore(left))\n                                    return left;\n                                var /** @type {?} */ right = simplify(expression['right']);\n                                if (shouldIgnore(right))\n                                    return right;\n                                switch (expression['operator']) {\n                                    case '&&':\n                                        return left && right;\n                                    case '||':\n                                        return left || right;\n                                    case '|':\n                                        return left | right;\n                                    case '^':\n                                        return left ^ right;\n                                    case '&':\n                                        return left & right;\n                                    case '==':\n                                        return left == right;\n                                    case '!=':\n                                        return left != right;\n                                    case '===':\n                                        return left === right;\n                                    case '!==':\n                                        return left !== right;\n                                    case '<':\n                                        return left < right;\n                                    case '>':\n                                        return left > right;\n                                    case '<=':\n                                        return left <= right;\n                                    case '>=':\n                                        return left >= right;\n                                    case '<<':\n                                        return left << right;\n                                    case '>>':\n                                        return left >> right;\n                                    case '+':\n                                        return left + right;\n                                    case '-':\n                                        return left - right;\n                                    case '*':\n                                        return left * right;\n                                    case '/':\n                                        return left / right;\n                                    case '%':\n                                        return left % right;\n                                }\n                                return null;\n                            case 'if':\n                                var /** @type {?} */ condition = simplify(expression['condition']);\n                                return condition ? simplify(expression['thenExpression']) :\n                                    simplify(expression['elseExpression']);\n                            case 'pre':\n                                var /** @type {?} */ operand = simplify(expression['operand']);\n                                if (shouldIgnore(operand))\n                                    return operand;\n                                switch (expression['operator']) {\n                                    case '+':\n                                        return operand;\n                                    case '-':\n                                        return -operand;\n                                    case '!':\n                                        return !operand;\n                                    case '~':\n                                        return ~operand;\n                                }\n                                return null;\n                            case 'index':\n                                var /** @type {?} */ indexTarget = simplify(expression['expression']);\n                                var /** @type {?} */ index = simplify(expression['index']);\n                                if (indexTarget && isPrimitive(index))\n                                    return indexTarget[index];\n                                return null;\n                            case 'select':\n                                var /** @type {?} */ member = expression['member'];\n                                var /** @type {?} */ selectContext = context;\n                                var /** @type {?} */ selectTarget = simplify(expression['expression']);\n                                if (selectTarget instanceof StaticSymbol) {\n                                    var /** @type {?} */ members = selectTarget.members.concat(member);\n                                    selectContext =\n                                        self.getStaticSymbol(selectTarget.filePath, selectTarget.name, members);\n                                    var /** @type {?} */ declarationValue = resolveReferenceValue(selectContext);\n                                    if (declarationValue) {\n                                        return simplifyInContext(selectContext, declarationValue, depth + 1, references);\n                                    }\n                                    else {\n                                        return selectContext;\n                                    }\n                                }\n                                if (selectTarget && isPrimitive(member))\n                                    return simplifyInContext(selectContext, selectTarget[member], depth + 1, references);\n                                return null;\n                            case 'reference':\n                                // Note: This only has to deal with variable references,\n                                // as symbol references have been converted into StaticSymbols already\n                                // in the StaticSymbolResolver!\n                                var /** @type {?} */ name = expression['name'];\n                                var /** @type {?} */ localValue = scope.resolve(name);\n                                if (localValue != BindingScope.missing) {\n                                    return localValue;\n                                }\n                                break;\n                            case 'class':\n                                return context;\n                            case 'function':\n                                return context;\n                            case 'new':\n                            case 'call':\n                                // Determine if the function is a built-in conversion\n                                staticSymbol = simplifyInContext(context, expression['expression'], depth + 1, /* references */ 0);\n                                if (staticSymbol instanceof StaticSymbol) {\n                                    if (staticSymbol === self.injectionToken || staticSymbol === self.opaqueToken) {\n                                        // if somebody calls new InjectionToken, don't create an InjectionToken,\n                                        // but rather return the symbol to which the InjectionToken is assigned to.\n                                        return context;\n                                    }\n                                    var /** @type {?} */ argExpressions = expression['arguments'] || [];\n                                    var /** @type {?} */ converter = self.conversionMap.get(staticSymbol);\n                                    if (converter) {\n                                        var /** @type {?} */ args = argExpressions\n                                            .map(function (arg) { return simplifyInContext(context, arg, depth + 1, references); })\n                                            .map(function (arg) { return shouldIgnore(arg) ? undefined : arg; });\n                                        return converter(context, args);\n                                    }\n                                    else {\n                                        // Determine if the function is one we can simplify.\n                                        var /** @type {?} */ targetFunction = resolveReferenceValue(staticSymbol);\n                                        return simplifyCall(staticSymbol, targetFunction, argExpressions);\n                                    }\n                                }\n                                return IGNORE;\n                            case 'error':\n                                var /** @type {?} */ message = produceErrorMessage(expression);\n                                if (expression['line']) {\n                                    message =\n                                        message + \" (position \" + (expression['line'] + 1) + \":\" + (expression['character'] + 1) + \" in the original .ts file)\";\n                                    self.reportError(positionalError(message, context.filePath, expression['line'], expression['character']), context);\n                                }\n                                else {\n                                    self.reportError(new Error(message), context);\n                                }\n                                return IGNORE;\n                            case 'ignore':\n                                return expression;\n                        }\n                        return null;\n                    }\n                    return mapStringMap(expression, function (value, name) {\n                        if (REFERENCE_SET.has(name)) {\n                            if (name === USE_VALUE && PROVIDE in expression) {\n                                // If this is a provider expression, check for special tokens that need the value\n                                // during analysis.\n                                var /** @type {?} */ provide = simplify(expression.provide);\n                                if (provide === self.ROUTES || provide == self.ANALYZE_FOR_ENTRY_COMPONENTS) {\n                                    return simplify(value);\n                                }\n                            }\n                            return simplifyInContext(context, value, depth, references + 1);\n                        }\n                        return simplify(value);\n                    });\n                }\n                return IGNORE;\n            }\n            try {\n                return simplify(value);\n            }\n            catch (e) {\n                var /** @type {?} */ members = context.members.length ? \".\" + context.members.join('.') : '';\n                var /** @type {?} */ message = e.message + \", resolving symbol \" + context.name + members + \" in \" + context.filePath;\n                if (e.fileName) {\n                    throw positionalError(message, e.fileName, e.line, e.column);\n                }\n                throw syntaxError(message);\n            }\n        }\n        var /** @type {?} */ recordedSimplifyInContext = function (context, value) {\n            try {\n                return simplifyInContext(context, value, 0, 0);\n            }\n            catch (e) {\n                _this.reportError(e, context);\n            }\n        };\n        var /** @type {?} */ result = this.errorRecorder ? recordedSimplifyInContext(context, value) :\n            simplifyInContext(context, value, 0, 0);\n        if (shouldIgnore(result)) {\n            return undefined;\n        }\n        return result;\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    StaticReflector.prototype.getTypeMetadata = function (type) {\n        var /** @type {?} */ resolvedSymbol = this.symbolResolver.resolveSymbol(type);\n        return resolvedSymbol && resolvedSymbol.metadata ? resolvedSymbol.metadata :\n            { __symbolic: 'class' };\n    };\n    return StaticReflector;\n}());\n/**\n * @param {?} error\n * @return {?}\n */\nfunction expandedMessage(error) {\n    switch (error.message) {\n        case 'Reference to non-exported class':\n            if (error.context && error.context.className) {\n                return \"Reference to a non-exported class \" + error.context.className + \". Consider exporting the class\";\n            }\n            break;\n        case 'Variable not initialized':\n            return 'Only initialized variables and constants can be referenced because the value of this variable is needed by the template compiler';\n        case 'Destructuring not supported':\n            return 'Referencing an exported destructured variable or constant is not supported by the template compiler. Consider simplifying this to avoid destructuring';\n        case 'Could not resolve type':\n            if (error.context && error.context.typeName) {\n                return \"Could not resolve type \" + error.context.typeName;\n            }\n            break;\n        case 'Function call not supported':\n            var /** @type {?} */ prefix = error.context && error.context.name ? \"Calling function '\" + error.context.name + \"', f\" : 'F';\n            return prefix +\n                'unction calls are not supported. Consider replacing the function or lambda with a reference to an exported function';\n        case 'Reference to a local symbol':\n            if (error.context && error.context.name) {\n                return \"Reference to a local (non-exported) symbol '\" + error.context.name + \"'. Consider exporting the symbol\";\n            }\n            break;\n    }\n    return error.message;\n}\n/**\n * @param {?} error\n * @return {?}\n */\nfunction produceErrorMessage(error) {\n    return \"Error encountered resolving symbol values statically. \" + expandedMessage(error);\n}\n/**\n * @param {?} input\n * @param {?} transform\n * @return {?}\n */\nfunction mapStringMap(input, transform) {\n    if (!input)\n        return {};\n    var /** @type {?} */ result = {};\n    Object.keys(input).forEach(function (key) {\n        var /** @type {?} */ value = transform(input[key], key);\n        if (!shouldIgnore(value)) {\n            if (HIDDEN_KEY.test(key)) {\n                Object.defineProperty(result, key, { enumerable: false, configurable: true, value: value });\n            }\n            else {\n                result[key] = value;\n            }\n        }\n    });\n    return result;\n}\n/**\n * @param {?} o\n * @return {?}\n */\nfunction isPrimitive(o) {\n    return o === null || (typeof o !== 'function' && typeof o !== 'object');\n}\n/**\n * @abstract\n */\nvar BindingScope = (function () {\n    function BindingScope() {\n    }\n    /**\n     * @abstract\n     * @param {?} name\n     * @return {?}\n     */\n    BindingScope.prototype.resolve = function (name) { };\n    /**\n     * @return {?}\n     */\n    BindingScope.build = function () {\n        var /** @type {?} */ current = new Map();\n        return {\n            define: function (name, value) {\n                current.set(name, value);\n                return this;\n            },\n            done: function () {\n                return current.size > 0 ? new PopulatedScope(current) : BindingScope.empty;\n            }\n        };\n    };\n    return BindingScope;\n}());\nBindingScope.missing = {};\nBindingScope.empty = { resolve: function (name) { return BindingScope.missing; } };\nvar PopulatedScope = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](PopulatedScope, _super);\n    /**\n     * @param {?} bindings\n     */\n    function PopulatedScope(bindings) {\n        var _this = _super.call(this) || this;\n        _this.bindings = bindings;\n        return _this;\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    PopulatedScope.prototype.resolve = function (name) {\n        return this.bindings.has(name) ? this.bindings.get(name) : BindingScope.missing;\n    };\n    return PopulatedScope;\n}(BindingScope));\n/**\n * @param {?} message\n * @param {?} fileName\n * @param {?} line\n * @param {?} column\n * @return {?}\n */\nfunction positionalError(message, fileName, line, column) {\n    var /** @type {?} */ result = new Error(message);\n    ((result)).fileName = fileName;\n    ((result)).line = line;\n    ((result)).column = column;\n    return result;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ResolvedStaticSymbol = (function () {\n    /**\n     * @param {?} symbol\n     * @param {?} metadata\n     */\n    function ResolvedStaticSymbol(symbol, metadata) {\n        this.symbol = symbol;\n        this.metadata = metadata;\n    }\n    return ResolvedStaticSymbol;\n}());\nvar SUPPORTED_SCHEMA_VERSION = 3;\n/**\n * This class is responsible for loading metadata per symbol,\n * and normalizing references between symbols.\n *\n * Internally, it only uses symbols without members,\n * and deduces the values for symbols with members based\n * on these symbols.\n */\nvar StaticSymbolResolver = (function () {\n    /**\n     * @param {?} host\n     * @param {?} staticSymbolCache\n     * @param {?} summaryResolver\n     * @param {?=} errorRecorder\n     */\n    function StaticSymbolResolver(host, staticSymbolCache, summaryResolver, errorRecorder) {\n        this.host = host;\n        this.staticSymbolCache = staticSymbolCache;\n        this.summaryResolver = summaryResolver;\n        this.errorRecorder = errorRecorder;\n        this.metadataCache = new Map();\n        this.resolvedSymbols = new Map();\n        this.resolvedFilePaths = new Set();\n        this.importAs = new Map();\n        this.symbolResourcePaths = new Map();\n        this.symbolFromFile = new Map();\n        this.knownFileNameToModuleNames = new Map();\n    }\n    /**\n     * @param {?} staticSymbol\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.resolveSymbol = function (staticSymbol) {\n        if (staticSymbol.members.length > 0) {\n            return ((this._resolveSymbolMembers(staticSymbol)));\n        }\n        var /** @type {?} */ result = this.resolvedSymbols.get(staticSymbol);\n        if (result) {\n            return result;\n        }\n        result = ((this._resolveSymbolFromSummary(staticSymbol)));\n        if (result) {\n            return result;\n        }\n        // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\n        // have summaries, only .d.ts files. So we always need to check both, the summary\n        // and metadata.\n        this._createSymbolsOf(staticSymbol.filePath);\n        result = ((this.resolvedSymbols.get(staticSymbol)));\n        return result;\n    };\n    /**\n     * getImportAs produces a symbol that can be used to import the given symbol.\n     * The import might be different than the symbol if the symbol is exported from\n     * a library with a summary; in which case we want to import the symbol from the\n     * ngfactory re-export instead of directly to avoid introducing a direct dependency\n     * on an otherwise indirect dependency.\n     *\n     * @param {?} staticSymbol the symbol for which to generate a import symbol\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.getImportAs = function (staticSymbol) {\n        if (staticSymbol.members.length) {\n            var /** @type {?} */ baseSymbol = this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name);\n            var /** @type {?} */ baseImportAs = this.getImportAs(baseSymbol);\n            return baseImportAs ?\n                this.getStaticSymbol(baseImportAs.filePath, baseImportAs.name, staticSymbol.members) :\n                null;\n        }\n        var /** @type {?} */ summarizedFileName = stripSummaryForJitFileSuffix(staticSymbol.filePath);\n        if (summarizedFileName !== staticSymbol.filePath) {\n            var /** @type {?} */ summarizedName = stripSummaryForJitNameSuffix(staticSymbol.name);\n            var /** @type {?} */ baseSymbol = this.getStaticSymbol(summarizedFileName, summarizedName, staticSymbol.members);\n            var /** @type {?} */ baseImportAs = this.getImportAs(baseSymbol);\n            return baseImportAs ?\n                this.getStaticSymbol(summaryForJitFileName(baseImportAs.filePath), summaryForJitName(baseImportAs.name), baseSymbol.members) :\n                null;\n        }\n        var /** @type {?} */ result = this.summaryResolver.getImportAs(staticSymbol);\n        if (!result) {\n            result = ((this.importAs.get(staticSymbol)));\n        }\n        return result;\n    };\n    /**\n     * getResourcePath produces the path to the original location of the symbol and should\n     * be used to determine the relative location of resource references recorded in\n     * symbol metadata.\n     * @param {?} staticSymbol\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.getResourcePath = function (staticSymbol) {\n        return this.symbolResourcePaths.get(staticSymbol) || staticSymbol.filePath;\n    };\n    /**\n     * getTypeArity returns the number of generic type parameters the given symbol\n     * has. If the symbol is not a type the result is null.\n     * @param {?} staticSymbol\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.getTypeArity = function (staticSymbol) {\n        // If the file is a factory/ngsummary file, don't resolve the symbol as doing so would\n        // cause the metadata for an factory/ngsummary file to be loaded which doesn't exist.\n        // All references to generated classes must include the correct arity whenever\n        // generating code.\n        if (isGeneratedFile(staticSymbol.filePath)) {\n            return null;\n        }\n        var /** @type {?} */ resolvedSymbol = this.resolveSymbol(staticSymbol);\n        while (resolvedSymbol && resolvedSymbol.metadata instanceof StaticSymbol) {\n            resolvedSymbol = this.resolveSymbol(resolvedSymbol.metadata);\n        }\n        return (resolvedSymbol && resolvedSymbol.metadata && resolvedSymbol.metadata.arity) || null;\n    };\n    /**\n     * Converts a file path to a module name that can be used as an `import`.\n     * @param {?} importedFilePath\n     * @param {?} containingFilePath\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.fileNameToModuleName = function (importedFilePath, containingFilePath) {\n        return this.knownFileNameToModuleNames.get(importedFilePath) ||\n            this.host.fileNameToModuleName(importedFilePath, containingFilePath);\n    };\n    /**\n     * @param {?} sourceSymbol\n     * @param {?} targetSymbol\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.recordImportAs = function (sourceSymbol, targetSymbol) {\n        sourceSymbol.assertNoMembers();\n        targetSymbol.assertNoMembers();\n        this.importAs.set(sourceSymbol, targetSymbol);\n    };\n    /**\n     * Invalidate all information derived from the given file.\n     *\n     * @param {?} fileName the file to invalidate\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.invalidateFile = function (fileName) {\n        this.metadataCache.delete(fileName);\n        this.resolvedFilePaths.delete(fileName);\n        var /** @type {?} */ symbols = this.symbolFromFile.get(fileName);\n        if (symbols) {\n            this.symbolFromFile.delete(fileName);\n            for (var _i = 0, symbols_1 = symbols; _i < symbols_1.length; _i++) {\n                var symbol = symbols_1[_i];\n                this.resolvedSymbols.delete(symbol);\n                this.importAs.delete(symbol);\n                this.symbolResourcePaths.delete(symbol);\n            }\n        }\n    };\n    /**\n     * @template T\n     * @param {?} cb\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.ignoreErrorsFor = function (cb) {\n        var /** @type {?} */ recorder = this.errorRecorder;\n        this.errorRecorder = function () { };\n        try {\n            return cb();\n        }\n        finally {\n            this.errorRecorder = recorder;\n        }\n    };\n    /**\n     * @param {?} staticSymbol\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype._resolveSymbolMembers = function (staticSymbol) {\n        var /** @type {?} */ members = staticSymbol.members;\n        var /** @type {?} */ baseResolvedSymbol = this.resolveSymbol(this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name));\n        if (!baseResolvedSymbol) {\n            return null;\n        }\n        var /** @type {?} */ baseMetadata = baseResolvedSymbol.metadata;\n        if (baseMetadata instanceof StaticSymbol) {\n            return new ResolvedStaticSymbol(staticSymbol, this.getStaticSymbol(baseMetadata.filePath, baseMetadata.name, members));\n        }\n        else if (baseMetadata && baseMetadata.__symbolic === 'class') {\n            if (baseMetadata.statics && members.length === 1) {\n                return new ResolvedStaticSymbol(staticSymbol, baseMetadata.statics[members[0]]);\n            }\n        }\n        else {\n            var /** @type {?} */ value = baseMetadata;\n            for (var /** @type {?} */ i = 0; i < members.length && value; i++) {\n                value = value[members[i]];\n            }\n            return new ResolvedStaticSymbol(staticSymbol, value);\n        }\n        return null;\n    };\n    /**\n     * @param {?} staticSymbol\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype._resolveSymbolFromSummary = function (staticSymbol) {\n        var /** @type {?} */ summary = this.summaryResolver.resolveSummary(staticSymbol);\n        return summary ? new ResolvedStaticSymbol(staticSymbol, summary.metadata) : null;\n    };\n    /**\n     * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.\n     * All types passed to the StaticResolver should be pseudo-types returned by this method.\n     *\n     * @param {?} declarationFile the absolute path of the file where the symbol is declared\n     * @param {?} name the name of the type.\n     * @param {?=} members a symbol for a static member of the named type\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.getStaticSymbol = function (declarationFile, name, members) {\n        return this.staticSymbolCache.get(declarationFile, name, members);\n    };\n    /**\n     * @param {?} filePath\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.getSymbolsOf = function (filePath) {\n        // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\n        // have summaries, only .d.ts files. So we always need to check both, the summary\n        // and metadata.\n        var /** @type {?} */ symbols = new Set(this.summaryResolver.getSymbolsOf(filePath));\n        this._createSymbolsOf(filePath);\n        this.resolvedSymbols.forEach(function (resolvedSymbol) {\n            if (resolvedSymbol.symbol.filePath === filePath) {\n                symbols.add(resolvedSymbol.symbol);\n            }\n        });\n        return Array.from(symbols);\n    };\n    /**\n     * @param {?} filePath\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype._createSymbolsOf = function (filePath) {\n        var _this = this;\n        if (this.resolvedFilePaths.has(filePath)) {\n            return;\n        }\n        this.resolvedFilePaths.add(filePath);\n        var /** @type {?} */ resolvedSymbols = [];\n        var /** @type {?} */ metadata = this.getModuleMetadata(filePath);\n        if (metadata['importAs']) {\n            // Index bundle indices should use the importAs module name defined\n            // in the bundle.\n            this.knownFileNameToModuleNames.set(filePath, metadata['importAs']);\n        }\n        if (metadata['metadata']) {\n            // handle direct declarations of the symbol\n            var /** @type {?} */ topLevelSymbolNames_1 = new Set(Object.keys(metadata['metadata']).map(unescapeIdentifier));\n            var /** @type {?} */ origins_1 = metadata['origins'] || {};\n            Object.keys(metadata['metadata']).forEach(function (metadataKey) {\n                var /** @type {?} */ symbolMeta = metadata['metadata'][metadataKey];\n                var /** @type {?} */ name = unescapeIdentifier(metadataKey);\n                var /** @type {?} */ symbol = _this.getStaticSymbol(filePath, name);\n                var /** @type {?} */ origin = origins_1.hasOwnProperty(metadataKey) && origins_1[metadataKey];\n                if (origin) {\n                    // If the symbol is from a bundled index, use the declaration location of the\n                    // symbol so relative references (such as './my.html') will be calculated\n                    // correctly.\n                    var /** @type {?} */ originFilePath = _this.resolveModule(origin, filePath);\n                    if (!originFilePath) {\n                        _this.reportError(new Error(\"Couldn't resolve original symbol for \" + origin + \" from \" + filePath));\n                    }\n                    else {\n                        _this.symbolResourcePaths.set(symbol, originFilePath);\n                    }\n                }\n                resolvedSymbols.push(_this.createResolvedSymbol(symbol, filePath, topLevelSymbolNames_1, symbolMeta));\n            });\n        }\n        // handle the symbols in one of the re-export location\n        if (metadata['exports']) {\n            var _loop_1 = function (moduleExport) {\n                // handle the symbols in the list of explicitly re-exported symbols.\n                if (moduleExport.export) {\n                    moduleExport.export.forEach(function (exportSymbol) {\n                        var /** @type {?} */ symbolName;\n                        if (typeof exportSymbol === 'string') {\n                            symbolName = exportSymbol;\n                        }\n                        else {\n                            symbolName = exportSymbol.as;\n                        }\n                        symbolName = unescapeIdentifier(symbolName);\n                        var /** @type {?} */ symName = symbolName;\n                        if (typeof exportSymbol !== 'string') {\n                            symName = unescapeIdentifier(exportSymbol.name);\n                        }\n                        var /** @type {?} */ resolvedModule = _this.resolveModule(moduleExport.from, filePath);\n                        if (resolvedModule) {\n                            var /** @type {?} */ targetSymbol = _this.getStaticSymbol(resolvedModule, symName);\n                            var /** @type {?} */ sourceSymbol = _this.getStaticSymbol(filePath, symbolName);\n                            resolvedSymbols.push(_this.createExport(sourceSymbol, targetSymbol));\n                        }\n                    });\n                }\n                else {\n                    // handle the symbols via export * directives.\n                    var /** @type {?} */ resolvedModule = this_1.resolveModule(moduleExport.from, filePath);\n                    if (resolvedModule) {\n                        var /** @type {?} */ nestedExports = this_1.getSymbolsOf(resolvedModule);\n                        nestedExports.forEach(function (targetSymbol) {\n                            var /** @type {?} */ sourceSymbol = _this.getStaticSymbol(filePath, targetSymbol.name);\n                            resolvedSymbols.push(_this.createExport(sourceSymbol, targetSymbol));\n                        });\n                    }\n                }\n            };\n            var this_1 = this;\n            for (var _i = 0, _a = metadata['exports']; _i < _a.length; _i++) {\n                var moduleExport = _a[_i];\n                _loop_1(/** @type {?} */ moduleExport);\n            }\n        }\n        resolvedSymbols.forEach(function (resolvedSymbol) { return _this.resolvedSymbols.set(resolvedSymbol.symbol, resolvedSymbol); });\n        this.symbolFromFile.set(filePath, resolvedSymbols.map(function (resolvedSymbol) { return resolvedSymbol.symbol; }));\n    };\n    /**\n     * @param {?} sourceSymbol\n     * @param {?} topLevelPath\n     * @param {?} topLevelSymbolNames\n     * @param {?} metadata\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.createResolvedSymbol = function (sourceSymbol, topLevelPath, topLevelSymbolNames, metadata) {\n        // For classes that don't have Angular summaries / metadata,\n        // we only keep their arity, but nothing else\n        // (e.g. their constructor parameters).\n        // We do this to prevent introducing deep imports\n        // as we didn't generate .ngfactory.ts files with proper reexports.\n        if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath) && metadata &&\n            metadata['__symbolic'] === 'class') {\n            var /** @type {?} */ transformedMeta_1 = { __symbolic: 'class', arity: metadata.arity };\n            return new ResolvedStaticSymbol(sourceSymbol, transformedMeta_1);\n        }\n        var /** @type {?} */ self = this;\n        var ReferenceTransformer = (function (_super) {\n            __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](ReferenceTransformer, _super);\n            function ReferenceTransformer() {\n                return _super !== null && _super.apply(this, arguments) || this;\n            }\n            /**\n             * @param {?} map\n             * @param {?} functionParams\n             * @return {?}\n             */\n            ReferenceTransformer.prototype.visitStringMap = function (map, functionParams) {\n                var /** @type {?} */ symbolic = map['__symbolic'];\n                if (symbolic === 'function') {\n                    var /** @type {?} */ oldLen = functionParams.length;\n                    functionParams.push.apply(functionParams, (map['parameters'] || []));\n                    var /** @type {?} */ result = _super.prototype.visitStringMap.call(this, map, functionParams);\n                    functionParams.length = oldLen;\n                    return result;\n                }\n                else if (symbolic === 'reference') {\n                    var /** @type {?} */ module_1 = map['module'];\n                    var /** @type {?} */ name = map['name'] ? unescapeIdentifier(map['name']) : map['name'];\n                    if (!name) {\n                        return null;\n                    }\n                    var /** @type {?} */ filePath = void 0;\n                    if (module_1) {\n                        filePath = ((self.resolveModule(module_1, sourceSymbol.filePath)));\n                        if (!filePath) {\n                            return {\n                                __symbolic: 'error',\n                                message: \"Could not resolve \" + module_1 + \" relative to \" + sourceSymbol.filePath + \".\"\n                            };\n                        }\n                        return self.getStaticSymbol(filePath, name);\n                    }\n                    else if (functionParams.indexOf(name) >= 0) {\n                        // reference to a function parameter\n                        return { __symbolic: 'reference', name: name };\n                    }\n                    else {\n                        if (topLevelSymbolNames.has(name)) {\n                            return self.getStaticSymbol(topLevelPath, name);\n                        }\n                        // ambient value\n                        null;\n                    }\n                }\n                else {\n                    return _super.prototype.visitStringMap.call(this, map, functionParams);\n                }\n            };\n            return ReferenceTransformer;\n        }(ValueTransformer));\n        var /** @type {?} */ transformedMeta = visitValue(metadata, new ReferenceTransformer(), []);\n        if (transformedMeta instanceof StaticSymbol) {\n            return this.createExport(sourceSymbol, transformedMeta);\n        }\n        return new ResolvedStaticSymbol(sourceSymbol, transformedMeta);\n    };\n    /**\n     * @param {?} sourceSymbol\n     * @param {?} targetSymbol\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.createExport = function (sourceSymbol, targetSymbol) {\n        sourceSymbol.assertNoMembers();\n        targetSymbol.assertNoMembers();\n        if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath)) {\n            // This case is for an ng library importing symbols from a plain ts library\n            // transitively.\n            // Note: We rely on the fact that we discover symbols in the direction\n            // from source files to library files\n            this.importAs.set(targetSymbol, this.getImportAs(sourceSymbol) || sourceSymbol);\n        }\n        return new ResolvedStaticSymbol(sourceSymbol, targetSymbol);\n    };\n    /**\n     * @param {?} error\n     * @param {?=} context\n     * @param {?=} path\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.reportError = function (error, context, path) {\n        if (this.errorRecorder) {\n            this.errorRecorder(error, (context && context.filePath) || path);\n        }\n        else {\n            throw error;\n        }\n    };\n    /**\n     * @param {?} module an absolute path to a module file.\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.getModuleMetadata = function (module) {\n        var /** @type {?} */ moduleMetadata = this.metadataCache.get(module);\n        if (!moduleMetadata) {\n            var /** @type {?} */ moduleMetadatas = this.host.getMetadataFor(module);\n            if (moduleMetadatas) {\n                var /** @type {?} */ maxVersion_1 = -1;\n                moduleMetadatas.forEach(function (md) {\n                    if (md['version'] > maxVersion_1) {\n                        maxVersion_1 = md['version'];\n                        moduleMetadata = md;\n                    }\n                });\n            }\n            if (!moduleMetadata) {\n                moduleMetadata =\n                    { __symbolic: 'module', version: SUPPORTED_SCHEMA_VERSION, module: module, metadata: {} };\n            }\n            if (moduleMetadata['version'] != SUPPORTED_SCHEMA_VERSION) {\n                var /** @type {?} */ errorMessage = moduleMetadata['version'] == 2 ?\n                    \"Unsupported metadata version \" + moduleMetadata['version'] + \" for module \" + module + \". This module should be compiled with a newer version of ngc\" :\n                    \"Metadata version mismatch for module \" + module + \", found version \" + moduleMetadata['version'] + \", expected \" + SUPPORTED_SCHEMA_VERSION;\n                this.reportError(new Error(errorMessage));\n            }\n            this.metadataCache.set(module, moduleMetadata);\n        }\n        return moduleMetadata;\n    };\n    /**\n     * @param {?} module\n     * @param {?} symbolName\n     * @param {?=} containingFile\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.getSymbolByModule = function (module, symbolName, containingFile) {\n        var /** @type {?} */ filePath = this.resolveModule(module, containingFile);\n        if (!filePath) {\n            this.reportError(new Error(\"Could not resolve module \" + module + (containingFile ? \" relative to $ {\\n            containingFile\\n          } \" : '')));\n            return this.getStaticSymbol(\"ERROR:\" + module, symbolName);\n        }\n        return this.getStaticSymbol(filePath, symbolName);\n    };\n    /**\n     * @param {?} module\n     * @param {?=} containingFile\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.resolveModule = function (module, containingFile) {\n        try {\n            return this.host.moduleNameToFileName(module, containingFile);\n        }\n        catch (e) {\n            console.error(\"Could not resolve module '\" + module + \"' relative to file \" + containingFile);\n            this.reportError(e, undefined, containingFile);\n        }\n        return null;\n    };\n    return StaticSymbolResolver;\n}());\n/**\n * @param {?} identifier\n * @return {?}\n */\nfunction unescapeIdentifier(identifier) {\n    return identifier.startsWith('___') ? identifier.substr(1) : identifier;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar AotSummaryResolver = (function () {\n    /**\n     * @param {?} host\n     * @param {?} staticSymbolCache\n     */\n    function AotSummaryResolver(host, staticSymbolCache) {\n        this.host = host;\n        this.staticSymbolCache = staticSymbolCache;\n        this.summaryCache = new Map();\n        this.loadedFilePaths = new Set();\n        this.importAs = new Map();\n    }\n    /**\n     * @param {?} filePath\n     * @return {?}\n     */\n    AotSummaryResolver.prototype.isLibraryFile = function (filePath) {\n        // Note: We need to strip the .ngfactory. file path,\n        // so this method also works for generated files\n        // (for which host.isSourceFile will always return false).\n        return !this.host.isSourceFile(stripGeneratedFileSuffix(filePath));\n    };\n    /**\n     * @param {?} filePath\n     * @return {?}\n     */\n    AotSummaryResolver.prototype.getLibraryFileName = function (filePath) { return this.host.getOutputFileName(filePath); };\n    /**\n     * @param {?} staticSymbol\n     * @return {?}\n     */\n    AotSummaryResolver.prototype.resolveSummary = function (staticSymbol) {\n        staticSymbol.assertNoMembers();\n        var /** @type {?} */ summary = this.summaryCache.get(staticSymbol);\n        if (!summary) {\n            this._loadSummaryFile(staticSymbol.filePath);\n            summary = ((this.summaryCache.get(staticSymbol)));\n        }\n        return summary;\n    };\n    /**\n     * @param {?} filePath\n     * @return {?}\n     */\n    AotSummaryResolver.prototype.getSymbolsOf = function (filePath) {\n        this._loadSummaryFile(filePath);\n        return Array.from(this.summaryCache.keys()).filter(function (symbol) { return symbol.filePath === filePath; });\n    };\n    /**\n     * @param {?} staticSymbol\n     * @return {?}\n     */\n    AotSummaryResolver.prototype.getImportAs = function (staticSymbol) {\n        staticSymbol.assertNoMembers();\n        return ((this.importAs.get(staticSymbol)));\n    };\n    /**\n     * @param {?} summary\n     * @return {?}\n     */\n    AotSummaryResolver.prototype.addSummary = function (summary) { this.summaryCache.set(summary.symbol, summary); };\n    /**\n     * @param {?} filePath\n     * @return {?}\n     */\n    AotSummaryResolver.prototype._loadSummaryFile = function (filePath) {\n        var _this = this;\n        if (this.loadedFilePaths.has(filePath)) {\n            return;\n        }\n        this.loadedFilePaths.add(filePath);\n        if (this.isLibraryFile(filePath)) {\n            var /** @type {?} */ summaryFilePath = summaryFileName(filePath);\n            var /** @type {?} */ json = void 0;\n            try {\n                json = this.host.loadSummary(summaryFilePath);\n            }\n            catch (e) {\n                console.error(\"Error loading summary file \" + summaryFilePath);\n                throw e;\n            }\n            if (json) {\n                var _a = deserializeSummaries(this.staticSymbolCache, json), summaries = _a.summaries, importAs = _a.importAs;\n                summaries.forEach(function (summary) { return _this.summaryCache.set(summary.symbol, summary); });\n                importAs.forEach(function (importAs) {\n                    _this.importAs.set(importAs.symbol, _this.staticSymbolCache.get(ngfactoryFilePath(filePath), importAs.importAs));\n                });\n            }\n        }\n    };\n    return AotSummaryResolver;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Creates a new AotCompiler based on options and a host.\n * @param {?} compilerHost\n * @param {?} options\n * @return {?}\n */\nfunction createAotCompiler(compilerHost, options) {\n    var /** @type {?} */ translations = options.translations || '';\n    var /** @type {?} */ urlResolver = createOfflineCompileUrlResolver();\n    var /** @type {?} */ symbolCache = new StaticSymbolCache();\n    var /** @type {?} */ summaryResolver = new AotSummaryResolver(compilerHost, symbolCache);\n    var /** @type {?} */ symbolResolver = new StaticSymbolResolver(compilerHost, symbolCache, summaryResolver);\n    var /** @type {?} */ staticReflector = new StaticReflector(summaryResolver, symbolResolver);\n    var /** @type {?} */ console = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Console\"]();\n    var /** @type {?} */ htmlParser = new I18NHtmlParser(new HtmlParser(), translations, options.i18nFormat, options.missingTranslation, console);\n    var /** @type {?} */ config = new CompilerConfig({\n        defaultEncapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].Emulated,\n        useJit: false,\n        enableLegacyTemplate: options.enableLegacyTemplate !== false,\n        missingTranslation: options.missingTranslation,\n    });\n    var /** @type {?} */ normalizer = new DirectiveNormalizer({ get: function (url) { return compilerHost.loadResource(url); } }, urlResolver, htmlParser, config);\n    var /** @type {?} */ expressionParser = new Parser(new Lexer());\n    var /** @type {?} */ elementSchemaRegistry = new DomElementSchemaRegistry();\n    var /** @type {?} */ tmplParser = new TemplateParser(config, staticReflector, expressionParser, elementSchemaRegistry, htmlParser, console, []);\n    var /** @type {?} */ resolver = new CompileMetadataResolver(config, new NgModuleResolver(staticReflector), new DirectiveResolver(staticReflector), new PipeResolver(staticReflector), summaryResolver, elementSchemaRegistry, normalizer, console, symbolCache, staticReflector);\n    // TODO(vicb): do not pass options.i18nFormat here\n    var /** @type {?} */ viewCompiler = new ViewCompiler(config, staticReflector, elementSchemaRegistry);\n    var /** @type {?} */ compiler = new AotCompiler(config, compilerHost, staticReflector, resolver, tmplParser, new StyleCompiler(urlResolver), viewCompiler, new NgModuleCompiler(staticReflector), new TypeScriptEmitter(), summaryResolver, options.locale || null, options.i18nFormat || null, options.enableSummariesForJit || null, symbolResolver);\n    return { compiler: compiler, reflector: staticReflector };\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} statements\n * @return {?}\n */\nfunction interpretStatements(statements) {\n    var /** @type {?} */ ctx = new _ExecutionContext(null, null, null, new Map());\n    var /** @type {?} */ visitor = new StatementInterpreter();\n    visitor.visitAllStatements(statements, ctx);\n    var /** @type {?} */ result = {};\n    ctx.exports.forEach(function (exportName) { result[exportName] = ctx.vars.get(exportName); });\n    return result;\n}\n/**\n * @param {?} varNames\n * @param {?} varValues\n * @param {?} statements\n * @param {?} ctx\n * @param {?} visitor\n * @return {?}\n */\nfunction _executeFunctionStatements(varNames, varValues, statements, ctx, visitor) {\n    var /** @type {?} */ childCtx = ctx.createChildWihtLocalVars();\n    for (var /** @type {?} */ i = 0; i < varNames.length; i++) {\n        childCtx.vars.set(varNames[i], varValues[i]);\n    }\n    var /** @type {?} */ result = visitor.visitAllStatements(statements, childCtx);\n    return result ? result.value : null;\n}\nvar _ExecutionContext = (function () {\n    /**\n     * @param {?} parent\n     * @param {?} instance\n     * @param {?} className\n     * @param {?} vars\n     */\n    function _ExecutionContext(parent, instance, className, vars) {\n        this.parent = parent;\n        this.instance = instance;\n        this.className = className;\n        this.vars = vars;\n        this.exports = [];\n    }\n    /**\n     * @return {?}\n     */\n    _ExecutionContext.prototype.createChildWihtLocalVars = function () {\n        return new _ExecutionContext(this, this.instance, this.className, new Map());\n    };\n    return _ExecutionContext;\n}());\nvar ReturnValue = (function () {\n    /**\n     * @param {?} value\n     */\n    function ReturnValue(value) {\n        this.value = value;\n    }\n    return ReturnValue;\n}());\n/**\n * @param {?} _classStmt\n * @param {?} _ctx\n * @param {?} _visitor\n * @return {?}\n */\nfunction createDynamicClass(_classStmt, _ctx, _visitor) {\n    var /** @type {?} */ propertyDescriptors = {};\n    _classStmt.getters.forEach(function (getter) {\n        // Note: use `function` instead of arrow function to capture `this`\n        propertyDescriptors[getter.name] = {\n            configurable: false,\n            get: function () {\n                var /** @type {?} */ instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\n                return _executeFunctionStatements([], [], getter.body, instanceCtx, _visitor);\n            }\n        };\n    });\n    _classStmt.methods.forEach(function (method) {\n        var /** @type {?} */ paramNames = method.params.map(function (param) { return param.name; });\n        // Note: use `function` instead of arrow function to capture `this`\n        propertyDescriptors[((method.name))] = {\n            writable: false,\n            configurable: false,\n            value: function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                var /** @type {?} */ instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\n                return _executeFunctionStatements(paramNames, args, method.body, instanceCtx, _visitor);\n            }\n        };\n    });\n    var /** @type {?} */ ctorParamNames = _classStmt.constructorMethod.params.map(function (param) { return param.name; });\n    // Note: use `function` instead of arrow function to capture `this`\n    var /** @type {?} */ ctor = function () {\n        var _this = this;\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var /** @type {?} */ instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\n        _classStmt.fields.forEach(function (field) { _this[field.name] = undefined; });\n        _executeFunctionStatements(ctorParamNames, args, _classStmt.constructorMethod.body, instanceCtx, _visitor);\n    };\n    var /** @type {?} */ superClass = _classStmt.parent ? _classStmt.parent.visitExpression(_visitor, _ctx) : Object;\n    ctor.prototype = Object.create(superClass.prototype, propertyDescriptors);\n    return ctor;\n}\nvar StatementInterpreter = (function () {\n    function StatementInterpreter() {\n    }\n    /**\n     * @param {?} ast\n     * @return {?}\n     */\n    StatementInterpreter.prototype.debugAst = function (ast) { return debugOutputAstAsTypeScript(ast); };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitDeclareVarStmt = function (stmt, ctx) {\n        ctx.vars.set(stmt.name, stmt.value.visitExpression(this, ctx));\n        if (stmt.hasModifier(StmtModifier.Exported)) {\n            ctx.exports.push(stmt.name);\n        }\n        return null;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitWriteVarExpr = function (expr, ctx) {\n        var /** @type {?} */ value = expr.value.visitExpression(this, ctx);\n        var /** @type {?} */ currCtx = ctx;\n        while (currCtx != null) {\n            if (currCtx.vars.has(expr.name)) {\n                currCtx.vars.set(expr.name, value);\n                return value;\n            }\n            currCtx = ((currCtx.parent));\n        }\n        throw new Error(\"Not declared variable \" + expr.name);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitReadVarExpr = function (ast, ctx) {\n        var /** @type {?} */ varName = ((ast.name));\n        if (ast.builtin != null) {\n            switch (ast.builtin) {\n                case BuiltinVar.Super:\n                    return ctx.instance.__proto__;\n                case BuiltinVar.This:\n                    return ctx.instance;\n                case BuiltinVar.CatchError:\n                    varName = CATCH_ERROR_VAR$2;\n                    break;\n                case BuiltinVar.CatchStack:\n                    varName = CATCH_STACK_VAR$2;\n                    break;\n                default:\n                    throw new Error(\"Unknown builtin variable \" + ast.builtin);\n            }\n        }\n        var /** @type {?} */ currCtx = ctx;\n        while (currCtx != null) {\n            if (currCtx.vars.has(varName)) {\n                return currCtx.vars.get(varName);\n            }\n            currCtx = ((currCtx.parent));\n        }\n        throw new Error(\"Not declared variable \" + varName);\n    };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitWriteKeyExpr = function (expr, ctx) {\n        var /** @type {?} */ receiver = expr.receiver.visitExpression(this, ctx);\n        var /** @type {?} */ index = expr.index.visitExpression(this, ctx);\n        var /** @type {?} */ value = expr.value.visitExpression(this, ctx);\n        receiver[index] = value;\n        return value;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitWritePropExpr = function (expr, ctx) {\n        var /** @type {?} */ receiver = expr.receiver.visitExpression(this, ctx);\n        var /** @type {?} */ value = expr.value.visitExpression(this, ctx);\n        receiver[expr.name] = value;\n        return value;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitInvokeMethodExpr = function (expr, ctx) {\n        var /** @type {?} */ receiver = expr.receiver.visitExpression(this, ctx);\n        var /** @type {?} */ args = this.visitAllExpressions(expr.args, ctx);\n        var /** @type {?} */ result;\n        if (expr.builtin != null) {\n            switch (expr.builtin) {\n                case BuiltinMethod.ConcatArray:\n                    result = receiver.concat.apply(receiver, args);\n                    break;\n                case BuiltinMethod.SubscribeObservable:\n                    result = receiver.subscribe({ next: args[0] });\n                    break;\n                case BuiltinMethod.Bind:\n                    result = receiver.bind.apply(receiver, args);\n                    break;\n                default:\n                    throw new Error(\"Unknown builtin method \" + expr.builtin);\n            }\n        }\n        else {\n            result = receiver[((expr.name))].apply(receiver, args);\n        }\n        return result;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitInvokeFunctionExpr = function (stmt, ctx) {\n        var /** @type {?} */ args = this.visitAllExpressions(stmt.args, ctx);\n        var /** @type {?} */ fnExpr = stmt.fn;\n        if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {\n            ctx.instance.constructor.prototype.constructor.apply(ctx.instance, args);\n            return null;\n        }\n        else {\n            var /** @type {?} */ fn$$1 = stmt.fn.visitExpression(this, ctx);\n            return fn$$1.apply(null, args);\n        }\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitReturnStmt = function (stmt, ctx) {\n        return new ReturnValue(stmt.value.visitExpression(this, ctx));\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitDeclareClassStmt = function (stmt, ctx) {\n        var /** @type {?} */ clazz = createDynamicClass(stmt, ctx, this);\n        ctx.vars.set(stmt.name, clazz);\n        if (stmt.hasModifier(StmtModifier.Exported)) {\n            ctx.exports.push(stmt.name);\n        }\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitExpressionStmt = function (stmt, ctx) {\n        return stmt.expr.visitExpression(this, ctx);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitIfStmt = function (stmt, ctx) {\n        var /** @type {?} */ condition = stmt.condition.visitExpression(this, ctx);\n        if (condition) {\n            return this.visitAllStatements(stmt.trueCase, ctx);\n        }\n        else if (stmt.falseCase != null) {\n            return this.visitAllStatements(stmt.falseCase, ctx);\n        }\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitTryCatchStmt = function (stmt, ctx) {\n        try {\n            return this.visitAllStatements(stmt.bodyStmts, ctx);\n        }\n        catch (e) {\n            var /** @type {?} */ childCtx = ctx.createChildWihtLocalVars();\n            childCtx.vars.set(CATCH_ERROR_VAR$2, e);\n            childCtx.vars.set(CATCH_STACK_VAR$2, e.stack);\n            return this.visitAllStatements(stmt.catchStmts, childCtx);\n        }\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitThrowStmt = function (stmt, ctx) {\n        throw stmt.error.visitExpression(this, ctx);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?=} context\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitCommentStmt = function (stmt, context) { return null; };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitInstantiateExpr = function (ast, ctx) {\n        var /** @type {?} */ args = this.visitAllExpressions(ast.args, ctx);\n        var /** @type {?} */ clazz = ast.classExpr.visitExpression(this, ctx);\n        return new (clazz.bind.apply(clazz, [void 0].concat(args)))();\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitLiteralExpr = function (ast, ctx) { return ast.value; };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitExternalExpr = function (ast, ctx) { return ast.value.runtime; };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitConditionalExpr = function (ast, ctx) {\n        if (ast.condition.visitExpression(this, ctx)) {\n            return ast.trueCase.visitExpression(this, ctx);\n        }\n        else if (ast.falseCase != null) {\n            return ast.falseCase.visitExpression(this, ctx);\n        }\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitNotExpr = function (ast, ctx) {\n        return !ast.condition.visitExpression(this, ctx);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitAssertNotNullExpr = function (ast, ctx) {\n        return ast.condition.visitExpression(this, ctx);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitCastExpr = function (ast, ctx) {\n        return ast.value.visitExpression(this, ctx);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitFunctionExpr = function (ast, ctx) {\n        var /** @type {?} */ paramNames = ast.params.map(function (param) { return param.name; });\n        return _declareFn(paramNames, ast.statements, ctx, this);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {\n        var /** @type {?} */ paramNames = stmt.params.map(function (param) { return param.name; });\n        ctx.vars.set(stmt.name, _declareFn(paramNames, stmt.statements, ctx, this));\n        if (stmt.hasModifier(StmtModifier.Exported)) {\n            ctx.exports.push(stmt.name);\n        }\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitBinaryOperatorExpr = function (ast, ctx) {\n        var _this = this;\n        var /** @type {?} */ lhs = function () { return ast.lhs.visitExpression(_this, ctx); };\n        var /** @type {?} */ rhs = function () { return ast.rhs.visitExpression(_this, ctx); };\n        switch (ast.operator) {\n            case BinaryOperator.Equals:\n                return lhs() == rhs();\n            case BinaryOperator.Identical:\n                return lhs() === rhs();\n            case BinaryOperator.NotEquals:\n                return lhs() != rhs();\n            case BinaryOperator.NotIdentical:\n                return lhs() !== rhs();\n            case BinaryOperator.And:\n                return lhs() && rhs();\n            case BinaryOperator.Or:\n                return lhs() || rhs();\n            case BinaryOperator.Plus:\n                return lhs() + rhs();\n            case BinaryOperator.Minus:\n                return lhs() - rhs();\n            case BinaryOperator.Divide:\n                return lhs() / rhs();\n            case BinaryOperator.Multiply:\n                return lhs() * rhs();\n            case BinaryOperator.Modulo:\n                return lhs() % rhs();\n            case BinaryOperator.Lower:\n                return lhs() < rhs();\n            case BinaryOperator.LowerEquals:\n                return lhs() <= rhs();\n            case BinaryOperator.Bigger:\n                return lhs() > rhs();\n            case BinaryOperator.BiggerEquals:\n                return lhs() >= rhs();\n            default:\n                throw new Error(\"Unknown operator \" + ast.operator);\n        }\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitReadPropExpr = function (ast, ctx) {\n        var /** @type {?} */ result;\n        var /** @type {?} */ receiver = ast.receiver.visitExpression(this, ctx);\n        result = receiver[ast.name];\n        return result;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitReadKeyExpr = function (ast, ctx) {\n        var /** @type {?} */ receiver = ast.receiver.visitExpression(this, ctx);\n        var /** @type {?} */ prop = ast.index.visitExpression(this, ctx);\n        return receiver[prop];\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitLiteralArrayExpr = function (ast, ctx) {\n        return this.visitAllExpressions(ast.entries, ctx);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitLiteralMapExpr = function (ast, ctx) {\n        var _this = this;\n        var /** @type {?} */ result = {};\n        ast.entries.forEach(function (entry) { return result[entry.key] = entry.value.visitExpression(_this, ctx); });\n        return result;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitCommaExpr = function (ast, context) {\n        var /** @type {?} */ values = this.visitAllExpressions(ast.parts, context);\n        return values[values.length - 1];\n    };\n    /**\n     * @param {?} expressions\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitAllExpressions = function (expressions, ctx) {\n        var _this = this;\n        return expressions.map(function (expr) { return expr.visitExpression(_this, ctx); });\n    };\n    /**\n     * @param {?} statements\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitAllStatements = function (statements, ctx) {\n        for (var /** @type {?} */ i = 0; i < statements.length; i++) {\n            var /** @type {?} */ stmt = statements[i];\n            var /** @type {?} */ val = stmt.visitStatement(this, ctx);\n            if (val instanceof ReturnValue) {\n                return val;\n            }\n        }\n        return null;\n    };\n    return StatementInterpreter;\n}());\n/**\n * @param {?} varNames\n * @param {?} statements\n * @param {?} ctx\n * @param {?} visitor\n * @return {?}\n */\nfunction _declareFn(varNames, statements, ctx, visitor) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return _executeFunctionStatements(varNames, args, statements, ctx, visitor);\n    };\n}\nvar CATCH_ERROR_VAR$2 = 'error';\nvar CATCH_STACK_VAR$2 = 'stack';\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @abstract\n */\nvar AbstractJsEmitterVisitor = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](AbstractJsEmitterVisitor, _super);\n    function AbstractJsEmitterVisitor() {\n        return _super.call(this, false) || this;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype.visitDeclareClassStmt = function (stmt, ctx) {\n        var _this = this;\n        ctx.pushClass(stmt);\n        this._visitClassConstructor(stmt, ctx);\n        if (stmt.parent != null) {\n            ctx.print(stmt, stmt.name + \".prototype = Object.create(\");\n            stmt.parent.visitExpression(this, ctx);\n            ctx.println(stmt, \".prototype);\");\n        }\n        stmt.getters.forEach(function (getter) { return _this._visitClassGetter(stmt, getter, ctx); });\n        stmt.methods.forEach(function (method) { return _this._visitClassMethod(stmt, method, ctx); });\n        ctx.popClass();\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype._visitClassConstructor = function (stmt, ctx) {\n        ctx.print(stmt, \"function \" + stmt.name + \"(\");\n        if (stmt.constructorMethod != null) {\n            this._visitParams(stmt.constructorMethod.params, ctx);\n        }\n        ctx.println(stmt, \") {\");\n        ctx.incIndent();\n        if (stmt.constructorMethod != null) {\n            if (stmt.constructorMethod.body.length > 0) {\n                ctx.println(stmt, \"var self = this;\");\n                this.visitAllStatements(stmt.constructorMethod.body, ctx);\n            }\n        }\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} getter\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype._visitClassGetter = function (stmt, getter, ctx) {\n        ctx.println(stmt, \"Object.defineProperty(\" + stmt.name + \".prototype, '\" + getter.name + \"', { get: function() {\");\n        ctx.incIndent();\n        if (getter.body.length > 0) {\n            ctx.println(stmt, \"var self = this;\");\n            this.visitAllStatements(getter.body, ctx);\n        }\n        ctx.decIndent();\n        ctx.println(stmt, \"}});\");\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} method\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype._visitClassMethod = function (stmt, method, ctx) {\n        ctx.print(stmt, stmt.name + \".prototype.\" + method.name + \" = function(\");\n        this._visitParams(method.params, ctx);\n        ctx.println(stmt, \") {\");\n        ctx.incIndent();\n        if (method.body.length > 0) {\n            ctx.println(stmt, \"var self = this;\");\n            this.visitAllStatements(method.body, ctx);\n        }\n        ctx.decIndent();\n        ctx.println(stmt, \"};\");\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype.visitReadVarExpr = function (ast, ctx) {\n        if (ast.builtin === BuiltinVar.This) {\n            ctx.print(ast, 'self');\n        }\n        else if (ast.builtin === BuiltinVar.Super) {\n            throw new Error(\"'super' needs to be handled at a parent ast node, not at the variable level!\");\n        }\n        else {\n            _super.prototype.visitReadVarExpr.call(this, ast, ctx);\n        }\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype.visitDeclareVarStmt = function (stmt, ctx) {\n        ctx.print(stmt, \"var \" + stmt.name + \" = \");\n        stmt.value.visitExpression(this, ctx);\n        ctx.println(stmt, \";\");\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype.visitCastExpr = function (ast, ctx) {\n        ast.value.visitExpression(this, ctx);\n        return null;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype.visitInvokeFunctionExpr = function (expr, ctx) {\n        var /** @type {?} */ fnExpr = expr.fn;\n        if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {\n            ((((ctx.currentClass)).parent)).visitExpression(this, ctx);\n            ctx.print(expr, \".call(this\");\n            if (expr.args.length > 0) {\n                ctx.print(expr, \", \");\n                this.visitAllExpressions(expr.args, ctx, ',');\n            }\n            ctx.print(expr, \")\");\n        }\n        else {\n            _super.prototype.visitInvokeFunctionExpr.call(this, expr, ctx);\n        }\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype.visitFunctionExpr = function (ast, ctx) {\n        ctx.print(ast, \"function(\");\n        this._visitParams(ast.params, ctx);\n        ctx.println(ast, \") {\");\n        ctx.incIndent();\n        this.visitAllStatements(ast.statements, ctx);\n        ctx.decIndent();\n        ctx.print(ast, \"}\");\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {\n        ctx.print(stmt, \"function \" + stmt.name + \"(\");\n        this._visitParams(stmt.params, ctx);\n        ctx.println(stmt, \") {\");\n        ctx.incIndent();\n        this.visitAllStatements(stmt.statements, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype.visitTryCatchStmt = function (stmt, ctx) {\n        ctx.println(stmt, \"try {\");\n        ctx.incIndent();\n        this.visitAllStatements(stmt.bodyStmts, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"} catch (\" + CATCH_ERROR_VAR$1.name + \") {\");\n        ctx.incIndent();\n        var /** @type {?} */ catchStmts = [/** @type {?} */ (CATCH_STACK_VAR$1.set(CATCH_ERROR_VAR$1.prop('stack')).toDeclStmt(null, [\n                StmtModifier.Final\n            ]))].concat(stmt.catchStmts);\n        this.visitAllStatements(catchStmts, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n        return null;\n    };\n    /**\n     * @param {?} params\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype._visitParams = function (params, ctx) {\n        this.visitAllObjects(function (param) { return ctx.print(null, param.name); }, params, ctx, ',');\n    };\n    /**\n     * @param {?} method\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype.getBuiltinMethodName = function (method) {\n        var /** @type {?} */ name;\n        switch (method) {\n            case BuiltinMethod.ConcatArray:\n                name = 'concat';\n                break;\n            case BuiltinMethod.SubscribeObservable:\n                name = 'subscribe';\n                break;\n            case BuiltinMethod.Bind:\n                name = 'bind';\n                break;\n            default:\n                throw new Error(\"Unknown builtin method: \" + method);\n        }\n        return name;\n    };\n    return AbstractJsEmitterVisitor;\n}(AbstractEmitterVisitor));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} sourceUrl\n * @param {?} ctx\n * @param {?} vars\n * @return {?}\n */\nfunction evalExpression(sourceUrl$$1, ctx, vars) {\n    var /** @type {?} */ fnBody = ctx.toSource() + \"\\n//# sourceURL=\" + sourceUrl$$1;\n    var /** @type {?} */ fnArgNames = [];\n    var /** @type {?} */ fnArgValues = [];\n    for (var /** @type {?} */ argName in vars) {\n        fnArgNames.push(argName);\n        fnArgValues.push(vars[argName]);\n    }\n    if (Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"isDevMode\"])()) {\n        // using `new Function(...)` generates a header, 1 line of no arguments, 2 lines otherwise\n        // E.g. ```\n        // function anonymous(a,b,c\n        // /**/) { ... }```\n        // We don't want to hard code this fact, so we auto detect it via an empty function first.\n        var /** @type {?} */ emptyFn = new (Function.bind.apply(Function, [void 0].concat(fnArgNames.concat('return null;'))))().toString();\n        var /** @type {?} */ headerLines = emptyFn.slice(0, emptyFn.indexOf('return null;')).split('\\n').length - 1;\n        fnBody += \"\\n\" + ctx.toSourceMapGenerator(sourceUrl$$1, sourceUrl$$1, headerLines).toJsComment();\n    }\n    return new (Function.bind.apply(Function, [void 0].concat(fnArgNames.concat(fnBody))))().apply(void 0, fnArgValues);\n}\n/**\n * @param {?} sourceUrl\n * @param {?} statements\n * @return {?}\n */\nfunction jitStatements(sourceUrl$$1, statements) {\n    var /** @type {?} */ converter = new JitEmitterVisitor();\n    var /** @type {?} */ ctx = EmitterVisitorContext.createRoot();\n    converter.visitAllStatements(statements, ctx);\n    converter.createReturnStmt(ctx);\n    return evalExpression(sourceUrl$$1, ctx, converter.getArgs());\n}\nvar JitEmitterVisitor = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](JitEmitterVisitor, _super);\n    function JitEmitterVisitor() {\n        var _this = _super.apply(this, arguments) || this;\n        _this._evalArgNames = [];\n        _this._evalArgValues = [];\n        _this._evalExportedVars = [];\n        return _this;\n    }\n    /**\n     * @param {?} ctx\n     * @return {?}\n     */\n    JitEmitterVisitor.prototype.createReturnStmt = function (ctx) {\n        var /** @type {?} */ stmt = new ReturnStatement(new LiteralMapExpr(this._evalExportedVars.map(function (resultVar) { return new LiteralMapEntry(resultVar, variable(resultVar), false); })));\n        stmt.visitStatement(this, ctx);\n    };\n    /**\n     * @return {?}\n     */\n    JitEmitterVisitor.prototype.getArgs = function () {\n        var /** @type {?} */ result = {};\n        for (var /** @type {?} */ i = 0; i < this._evalArgNames.length; i++) {\n            result[this._evalArgNames[i]] = this._evalArgValues[i];\n        }\n        return result;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    JitEmitterVisitor.prototype.visitExternalExpr = function (ast, ctx) {\n        var /** @type {?} */ value = ast.value.runtime;\n        var /** @type {?} */ id = this._evalArgValues.indexOf(value);\n        if (id === -1) {\n            id = this._evalArgValues.length;\n            this._evalArgValues.push(value);\n            var /** @type {?} */ name = identifierName({ reference: ast.value.runtime }) || 'val';\n            this._evalArgNames.push(\"jit_\" + name + \"_\" + id);\n        }\n        ctx.print(ast, this._evalArgNames[id]);\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    JitEmitterVisitor.prototype.visitDeclareVarStmt = function (stmt, ctx) {\n        if (stmt.hasModifier(StmtModifier.Exported)) {\n            this._evalExportedVars.push(stmt.name);\n        }\n        return _super.prototype.visitDeclareVarStmt.call(this, stmt, ctx);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    JitEmitterVisitor.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {\n        if (stmt.hasModifier(StmtModifier.Exported)) {\n            this._evalExportedVars.push(stmt.name);\n        }\n        return _super.prototype.visitDeclareFunctionStmt.call(this, stmt, ctx);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    JitEmitterVisitor.prototype.visitDeclareClassStmt = function (stmt, ctx) {\n        if (stmt.hasModifier(StmtModifier.Exported)) {\n            this._evalExportedVars.push(stmt.name);\n        }\n        return _super.prototype.visitDeclareClassStmt.call(this, stmt, ctx);\n    };\n    return JitEmitterVisitor;\n}(AbstractJsEmitterVisitor));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * An internal module of the Angular compiler that begins with component types,\n * extracts templates, and eventually produces a compiled version of the component\n * ready for linking into an application.\n *\n * \\@security When compiling templates at runtime, you must ensure that the entire template comes\n * from a trusted source. Attacker-controlled data introduced by a template could expose your\n * application to XSS risks.  For more detail, see the [Security Guide](http://g.co/ng/security).\n */\nvar JitCompiler = (function () {\n    /**\n     * @param {?} _injector\n     * @param {?} _metadataResolver\n     * @param {?} _templateParser\n     * @param {?} _styleCompiler\n     * @param {?} _viewCompiler\n     * @param {?} _ngModuleCompiler\n     * @param {?} _summaryResolver\n     * @param {?} _compilerConfig\n     * @param {?} _console\n     */\n    function JitCompiler(_injector, _metadataResolver, _templateParser, _styleCompiler, _viewCompiler, _ngModuleCompiler, _summaryResolver, _compilerConfig, _console) {\n        this._injector = _injector;\n        this._metadataResolver = _metadataResolver;\n        this._templateParser = _templateParser;\n        this._styleCompiler = _styleCompiler;\n        this._viewCompiler = _viewCompiler;\n        this._ngModuleCompiler = _ngModuleCompiler;\n        this._summaryResolver = _summaryResolver;\n        this._compilerConfig = _compilerConfig;\n        this._console = _console;\n        this._compiledTemplateCache = new Map();\n        this._compiledHostTemplateCache = new Map();\n        this._compiledDirectiveWrapperCache = new Map();\n        this._compiledNgModuleCache = new Map();\n        this._sharedStylesheetCount = 0;\n    }\n    Object.defineProperty(JitCompiler.prototype, \"injector\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this._injector; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    JitCompiler.prototype.compileModuleSync = function (moduleType) {\n        return SyncAsync.assertSync(this._compileModuleAndComponents(moduleType, true));\n    };\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    JitCompiler.prototype.compileModuleAsync = function (moduleType) {\n        return Promise.resolve(this._compileModuleAndComponents(moduleType, false));\n    };\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    JitCompiler.prototype.compileModuleAndAllComponentsSync = function (moduleType) {\n        return SyncAsync.assertSync(this._compileModuleAndAllComponents(moduleType, true));\n    };\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    JitCompiler.prototype.compileModuleAndAllComponentsAsync = function (moduleType) {\n        return Promise.resolve(this._compileModuleAndAllComponents(moduleType, false));\n    };\n    /**\n     * @param {?} component\n     * @return {?}\n     */\n    JitCompiler.prototype.getNgContentSelectors = function (component) {\n        this._console.warn('Compiler.getNgContentSelectors is deprecated. Use ComponentFactory.ngContentSelectors instead!');\n        var /** @type {?} */ template = this._compiledTemplateCache.get(component);\n        if (!template) {\n            throw new Error(\"The component \" + Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"stringify\"])(component) + \" is not yet compiled!\");\n        }\n        return ((template.compMeta.template)).ngContentSelectors;\n    };\n    /**\n     * @template T\n     * @param {?} component\n     * @return {?}\n     */\n    JitCompiler.prototype.getComponentFactory = function (component) {\n        var /** @type {?} */ summary = this._metadataResolver.getDirectiveSummary(component);\n        return (summary.componentFactory);\n    };\n    /**\n     * @param {?} summaries\n     * @return {?}\n     */\n    JitCompiler.prototype.loadAotSummaries = function (summaries) {\n        var _this = this;\n        this.clearCache();\n        flattenSummaries(summaries).forEach(function (summary) {\n            _this._summaryResolver.addSummary({ symbol: summary.type.reference, metadata: null, type: summary });\n        });\n    };\n    /**\n     * @param {?} ref\n     * @return {?}\n     */\n    JitCompiler.prototype.hasAotSummary = function (ref) { return !!this._summaryResolver.resolveSummary(ref); };\n    /**\n     * @param {?} ids\n     * @return {?}\n     */\n    JitCompiler.prototype._filterJitIdentifiers = function (ids) {\n        var _this = this;\n        return ids.map(function (mod) { return mod.reference; }).filter(function (ref) { return !_this.hasAotSummary(ref); });\n    };\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @param {?} isSync\n     * @return {?}\n     */\n    JitCompiler.prototype._compileModuleAndComponents = function (moduleType, isSync) {\n        var _this = this;\n        return SyncAsync.then(this._loadModules(moduleType, isSync), function () {\n            _this._compileComponents(moduleType, null);\n            return _this._compileModule(moduleType);\n        });\n    };\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @param {?} isSync\n     * @return {?}\n     */\n    JitCompiler.prototype._compileModuleAndAllComponents = function (moduleType, isSync) {\n        var _this = this;\n        return SyncAsync.then(this._loadModules(moduleType, isSync), function () {\n            var /** @type {?} */ componentFactories = [];\n            _this._compileComponents(moduleType, componentFactories);\n            return new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ModuleWithComponentFactories\"](_this._compileModule(moduleType), componentFactories);\n        });\n    };\n    /**\n     * @param {?} mainModule\n     * @param {?} isSync\n     * @return {?}\n     */\n    JitCompiler.prototype._loadModules = function (mainModule, isSync) {\n        var _this = this;\n        var /** @type {?} */ loading = [];\n        var /** @type {?} */ mainNgModule = ((this._metadataResolver.getNgModuleMetadata(mainModule)));\n        // Note: for runtime compilation, we want to transitively compile all modules,\n        // so we also need to load the declared directives / pipes for all nested modules.\n        this._filterJitIdentifiers(mainNgModule.transitiveModule.modules).forEach(function (nestedNgModule) {\n            // getNgModuleMetadata only returns null if the value passed in is not an NgModule\n            var /** @type {?} */ moduleMeta = ((_this._metadataResolver.getNgModuleMetadata(nestedNgModule)));\n            _this._filterJitIdentifiers(moduleMeta.declaredDirectives).forEach(function (ref) {\n                var /** @type {?} */ promise = _this._metadataResolver.loadDirectiveMetadata(moduleMeta.type.reference, ref, isSync);\n                if (promise) {\n                    loading.push(promise);\n                }\n            });\n            _this._filterJitIdentifiers(moduleMeta.declaredPipes)\n                .forEach(function (ref) { return _this._metadataResolver.getOrLoadPipeMetadata(ref); });\n        });\n        return SyncAsync.all(loading);\n    };\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    JitCompiler.prototype._compileModule = function (moduleType) {\n        var _this = this;\n        var /** @type {?} */ ngModuleFactory = ((this._compiledNgModuleCache.get(moduleType)));\n        if (!ngModuleFactory) {\n            var /** @type {?} */ moduleMeta_1 = ((this._metadataResolver.getNgModuleMetadata(moduleType)));\n            // Always provide a bound Compiler\n            var /** @type {?} */ extraProviders = [this._metadataResolver.getProviderMetadata(new ProviderMeta(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Compiler\"], { useFactory: function () { return new ModuleBoundCompiler(_this, moduleMeta_1.type.reference); } }))];\n            var /** @type {?} */ outputCtx = createOutputContext();\n            var /** @type {?} */ compileResult = this._ngModuleCompiler.compile(outputCtx, moduleMeta_1, extraProviders);\n            if (!this._compilerConfig.useJit) {\n                ngModuleFactory =\n                    interpretStatements(outputCtx.statements)[compileResult.ngModuleFactoryVar];\n            }\n            else {\n                ngModuleFactory = jitStatements(ngModuleJitUrl(moduleMeta_1), outputCtx.statements)[compileResult.ngModuleFactoryVar];\n            }\n            this._compiledNgModuleCache.set(moduleMeta_1.type.reference, ngModuleFactory);\n        }\n        return ngModuleFactory;\n    };\n    /**\n     * \\@internal\n     * @param {?} mainModule\n     * @param {?} allComponentFactories\n     * @return {?}\n     */\n    JitCompiler.prototype._compileComponents = function (mainModule, allComponentFactories) {\n        var _this = this;\n        var /** @type {?} */ ngModule = ((this._metadataResolver.getNgModuleMetadata(mainModule)));\n        var /** @type {?} */ moduleByJitDirective = new Map();\n        var /** @type {?} */ templates = new Set();\n        var /** @type {?} */ transJitModules = this._filterJitIdentifiers(ngModule.transitiveModule.modules);\n        transJitModules.forEach(function (localMod) {\n            var /** @type {?} */ localModuleMeta = ((_this._metadataResolver.getNgModuleMetadata(localMod)));\n            _this._filterJitIdentifiers(localModuleMeta.declaredDirectives).forEach(function (dirRef) {\n                moduleByJitDirective.set(dirRef, localModuleMeta);\n                var /** @type {?} */ dirMeta = _this._metadataResolver.getDirectiveMetadata(dirRef);\n                if (dirMeta.isComponent) {\n                    templates.add(_this._createCompiledTemplate(dirMeta, localModuleMeta));\n                    if (allComponentFactories) {\n                        var /** @type {?} */ template = _this._createCompiledHostTemplate(dirMeta.type.reference, localModuleMeta);\n                        templates.add(template);\n                        allComponentFactories.push(/** @type {?} */ (dirMeta.componentFactory));\n                    }\n                }\n            });\n        });\n        transJitModules.forEach(function (localMod) {\n            var /** @type {?} */ localModuleMeta = ((_this._metadataResolver.getNgModuleMetadata(localMod)));\n            _this._filterJitIdentifiers(localModuleMeta.declaredDirectives).forEach(function (dirRef) {\n                var /** @type {?} */ dirMeta = _this._metadataResolver.getDirectiveMetadata(dirRef);\n                if (dirMeta.isComponent) {\n                    dirMeta.entryComponents.forEach(function (entryComponentType) {\n                        var /** @type {?} */ moduleMeta = ((moduleByJitDirective.get(entryComponentType.componentType)));\n                        templates.add(_this._createCompiledHostTemplate(entryComponentType.componentType, moduleMeta));\n                    });\n                }\n            });\n            localModuleMeta.entryComponents.forEach(function (entryComponentType) {\n                if (!_this.hasAotSummary(entryComponentType.componentType.reference)) {\n                    var /** @type {?} */ moduleMeta = ((moduleByJitDirective.get(entryComponentType.componentType)));\n                    templates.add(_this._createCompiledHostTemplate(entryComponentType.componentType, moduleMeta));\n                }\n            });\n        });\n        templates.forEach(function (template) { return _this._compileTemplate(template); });\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    JitCompiler.prototype.clearCacheFor = function (type) {\n        this._compiledNgModuleCache.delete(type);\n        this._metadataResolver.clearCacheFor(type);\n        this._compiledHostTemplateCache.delete(type);\n        var /** @type {?} */ compiledTemplate = this._compiledTemplateCache.get(type);\n        if (compiledTemplate) {\n            this._compiledTemplateCache.delete(type);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    JitCompiler.prototype.clearCache = function () {\n        this._metadataResolver.clearCache();\n        this._compiledTemplateCache.clear();\n        this._compiledHostTemplateCache.clear();\n        this._compiledNgModuleCache.clear();\n    };\n    /**\n     * @param {?} compType\n     * @param {?} ngModule\n     * @return {?}\n     */\n    JitCompiler.prototype._createCompiledHostTemplate = function (compType, ngModule) {\n        if (!ngModule) {\n            throw new Error(\"Component \" + Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"stringify\"])(compType) + \" is not part of any NgModule or the module has not been imported into your module.\");\n        }\n        var /** @type {?} */ compiledTemplate = this._compiledHostTemplateCache.get(compType);\n        if (!compiledTemplate) {\n            var /** @type {?} */ compMeta = this._metadataResolver.getDirectiveMetadata(compType);\n            assertComponent(compMeta);\n            var /** @type {?} */ componentFactory = (compMeta.componentFactory);\n            var /** @type {?} */ hostClass = this._metadataResolver.getHostComponentType(compType);\n            var /** @type {?} */ hostMeta = createHostComponentMeta(hostClass, compMeta, /** @type {?} */ (Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"getComponentViewDefinitionFactory\"])(componentFactory)));\n            compiledTemplate =\n                new CompiledTemplate(true, compMeta.type, hostMeta, ngModule, [compMeta.type]);\n            this._compiledHostTemplateCache.set(compType, compiledTemplate);\n        }\n        return compiledTemplate;\n    };\n    /**\n     * @param {?} compMeta\n     * @param {?} ngModule\n     * @return {?}\n     */\n    JitCompiler.prototype._createCompiledTemplate = function (compMeta, ngModule) {\n        var /** @type {?} */ compiledTemplate = this._compiledTemplateCache.get(compMeta.type.reference);\n        if (!compiledTemplate) {\n            assertComponent(compMeta);\n            compiledTemplate = new CompiledTemplate(false, compMeta.type, compMeta, ngModule, ngModule.transitiveModule.directives);\n            this._compiledTemplateCache.set(compMeta.type.reference, compiledTemplate);\n        }\n        return compiledTemplate;\n    };\n    /**\n     * @param {?} template\n     * @return {?}\n     */\n    JitCompiler.prototype._compileTemplate = function (template) {\n        var _this = this;\n        if (template.isCompiled) {\n            return;\n        }\n        var /** @type {?} */ compMeta = template.compMeta;\n        var /** @type {?} */ externalStylesheetsByModuleUrl = new Map();\n        var /** @type {?} */ outputContext = createOutputContext();\n        var /** @type {?} */ componentStylesheet = this._styleCompiler.compileComponent(outputContext, compMeta); /** @type {?} */\n        ((compMeta.template)).externalStylesheets.forEach(function (stylesheetMeta) {\n            var /** @type {?} */ compiledStylesheet = _this._styleCompiler.compileStyles(createOutputContext(), compMeta, stylesheetMeta);\n            externalStylesheetsByModuleUrl.set(/** @type {?} */ ((stylesheetMeta.moduleUrl)), compiledStylesheet);\n        });\n        this._resolveStylesCompileResult(componentStylesheet, externalStylesheetsByModuleUrl);\n        var /** @type {?} */ directives = template.directives.map(function (dir) { return _this._metadataResolver.getDirectiveSummary(dir.reference); });\n        var /** @type {?} */ pipes = template.ngModule.transitiveModule.pipes.map(function (pipe) { return _this._metadataResolver.getPipeSummary(pipe.reference); });\n        var _a = this._templateParser.parse(compMeta, /** @type {?} */ ((((compMeta.template)).template)), directives, pipes, template.ngModule.schemas, templateSourceUrl(template.ngModule.type, template.compMeta, /** @type {?} */ ((template.compMeta.template)))), parsedTemplate = _a.template, usedPipes = _a.pipes;\n        var /** @type {?} */ compileResult = this._viewCompiler.compileComponent(outputContext, compMeta, parsedTemplate, variable(componentStylesheet.stylesVar), usedPipes);\n        var /** @type {?} */ evalResult;\n        if (!this._compilerConfig.useJit) {\n            evalResult = interpretStatements(outputContext.statements);\n        }\n        else {\n            evalResult = jitStatements(templateJitUrl(template.ngModule.type, template.compMeta), outputContext.statements);\n        }\n        var /** @type {?} */ viewClass = evalResult[compileResult.viewClassVar];\n        var /** @type {?} */ rendererType = evalResult[compileResult.rendererTypeVar];\n        template.compiled(viewClass, rendererType);\n    };\n    /**\n     * @param {?} result\n     * @param {?} externalStylesheetsByModuleUrl\n     * @return {?}\n     */\n    JitCompiler.prototype._resolveStylesCompileResult = function (result, externalStylesheetsByModuleUrl) {\n        var _this = this;\n        result.dependencies.forEach(function (dep, i) {\n            var /** @type {?} */ nestedCompileResult = ((externalStylesheetsByModuleUrl.get(dep.moduleUrl)));\n            var /** @type {?} */ nestedStylesArr = _this._resolveAndEvalStylesCompileResult(nestedCompileResult, externalStylesheetsByModuleUrl);\n            dep.setValue(nestedStylesArr);\n        });\n    };\n    /**\n     * @param {?} result\n     * @param {?} externalStylesheetsByModuleUrl\n     * @return {?}\n     */\n    JitCompiler.prototype._resolveAndEvalStylesCompileResult = function (result, externalStylesheetsByModuleUrl) {\n        this._resolveStylesCompileResult(result, externalStylesheetsByModuleUrl);\n        if (!this._compilerConfig.useJit) {\n            return interpretStatements(result.outputCtx.statements)[result.stylesVar];\n        }\n        else {\n            return jitStatements(sharedStylesheetJitUrl(result.meta, this._sharedStylesheetCount++), result.outputCtx.statements)[result.stylesVar];\n        }\n    };\n    return JitCompiler;\n}());\nJitCompiler.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nJitCompiler.ctorParameters = function () { return [\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injector\"], },\n    { type: CompileMetadataResolver, },\n    { type: TemplateParser, },\n    { type: StyleCompiler, },\n    { type: ViewCompiler, },\n    { type: NgModuleCompiler, },\n    { type: SummaryResolver, },\n    { type: CompilerConfig, },\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Console\"], },\n]; };\nvar CompiledTemplate = (function () {\n    /**\n     * @param {?} isHost\n     * @param {?} compType\n     * @param {?} compMeta\n     * @param {?} ngModule\n     * @param {?} directives\n     */\n    function CompiledTemplate(isHost, compType, compMeta, ngModule, directives) {\n        this.isHost = isHost;\n        this.compType = compType;\n        this.compMeta = compMeta;\n        this.ngModule = ngModule;\n        this.directives = directives;\n        this._viewClass = ((null));\n        this.isCompiled = false;\n    }\n    /**\n     * @param {?} viewClass\n     * @param {?} rendererType\n     * @return {?}\n     */\n    CompiledTemplate.prototype.compiled = function (viewClass, rendererType) {\n        this._viewClass = viewClass;\n        ((this.compMeta.componentViewType)).setDelegate(viewClass);\n        for (var /** @type {?} */ prop in rendererType) {\n            ((this.compMeta.rendererType))[prop] = rendererType[prop];\n        }\n        this.isCompiled = true;\n    };\n    return CompiledTemplate;\n}());\n/**\n * @param {?} meta\n * @return {?}\n */\nfunction assertComponent(meta) {\n    if (!meta.isComponent) {\n        throw new Error(\"Could not compile '\" + identifierName(meta.type) + \"' because it is not a component.\");\n    }\n}\n/**\n * Implements `Compiler` by delegating to the JitCompiler using a known module.\n */\nvar ModuleBoundCompiler = (function () {\n    /**\n     * @param {?} _delegate\n     * @param {?} _ngModule\n     */\n    function ModuleBoundCompiler(_delegate, _ngModule) {\n        this._delegate = _delegate;\n        this._ngModule = _ngModule;\n    }\n    Object.defineProperty(ModuleBoundCompiler.prototype, \"_injector\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this._delegate.injector; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    ModuleBoundCompiler.prototype.compileModuleSync = function (moduleType) {\n        return this._delegate.compileModuleSync(moduleType);\n    };\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    ModuleBoundCompiler.prototype.compileModuleAsync = function (moduleType) {\n        return this._delegate.compileModuleAsync(moduleType);\n    };\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    ModuleBoundCompiler.prototype.compileModuleAndAllComponentsSync = function (moduleType) {\n        return this._delegate.compileModuleAndAllComponentsSync(moduleType);\n    };\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    ModuleBoundCompiler.prototype.compileModuleAndAllComponentsAsync = function (moduleType) {\n        return this._delegate.compileModuleAndAllComponentsAsync(moduleType);\n    };\n    /**\n     * @param {?} component\n     * @return {?}\n     */\n    ModuleBoundCompiler.prototype.getNgContentSelectors = function (component) {\n        return this._delegate.getNgContentSelectors(component);\n    };\n    /**\n     * Clears all caches\n     * @return {?}\n     */\n    ModuleBoundCompiler.prototype.clearCache = function () { this._delegate.clearCache(); };\n    /**\n     * Clears the cache for the given component/ngModule.\n     * @param {?} type\n     * @return {?}\n     */\n    ModuleBoundCompiler.prototype.clearCacheFor = function (type) { this._delegate.clearCacheFor(type); };\n    return ModuleBoundCompiler;\n}());\n/**\n * @param {?} fn\n * @param {?=} out\n * @return {?}\n */\nfunction flattenSummaries(fn$$1, out) {\n    if (out === void 0) { out = []; }\n    fn$$1().forEach(function (entry) {\n        if (typeof entry === 'function') {\n            flattenSummaries(entry, out);\n        }\n        else {\n            out.push(entry);\n        }\n    });\n    return out;\n}\n/**\n * @return {?}\n */\nfunction createOutputContext() {\n    var /** @type {?} */ importExpr$$1 = function (symbol) { return importExpr({ name: identifierName(symbol), moduleName: null, runtime: symbol }); };\n    return { statements: [], genFilePath: '', importExpr: importExpr$$1 };\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A container for message extracted from the templates.\n */\nvar MessageBundle = (function () {\n    /**\n     * @param {?} _htmlParser\n     * @param {?} _implicitTags\n     * @param {?} _implicitAttrs\n     * @param {?=} _locale\n     */\n    function MessageBundle(_htmlParser, _implicitTags, _implicitAttrs, _locale) {\n        if (_locale === void 0) { _locale = null; }\n        this._htmlParser = _htmlParser;\n        this._implicitTags = _implicitTags;\n        this._implicitAttrs = _implicitAttrs;\n        this._locale = _locale;\n        this._messages = [];\n    }\n    /**\n     * @param {?} html\n     * @param {?} url\n     * @param {?} interpolationConfig\n     * @return {?}\n     */\n    MessageBundle.prototype.updateFromTemplate = function (html, url, interpolationConfig) {\n        var /** @type {?} */ htmlParserResult = this._htmlParser.parse(html, url, true, interpolationConfig);\n        if (htmlParserResult.errors.length) {\n            return htmlParserResult.errors;\n        }\n        var /** @type {?} */ i18nParserResult = extractMessages(htmlParserResult.rootNodes, interpolationConfig, this._implicitTags, this._implicitAttrs);\n        if (i18nParserResult.errors.length) {\n            return i18nParserResult.errors;\n        }\n        (_a = this._messages).push.apply(_a, i18nParserResult.messages);\n        return [];\n        var _a;\n    };\n    /**\n     * @return {?}\n     */\n    MessageBundle.prototype.getMessages = function () { return this._messages; };\n    /**\n     * @param {?} serializer\n     * @param {?=} filterSources\n     * @return {?}\n     */\n    MessageBundle.prototype.write = function (serializer, filterSources) {\n        var /** @type {?} */ messages = {};\n        var /** @type {?} */ mapperVisitor = new MapPlaceholderNames();\n        // Deduplicate messages based on their ID\n        this._messages.forEach(function (message) {\n            var /** @type {?} */ id = serializer.digest(message);\n            if (!messages.hasOwnProperty(id)) {\n                messages[id] = message;\n            }\n            else {\n                (_a = messages[id].sources).push.apply(_a, message.sources);\n            }\n            var _a;\n        });\n        // Transform placeholder names using the serializer mapping\n        var /** @type {?} */ msgList = Object.keys(messages).map(function (id) {\n            var /** @type {?} */ mapper = serializer.createNameMapper(messages[id]);\n            var /** @type {?} */ src = messages[id];\n            var /** @type {?} */ nodes = mapper ? mapperVisitor.convert(src.nodes, mapper) : src.nodes;\n            var /** @type {?} */ transformedMessage = new Message(nodes, {}, {}, src.meaning, src.description, id);\n            transformedMessage.sources = src.sources;\n            if (filterSources) {\n                transformedMessage.sources.forEach(function (source) { return source.filePath = filterSources(source.filePath); });\n            }\n            return transformedMessage;\n        });\n        return serializer.write(msgList, this._locale);\n    };\n    return MessageBundle;\n}());\nvar MapPlaceholderNames = (function (_super) {\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MapPlaceholderNames, _super);\n    function MapPlaceholderNames() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} nodes\n     * @param {?} mapper\n     * @return {?}\n     */\n    MapPlaceholderNames.prototype.convert = function (nodes, mapper) {\n        var _this = this;\n        return mapper ? nodes.map(function (n) { return n.visit(_this, mapper); }) : nodes;\n    };\n    /**\n     * @param {?} ph\n     * @param {?} mapper\n     * @return {?}\n     */\n    MapPlaceholderNames.prototype.visitTagPlaceholder = function (ph, mapper) {\n        var _this = this;\n        var /** @type {?} */ startName = ((mapper.toPublicName(ph.startName)));\n        var /** @type {?} */ closeName = ph.closeName ? ((mapper.toPublicName(ph.closeName))) : ph.closeName;\n        var /** @type {?} */ children = ph.children.map(function (n) { return n.visit(_this, mapper); });\n        return new TagPlaceholder(ph.tag, ph.attrs, startName, closeName, children, ph.isVoid, ph.sourceSpan);\n    };\n    /**\n     * @param {?} ph\n     * @param {?} mapper\n     * @return {?}\n     */\n    MapPlaceholderNames.prototype.visitPlaceholder = function (ph, mapper) {\n        return new Placeholder(ph.value, /** @type {?} */ ((mapper.toPublicName(ph.name))), ph.sourceSpan);\n    };\n    /**\n     * @param {?} ph\n     * @param {?} mapper\n     * @return {?}\n     */\n    MapPlaceholderNames.prototype.visitIcuPlaceholder = function (ph, mapper) {\n        return new IcuPlaceholder(ph.value, /** @type {?} */ ((mapper.toPublicName(ph.name))), ph.sourceSpan);\n    };\n    return MapPlaceholderNames;\n}(CloneVisitor));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Extract i18n messages from source code\n */\nvar Extractor = (function () {\n    /**\n     * @param {?} host\n     * @param {?} staticSymbolResolver\n     * @param {?} messageBundle\n     * @param {?} metadataResolver\n     */\n    function Extractor(host, staticSymbolResolver, messageBundle, metadataResolver) {\n        this.host = host;\n        this.staticSymbolResolver = staticSymbolResolver;\n        this.messageBundle = messageBundle;\n        this.metadataResolver = metadataResolver;\n    }\n    /**\n     * @param {?} rootFiles\n     * @return {?}\n     */\n    Extractor.prototype.extract = function (rootFiles) {\n        var _this = this;\n        var /** @type {?} */ programSymbols = extractProgramSymbols(this.staticSymbolResolver, rootFiles, this.host);\n        var _a = analyzeAndValidateNgModules(programSymbols, this.host, this.metadataResolver), files = _a.files, ngModules = _a.ngModules;\n        return Promise\n            .all(ngModules.map(function (ngModule) { return _this.metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, false); }))\n            .then(function () {\n            var /** @type {?} */ errors = [];\n            files.forEach(function (file) {\n                var /** @type {?} */ compMetas = [];\n                file.directives.forEach(function (directiveType) {\n                    var /** @type {?} */ dirMeta = _this.metadataResolver.getDirectiveMetadata(directiveType);\n                    if (dirMeta && dirMeta.isComponent) {\n                        compMetas.push(dirMeta);\n                    }\n                });\n                compMetas.forEach(function (compMeta) {\n                    var /** @type {?} */ html = ((((compMeta.template)).template));\n                    var /** @type {?} */ interpolationConfig = InterpolationConfig.fromArray(/** @type {?} */ ((compMeta.template)).interpolation);\n                    errors.push.apply(errors, ((_this.messageBundle.updateFromTemplate(html, file.srcUrl, interpolationConfig))));\n                });\n            });\n            if (errors.length) {\n                throw new Error(errors.map(function (e) { return e.toString(); }).join('\\n'));\n            }\n            return _this.messageBundle;\n        });\n    };\n    /**\n     * @param {?} host\n     * @param {?} locale\n     * @return {?}\n     */\n    Extractor.create = function (host, locale) {\n        var /** @type {?} */ htmlParser = new HtmlParser();\n        var /** @type {?} */ urlResolver = createOfflineCompileUrlResolver();\n        var /** @type {?} */ symbolCache = new StaticSymbolCache();\n        var /** @type {?} */ summaryResolver = new AotSummaryResolver(host, symbolCache);\n        var /** @type {?} */ staticSymbolResolver = new StaticSymbolResolver(host, symbolCache, summaryResolver);\n        var /** @type {?} */ staticReflector = new StaticReflector(summaryResolver, staticSymbolResolver);\n        var /** @type {?} */ config = new CompilerConfig({ defaultEncapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].Emulated, useJit: false });\n        var /** @type {?} */ normalizer = new DirectiveNormalizer({ get: function (url) { return host.loadResource(url); } }, urlResolver, htmlParser, config);\n        var /** @type {?} */ elementSchemaRegistry = new DomElementSchemaRegistry();\n        var /** @type {?} */ resolver = new CompileMetadataResolver(config, new NgModuleResolver(staticReflector), new DirectiveResolver(staticReflector), new PipeResolver(staticReflector), summaryResolver, elementSchemaRegistry, normalizer, new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Console\"](), symbolCache, staticReflector);\n        // TODO(vicb): implicit tags & attributes\n        var /** @type {?} */ messageBundle = new MessageBundle(htmlParser, [], {}, locale);\n        var /** @type {?} */ extractor = new Extractor(host, staticSymbolResolver, messageBundle, resolver);\n        return { extractor: extractor, staticReflector: staticReflector };\n    };\n    return Extractor;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar JitReflector = (function () {\n    function JitReflector() {\n        this.reflectionCapabilities = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ReflectionCapabilities\"]();\n    }\n    /**\n     * @param {?} type\n     * @param {?} cmpMetadata\n     * @return {?}\n     */\n    JitReflector.prototype.componentModuleUrl = function (type, cmpMetadata) {\n        var /** @type {?} */ moduleId = cmpMetadata.moduleId;\n        if (typeof moduleId === 'string') {\n            var /** @type {?} */ scheme = getUrlScheme(moduleId);\n            return scheme ? moduleId : \"package:\" + moduleId + MODULE_SUFFIX;\n        }\n        else if (moduleId !== null && moduleId !== void 0) {\n            throw syntaxError(\"moduleId should be a string in \\\"\" + Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"stringify\"])(type) + \"\\\". See https://goo.gl/wIDDiL for more information.\\n\" +\n                \"If you're using Webpack you should inline the template and the styles, see https://goo.gl/X2J8zc.\");\n        }\n        return \"./\" + Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"stringify\"])(type);\n    };\n    /**\n     * @param {?} typeOrFunc\n     * @return {?}\n     */\n    JitReflector.prototype.parameters = function (typeOrFunc) {\n        return this.reflectionCapabilities.parameters(typeOrFunc);\n    };\n    /**\n     * @param {?} typeOrFunc\n     * @return {?}\n     */\n    JitReflector.prototype.annotations = function (typeOrFunc) {\n        return this.reflectionCapabilities.annotations(typeOrFunc);\n    };\n    /**\n     * @param {?} typeOrFunc\n     * @return {?}\n     */\n    JitReflector.prototype.propMetadata = function (typeOrFunc) {\n        return this.reflectionCapabilities.propMetadata(typeOrFunc);\n    };\n    /**\n     * @param {?} type\n     * @param {?} lcProperty\n     * @return {?}\n     */\n    JitReflector.prototype.hasLifecycleHook = function (type, lcProperty) {\n        return this.reflectionCapabilities.hasLifecycleHook(type, lcProperty);\n    };\n    /**\n     * @param {?} ref\n     * @return {?}\n     */\n    JitReflector.prototype.resolveExternalReference = function (ref) { return ref.runtime; };\n    return JitReflector;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _NO_RESOURCE_LOADER = {\n    /**\n     * @param {?} url\n     * @return {?}\n     */\n    get: function (url) {\n        throw new Error(\"No ResourceLoader implementation has been provided. Can't read the url \\\"\" + url + \"\\\"\");\n    }\n};\nvar baseHtmlParser = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"InjectionToken\"]('HtmlParser');\n/**\n * A set of providers that provide `JitCompiler` and its dependencies to use for\n * template compilation.\n */\nvar COMPILER_PROVIDERS = [\n    { provide: CompileReflector, useValue: new JitReflector() },\n    { provide: ResourceLoader, useValue: _NO_RESOURCE_LOADER },\n    JitSummaryResolver,\n    { provide: SummaryResolver, useExisting: JitSummaryResolver },\n    __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Console\"],\n    Lexer,\n    Parser,\n    {\n        provide: baseHtmlParser,\n        useClass: HtmlParser,\n    },\n    {\n        provide: I18NHtmlParser,\n        useFactory: function (parser, translations, format, config, console) {\n            translations = translations || '';\n            var missingTranslation = translations ? config.missingTranslation : __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"MissingTranslationStrategy\"].Ignore;\n            return new I18NHtmlParser(parser, translations, format, missingTranslation, console);\n        },\n        deps: [\n            baseHtmlParser,\n            [new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"](), new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"](__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"TRANSLATIONS\"])],\n            [new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"](), new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"](__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"TRANSLATIONS_FORMAT\"])],\n            [CompilerConfig],\n            [__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Console\"]],\n        ]\n    },\n    {\n        provide: HtmlParser,\n        useExisting: I18NHtmlParser,\n    },\n    TemplateParser,\n    DirectiveNormalizer,\n    CompileMetadataResolver,\n    DEFAULT_PACKAGE_URL_PROVIDER,\n    StyleCompiler,\n    ViewCompiler,\n    NgModuleCompiler,\n    { provide: CompilerConfig, useValue: new CompilerConfig() },\n    JitCompiler,\n    { provide: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Compiler\"], useExisting: JitCompiler },\n    DomElementSchemaRegistry,\n    { provide: ElementSchemaRegistry, useExisting: DomElementSchemaRegistry },\n    UrlResolver,\n    DirectiveResolver,\n    PipeResolver,\n    NgModuleResolver,\n];\nvar JitCompilerFactory = (function () {\n    /**\n     * @param {?} defaultOptions\n     */\n    function JitCompilerFactory(defaultOptions) {\n        var compilerOptions = {\n            useDebug: Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"isDevMode\"])(),\n            useJit: true,\n            defaultEncapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].Emulated,\n            missingTranslation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"MissingTranslationStrategy\"].Warning,\n            enableLegacyTemplate: true,\n        };\n        this._defaultOptions = [compilerOptions].concat(defaultOptions);\n    }\n    /**\n     * @param {?=} options\n     * @return {?}\n     */\n    JitCompilerFactory.prototype.createCompiler = function (options) {\n        if (options === void 0) { options = []; }\n        var /** @type {?} */ opts = _mergeOptions(this._defaultOptions.concat(options));\n        var /** @type {?} */ injector = __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ReflectiveInjector\"].resolveAndCreate([\n            COMPILER_PROVIDERS, {\n                provide: CompilerConfig,\n                useFactory: function () {\n                    return new CompilerConfig({\n                        // let explicit values from the compiler options overwrite options\n                        // from the app providers\n                        useJit: opts.useJit,\n                        // let explicit values from the compiler options overwrite options\n                        // from the app providers\n                        defaultEncapsulation: opts.defaultEncapsulation,\n                        missingTranslation: opts.missingTranslation,\n                        enableLegacyTemplate: opts.enableLegacyTemplate,\n                    });\n                },\n                deps: []\n            }, /** @type {?} */ ((opts.providers))\n        ]);\n        return injector.get(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Compiler\"]);\n    };\n    return JitCompilerFactory;\n}());\nJitCompilerFactory.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nJitCompilerFactory.ctorParameters = function () { return [\n    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"COMPILER_OPTIONS\"],] },] },\n]; };\n/**\n * A platform that included corePlatform and the compiler.\n *\n * \\@experimental\n */\nvar platformCoreDynamic = Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"createPlatformFactory\"])(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"platformCore\"], 'coreDynamic', [\n    { provide: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"COMPILER_OPTIONS\"], useValue: {}, multi: true },\n    { provide: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"CompilerFactory\"], useClass: JitCompilerFactory },\n]);\n/**\n * @param {?} optionsArr\n * @return {?}\n */\nfunction _mergeOptions(optionsArr) {\n    return {\n        useJit: _lastDefined(optionsArr.map(function (options) { return options.useJit; })),\n        defaultEncapsulation: _lastDefined(optionsArr.map(function (options) { return options.defaultEncapsulation; })),\n        providers: _mergeArrays(optionsArr.map(function (options) { return ((options.providers)); })),\n        missingTranslation: _lastDefined(optionsArr.map(function (options) { return options.missingTranslation; })),\n        enableLegacyTemplate: _lastDefined(optionsArr.map(function (options) { return options.enableLegacyTemplate; })),\n    };\n}\n/**\n * @template T\n * @param {?} args\n * @return {?}\n */\nfunction _lastDefined(args) {\n    for (var /** @type {?} */ i = args.length - 1; i >= 0; i--) {\n        if (args[i] !== undefined) {\n            return args[i];\n        }\n    }\n    return undefined;\n}\n/**\n * @param {?} parts\n * @return {?}\n */\nfunction _mergeArrays(parts) {\n    var /** @type {?} */ result = [];\n    parts.forEach(function (part) { return part && result.push.apply(result, part); });\n    return result;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @module\n * @description\n * Entry point for all APIs of the compiler package.\n *\n * <div class=\"callout is-critical\">\n *   <header>Unstable APIs</header>\n *   <p>\n *     All compiler apis are currently considered experimental and private!\n *   </p>\n *   <p>\n *     We expect the APIs in this package to keep on changing. Do not rely on them.\n *   </p>\n * </div>\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @module\n * @description\n * Entry point for all public APIs of the compiler package.\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n//# sourceMappingURL=compiler.js.map\n//# sourceMappingURL=compiler.es5.js.map\n// CONCATENATED MODULE: ./node_modules/@angular/platform-browser-dynamic/@angular/platform-browser-dynamic.es5.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RESOURCE_CACHE_PROVIDER\", function() { return RESOURCE_CACHE_PROVIDER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"platformBrowserDynamic\", function() { return platformBrowserDynamic; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VERSION\", function() { return platform_browser_dynamic_es5_VERSION; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS\", function() { return INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ResourceLoaderImpl\", function() { return ResourceLoaderImpl; });\n/* harmony import */ var platform_browser_dynamic_es5___WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(40);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__angular_common__ = __webpack_require__(64);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__angular_platform_browser__ = __webpack_require__(65);\n\n/**\n * @license Angular v4.3.3\n * (c) 2010-2017 Google, Inc. https://angular.io/\n * License: MIT\n */\n\n\n\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ResourceLoaderImpl = (function (_super) {\n    platform_browser_dynamic_es5___WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](ResourceLoaderImpl, _super);\n    function ResourceLoaderImpl() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ResourceLoaderImpl.prototype.get = function (url) {\n        var resolve;\n        var reject;\n        var promise = new Promise(function (res, rej) {\n            resolve = res;\n            reject = rej;\n        });\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url, true);\n        xhr.responseType = 'text';\n        xhr.onload = function () {\n            // responseText is the old-school way of retrieving response (supported by IE8 & 9)\n            // response/responseType properties were introduced in ResourceLoader Level2 spec (supported\n            // by IE10)\n            var response = xhr.response || xhr.responseText;\n            // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)\n            var status = xhr.status === 1223 ? 204 : xhr.status;\n            // fix status code when it is 0 (0 status is undocumented).\n            // Occurs when accessing file resources or on Android 4.1 stock browser\n            // while retrieving files from application cache.\n            if (status === 0) {\n                status = response ? 200 : 0;\n            }\n            if (200 <= status && status <= 300) {\n                resolve(response);\n            }\n            else {\n                reject(\"Failed to load \" + url);\n            }\n        };\n        xhr.onerror = function () { reject(\"Failed to load \" + url); };\n        xhr.send();\n        return promise;\n    };\n    return ResourceLoaderImpl;\n}(ResourceLoader));\nResourceLoaderImpl.decorators = [\n    { type: __WEBPACK_IMPORTED_MODULE_2__angular_core__[\"Injectable\"] },\n];\n/** @nocollapse */\nResourceLoaderImpl.ctorParameters = function () { return []; };\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS = [\n    __WEBPACK_IMPORTED_MODULE_4__angular_platform_browser__[\"INTERNAL_BROWSER_PLATFORM_PROVIDERS\"],\n    {\n        provide: __WEBPACK_IMPORTED_MODULE_2__angular_core__[\"COMPILER_OPTIONS\"],\n        useValue: { providers: [{ provide: ResourceLoader, useClass: ResourceLoaderImpl }] },\n        multi: true\n    },\n    { provide: __WEBPACK_IMPORTED_MODULE_2__angular_core__[\"PLATFORM_ID\"], useValue: __WEBPACK_IMPORTED_MODULE_3__angular_common__[\"d\" /* PLATFORM_BROWSER_ID */] },\n];\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * An implementation of ResourceLoader that uses a template cache to avoid doing an actual\n * ResourceLoader.\n *\n * The template cache needs to be built and loaded into window.$templateCache\n * via a separate mechanism.\n */\nvar CachedResourceLoader = (function (_super) {\n    platform_browser_dynamic_es5___WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](CachedResourceLoader, _super);\n    function CachedResourceLoader() {\n        var _this = _super.call(this) || this;\n        _this._cache = __WEBPACK_IMPORTED_MODULE_2__angular_core__[\"global\"].$templateCache;\n        if (_this._cache == null) {\n            throw new Error('CachedResourceLoader: Template cache was not found in $templateCache.');\n        }\n        return _this;\n    }\n    CachedResourceLoader.prototype.get = function (url) {\n        if (this._cache.hasOwnProperty(url)) {\n            return Promise.resolve(this._cache[url]);\n        }\n        else {\n            return Promise.reject('CachedResourceLoader: Did not find cached template for ' + url);\n        }\n    };\n    return CachedResourceLoader;\n}(ResourceLoader));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @module\n * @description\n * Entry point for all public APIs of the common package.\n */\n/**\n * @stable\n */\nvar platform_browser_dynamic_es5_VERSION = new __WEBPACK_IMPORTED_MODULE_2__angular_core__[\"Version\"]('4.3.3');\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @experimental\n */\nvar RESOURCE_CACHE_PROVIDER = [{ provide: ResourceLoader, useClass: CachedResourceLoader }];\n/**\n * @stable\n */\nvar platformBrowserDynamic = Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__[\"createPlatformFactory\"])(platformCoreDynamic, 'browserDynamic', INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS);\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @module\n * @description\n * Entry point for all public APIs of the platform-browser-dynamic package.\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n//# sourceMappingURL=platform-browser-dynamic.es5.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbXBpbGVyL0Bhbmd1bGFyL2NvbXBpbGVyLmVzNS5qcz81MjRkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMvQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljLmVzNS5qcz8zYmFkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XG4vKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXIgdjQuMy4zXG4gKiAoYykgMjAxMC0yMDE3IEdvb2dsZSwgSW5jLiBodHRwczovL2FuZ3VsYXIuaW8vXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuaW1wb3J0IHsgQU5BTFlaRV9GT1JfRU5UUllfQ09NUE9ORU5UUywgQXR0cmlidXRlLCBDT01QSUxFUl9PUFRJT05TLCBDVVNUT01fRUxFTUVOVFNfU0NIRU1BLCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ2hhbmdlRGV0ZWN0b3JSZWYsIENvbXBpbGVyLCBDb21waWxlckZhY3RvcnksIENvbXBvbmVudCwgQ29tcG9uZW50RmFjdG9yeSwgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBDb21wb25lbnRSZWYsIENvbnRlbnRDaGlsZCwgQ29udGVudENoaWxkcmVuLCBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEhvc3QsIEhvc3RCaW5kaW5nLCBIb3N0TGlzdGVuZXIsIEluamVjdCwgSW5qZWN0YWJsZSwgSW5qZWN0aW9uVG9rZW4sIEluamVjdG9yLCBJbnB1dCwgTE9DQUxFX0lELCBNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSwgTW9kdWxlV2l0aENvbXBvbmVudEZhY3RvcmllcywgTk9fRVJST1JTX1NDSEVNQSwgTmdNb2R1bGUsIE5nTW9kdWxlRmFjdG9yeSwgTmdNb2R1bGVSZWYsIE9wdGlvbmFsLCBPdXRwdXQsIFBBQ0tBR0VfUk9PVF9VUkwsIFBpcGUsIFF1ZXJ5LCBRdWVyeUxpc3QsIFJlZmxlY3RpdmVJbmplY3RvciwgUmVuZGVyZXIsIFNlY3VyaXR5Q29udGV4dCwgU2VsZiwgU2tpcFNlbGYsIFRSQU5TTEFUSU9OUywgVFJBTlNMQVRJT05TX0ZPUk1BVCwgVGVtcGxhdGVSZWYsIFR5cGUsIFZlcnNpb24sIFZpZXdDaGlsZCwgVmlld0NoaWxkcmVuLCBWaWV3Q29udGFpbmVyUmVmLCBWaWV3RW5jYXBzdWxhdGlvbiwgYW5pbWF0ZSwgY3JlYXRlUGxhdGZvcm1GYWN0b3J5LCBncm91cCwgaXNEZXZNb2RlLCBrZXlmcmFtZXMsIHBsYXRmb3JtQ29yZSwgcmVzb2x2ZUZvcndhcmRSZWYsIHNlcXVlbmNlLCBzdGF0ZSwgc3R5bGUsIHRyYW5zaXRpb24sIHRyaWdnZXIsIMm1Q29kZWdlbkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgybVDb25zb2xlLCDJtUVNUFRZX0FSUkFZLCDJtUVNUFRZX01BUCwgybVFUlJPUl9DT01QT05FTlRfVFlQRSwgybVSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLCDJtWFuZCwgybVjY2YsIMm1Y21mLCDJtWNydCwgybVkaWQsIMm1ZWxkLCDJtWVsZW1lbnRFdmVudEZ1bGxOYW1lLCDJtWdldENvbXBvbmVudFZpZXdEZWZpbml0aW9uRmFjdG9yeSwgybVpbmxpbmVJbnRlcnBvbGF0ZSwgybVpbnRlcnBvbGF0ZSwgybVpc1Byb21pc2UsIMm1bW9kLCDJtW1wZCwgybVuY2QsIMm1bm92LCDJtXBhZCwgybVwaWQsIMm1cG9kLCDJtXBwZCwgybVwcmQsIMm1cXVkLCDJtXJlZ2lzdGVyTW9kdWxlRmFjdG9yeSwgybVzdHJpbmdpZnksIMm1dGVkLCDJtXVudiwgybV2aWQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQG1vZHVsZVxuICogQGRlc2NyaXB0aW9uXG4gKiBFbnRyeSBwb2ludCBmb3IgYWxsIHB1YmxpYyBBUElzIG9mIHRoZSBjb21tb24gcGFja2FnZS5cbiAqL1xuLyoqXG4gKiBcXEBzdGFibGVcbiAqL1xudmFyIFZFUlNJT04gPSBuZXcgVmVyc2lvbignNC4zLjMnKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQSBzZWdtZW50IG9mIHRleHQgd2l0aGluIHRoZSB0ZW1wbGF0ZS5cbiAqL1xudmFyIFRleHRBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IG5nQ29udGVudEluZGV4XG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gVGV4dEFzdCh2YWx1ZSwgbmdDb250ZW50SW5kZXgsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm5nQ29udGVudEluZGV4ID0gbmdDb250ZW50SW5kZXg7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGV4dEFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFRleHQodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIFRleHRBc3Q7XG59KCkpO1xuLyoqXG4gKiBBIGJvdW5kIGV4cHJlc3Npb24gd2l0aGluIHRoZSB0ZXh0IG9mIGEgdGVtcGxhdGUuXG4gKi9cbnZhciBCb3VuZFRleHRBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IG5nQ29udGVudEluZGV4XG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQm91bmRUZXh0QXN0KHZhbHVlLCBuZ0NvbnRlbnRJbmRleCwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMubmdDb250ZW50SW5kZXggPSBuZ0NvbnRlbnRJbmRleDtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCb3VuZFRleHRBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRCb3VuZFRleHQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQm91bmRUZXh0QXN0O1xufSgpKTtcbi8qKlxuICogQSBwbGFpbiBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudC5cbiAqL1xudmFyIEF0dHJBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBdHRyQXN0KG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBdHRyQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0QXR0cih0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gQXR0ckFzdDtcbn0oKSk7XG4vKipcbiAqIEEgYmluZGluZyBmb3IgYW4gZWxlbWVudCBwcm9wZXJ0eSAoZS5nLiBgW3Byb3BlcnR5XT1cImV4cHJlc3Npb25cImApIG9yIGFuIGFuaW1hdGlvbiB0cmlnZ2VyIChlLmcuXG4gKiBgW1xcQHRyaWdnZXJdPVwic3RhdGVFeHBcImApXG4gKi9cbnZhciBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHBhcmFtIHs/fSBzZWN1cml0eUNvbnRleHRcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSB1bml0XG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQm91bmRFbGVtZW50UHJvcGVydHlBc3QobmFtZSwgdHlwZSwgc2VjdXJpdHlDb250ZXh0LCB2YWx1ZSwgdW5pdCwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnNlY3VyaXR5Q29udGV4dCA9IHNlY3VyaXR5Q29udGV4dDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnVuaXQgPSB1bml0O1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJvdW5kRWxlbWVudFByb3BlcnR5QXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RWxlbWVudFByb3BlcnR5KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJvdW5kRWxlbWVudFByb3BlcnR5QXN0LnByb3RvdHlwZSwgXCJpc0FuaW1hdGlvblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT09IFByb3BlcnR5QmluZGluZ1R5cGUuQW5pbWF0aW9uOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gQm91bmRFbGVtZW50UHJvcGVydHlBc3Q7XG59KCkpO1xuLyoqXG4gKiBBIGJpbmRpbmcgZm9yIGFuIGVsZW1lbnQgZXZlbnQgKGUuZy4gYChldmVudCk9XCJoYW5kbGVyKClcImApIG9yIGFuIGFuaW1hdGlvbiB0cmlnZ2VyIGV2ZW50IChlLmcuXG4gKiBgKFxcQHRyaWdnZXIucGhhc2UpPVwiY2FsbGJhY2soJGV2ZW50KVwiYCkuXG4gKi9cbnZhciBCb3VuZEV2ZW50QXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFxuICAgICAqIEBwYXJhbSB7P30gcGhhc2VcbiAgICAgKiBAcGFyYW0gez99IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCb3VuZEV2ZW50QXN0KG5hbWUsIHRhcmdldCwgcGhhc2UsIGhhbmRsZXIsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMucGhhc2UgPSBwaGFzZTtcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRcbiAgICAgKiBAcGFyYW0gez99IHBoYXNlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCb3VuZEV2ZW50QXN0LmNhbGNGdWxsTmFtZSA9IGZ1bmN0aW9uIChuYW1lLCB0YXJnZXQsIHBoYXNlKSB7XG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQgKyBcIjpcIiArIG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGhhc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBcIkBcIiArIG5hbWUgKyBcIi5cIiArIHBoYXNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQm91bmRFdmVudEFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEV2ZW50KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJvdW5kRXZlbnRBc3QucHJvdG90eXBlLCBcImZ1bGxOYW1lXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJvdW5kRXZlbnRBc3QuY2FsY0Z1bGxOYW1lKHRoaXMubmFtZSwgdGhpcy50YXJnZXQsIHRoaXMucGhhc2UpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQm91bmRFdmVudEFzdC5wcm90b3R5cGUsIFwiaXNBbmltYXRpb25cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gISF0aGlzLnBoYXNlOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gQm91bmRFdmVudEFzdDtcbn0oKSk7XG4vKipcbiAqIEEgcmVmZXJlbmNlIGRlY2xhcmF0aW9uIG9uIGFuIGVsZW1lbnQgKGUuZy4gYGxldCBzb21lTmFtZT1cImV4cHJlc3Npb25cImApLlxuICovXG52YXIgUmVmZXJlbmNlQXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVmZXJlbmNlQXN0KG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWZlcmVuY2VBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRSZWZlcmVuY2UodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVmZXJlbmNlQXN0O1xufSgpKTtcbi8qKlxuICogQSB2YXJpYWJsZSBkZWNsYXJhdGlvbiBvbiBhIDxuZy10ZW1wbGF0ZT4gKGUuZy4gYHZhci1zb21lTmFtZT1cInNvbWVMb2NhbE5hbWVcImApLlxuICovXG52YXIgVmFyaWFibGVBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBWYXJpYWJsZUFzdChuYW1lLCB2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmFyaWFibGVBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRWYXJpYWJsZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBWYXJpYWJsZUFzdDtcbn0oKSk7XG4vKipcbiAqIEFuIGVsZW1lbnQgZGVjbGFyYXRpb24gaW4gYSB0ZW1wbGF0ZS5cbiAqL1xudmFyIEVsZW1lbnRBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gYXR0cnNcbiAgICAgKiBAcGFyYW0gez99IGlucHV0c1xuICAgICAqIEBwYXJhbSB7P30gb3V0cHV0c1xuICAgICAqIEBwYXJhbSB7P30gcmVmZXJlbmNlc1xuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlc1xuICAgICAqIEBwYXJhbSB7P30gcHJvdmlkZXJzXG4gICAgICogQHBhcmFtIHs/fSBoYXNWaWV3Q29udGFpbmVyXG4gICAgICogQHBhcmFtIHs/fSBxdWVyeU1hdGNoZXNcbiAgICAgKiBAcGFyYW0gez99IGNoaWxkcmVuXG4gICAgICogQHBhcmFtIHs/fSBuZ0NvbnRlbnRJbmRleFxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7P30gZW5kU291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEVsZW1lbnRBc3QobmFtZSwgYXR0cnMsIGlucHV0cywgb3V0cHV0cywgcmVmZXJlbmNlcywgZGlyZWN0aXZlcywgcHJvdmlkZXJzLCBoYXNWaWV3Q29udGFpbmVyLCBxdWVyeU1hdGNoZXMsIGNoaWxkcmVuLCBuZ0NvbnRlbnRJbmRleCwgc291cmNlU3BhbiwgZW5kU291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMuaW5wdXRzID0gaW5wdXRzO1xuICAgICAgICB0aGlzLm91dHB1dHMgPSBvdXRwdXRzO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXMgPSByZWZlcmVuY2VzO1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xuICAgICAgICB0aGlzLnByb3ZpZGVycyA9IHByb3ZpZGVycztcbiAgICAgICAgdGhpcy5oYXNWaWV3Q29udGFpbmVyID0gaGFzVmlld0NvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5xdWVyeU1hdGNoZXMgPSBxdWVyeU1hdGNoZXM7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5uZ0NvbnRlbnRJbmRleCA9IG5nQ29udGVudEluZGV4O1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmVuZFNvdXJjZVNwYW4gPSBlbmRTb3VyY2VTcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVsZW1lbnRBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRFbGVtZW50KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEVsZW1lbnRBc3Q7XG59KCkpO1xuLyoqXG4gKiBBIGA8bmctdGVtcGxhdGU+YCBlbGVtZW50IGluY2x1ZGVkIGluIGFuIEFuZ3VsYXIgdGVtcGxhdGUuXG4gKi9cbnZhciBFbWJlZGRlZFRlbXBsYXRlQXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGF0dHJzXG4gICAgICogQHBhcmFtIHs/fSBvdXRwdXRzXG4gICAgICogQHBhcmFtIHs/fSByZWZlcmVuY2VzXG4gICAgICogQHBhcmFtIHs/fSB2YXJpYWJsZXNcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZXNcbiAgICAgKiBAcGFyYW0gez99IHByb3ZpZGVyc1xuICAgICAqIEBwYXJhbSB7P30gaGFzVmlld0NvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7P30gcXVlcnlNYXRjaGVzXG4gICAgICogQHBhcmFtIHs/fSBjaGlsZHJlblxuICAgICAqIEBwYXJhbSB7P30gbmdDb250ZW50SW5kZXhcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFbWJlZGRlZFRlbXBsYXRlQXN0KGF0dHJzLCBvdXRwdXRzLCByZWZlcmVuY2VzLCB2YXJpYWJsZXMsIGRpcmVjdGl2ZXMsIHByb3ZpZGVycywgaGFzVmlld0NvbnRhaW5lciwgcXVlcnlNYXRjaGVzLCBjaGlsZHJlbiwgbmdDb250ZW50SW5kZXgsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLm91dHB1dHMgPSBvdXRwdXRzO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXMgPSByZWZlcmVuY2VzO1xuICAgICAgICB0aGlzLnZhcmlhYmxlcyA9IHZhcmlhYmxlcztcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcbiAgICAgICAgdGhpcy5wcm92aWRlcnMgPSBwcm92aWRlcnM7XG4gICAgICAgIHRoaXMuaGFzVmlld0NvbnRhaW5lciA9IGhhc1ZpZXdDb250YWluZXI7XG4gICAgICAgIHRoaXMucXVlcnlNYXRjaGVzID0gcXVlcnlNYXRjaGVzO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMubmdDb250ZW50SW5kZXggPSBuZ0NvbnRlbnRJbmRleDtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbWJlZGRlZFRlbXBsYXRlQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RW1iZWRkZWRUZW1wbGF0ZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBFbWJlZGRlZFRlbXBsYXRlQXN0O1xufSgpKTtcbi8qKlxuICogQSBkaXJlY3RpdmUgcHJvcGVydHkgd2l0aCBhIGJvdW5kIHZhbHVlIChlLmcuIGAqbmdJZj1cImNvbmRpdGlvblwiKS5cbiAqL1xudmFyIEJvdW5kRGlyZWN0aXZlUHJvcGVydHlBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlTmFtZVxuICAgICAqIEBwYXJhbSB7P30gdGVtcGxhdGVOYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJvdW5kRGlyZWN0aXZlUHJvcGVydHlBc3QoZGlyZWN0aXZlTmFtZSwgdGVtcGxhdGVOYW1lLCB2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZU5hbWUgPSBkaXJlY3RpdmVOYW1lO1xuICAgICAgICB0aGlzLnRlbXBsYXRlTmFtZSA9IHRlbXBsYXRlTmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJvdW5kRGlyZWN0aXZlUHJvcGVydHlBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXREaXJlY3RpdmVQcm9wZXJ0eSh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBCb3VuZERpcmVjdGl2ZVByb3BlcnR5QXN0O1xufSgpKTtcbi8qKlxuICogQSBkaXJlY3RpdmUgZGVjbGFyZWQgb24gYW4gZWxlbWVudC5cbiAqL1xudmFyIERpcmVjdGl2ZUFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3RpdmVcbiAgICAgKiBAcGFyYW0gez99IGlucHV0c1xuICAgICAqIEBwYXJhbSB7P30gaG9zdFByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0gez99IGhvc3RFdmVudHNcbiAgICAgKiBAcGFyYW0gez99IGNvbnRlbnRRdWVyeVN0YXJ0SWRcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEaXJlY3RpdmVBc3QoZGlyZWN0aXZlLCBpbnB1dHMsIGhvc3RQcm9wZXJ0aWVzLCBob3N0RXZlbnRzLCBjb250ZW50UXVlcnlTdGFydElkLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMuZGlyZWN0aXZlID0gZGlyZWN0aXZlO1xuICAgICAgICB0aGlzLmlucHV0cyA9IGlucHV0cztcbiAgICAgICAgdGhpcy5ob3N0UHJvcGVydGllcyA9IGhvc3RQcm9wZXJ0aWVzO1xuICAgICAgICB0aGlzLmhvc3RFdmVudHMgPSBob3N0RXZlbnRzO1xuICAgICAgICB0aGlzLmNvbnRlbnRRdWVyeVN0YXJ0SWQgPSBjb250ZW50UXVlcnlTdGFydElkO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERpcmVjdGl2ZUFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdERpcmVjdGl2ZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBEaXJlY3RpdmVBc3Q7XG59KCkpO1xuLyoqXG4gKiBBIHByb3ZpZGVyIGRlY2xhcmVkIG9uIGFuIGVsZW1lbnRcbiAqL1xudmFyIFByb3ZpZGVyQXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRva2VuXG4gICAgICogQHBhcmFtIHs/fSBtdWx0aVByb3ZpZGVyXG4gICAgICogQHBhcmFtIHs/fSBlYWdlclxuICAgICAqIEBwYXJhbSB7P30gcHJvdmlkZXJzXG4gICAgICogQHBhcmFtIHs/fSBwcm92aWRlclR5cGVcbiAgICAgKiBAcGFyYW0gez99IGxpZmVjeWNsZUhvb2tzXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gUHJvdmlkZXJBc3QodG9rZW4sIG11bHRpUHJvdmlkZXIsIGVhZ2VyLCBwcm92aWRlcnMsIHByb3ZpZGVyVHlwZSwgbGlmZWN5Y2xlSG9va3MsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB0aGlzLm11bHRpUHJvdmlkZXIgPSBtdWx0aVByb3ZpZGVyO1xuICAgICAgICB0aGlzLmVhZ2VyID0gZWFnZXI7XG4gICAgICAgIHRoaXMucHJvdmlkZXJzID0gcHJvdmlkZXJzO1xuICAgICAgICB0aGlzLnByb3ZpZGVyVHlwZSA9IHByb3ZpZGVyVHlwZTtcbiAgICAgICAgdGhpcy5saWZlY3ljbGVIb29rcyA9IGxpZmVjeWNsZUhvb2tzO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFByb3ZpZGVyQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIC8vIE5vIHZpc2l0IG1ldGhvZCBpbiB0aGUgdmlzaXRvciBmb3Igbm93Li4uXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIFByb3ZpZGVyQXN0O1xufSgpKTtcbnZhciBQcm92aWRlckFzdFR5cGUgPSB7fTtcblByb3ZpZGVyQXN0VHlwZS5QdWJsaWNTZXJ2aWNlID0gMDtcblByb3ZpZGVyQXN0VHlwZS5Qcml2YXRlU2VydmljZSA9IDE7XG5Qcm92aWRlckFzdFR5cGUuQ29tcG9uZW50ID0gMjtcblByb3ZpZGVyQXN0VHlwZS5EaXJlY3RpdmUgPSAzO1xuUHJvdmlkZXJBc3RUeXBlLkJ1aWx0aW4gPSA0O1xuUHJvdmlkZXJBc3RUeXBlW1Byb3ZpZGVyQXN0VHlwZS5QdWJsaWNTZXJ2aWNlXSA9IFwiUHVibGljU2VydmljZVwiO1xuUHJvdmlkZXJBc3RUeXBlW1Byb3ZpZGVyQXN0VHlwZS5Qcml2YXRlU2VydmljZV0gPSBcIlByaXZhdGVTZXJ2aWNlXCI7XG5Qcm92aWRlckFzdFR5cGVbUHJvdmlkZXJBc3RUeXBlLkNvbXBvbmVudF0gPSBcIkNvbXBvbmVudFwiO1xuUHJvdmlkZXJBc3RUeXBlW1Byb3ZpZGVyQXN0VHlwZS5EaXJlY3RpdmVdID0gXCJEaXJlY3RpdmVcIjtcblByb3ZpZGVyQXN0VHlwZVtQcm92aWRlckFzdFR5cGUuQnVpbHRpbl0gPSBcIkJ1aWx0aW5cIjtcbi8qKlxuICogUG9zaXRpb24gd2hlcmUgY29udGVudCBpcyB0byBiZSBwcm9qZWN0ZWQgKGluc3RhbmNlIG9mIGA8bmctY29udGVudD5gIGluIGEgdGVtcGxhdGUpLlxuICovXG52YXIgTmdDb250ZW50QXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICogQHBhcmFtIHs/fSBuZ0NvbnRlbnRJbmRleFxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE5nQ29udGVudEFzdChpbmRleCwgbmdDb250ZW50SW5kZXgsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLm5nQ29udGVudEluZGV4ID0gbmdDb250ZW50SW5kZXg7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTmdDb250ZW50QXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TmdDb250ZW50KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIE5nQ29udGVudEFzdDtcbn0oKSk7XG52YXIgUHJvcGVydHlCaW5kaW5nVHlwZSA9IHt9O1xuUHJvcGVydHlCaW5kaW5nVHlwZS5Qcm9wZXJ0eSA9IDA7XG5Qcm9wZXJ0eUJpbmRpbmdUeXBlLkF0dHJpYnV0ZSA9IDE7XG5Qcm9wZXJ0eUJpbmRpbmdUeXBlLkNsYXNzID0gMjtcblByb3BlcnR5QmluZGluZ1R5cGUuU3R5bGUgPSAzO1xuUHJvcGVydHlCaW5kaW5nVHlwZS5BbmltYXRpb24gPSA0O1xuUHJvcGVydHlCaW5kaW5nVHlwZVtQcm9wZXJ0eUJpbmRpbmdUeXBlLlByb3BlcnR5XSA9IFwiUHJvcGVydHlcIjtcblByb3BlcnR5QmluZGluZ1R5cGVbUHJvcGVydHlCaW5kaW5nVHlwZS5BdHRyaWJ1dGVdID0gXCJBdHRyaWJ1dGVcIjtcblByb3BlcnR5QmluZGluZ1R5cGVbUHJvcGVydHlCaW5kaW5nVHlwZS5DbGFzc10gPSBcIkNsYXNzXCI7XG5Qcm9wZXJ0eUJpbmRpbmdUeXBlW1Byb3BlcnR5QmluZGluZ1R5cGUuU3R5bGVdID0gXCJTdHlsZVwiO1xuUHJvcGVydHlCaW5kaW5nVHlwZVtQcm9wZXJ0eUJpbmRpbmdUeXBlLkFuaW1hdGlvbl0gPSBcIkFuaW1hdGlvblwiO1xuLyoqXG4gKiBBIHZpc2l0b3IgdGhhdCBhY2NlcHRzIGVhY2ggbm9kZSBidXQgZG9lc24ndCBkbyBhbnl0aGluZy4gSXQgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZFxuICogYXMgdGhlIGJhc2UgY2xhc3MgZm9yIGEgdmlzaXRvciB0aGF0IGlzIG9ubHkgaW50ZXJlc3RlZCBpbiBhIHN1YnNldCBvZiB0aGUgbm9kZSB0eXBlcy5cbiAqL1xudmFyIE51bGxUZW1wbGF0ZVZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE51bGxUZW1wbGF0ZVZpc2l0b3IoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOdWxsVGVtcGxhdGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdE5nQ29udGVudCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTnVsbFRlbXBsYXRlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbWJlZGRlZFRlbXBsYXRlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOdWxsVGVtcGxhdGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE51bGxUZW1wbGF0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVmZXJlbmNlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOdWxsVGVtcGxhdGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdFZhcmlhYmxlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOdWxsVGVtcGxhdGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV2ZW50ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOdWxsVGVtcGxhdGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEVsZW1lbnRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTnVsbFRlbXBsYXRlVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOdWxsVGVtcGxhdGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJvdW5kVGV4dCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTnVsbFRlbXBsYXRlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOdWxsVGVtcGxhdGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdERpcmVjdGl2ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTnVsbFRlbXBsYXRlVmlzaXRvci5wcm90b3R5cGUudmlzaXREaXJlY3RpdmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICByZXR1cm4gTnVsbFRlbXBsYXRlVmlzaXRvcjtcbn0oKSk7XG4vKipcbiAqIEJhc2UgY2xhc3MgdGhhdCBjYW4gYmUgdXNlZCB0byBidWlsZCBhIHZpc2l0b3IgdGhhdCB2aXNpdHMgZWFjaCBub2RlXG4gKiBpbiBhbiB0ZW1wbGF0ZSBhc3QgcmVjdXJzaXZlbHkuXG4gKi9cbnZhciBSZWN1cnNpdmVUZW1wbGF0ZUFzdFZpc2l0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFJlY3Vyc2l2ZVRlbXBsYXRlQXN0VmlzaXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWN1cnNpdmVUZW1wbGF0ZUFzdFZpc2l0b3IoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlVGVtcGxhdGVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEVtYmVkZGVkVGVtcGxhdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0Q2hpbGRyZW4oY29udGV4dCwgZnVuY3Rpb24gKHZpc2l0KSB7XG4gICAgICAgICAgICB2aXNpdChhc3QuYXR0cnMpO1xuICAgICAgICAgICAgdmlzaXQoYXN0LnJlZmVyZW5jZXMpO1xuICAgICAgICAgICAgdmlzaXQoYXN0LnZhcmlhYmxlcyk7XG4gICAgICAgICAgICB2aXNpdChhc3QuZGlyZWN0aXZlcyk7XG4gICAgICAgICAgICB2aXNpdChhc3QucHJvdmlkZXJzKTtcbiAgICAgICAgICAgIHZpc2l0KGFzdC5jaGlsZHJlbik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZVRlbXBsYXRlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGNvbnRleHQsIGZ1bmN0aW9uICh2aXNpdCkge1xuICAgICAgICAgICAgdmlzaXQoYXN0LmF0dHJzKTtcbiAgICAgICAgICAgIHZpc2l0KGFzdC5pbnB1dHMpO1xuICAgICAgICAgICAgdmlzaXQoYXN0Lm91dHB1dHMpO1xuICAgICAgICAgICAgdmlzaXQoYXN0LnJlZmVyZW5jZXMpO1xuICAgICAgICAgICAgdmlzaXQoYXN0LmRpcmVjdGl2ZXMpO1xuICAgICAgICAgICAgdmlzaXQoYXN0LnByb3ZpZGVycyk7XG4gICAgICAgICAgICB2aXNpdChhc3QuY2hpbGRyZW4pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVUZW1wbGF0ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGlyZWN0aXZlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGNvbnRleHQsIGZ1bmN0aW9uICh2aXNpdCkge1xuICAgICAgICAgICAgdmlzaXQoYXN0LmlucHV0cyk7XG4gICAgICAgICAgICB2aXNpdChhc3QuaG9zdFByb3BlcnRpZXMpO1xuICAgICAgICAgICAgdmlzaXQoYXN0Lmhvc3RFdmVudHMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHBhcmFtIHs/fSBjYlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlVGVtcGxhdGVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdENoaWxkcmVuID0gZnVuY3Rpb24gKGNvbnRleHQsIGNiKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdCA9IHRoaXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdGVtcGxhdGUgVFxuICAgICAgICAgKiBAcGFyYW0gez99IGNoaWxkcmVuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiB2aXNpdChjaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGVtcGxhdGVWaXNpdEFsbCh0LCBjaGlsZHJlbiwgY29udGV4dCkpO1xuICAgICAgICB9XG4gICAgICAgIGNiKHZpc2l0KTtcbiAgICAgICAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgcmVzdWx0cyk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVjdXJzaXZlVGVtcGxhdGVBc3RWaXNpdG9yO1xufShOdWxsVGVtcGxhdGVWaXNpdG9yKSk7XG4vKipcbiAqIFZpc2l0IGV2ZXJ5IG5vZGUgaW4gYSBsaXN0IG9mIHtcXEBsaW5rIFRlbXBsYXRlQXN0fXMgd2l0aCB0aGUgZ2l2ZW4ge1xcQGxpbmsgVGVtcGxhdGVBc3RWaXNpdG9yfS5cbiAqIEBwYXJhbSB7P30gdmlzaXRvclxuICogQHBhcmFtIHs/fSBhc3RzXG4gKiBAcGFyYW0gez89fSBjb250ZXh0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB0ZW1wbGF0ZVZpc2l0QWxsKHZpc2l0b3IsIGFzdHMsIGNvbnRleHQpIHtcbiAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gW107XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlzaXQgPSB2aXNpdG9yLnZpc2l0ID9cbiAgICAgICAgZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gKCh2aXNpdG9yLnZpc2l0KSkoYXN0LCBjb250ZXh0KSB8fCBhc3QudmlzaXQodmlzaXRvciwgY29udGV4dCk7IH0gOlxuICAgICAgICBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBhc3QudmlzaXQodmlzaXRvciwgY29udGV4dCk7IH07XG4gICAgYXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0UmVzdWx0ID0gdmlzaXQoYXN0KTtcbiAgICAgICAgaWYgKGFzdFJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXN0UmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEEgdG9rZW4gcmVwcmVzZW50aW5nIHRoZSBhIHJlZmVyZW5jZSB0byBhIHN0YXRpYyB0eXBlLlxuICpcbiAqIFRoaXMgdG9rZW4gaXMgdW5pcXVlIGZvciBhIGZpbGVQYXRoIGFuZCBuYW1lIGFuZCBjYW4gYmUgdXNlZCBhcyBhIGhhc2ggdGFibGUga2V5LlxuICovXG52YXIgU3RhdGljU3ltYm9sID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZpbGVQYXRoXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBtZW1iZXJzXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3RhdGljU3ltYm9sKGZpbGVQYXRoLCBuYW1lLCBtZW1iZXJzKSB7XG4gICAgICAgIHRoaXMuZmlsZVBhdGggPSBmaWxlUGF0aDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5tZW1iZXJzID0gbWVtYmVycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNTeW1ib2wucHJvdG90eXBlLmFzc2VydE5vTWVtYmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubWVtYmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgc3RhdGU6IHN5bWJvbCB3aXRob3V0IG1lbWJlcnMgZXhwZWN0ZWQsIGJ1dCBnb3QgXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzKSArIFwiLlwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN0YXRpY1N5bWJvbDtcbn0oKSk7XG4vKipcbiAqIEEgY2FjaGUgb2Ygc3RhdGljIHN5bWJvbCB1c2VkIGJ5IHRoZSBTdGF0aWNSZWZsZWN0b3IgdG8gcmV0dXJuIHRoZSBzYW1lIHN5bWJvbCBmb3IgdGhlXG4gKiBzYW1lIHN5bWJvbCB2YWx1ZXMuXG4gKi9cbnZhciBTdGF0aWNTeW1ib2xDYWNoZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhdGljU3ltYm9sQ2FjaGUoKSB7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGVjbGFyYXRpb25GaWxlXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/PX0gbWVtYmVyc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljU3ltYm9sQ2FjaGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChkZWNsYXJhdGlvbkZpbGUsIG5hbWUsIG1lbWJlcnMpIHtcbiAgICAgICAgbWVtYmVycyA9IG1lbWJlcnMgfHwgW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lbWJlclN1ZmZpeCA9IG1lbWJlcnMubGVuZ3RoID8gXCIuXCIgKyBtZW1iZXJzLmpvaW4oJy4nKSA6ICcnO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZXkgPSBcIlxcXCJcIiArIGRlY2xhcmF0aW9uRmlsZSArIFwiXFxcIi5cIiArIG5hbWUgKyBtZW1iZXJTdWZmaXg7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHRoaXMuY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgU3RhdGljU3ltYm9sKGRlY2xhcmF0aW9uRmlsZSwgbmFtZSwgbWVtYmVycyk7XG4gICAgICAgICAgICB0aGlzLmNhY2hlLnNldChrZXksIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0aWNTeW1ib2xDYWNoZTtcbn0oKSk7XG52YXIgVGFnQ29udGVudFR5cGUgPSB7fTtcblRhZ0NvbnRlbnRUeXBlLlJBV19URVhUID0gMDtcblRhZ0NvbnRlbnRUeXBlLkVTQ0FQQUJMRV9SQVdfVEVYVCA9IDE7XG5UYWdDb250ZW50VHlwZS5QQVJTQUJMRV9EQVRBID0gMjtcblRhZ0NvbnRlbnRUeXBlW1RhZ0NvbnRlbnRUeXBlLlJBV19URVhUXSA9IFwiUkFXX1RFWFRcIjtcblRhZ0NvbnRlbnRUeXBlW1RhZ0NvbnRlbnRUeXBlLkVTQ0FQQUJMRV9SQVdfVEVYVF0gPSBcIkVTQ0FQQUJMRV9SQVdfVEVYVFwiO1xuVGFnQ29udGVudFR5cGVbVGFnQ29udGVudFR5cGUuUEFSU0FCTEVfREFUQV0gPSBcIlBBUlNBQkxFX0RBVEFcIjtcbi8qKlxuICogQHBhcmFtIHs/fSBlbGVtZW50TmFtZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc3BsaXROc05hbWUoZWxlbWVudE5hbWUpIHtcbiAgICBpZiAoZWxlbWVudE5hbWVbMF0gIT0gJzonKSB7XG4gICAgICAgIHJldHVybiBbbnVsbCwgZWxlbWVudE5hbWVdO1xuICAgIH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb2xvbkluZGV4ID0gZWxlbWVudE5hbWUuaW5kZXhPZignOicsIDEpO1xuICAgIGlmIChjb2xvbkluZGV4ID09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGZvcm1hdCBcXFwiXCIgKyBlbGVtZW50TmFtZSArIFwiXFxcIiBleHBlY3RpbmcgXFxcIjpuYW1lc3BhY2U6bmFtZVxcXCJcIik7XG4gICAgfVxuICAgIHJldHVybiBbZWxlbWVudE5hbWUuc2xpY2UoMSwgY29sb25JbmRleCksIGVsZW1lbnROYW1lLnNsaWNlKGNvbG9uSW5kZXggKyAxKV07XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdGFnTmFtZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNOZ0NvbnRhaW5lcih0YWdOYW1lKSB7XG4gICAgcmV0dXJuIHNwbGl0TnNOYW1lKHRhZ05hbWUpWzFdID09PSAnbmctY29udGFpbmVyJztcbn1cbi8qKlxuICogQHBhcmFtIHs/fSB0YWdOYW1lXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc05nQ29udGVudCh0YWdOYW1lKSB7XG4gICAgcmV0dXJuIHNwbGl0TnNOYW1lKHRhZ05hbWUpWzFdID09PSAnbmctY29udGVudCc7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdGFnTmFtZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNOZ1RlbXBsYXRlKHRhZ05hbWUpIHtcbiAgICByZXR1cm4gc3BsaXROc05hbWUodGFnTmFtZSlbMV0gPT09ICduZy10ZW1wbGF0ZSc7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZnVsbE5hbWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGdldE5zUHJlZml4KGZ1bGxOYW1lKSB7XG4gICAgcmV0dXJuIGZ1bGxOYW1lID09PSBudWxsID8gbnVsbCA6IHNwbGl0TnNOYW1lKGZ1bGxOYW1lKVswXTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBwcmVmaXhcbiAqIEBwYXJhbSB7P30gbG9jYWxOYW1lXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBtZXJnZU5zQW5kTmFtZShwcmVmaXgsIGxvY2FsTmFtZSkge1xuICAgIHJldHVybiBwcmVmaXggPyBcIjpcIiArIHByZWZpeCArIFwiOlwiICsgbG9jYWxOYW1lIDogbG9jYWxOYW1lO1xufVxuLy8gc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1MS9zeW50YXguaHRtbCNuYW1lZC1jaGFyYWN0ZXItcmVmZXJlbmNlc1xuLy8gc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VudGl0aWVzLmpzb25cbi8vIFRoaXMgbGlzdCBpcyBub3QgZXhoYXVzdGl2ZSB0byBrZWVwIHRoZSBjb21waWxlciBmb290cHJpbnQgbG93LlxuLy8gVGhlIGAmIzEyMztgIC8gYCYjeDFhYjtgIHN5bnRheCBzaG91bGQgYmUgdXNlZCB3aGVuIHRoZSBuYW1lZCBjaGFyYWN0ZXIgcmVmZXJlbmNlIGRvZXMgbm90XG4vLyBleGlzdC5cbnZhciBOQU1FRF9FTlRJVElFUyA9IHtcbiAgICAnQWFjdXRlJzogJ1xcdTAwQzEnLFxuICAgICdhYWN1dGUnOiAnXFx1MDBFMScsXG4gICAgJ0FjaXJjJzogJ1xcdTAwQzInLFxuICAgICdhY2lyYyc6ICdcXHUwMEUyJyxcbiAgICAnYWN1dGUnOiAnXFx1MDBCNCcsXG4gICAgJ0FFbGlnJzogJ1xcdTAwQzYnLFxuICAgICdhZWxpZyc6ICdcXHUwMEU2JyxcbiAgICAnQWdyYXZlJzogJ1xcdTAwQzAnLFxuICAgICdhZ3JhdmUnOiAnXFx1MDBFMCcsXG4gICAgJ2FsZWZzeW0nOiAnXFx1MjEzNScsXG4gICAgJ0FscGhhJzogJ1xcdTAzOTEnLFxuICAgICdhbHBoYSc6ICdcXHUwM0IxJyxcbiAgICAnYW1wJzogJyYnLFxuICAgICdhbmQnOiAnXFx1MjIyNycsXG4gICAgJ2FuZyc6ICdcXHUyMjIwJyxcbiAgICAnYXBvcyc6ICdcXHUwMDI3JyxcbiAgICAnQXJpbmcnOiAnXFx1MDBDNScsXG4gICAgJ2FyaW5nJzogJ1xcdTAwRTUnLFxuICAgICdhc3ltcCc6ICdcXHUyMjQ4JyxcbiAgICAnQXRpbGRlJzogJ1xcdTAwQzMnLFxuICAgICdhdGlsZGUnOiAnXFx1MDBFMycsXG4gICAgJ0F1bWwnOiAnXFx1MDBDNCcsXG4gICAgJ2F1bWwnOiAnXFx1MDBFNCcsXG4gICAgJ2JkcXVvJzogJ1xcdTIwMUUnLFxuICAgICdCZXRhJzogJ1xcdTAzOTInLFxuICAgICdiZXRhJzogJ1xcdTAzQjInLFxuICAgICdicnZiYXInOiAnXFx1MDBBNicsXG4gICAgJ2J1bGwnOiAnXFx1MjAyMicsXG4gICAgJ2NhcCc6ICdcXHUyMjI5JyxcbiAgICAnQ2NlZGlsJzogJ1xcdTAwQzcnLFxuICAgICdjY2VkaWwnOiAnXFx1MDBFNycsXG4gICAgJ2NlZGlsJzogJ1xcdTAwQjgnLFxuICAgICdjZW50JzogJ1xcdTAwQTInLFxuICAgICdDaGknOiAnXFx1MDNBNycsXG4gICAgJ2NoaSc6ICdcXHUwM0M3JyxcbiAgICAnY2lyYyc6ICdcXHUwMkM2JyxcbiAgICAnY2x1YnMnOiAnXFx1MjY2MycsXG4gICAgJ2NvbmcnOiAnXFx1MjI0NScsXG4gICAgJ2NvcHknOiAnXFx1MDBBOScsXG4gICAgJ2NyYXJyJzogJ1xcdTIxQjUnLFxuICAgICdjdXAnOiAnXFx1MjIyQScsXG4gICAgJ2N1cnJlbic6ICdcXHUwMEE0JyxcbiAgICAnZGFnZ2VyJzogJ1xcdTIwMjAnLFxuICAgICdEYWdnZXInOiAnXFx1MjAyMScsXG4gICAgJ2RhcnInOiAnXFx1MjE5MycsXG4gICAgJ2RBcnInOiAnXFx1MjFEMycsXG4gICAgJ2RlZyc6ICdcXHUwMEIwJyxcbiAgICAnRGVsdGEnOiAnXFx1MDM5NCcsXG4gICAgJ2RlbHRhJzogJ1xcdTAzQjQnLFxuICAgICdkaWFtcyc6ICdcXHUyNjY2JyxcbiAgICAnZGl2aWRlJzogJ1xcdTAwRjcnLFxuICAgICdFYWN1dGUnOiAnXFx1MDBDOScsXG4gICAgJ2VhY3V0ZSc6ICdcXHUwMEU5JyxcbiAgICAnRWNpcmMnOiAnXFx1MDBDQScsXG4gICAgJ2VjaXJjJzogJ1xcdTAwRUEnLFxuICAgICdFZ3JhdmUnOiAnXFx1MDBDOCcsXG4gICAgJ2VncmF2ZSc6ICdcXHUwMEU4JyxcbiAgICAnZW1wdHknOiAnXFx1MjIwNScsXG4gICAgJ2Vtc3AnOiAnXFx1MjAwMycsXG4gICAgJ2Vuc3AnOiAnXFx1MjAwMicsXG4gICAgJ0Vwc2lsb24nOiAnXFx1MDM5NScsXG4gICAgJ2Vwc2lsb24nOiAnXFx1MDNCNScsXG4gICAgJ2VxdWl2JzogJ1xcdTIyNjEnLFxuICAgICdFdGEnOiAnXFx1MDM5NycsXG4gICAgJ2V0YSc6ICdcXHUwM0I3JyxcbiAgICAnRVRIJzogJ1xcdTAwRDAnLFxuICAgICdldGgnOiAnXFx1MDBGMCcsXG4gICAgJ0V1bWwnOiAnXFx1MDBDQicsXG4gICAgJ2V1bWwnOiAnXFx1MDBFQicsXG4gICAgJ2V1cm8nOiAnXFx1MjBBQycsXG4gICAgJ2V4aXN0JzogJ1xcdTIyMDMnLFxuICAgICdmbm9mJzogJ1xcdTAxOTInLFxuICAgICdmb3JhbGwnOiAnXFx1MjIwMCcsXG4gICAgJ2ZyYWMxMic6ICdcXHUwMEJEJyxcbiAgICAnZnJhYzE0JzogJ1xcdTAwQkMnLFxuICAgICdmcmFjMzQnOiAnXFx1MDBCRScsXG4gICAgJ2ZyYXNsJzogJ1xcdTIwNDQnLFxuICAgICdHYW1tYSc6ICdcXHUwMzkzJyxcbiAgICAnZ2FtbWEnOiAnXFx1MDNCMycsXG4gICAgJ2dlJzogJ1xcdTIyNjUnLFxuICAgICdndCc6ICc+JyxcbiAgICAnaGFycic6ICdcXHUyMTk0JyxcbiAgICAnaEFycic6ICdcXHUyMUQ0JyxcbiAgICAnaGVhcnRzJzogJ1xcdTI2NjUnLFxuICAgICdoZWxsaXAnOiAnXFx1MjAyNicsXG4gICAgJ0lhY3V0ZSc6ICdcXHUwMENEJyxcbiAgICAnaWFjdXRlJzogJ1xcdTAwRUQnLFxuICAgICdJY2lyYyc6ICdcXHUwMENFJyxcbiAgICAnaWNpcmMnOiAnXFx1MDBFRScsXG4gICAgJ2lleGNsJzogJ1xcdTAwQTEnLFxuICAgICdJZ3JhdmUnOiAnXFx1MDBDQycsXG4gICAgJ2lncmF2ZSc6ICdcXHUwMEVDJyxcbiAgICAnaW1hZ2UnOiAnXFx1MjExMScsXG4gICAgJ2luZmluJzogJ1xcdTIyMUUnLFxuICAgICdpbnQnOiAnXFx1MjIyQicsXG4gICAgJ0lvdGEnOiAnXFx1MDM5OScsXG4gICAgJ2lvdGEnOiAnXFx1MDNCOScsXG4gICAgJ2lxdWVzdCc6ICdcXHUwMEJGJyxcbiAgICAnaXNpbic6ICdcXHUyMjA4JyxcbiAgICAnSXVtbCc6ICdcXHUwMENGJyxcbiAgICAnaXVtbCc6ICdcXHUwMEVGJyxcbiAgICAnS2FwcGEnOiAnXFx1MDM5QScsXG4gICAgJ2thcHBhJzogJ1xcdTAzQkEnLFxuICAgICdMYW1iZGEnOiAnXFx1MDM5QicsXG4gICAgJ2xhbWJkYSc6ICdcXHUwM0JCJyxcbiAgICAnbGFuZyc6ICdcXHUyN0U4JyxcbiAgICAnbGFxdW8nOiAnXFx1MDBBQicsXG4gICAgJ2xhcnInOiAnXFx1MjE5MCcsXG4gICAgJ2xBcnInOiAnXFx1MjFEMCcsXG4gICAgJ2xjZWlsJzogJ1xcdTIzMDgnLFxuICAgICdsZHF1byc6ICdcXHUyMDFDJyxcbiAgICAnbGUnOiAnXFx1MjI2NCcsXG4gICAgJ2xmbG9vcic6ICdcXHUyMzBBJyxcbiAgICAnbG93YXN0JzogJ1xcdTIyMTcnLFxuICAgICdsb3onOiAnXFx1MjVDQScsXG4gICAgJ2xybSc6ICdcXHUyMDBFJyxcbiAgICAnbHNhcXVvJzogJ1xcdTIwMzknLFxuICAgICdsc3F1byc6ICdcXHUyMDE4JyxcbiAgICAnbHQnOiAnPCcsXG4gICAgJ21hY3InOiAnXFx1MDBBRicsXG4gICAgJ21kYXNoJzogJ1xcdTIwMTQnLFxuICAgICdtaWNybyc6ICdcXHUwMEI1JyxcbiAgICAnbWlkZG90JzogJ1xcdTAwQjcnLFxuICAgICdtaW51cyc6ICdcXHUyMjEyJyxcbiAgICAnTXUnOiAnXFx1MDM5QycsXG4gICAgJ211JzogJ1xcdTAzQkMnLFxuICAgICduYWJsYSc6ICdcXHUyMjA3JyxcbiAgICAnbmJzcCc6ICdcXHUwMEEwJyxcbiAgICAnbmRhc2gnOiAnXFx1MjAxMycsXG4gICAgJ25lJzogJ1xcdTIyNjAnLFxuICAgICduaSc6ICdcXHUyMjBCJyxcbiAgICAnbm90JzogJ1xcdTAwQUMnLFxuICAgICdub3Rpbic6ICdcXHUyMjA5JyxcbiAgICAnbnN1Yic6ICdcXHUyMjg0JyxcbiAgICAnTnRpbGRlJzogJ1xcdTAwRDEnLFxuICAgICdudGlsZGUnOiAnXFx1MDBGMScsXG4gICAgJ051JzogJ1xcdTAzOUQnLFxuICAgICdudSc6ICdcXHUwM0JEJyxcbiAgICAnT2FjdXRlJzogJ1xcdTAwRDMnLFxuICAgICdvYWN1dGUnOiAnXFx1MDBGMycsXG4gICAgJ09jaXJjJzogJ1xcdTAwRDQnLFxuICAgICdvY2lyYyc6ICdcXHUwMEY0JyxcbiAgICAnT0VsaWcnOiAnXFx1MDE1MicsXG4gICAgJ29lbGlnJzogJ1xcdTAxNTMnLFxuICAgICdPZ3JhdmUnOiAnXFx1MDBEMicsXG4gICAgJ29ncmF2ZSc6ICdcXHUwMEYyJyxcbiAgICAnb2xpbmUnOiAnXFx1MjAzRScsXG4gICAgJ09tZWdhJzogJ1xcdTAzQTknLFxuICAgICdvbWVnYSc6ICdcXHUwM0M5JyxcbiAgICAnT21pY3Jvbic6ICdcXHUwMzlGJyxcbiAgICAnb21pY3Jvbic6ICdcXHUwM0JGJyxcbiAgICAnb3BsdXMnOiAnXFx1MjI5NScsXG4gICAgJ29yJzogJ1xcdTIyMjgnLFxuICAgICdvcmRmJzogJ1xcdTAwQUEnLFxuICAgICdvcmRtJzogJ1xcdTAwQkEnLFxuICAgICdPc2xhc2gnOiAnXFx1MDBEOCcsXG4gICAgJ29zbGFzaCc6ICdcXHUwMEY4JyxcbiAgICAnT3RpbGRlJzogJ1xcdTAwRDUnLFxuICAgICdvdGlsZGUnOiAnXFx1MDBGNScsXG4gICAgJ290aW1lcyc6ICdcXHUyMjk3JyxcbiAgICAnT3VtbCc6ICdcXHUwMEQ2JyxcbiAgICAnb3VtbCc6ICdcXHUwMEY2JyxcbiAgICAncGFyYSc6ICdcXHUwMEI2JyxcbiAgICAncGVybWlsJzogJ1xcdTIwMzAnLFxuICAgICdwZXJwJzogJ1xcdTIyQTUnLFxuICAgICdQaGknOiAnXFx1MDNBNicsXG4gICAgJ3BoaSc6ICdcXHUwM0M2JyxcbiAgICAnUGknOiAnXFx1MDNBMCcsXG4gICAgJ3BpJzogJ1xcdTAzQzAnLFxuICAgICdwaXYnOiAnXFx1MDNENicsXG4gICAgJ3BsdXNtbic6ICdcXHUwMEIxJyxcbiAgICAncG91bmQnOiAnXFx1MDBBMycsXG4gICAgJ3ByaW1lJzogJ1xcdTIwMzInLFxuICAgICdQcmltZSc6ICdcXHUyMDMzJyxcbiAgICAncHJvZCc6ICdcXHUyMjBGJyxcbiAgICAncHJvcCc6ICdcXHUyMjFEJyxcbiAgICAnUHNpJzogJ1xcdTAzQTgnLFxuICAgICdwc2knOiAnXFx1MDNDOCcsXG4gICAgJ3F1b3QnOiAnXFx1MDAyMicsXG4gICAgJ3JhZGljJzogJ1xcdTIyMUEnLFxuICAgICdyYW5nJzogJ1xcdTI3RTknLFxuICAgICdyYXF1byc6ICdcXHUwMEJCJyxcbiAgICAncmFycic6ICdcXHUyMTkyJyxcbiAgICAnckFycic6ICdcXHUyMUQyJyxcbiAgICAncmNlaWwnOiAnXFx1MjMwOScsXG4gICAgJ3JkcXVvJzogJ1xcdTIwMUQnLFxuICAgICdyZWFsJzogJ1xcdTIxMUMnLFxuICAgICdyZWcnOiAnXFx1MDBBRScsXG4gICAgJ3JmbG9vcic6ICdcXHUyMzBCJyxcbiAgICAnUmhvJzogJ1xcdTAzQTEnLFxuICAgICdyaG8nOiAnXFx1MDNDMScsXG4gICAgJ3JsbSc6ICdcXHUyMDBGJyxcbiAgICAncnNhcXVvJzogJ1xcdTIwM0EnLFxuICAgICdyc3F1byc6ICdcXHUyMDE5JyxcbiAgICAnc2JxdW8nOiAnXFx1MjAxQScsXG4gICAgJ1NjYXJvbic6ICdcXHUwMTYwJyxcbiAgICAnc2Nhcm9uJzogJ1xcdTAxNjEnLFxuICAgICdzZG90JzogJ1xcdTIyQzUnLFxuICAgICdzZWN0JzogJ1xcdTAwQTcnLFxuICAgICdzaHknOiAnXFx1MDBBRCcsXG4gICAgJ1NpZ21hJzogJ1xcdTAzQTMnLFxuICAgICdzaWdtYSc6ICdcXHUwM0MzJyxcbiAgICAnc2lnbWFmJzogJ1xcdTAzQzInLFxuICAgICdzaW0nOiAnXFx1MjIzQycsXG4gICAgJ3NwYWRlcyc6ICdcXHUyNjYwJyxcbiAgICAnc3ViJzogJ1xcdTIyODInLFxuICAgICdzdWJlJzogJ1xcdTIyODYnLFxuICAgICdzdW0nOiAnXFx1MjIxMScsXG4gICAgJ3N1cCc6ICdcXHUyMjgzJyxcbiAgICAnc3VwMSc6ICdcXHUwMEI5JyxcbiAgICAnc3VwMic6ICdcXHUwMEIyJyxcbiAgICAnc3VwMyc6ICdcXHUwMEIzJyxcbiAgICAnc3VwZSc6ICdcXHUyMjg3JyxcbiAgICAnc3psaWcnOiAnXFx1MDBERicsXG4gICAgJ1RhdSc6ICdcXHUwM0E0JyxcbiAgICAndGF1JzogJ1xcdTAzQzQnLFxuICAgICd0aGVyZTQnOiAnXFx1MjIzNCcsXG4gICAgJ1RoZXRhJzogJ1xcdTAzOTgnLFxuICAgICd0aGV0YSc6ICdcXHUwM0I4JyxcbiAgICAndGhldGFzeW0nOiAnXFx1MDNEMScsXG4gICAgJ3RoaW5zcCc6ICdcXHUyMDA5JyxcbiAgICAnVEhPUk4nOiAnXFx1MDBERScsXG4gICAgJ3Rob3JuJzogJ1xcdTAwRkUnLFxuICAgICd0aWxkZSc6ICdcXHUwMkRDJyxcbiAgICAndGltZXMnOiAnXFx1MDBENycsXG4gICAgJ3RyYWRlJzogJ1xcdTIxMjInLFxuICAgICdVYWN1dGUnOiAnXFx1MDBEQScsXG4gICAgJ3VhY3V0ZSc6ICdcXHUwMEZBJyxcbiAgICAndWFycic6ICdcXHUyMTkxJyxcbiAgICAndUFycic6ICdcXHUyMUQxJyxcbiAgICAnVWNpcmMnOiAnXFx1MDBEQicsXG4gICAgJ3VjaXJjJzogJ1xcdTAwRkInLFxuICAgICdVZ3JhdmUnOiAnXFx1MDBEOScsXG4gICAgJ3VncmF2ZSc6ICdcXHUwMEY5JyxcbiAgICAndW1sJzogJ1xcdTAwQTgnLFxuICAgICd1cHNpaCc6ICdcXHUwM0QyJyxcbiAgICAnVXBzaWxvbic6ICdcXHUwM0E1JyxcbiAgICAndXBzaWxvbic6ICdcXHUwM0M1JyxcbiAgICAnVXVtbCc6ICdcXHUwMERDJyxcbiAgICAndXVtbCc6ICdcXHUwMEZDJyxcbiAgICAnd2VpZXJwJzogJ1xcdTIxMTgnLFxuICAgICdYaSc6ICdcXHUwMzlFJyxcbiAgICAneGknOiAnXFx1MDNCRScsXG4gICAgJ1lhY3V0ZSc6ICdcXHUwMEREJyxcbiAgICAneWFjdXRlJzogJ1xcdTAwRkQnLFxuICAgICd5ZW4nOiAnXFx1MDBBNScsXG4gICAgJ3l1bWwnOiAnXFx1MDBGRicsXG4gICAgJ1l1bWwnOiAnXFx1MDE3OCcsXG4gICAgJ1pldGEnOiAnXFx1MDM5NicsXG4gICAgJ3pldGEnOiAnXFx1MDNCNicsXG4gICAgJ3p3aic6ICdcXHUyMDBEJyxcbiAgICAnenduaic6ICdcXHUyMDBDJyxcbn07XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgSHRtbFRhZ0RlZmluaXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IF9fMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEh0bWxUYWdEZWZpbml0aW9uKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBjbG9zZWRCeUNoaWxkcmVuID0gX2IuY2xvc2VkQnlDaGlsZHJlbiwgcmVxdWlyZWRQYXJlbnRzID0gX2IucmVxdWlyZWRQYXJlbnRzLCBpbXBsaWNpdE5hbWVzcGFjZVByZWZpeCA9IF9iLmltcGxpY2l0TmFtZXNwYWNlUHJlZml4LCBfYyA9IF9iLmNvbnRlbnRUeXBlLCBjb250ZW50VHlwZSA9IF9jID09PSB2b2lkIDAgPyBUYWdDb250ZW50VHlwZS5QQVJTQUJMRV9EQVRBIDogX2MsIF9kID0gX2IuY2xvc2VkQnlQYXJlbnQsIGNsb3NlZEJ5UGFyZW50ID0gX2QgPT09IHZvaWQgMCA/IGZhbHNlIDogX2QsIF9lID0gX2IuaXNWb2lkLCBpc1ZvaWQgPSBfZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZSwgX2YgPSBfYi5pZ25vcmVGaXJzdExmLCBpZ25vcmVGaXJzdExmID0gX2YgPT09IHZvaWQgMCA/IGZhbHNlIDogX2Y7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuY2xvc2VkQnlDaGlsZHJlbiA9IHt9O1xuICAgICAgICB0aGlzLmNsb3NlZEJ5UGFyZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FuU2VsZkNsb3NlID0gZmFsc2U7XG4gICAgICAgIGlmIChjbG9zZWRCeUNoaWxkcmVuICYmIGNsb3NlZEJ5Q2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY2xvc2VkQnlDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uICh0YWdOYW1lKSB7IHJldHVybiBfdGhpcy5jbG9zZWRCeUNoaWxkcmVuW3RhZ05hbWVdID0gdHJ1ZTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1ZvaWQgPSBpc1ZvaWQ7XG4gICAgICAgIHRoaXMuY2xvc2VkQnlQYXJlbnQgPSBjbG9zZWRCeVBhcmVudCB8fCBpc1ZvaWQ7XG4gICAgICAgIGlmIChyZXF1aXJlZFBhcmVudHMgJiYgcmVxdWlyZWRQYXJlbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWlyZWRQYXJlbnRzID0ge307XG4gICAgICAgICAgICAvLyBUaGUgZmlyc3QgcGFyZW50IGlzIHRoZSBsaXN0IGlzIGF1dG9tYXRpY2FsbHkgd2hlbiBub25lIG9mIHRoZSBsaXN0ZWQgcGFyZW50cyBhcmUgcHJlc2VudFxuICAgICAgICAgICAgdGhpcy5wYXJlbnRUb0FkZCA9IHJlcXVpcmVkUGFyZW50c1swXTtcbiAgICAgICAgICAgIHJlcXVpcmVkUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uICh0YWdOYW1lKSB7IHJldHVybiBfdGhpcy5yZXF1aXJlZFBhcmVudHNbdGFnTmFtZV0gPSB0cnVlOyB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmltcGxpY2l0TmFtZXNwYWNlUHJlZml4ID0gaW1wbGljaXROYW1lc3BhY2VQcmVmaXggfHwgbnVsbDtcbiAgICAgICAgdGhpcy5jb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlO1xuICAgICAgICB0aGlzLmlnbm9yZUZpcnN0TGYgPSBpZ25vcmVGaXJzdExmO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGN1cnJlbnRQYXJlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0bWxUYWdEZWZpbml0aW9uLnByb3RvdHlwZS5yZXF1aXJlRXh0cmFQYXJlbnQgPSBmdW5jdGlvbiAoY3VycmVudFBhcmVudCkge1xuICAgICAgICBpZiAoIXRoaXMucmVxdWlyZWRQYXJlbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsY1BhcmVudCA9IGN1cnJlbnRQYXJlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNQYXJlbnRUZW1wbGF0ZSA9IGxjUGFyZW50ID09PSAndGVtcGxhdGUnIHx8IGN1cnJlbnRQYXJlbnQgPT09ICduZy10ZW1wbGF0ZSc7XG4gICAgICAgIHJldHVybiAhaXNQYXJlbnRUZW1wbGF0ZSAmJiB0aGlzLnJlcXVpcmVkUGFyZW50c1tsY1BhcmVudF0gIT0gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHRtbFRhZ0RlZmluaXRpb24ucHJvdG90eXBlLmlzQ2xvc2VkQnlDaGlsZCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVm9pZCB8fCBuYW1lLnRvTG93ZXJDYXNlKCkgaW4gdGhpcy5jbG9zZWRCeUNoaWxkcmVuO1xuICAgIH07XG4gICAgcmV0dXJuIEh0bWxUYWdEZWZpbml0aW9uO1xufSgpKTtcbi8vIHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNTEvc3ludGF4Lmh0bWwjb3B0aW9uYWwtdGFnc1xuLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiBkb2VzIG5vdCBmdWxseSBjb25mb3JtIHRvIHRoZSBIVE1MNSBzcGVjLlxudmFyIFRBR19ERUZJTklUSU9OUyA9IHtcbiAgICAnYmFzZSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAnbWV0YSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAnYXJlYSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAnZW1iZWQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgJ2xpbmsnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgJ2ltZyc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAnaW5wdXQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgJ3BhcmFtJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICdocic6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAnYnInOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgJ3NvdXJjZSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAndHJhY2snOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgJ3dicic6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAncCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7XG4gICAgICAgIGNsb3NlZEJ5Q2hpbGRyZW46IFtcbiAgICAgICAgICAgICdhZGRyZXNzJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYmxvY2txdW90ZScsICdkaXYnLCAnZGwnLCAnZmllbGRzZXQnLCAnZm9vdGVyJywgJ2Zvcm0nLFxuICAgICAgICAgICAgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWRlcicsICdoZ3JvdXAnLCAnaHInLFxuICAgICAgICAgICAgJ21haW4nLCAnbmF2JywgJ29sJywgJ3AnLCAncHJlJywgJ3NlY3Rpb24nLCAndGFibGUnLCAndWwnXG4gICAgICAgIF0sXG4gICAgICAgIGNsb3NlZEJ5UGFyZW50OiB0cnVlXG4gICAgfSksXG4gICAgJ3RoZWFkJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWyd0Ym9keScsICd0Zm9vdCddIH0pLFxuICAgICd0Ym9keSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsndGJvZHknLCAndGZvb3QnXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgJ3Rmb290JzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWyd0Ym9keSddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAndHInOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oe1xuICAgICAgICBjbG9zZWRCeUNoaWxkcmVuOiBbJ3RyJ10sXG4gICAgICAgIHJlcXVpcmVkUGFyZW50czogWyd0Ym9keScsICd0Zm9vdCcsICd0aGVhZCddLFxuICAgICAgICBjbG9zZWRCeVBhcmVudDogdHJ1ZVxuICAgIH0pLFxuICAgICd0ZCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsndGQnLCAndGgnXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgJ3RoJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWyd0ZCcsICd0aCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAnY29sJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgcmVxdWlyZWRQYXJlbnRzOiBbJ2NvbGdyb3VwJ10sIGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAnc3ZnJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaW1wbGljaXROYW1lc3BhY2VQcmVmaXg6ICdzdmcnIH0pLFxuICAgICdtYXRoJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaW1wbGljaXROYW1lc3BhY2VQcmVmaXg6ICdtYXRoJyB9KSxcbiAgICAnbGknOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ2xpJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICdkdCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsnZHQnLCAnZGQnXSB9KSxcbiAgICAnZGQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ2R0JywgJ2RkJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICdyYic6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsncmInLCAncnQnLCAncnRjJywgJ3JwJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICdydCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsncmInLCAncnQnLCAncnRjJywgJ3JwJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICdydGMnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3JiJywgJ3J0YycsICdycCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAncnAnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3JiJywgJ3J0JywgJ3J0YycsICdycCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAnb3B0Z3JvdXAnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ29wdGdyb3VwJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICdvcHRpb24nOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ29wdGlvbicsICdvcHRncm91cCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAncHJlJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaWdub3JlRmlyc3RMZjogdHJ1ZSB9KSxcbiAgICAnbGlzdGluZyc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlnbm9yZUZpcnN0TGY6IHRydWUgfSksXG4gICAgJ3N0eWxlJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY29udGVudFR5cGU6IFRhZ0NvbnRlbnRUeXBlLlJBV19URVhUIH0pLFxuICAgICdzY3JpcHQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjb250ZW50VHlwZTogVGFnQ29udGVudFR5cGUuUkFXX1RFWFQgfSksXG4gICAgJ3RpdGxlJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY29udGVudFR5cGU6IFRhZ0NvbnRlbnRUeXBlLkVTQ0FQQUJMRV9SQVdfVEVYVCB9KSxcbiAgICAndGV4dGFyZWEnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjb250ZW50VHlwZTogVGFnQ29udGVudFR5cGUuRVNDQVBBQkxFX1JBV19URVhULCBpZ25vcmVGaXJzdExmOiB0cnVlIH0pLFxufTtcbnZhciBfREVGQVVMVF9UQUdfREVGSU5JVElPTiA9IG5ldyBIdG1sVGFnRGVmaW5pdGlvbigpO1xuLyoqXG4gKiBAcGFyYW0gez99IHRhZ05hbWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGdldEh0bWxUYWdEZWZpbml0aW9uKHRhZ05hbWUpIHtcbiAgICByZXR1cm4gVEFHX0RFRklOSVRJT05TW3RhZ05hbWUudG9Mb3dlckNhc2UoKV0gfHwgX0RFRkFVTFRfVEFHX0RFRklOSVRJT047XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgX1NFTEVDVE9SX1JFR0VYUCA9IG5ldyBSZWdFeHAoJyhcXFxcOm5vdFxcXFwoKXwnICtcbiAgICAnKFstXFxcXHddKyl8JyArXG4gICAgJyg/OlxcXFwuKFstXFxcXHddKykpfCcgK1xuICAgIC8vIFwiLVwiIHNob3VsZCBhcHBlYXIgZmlyc3QgaW4gdGhlIHJlZ2V4cCBiZWxvdyBhcyBGRjMxIHBhcnNlcyBcIlsuLVxcd11cIiBhcyBhIHJhbmdlXG4gICAgJyg/OlxcXFxbKFstLlxcXFx3Kl0rKSg/Oj0oW1xcXCJcXCddPykoW15cXFxcXVxcXCJcXCddKilcXFxcNSk/XFxcXF0pfCcgK1xuICAgIC8vIFwiW25hbWU9XCJ2YWx1ZVwiXVwiLFxuICAgIC8vIFwiW25hbWU9J3ZhbHVlJ11cIlxuICAgICcoXFxcXCkpfCcgK1xuICAgICcoXFxcXHMqLFxcXFxzKiknLCAvLyBcIixcIlxuJ2cnKTtcbi8qKlxuICogQSBjc3Mgc2VsZWN0b3IgY29udGFpbnMgYW4gZWxlbWVudCBuYW1lLFxuICogY3NzIGNsYXNzZXMgYW5kIGF0dHJpYnV0ZS92YWx1ZSBwYWlycyB3aXRoIHRoZSBwdXJwb3NlXG4gKiBvZiBzZWxlY3Rpbmcgc3Vic2V0cyBvdXQgb2YgdGhlbS5cbiAqL1xudmFyIENzc1NlbGVjdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDc3NTZWxlY3RvcigpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jbGFzc05hbWVzID0gW107XG4gICAgICAgIHRoaXMuYXR0cnMgPSBbXTtcbiAgICAgICAgdGhpcy5ub3RTZWxlY3RvcnMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3RvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ3NzU2VsZWN0b3IucGFyc2UgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0cyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBfYWRkUmVzdWx0ID0gZnVuY3Rpb24gKHJlcywgY3NzU2VsKSB7XG4gICAgICAgICAgICBpZiAoY3NzU2VsLm5vdFNlbGVjdG9ycy5sZW5ndGggPiAwICYmICFjc3NTZWwuZWxlbWVudCAmJiBjc3NTZWwuY2xhc3NOYW1lcy5sZW5ndGggPT0gMCAmJlxuICAgICAgICAgICAgICAgIGNzc1NlbC5hdHRycy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIGNzc1NlbC5lbGVtZW50ID0gJyonO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzLnB1c2goY3NzU2VsKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3NzU2VsZWN0b3IgPSBuZXcgQ3NzU2VsZWN0b3IoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWF0Y2g7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGN1cnJlbnQgPSBjc3NTZWxlY3RvcjtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5Ob3QgPSBmYWxzZTtcbiAgICAgICAgX1NFTEVDVE9SX1JFR0VYUC5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAobWF0Y2ggPSBfU0VMRUNUT1JfUkVHRVhQLmV4ZWMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5Ob3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZXN0aW5nIDpub3QgaXMgbm90IGFsbG93ZWQgaW4gYSBzZWxlY3RvcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbk5vdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IG5ldyBDc3NTZWxlY3RvcigpO1xuICAgICAgICAgICAgICAgIGNzc1NlbGVjdG9yLm5vdFNlbGVjdG9ycy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzJdKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudC5zZXRFbGVtZW50KG1hdGNoWzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFszXSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQuYWRkQ2xhc3NOYW1lKG1hdGNoWzNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFs0XSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQuYWRkQXR0cmlidXRlKG1hdGNoWzRdLCBtYXRjaFs2XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hbN10pIHtcbiAgICAgICAgICAgICAgICBpbk5vdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjc3NTZWxlY3RvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFs4XSkge1xuICAgICAgICAgICAgICAgIGlmIChpbk5vdCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011bHRpcGxlIHNlbGVjdG9ycyBpbiA6bm90IGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9hZGRSZXN1bHQocmVzdWx0cywgY3NzU2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgIGNzc1NlbGVjdG9yID0gY3VycmVudCA9IG5ldyBDc3NTZWxlY3RvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF9hZGRSZXN1bHQocmVzdWx0cywgY3NzU2VsZWN0b3IpO1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ3NzU2VsZWN0b3IucHJvdG90eXBlLmlzRWxlbWVudFNlbGVjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNFbGVtZW50U2VsZWN0b3IoKSAmJiB0aGlzLmNsYXNzTmFtZXMubGVuZ3RoID09IDAgJiYgdGhpcy5hdHRycy5sZW5ndGggPT0gMCAmJlxuICAgICAgICAgICAgdGhpcy5ub3RTZWxlY3RvcnMubGVuZ3RoID09PSAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUuaGFzRWxlbWVudFNlbGVjdG9yID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gISF0aGlzLmVsZW1lbnQ7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gZWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ3NzU2VsZWN0b3IucHJvdG90eXBlLnNldEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICBpZiAoZWxlbWVudCA9PT0gdm9pZCAwKSB7IGVsZW1lbnQgPSBudWxsOyB9XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIGEgdGVtcGxhdGUgc3RyaW5nIGZvciBhbiBlbGVtZW50IHRoYXQgbWF0Y2hlcyB0aGUgc2VsZWN0b3IuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUuZ2V0TWF0Y2hpbmdFbGVtZW50VGVtcGxhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRhZ05hbWUgPSB0aGlzLmVsZW1lbnQgfHwgJ2Rpdic7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsYXNzQXR0ciA9IHRoaXMuY2xhc3NOYW1lcy5sZW5ndGggPiAwID8gXCIgY2xhc3M9XFxcIlwiICsgdGhpcy5jbGFzc05hbWVzLmpvaW4oJyAnKSArIFwiXFxcIlwiIDogJyc7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGF0dHJzID0gJyc7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCB0aGlzLmF0dHJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhdHRyTmFtZSA9IHRoaXMuYXR0cnNbaV07XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhdHRyVmFsdWUgPSB0aGlzLmF0dHJzW2kgKyAxXSAhPT0gJycgPyBcIj1cXFwiXCIgKyB0aGlzLmF0dHJzW2kgKyAxXSArIFwiXFxcIlwiIDogJyc7XG4gICAgICAgICAgICBhdHRycyArPSBcIiBcIiArIGF0dHJOYW1lICsgYXR0clZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRIdG1sVGFnRGVmaW5pdGlvbih0YWdOYW1lKS5pc1ZvaWQgPyBcIjxcIiArIHRhZ05hbWUgKyBjbGFzc0F0dHIgKyBhdHRycyArIFwiLz5cIiA6XG4gICAgICAgICAgICBcIjxcIiArIHRhZ05hbWUgKyBjbGFzc0F0dHIgKyBhdHRycyArIFwiPjwvXCIgKyB0YWdOYW1lICsgXCI+XCI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez89fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ3NzU2VsZWN0b3IucHJvdG90eXBlLmFkZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9ICcnOyB9XG4gICAgICAgIHRoaXMuYXR0cnMucHVzaChuYW1lLCB2YWx1ZSAmJiB2YWx1ZS50b0xvd2VyQ2FzZSgpIHx8ICcnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ3NzU2VsZWN0b3IucHJvdG90eXBlLmFkZENsYXNzTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7IHRoaXMuY2xhc3NOYW1lcy5wdXNoKG5hbWUudG9Mb3dlckNhc2UoKSk7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlcyA9IHRoaXMuZWxlbWVudCB8fCAnJztcbiAgICAgICAgaWYgKHRoaXMuY2xhc3NOYW1lcykge1xuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWVzLmZvckVhY2goZnVuY3Rpb24gKGtsYXNzKSB7IHJldHVybiByZXMgKz0gXCIuXCIgKyBrbGFzczsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXR0cnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCB0aGlzLmF0dHJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZSA9IHRoaXMuYXR0cnNbaV07XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSB0aGlzLmF0dHJzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICByZXMgKz0gXCJbXCIgKyBuYW1lICsgKHZhbHVlID8gJz0nICsgdmFsdWUgOiAnJykgKyBcIl1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vdFNlbGVjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChub3RTZWxlY3RvcikgeyByZXR1cm4gcmVzICs9IFwiOm5vdChcIiArIG5vdFNlbGVjdG9yICsgXCIpXCI7IH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgcmV0dXJuIENzc1NlbGVjdG9yO1xufSgpKTtcbi8qKlxuICogUmVhZHMgYSBsaXN0IG9mIENzc1NlbGVjdG9ycyBhbmQgYWxsb3dzIHRvIGNhbGN1bGF0ZSB3aGljaCBvbmVzXG4gKiBhcmUgY29udGFpbmVkIGluIGEgZ2l2ZW4gQ3NzU2VsZWN0b3IuXG4gKi9cbnZhciBTZWxlY3Rvck1hdGNoZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlbGVjdG9yTWF0Y2hlcigpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fZWxlbWVudFBhcnRpYWxNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2NsYXNzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jbGFzc1BhcnRpYWxNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2F0dHJWYWx1ZU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fYXR0clZhbHVlUGFydGlhbE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fbGlzdENvbnRleHRzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm90U2VsZWN0b3JzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZWxlY3Rvck1hdGNoZXIuY3JlYXRlTm90TWF0Y2hlciA9IGZ1bmN0aW9uIChub3RTZWxlY3RvcnMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm90TWF0Y2hlciA9IG5ldyBTZWxlY3Rvck1hdGNoZXIoKTtcbiAgICAgICAgbm90TWF0Y2hlci5hZGRTZWxlY3RhYmxlcyhub3RTZWxlY3RvcnMsIG51bGwpO1xuICAgICAgICByZXR1cm4gbm90TWF0Y2hlcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY3NzU2VsZWN0b3JzXG4gICAgICogQHBhcmFtIHs/PX0gY2FsbGJhY2tDdHh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZWxlY3Rvck1hdGNoZXIucHJvdG90eXBlLmFkZFNlbGVjdGFibGVzID0gZnVuY3Rpb24gKGNzc1NlbGVjdG9ycywgY2FsbGJhY2tDdHh0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxpc3RDb250ZXh0ID0gKChudWxsKSk7XG4gICAgICAgIGlmIChjc3NTZWxlY3RvcnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbGlzdENvbnRleHQgPSBuZXcgU2VsZWN0b3JMaXN0Q29udGV4dChjc3NTZWxlY3RvcnMpO1xuICAgICAgICAgICAgdGhpcy5fbGlzdENvbnRleHRzLnB1c2gobGlzdENvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBjc3NTZWxlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZFNlbGVjdGFibGUoY3NzU2VsZWN0b3JzW2ldLCBjYWxsYmFja0N0eHQsIGxpc3RDb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGFuIG9iamVjdCB0aGF0IGNhbiBiZSBmb3VuZCBsYXRlciBvbiBieSBjYWxsaW5nIGBtYXRjaGAuXG4gICAgICogQHBhcmFtIHs/fSBjc3NTZWxlY3RvciBBIGNzcyBzZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gY2FsbGJhY2tDdHh0IEFuIG9wYXF1ZSBvYmplY3QgdGhhdCB3aWxsIGJlIGdpdmVuIHRvIHRoZSBjYWxsYmFjayBvZiB0aGUgYG1hdGNoYCBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7P30gbGlzdENvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlbGVjdG9yTWF0Y2hlci5wcm90b3R5cGUuX2FkZFNlbGVjdGFibGUgPSBmdW5jdGlvbiAoY3NzU2VsZWN0b3IsIGNhbGxiYWNrQ3R4dCwgbGlzdENvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWF0Y2hlciA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsZW1lbnQgPSBjc3NTZWxlY3Rvci5lbGVtZW50O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbGFzc05hbWVzID0gY3NzU2VsZWN0b3IuY2xhc3NOYW1lcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXR0cnMgPSBjc3NTZWxlY3Rvci5hdHRycztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VsZWN0YWJsZSA9IG5ldyBTZWxlY3RvckNvbnRleHQoY3NzU2VsZWN0b3IsIGNhbGxiYWNrQ3R4dCwgbGlzdENvbnRleHQpO1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNUZXJtaW5hbCA9IGF0dHJzLmxlbmd0aCA9PT0gMCAmJiBjbGFzc05hbWVzLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgICAgIGlmIChpc1Rlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkVGVybWluYWwobWF0Y2hlci5fZWxlbWVudE1hcCwgZWxlbWVudCwgc2VsZWN0YWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVyID0gdGhpcy5fYWRkUGFydGlhbChtYXRjaGVyLl9lbGVtZW50UGFydGlhbE1hcCwgZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsYXNzTmFtZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBjbGFzc05hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNUZXJtaW5hbCA9IGF0dHJzLmxlbmd0aCA9PT0gMCAmJiBpID09PSBjbGFzc05hbWVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xhc3NOYW1lID0gY2xhc3NOYW1lc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNUZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRUZXJtaW5hbChtYXRjaGVyLl9jbGFzc01hcCwgY2xhc3NOYW1lLCBzZWxlY3RhYmxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXIgPSB0aGlzLl9hZGRQYXJ0aWFsKG1hdGNoZXIuX2NsYXNzUGFydGlhbE1hcCwgY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc1Rlcm1pbmFsID0gaSA9PT0gYXR0cnMubGVuZ3RoIC0gMjtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lID0gYXR0cnNbaV07XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSBhdHRyc1tpICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKGlzVGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVybWluYWxNYXAgPSBtYXRjaGVyLl9hdHRyVmFsdWVNYXA7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlcm1pbmFsVmFsdWVzTWFwID0gdGVybWluYWxNYXAuZ2V0KG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRlcm1pbmFsVmFsdWVzTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hbFZhbHVlc01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmFsTWFwLnNldChuYW1lLCB0ZXJtaW5hbFZhbHVlc01hcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkVGVybWluYWwodGVybWluYWxWYWx1ZXNNYXAsIHZhbHVlLCBzZWxlY3RhYmxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnRpYWxNYXAgPSBtYXRjaGVyLl9hdHRyVmFsdWVQYXJ0aWFsTWFwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJ0aWFsVmFsdWVzTWFwID0gcGFydGlhbE1hcC5nZXQobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFydGlhbFZhbHVlc01hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbFZhbHVlc01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWxNYXAuc2V0KG5hbWUsIHBhcnRpYWxWYWx1ZXNNYXApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXIgPSB0aGlzLl9hZGRQYXJ0aWFsKHBhcnRpYWxWYWx1ZXNNYXAsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWFwXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3RhYmxlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZWxlY3Rvck1hdGNoZXIucHJvdG90eXBlLl9hZGRUZXJtaW5hbCA9IGZ1bmN0aW9uIChtYXAsIG5hbWUsIHNlbGVjdGFibGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVybWluYWxMaXN0ID0gbWFwLmdldChuYW1lKTtcbiAgICAgICAgaWYgKCF0ZXJtaW5hbExpc3QpIHtcbiAgICAgICAgICAgIHRlcm1pbmFsTGlzdCA9IFtdO1xuICAgICAgICAgICAgbWFwLnNldChuYW1lLCB0ZXJtaW5hbExpc3QpO1xuICAgICAgICB9XG4gICAgICAgIHRlcm1pbmFsTGlzdC5wdXNoKHNlbGVjdGFibGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtYXBcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlbGVjdG9yTWF0Y2hlci5wcm90b3R5cGUuX2FkZFBhcnRpYWwgPSBmdW5jdGlvbiAobWFwLCBuYW1lKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hdGNoZXIgPSBtYXAuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoIW1hdGNoZXIpIHtcbiAgICAgICAgICAgIG1hdGNoZXIgPSBuZXcgU2VsZWN0b3JNYXRjaGVyKCk7XG4gICAgICAgICAgICBtYXAuc2V0KG5hbWUsIG1hdGNoZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXRjaGVyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgb2JqZWN0cyB0aGF0IGhhdmUgYmVlbiBhZGRlZCB2aWEgYGFkZFNlbGVjdGFibGVgXG4gICAgICogd2hvc2UgY3NzIHNlbGVjdG9yIGlzIGNvbnRhaW5lZCBpbiB0aGUgZ2l2ZW4gY3NzIHNlbGVjdG9yLlxuICAgICAqIEBwYXJhbSB7P30gY3NzU2VsZWN0b3IgQSBjc3Mgc2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IG1hdGNoZWRDYWxsYmFjayBUaGlzIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIG9iamVjdCBoYW5kZWQgaW50byBgYWRkU2VsZWN0YWJsZWBcbiAgICAgKiBAcmV0dXJuIHs/fSBib29sZWFuIHRydWUgaWYgYSBtYXRjaCB3YXMgZm91bmRcbiAgICAgKi9cbiAgICBTZWxlY3Rvck1hdGNoZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsZW1lbnQgPSAoKGNzc1NlbGVjdG9yLmVsZW1lbnQpKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xhc3NOYW1lcyA9IGNzc1NlbGVjdG9yLmNsYXNzTmFtZXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGF0dHJzID0gY3NzU2VsZWN0b3IuYXR0cnM7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCB0aGlzLl9saXN0Q29udGV4dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX2xpc3RDb250ZXh0c1tpXS5hbHJlYWR5TWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX21hdGNoVGVybWluYWwodGhpcy5fZWxlbWVudE1hcCwgZWxlbWVudCwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICByZXN1bHQgPSB0aGlzLl9tYXRjaFBhcnRpYWwodGhpcy5fZWxlbWVudFBhcnRpYWxNYXAsIGVsZW1lbnQsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8XG4gICAgICAgICAgICByZXN1bHQ7XG4gICAgICAgIGlmIChjbGFzc05hbWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgY2xhc3NOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbaV07XG4gICAgICAgICAgICAgICAgcmVzdWx0ID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWF0Y2hUZXJtaW5hbCh0aGlzLl9jbGFzc01hcCwgY2xhc3NOYW1lLCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWF0Y2hQYXJ0aWFsKHRoaXMuX2NsYXNzUGFydGlhbE1hcCwgY2xhc3NOYW1lLCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRycykge1xuICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZSA9IGF0dHJzW2ldO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gYXR0cnNbaSArIDFdO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlcm1pbmFsVmFsdWVzTWFwID0gKCh0aGlzLl9hdHRyVmFsdWVNYXAuZ2V0KG5hbWUpKSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaFRlcm1pbmFsKHRlcm1pbmFsVmFsdWVzTWFwLCAnJywgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaFRlcm1pbmFsKHRlcm1pbmFsVmFsdWVzTWFwLCB2YWx1ZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnRpYWxWYWx1ZXNNYXAgPSAoKHRoaXMuX2F0dHJWYWx1ZVBhcnRpYWxNYXAuZ2V0KG5hbWUpKSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX21hdGNoUGFydGlhbChwYXJ0aWFsVmFsdWVzTWFwLCAnJywgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaFBhcnRpYWwocGFydGlhbFZhbHVlc01hcCwgdmFsdWUsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogXFxAaW50ZXJuYWxcbiAgICAgKiBAcGFyYW0gez99IG1hcFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gY3NzU2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IG1hdGNoZWRDYWxsYmFja1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VsZWN0b3JNYXRjaGVyLnByb3RvdHlwZS5fbWF0Y2hUZXJtaW5hbCA9IGZ1bmN0aW9uIChtYXAsIG5hbWUsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFtYXAgfHwgdHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VsZWN0YWJsZXMgPSBtYXAuZ2V0KG5hbWUpIHx8IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFyU2VsZWN0YWJsZXMgPSAoKG1hcC5nZXQoJyonKSkpO1xuICAgICAgICBpZiAoc3RhclNlbGVjdGFibGVzKSB7XG4gICAgICAgICAgICBzZWxlY3RhYmxlcyA9IHNlbGVjdGFibGVzLmNvbmNhdChzdGFyU2VsZWN0YWJsZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxlY3RhYmxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZWxlY3RhYmxlO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHNlbGVjdGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzZWxlY3RhYmxlID0gc2VsZWN0YWJsZXNbaV07XG4gICAgICAgICAgICByZXN1bHQgPSBzZWxlY3RhYmxlLmZpbmFsaXplKGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogXFxAaW50ZXJuYWxcbiAgICAgKiBAcGFyYW0gez99IG1hcFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gY3NzU2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IG1hdGNoZWRDYWxsYmFja1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VsZWN0b3JNYXRjaGVyLnByb3RvdHlwZS5fbWF0Y2hQYXJ0aWFsID0gZnVuY3Rpb24gKG1hcCwgbmFtZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykge1xuICAgICAgICBpZiAoIW1hcCB8fCB0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZXN0ZWRTZWxlY3RvciA9IG1hcC5nZXQobmFtZSk7XG4gICAgICAgIGlmICghbmVzdGVkU2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPKHBlcmYpOiBnZXQgcmlkIG9mIHJlY3Vyc2lvbiBhbmQgbWVhc3VyZSBhZ2FpblxuICAgICAgICAvLyBUT0RPKHBlcmYpOiBkb24ndCBwYXNzIHRoZSB3aG9sZSBzZWxlY3RvciBpbnRvIHRoZSByZWN1cnNpb24sXG4gICAgICAgIC8vIGJ1dCBvbmx5IHRoZSBub3QgcHJvY2Vzc2VkIHBhcnRzXG4gICAgICAgIHJldHVybiBuZXN0ZWRTZWxlY3Rvci5tYXRjaChjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKTtcbiAgICB9O1xuICAgIHJldHVybiBTZWxlY3Rvck1hdGNoZXI7XG59KCkpO1xudmFyIFNlbGVjdG9yTGlzdENvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0b3JzXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2VsZWN0b3JMaXN0Q29udGV4dChzZWxlY3RvcnMpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RvcnMgPSBzZWxlY3RvcnM7XG4gICAgICAgIHRoaXMuYWxyZWFkeU1hdGNoZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIFNlbGVjdG9yTGlzdENvbnRleHQ7XG59KCkpO1xudmFyIFNlbGVjdG9yQ29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gY2JDb250ZXh0XG4gICAgICogQHBhcmFtIHs/fSBsaXN0Q29udGV4dFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNlbGVjdG9yQ29udGV4dChzZWxlY3RvciwgY2JDb250ZXh0LCBsaXN0Q29udGV4dCkge1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIHRoaXMuY2JDb250ZXh0ID0gY2JDb250ZXh0O1xuICAgICAgICB0aGlzLmxpc3RDb250ZXh0ID0gbGlzdENvbnRleHQ7XG4gICAgICAgIHRoaXMubm90U2VsZWN0b3JzID0gc2VsZWN0b3Iubm90U2VsZWN0b3JzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNzc1NlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VsZWN0b3JDb250ZXh0LnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uIChjc3NTZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMubm90U2VsZWN0b3JzLmxlbmd0aCA+IDAgJiYgKCF0aGlzLmxpc3RDb250ZXh0IHx8ICF0aGlzLmxpc3RDb250ZXh0LmFscmVhZHlNYXRjaGVkKSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm90TWF0Y2hlciA9IFNlbGVjdG9yTWF0Y2hlci5jcmVhdGVOb3RNYXRjaGVyKHRoaXMubm90U2VsZWN0b3JzKTtcbiAgICAgICAgICAgIHJlc3VsdCA9ICFub3RNYXRjaGVyLm1hdGNoKGNzc1NlbGVjdG9yLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0ICYmIGNhbGxiYWNrICYmICghdGhpcy5saXN0Q29udGV4dCB8fCAhdGhpcy5saXN0Q29udGV4dC5hbHJlYWR5TWF0Y2hlZCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpc3RDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0Q29udGV4dC5hbHJlYWR5TWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayh0aGlzLnNlbGVjdG9yLCB0aGlzLmNiQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBTZWxlY3RvckNvbnRleHQ7XG59KCkpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIE1PRFVMRV9TVUZGSVggPSAnJztcbnZhciBEQVNIX0NBU0VfUkVHRVhQID0gLy0rKFthLXowLTldKS9nO1xuLyoqXG4gKiBAcGFyYW0gez99IGlucHV0XG4gKiBAcmV0dXJuIHs/fVxuICovXG4vKipcbiAqIEBwYXJhbSB7P30gaW5wdXRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGRhc2hDYXNlVG9DYW1lbENhc2UoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQucmVwbGFjZShEQVNIX0NBU0VfUkVHRVhQLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBtW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1bMV0udG9VcHBlckNhc2UoKTtcbiAgICB9KTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBpbnB1dFxuICogQHBhcmFtIHs/fSBkZWZhdWx0VmFsdWVzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzcGxpdEF0Q29sb24oaW5wdXQsIGRlZmF1bHRWYWx1ZXMpIHtcbiAgICByZXR1cm4gX3NwbGl0QXQoaW5wdXQsICc6JywgZGVmYXVsdFZhbHVlcyk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gaW5wdXRcbiAqIEBwYXJhbSB7P30gZGVmYXVsdFZhbHVlc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc3BsaXRBdFBlcmlvZChpbnB1dCwgZGVmYXVsdFZhbHVlcykge1xuICAgIHJldHVybiBfc3BsaXRBdChpbnB1dCwgJy4nLCBkZWZhdWx0VmFsdWVzKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBpbnB1dFxuICogQHBhcmFtIHs/fSBjaGFyYWN0ZXJcbiAqIEBwYXJhbSB7P30gZGVmYXVsdFZhbHVlc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX3NwbGl0QXQoaW5wdXQsIGNoYXJhY3RlciwgZGVmYXVsdFZhbHVlcykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGNoYXJhY3RlckluZGV4ID0gaW5wdXQuaW5kZXhPZihjaGFyYWN0ZXIpO1xuICAgIGlmIChjaGFyYWN0ZXJJbmRleCA9PSAtMSlcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZXM7XG4gICAgcmV0dXJuIFtpbnB1dC5zbGljZSgwLCBjaGFyYWN0ZXJJbmRleCkudHJpbSgpLCBpbnB1dC5zbGljZShjaGFyYWN0ZXJJbmRleCArIDEpLnRyaW0oKV07XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdmFsdWVcbiAqIEBwYXJhbSB7P30gdmlzaXRvclxuICogQHBhcmFtIHs/fSBjb250ZXh0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB2aXNpdFZhbHVlKHZhbHVlLCB2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QXJyYXkoLyoqIEB0eXBlIHs/fSAqLyAodmFsdWUpLCBjb250ZXh0KTtcbiAgICB9XG4gICAgaWYgKGlzU3RyaWN0U3RyaW5nTWFwKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFN0cmluZ01hcCgvKiogQHR5cGUgez99ICovICh2YWx1ZSksIGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8XG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRQcmltaXRpdmUodmFsdWUsIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdmlzaXRvci52aXNpdE90aGVyKHZhbHVlLCBjb250ZXh0KTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSB2YWxcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzRGVmaW5lZCh2YWwpIHtcbiAgICByZXR1cm4gdmFsICE9PSBudWxsICYmIHZhbCAhPT0gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHs/fSB2YWxcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG5vVW5kZWZpbmVkKHZhbCkge1xuICAgIHJldHVybiB2YWwgPT09IHVuZGVmaW5lZCA/ICgobnVsbCkpIDogdmFsO1xufVxudmFyIFZhbHVlVHJhbnNmb3JtZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZhbHVlVHJhbnNmb3JtZXIoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXJyXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWYWx1ZVRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEFycmF5ID0gZnVuY3Rpb24gKGFyciwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gYXJyLm1hcChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZpc2l0VmFsdWUodmFsdWUsIF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1hcFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmFsdWVUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRTdHJpbmdNYXAgPSBmdW5jdGlvbiAobWFwLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhtYXApLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXN1bHRba2V5XSA9IHZpc2l0VmFsdWUobWFwW2tleV0sIF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWYWx1ZVRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFByaW1pdGl2ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgY29udGV4dCkgeyByZXR1cm4gdmFsdWU7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmFsdWVUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRPdGhlciA9IGZ1bmN0aW9uICh2YWx1ZSwgY29udGV4dCkgeyByZXR1cm4gdmFsdWU7IH07XG4gICAgcmV0dXJuIFZhbHVlVHJhbnNmb3JtZXI7XG59KCkpO1xudmFyIFN5bmNBc3luYyA9IHtcbiAgICBhc3NlcnRTeW5jOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKMm1aXNQcm9taXNlKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBzdGF0ZTogdmFsdWUgY2Fubm90IGJlIGEgcHJvbWlzZVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICB0aGVuOiBmdW5jdGlvbiAodmFsdWUsIGNiKSB7IHJldHVybiDJtWlzUHJvbWlzZSh2YWx1ZSkgPyB2YWx1ZS50aGVuKGNiKSA6IGNiKHZhbHVlKTsgfSxcbiAgICBhbGw6IGZ1bmN0aW9uIChzeW5jQXN5bmNWYWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHN5bmNBc3luY1ZhbHVlcy5zb21lKMm1aXNQcm9taXNlKSA/IFByb21pc2UuYWxsKHN5bmNBc3luY1ZhbHVlcykgOiAoc3luY0FzeW5jVmFsdWVzKTtcbiAgICB9XG59O1xuLyoqXG4gKiBAcGFyYW0gez99IG1zZ1xuICogQHBhcmFtIHs/PX0gcGFyc2VFcnJvcnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHN5bnRheEVycm9yKG1zZywgcGFyc2VFcnJvcnMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvciA9IEVycm9yKG1zZyk7XG4gICAgKChlcnJvcikpW0VSUk9SX1NZTlRBWF9FUlJPUl0gPSB0cnVlO1xuICAgIGlmIChwYXJzZUVycm9ycylcbiAgICAgICAgKChlcnJvcikpW0VSUk9SX1BBUlNFX0VSUk9SU10gPSBwYXJzZUVycm9ycztcbiAgICByZXR1cm4gZXJyb3I7XG59XG52YXIgRVJST1JfU1lOVEFYX0VSUk9SID0gJ25nU3ludGF4RXJyb3InO1xudmFyIEVSUk9SX1BBUlNFX0VSUk9SUyA9ICduZ1BhcnNlRXJyb3JzJztcbi8qKlxuICogQHBhcmFtIHs/fSBlcnJvclxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNTeW50YXhFcnJvcihlcnJvcikge1xuICAgIHJldHVybiAoKGVycm9yKSlbRVJST1JfU1lOVEFYX0VSUk9SXTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBlcnJvclxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZ2V0UGFyc2VFcnJvcnMoZXJyb3IpIHtcbiAgICByZXR1cm4gKChlcnJvcikpW0VSUk9SX1BBUlNFX0VSUk9SU10gfHwgW107XG59XG4vKipcbiAqIEBwYXJhbSB7P30gc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHMpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKC8oWy4qKz9ePSE6JHt9KCl8W1xcXVxcL1xcXFxdKS9nLCAnXFxcXCQxJyk7XG59XG52YXIgU1RSSU5HX01BUF9QUk9UTyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih7fSk7XG4vKipcbiAqIEBwYXJhbSB7P30gb2JqXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc1N0cmljdFN0cmluZ01hcChvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopID09PSBTVFJJTkdfTUFQX1BST1RPO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHN0clxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdXRmOEVuY29kZShzdHIpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbmNvZGVkID0gJyc7XG4gICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmRleCA9IDA7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb2RlUG9pbnQgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgIC8vIGRlY29kZSBzdXJyb2dhdGVcbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nI3N1cnJvZ2F0ZS1mb3JtdWxhZVxuICAgICAgICBpZiAoY29kZVBvaW50ID49IDB4ZDgwMCAmJiBjb2RlUG9pbnQgPD0gMHhkYmZmICYmIHN0ci5sZW5ndGggPiAoaW5kZXggKyAxKSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbG93ID0gc3RyLmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcbiAgICAgICAgICAgIGlmIChsb3cgPj0gMHhkYzAwICYmIGxvdyA8PSAweGRmZmYpIHtcbiAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9ICgoY29kZVBvaW50IC0gMHhkODAwKSA8PCAxMCkgKyBsb3cgLSAweGRjMDAgKyAweDEwMDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHg3Zikge1xuICAgICAgICAgICAgZW5jb2RlZCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29kZVBvaW50IDw9IDB4N2ZmKSB7XG4gICAgICAgICAgICBlbmNvZGVkICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gNikgJiAweDFGKSB8IDB4YzAsIChjb2RlUG9pbnQgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvZGVQb2ludCA8PSAweGZmZmYpIHtcbiAgICAgICAgICAgIGVuY29kZWQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoY29kZVBvaW50ID4+IDEyKSB8IDB4ZTAsICgoY29kZVBvaW50ID4+IDYpICYgMHgzZikgfCAweDgwLCAoY29kZVBvaW50ICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2RlUG9pbnQgPD0gMHgxZmZmZmYpIHtcbiAgICAgICAgICAgIGVuY29kZWQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxOCkgJiAweDA3KSB8IDB4ZjAsICgoY29kZVBvaW50ID4+IDEyKSAmIDB4M2YpIHwgMHg4MCwgKChjb2RlUG9pbnQgPj4gNikgJiAweDNmKSB8IDB4ODAsIChjb2RlUG9pbnQgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbmNvZGVkO1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLy8gZ3JvdXAgMDogXCJbcHJvcF0gb3IgKGV2ZW50KSBvciBAdHJpZ2dlclwiXG4vLyBncm91cCAxOiBcInByb3BcIiBmcm9tIFwiW3Byb3BdXCJcbi8vIGdyb3VwIDI6IFwiZXZlbnRcIiBmcm9tIFwiKGV2ZW50KVwiXG4vLyBncm91cCAzOiBcIkB0cmlnZ2VyXCIgZnJvbSBcIkB0cmlnZ2VyXCJcbnZhciBIT1NUX1JFR19FWFAgPSAvXig/Oig/OlxcWyhbXlxcXV0rKVxcXSl8KD86XFwoKFteXFwpXSspXFwpKSl8KFxcQFstXFx3XSspJC87XG52YXIgQ29tcGlsZUFuaW1hdGlvbkVudHJ5TWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IG5hbWVcbiAgICAgKiBAcGFyYW0gez89fSBkZWZpbml0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbXBpbGVBbmltYXRpb25FbnRyeU1ldGFkYXRhKG5hbWUsIGRlZmluaXRpb25zKSB7XG4gICAgICAgIGlmIChuYW1lID09PSB2b2lkIDApIHsgbmFtZSA9IG51bGw7IH1cbiAgICAgICAgaWYgKGRlZmluaXRpb25zID09PSB2b2lkIDApIHsgZGVmaW5pdGlvbnMgPSBudWxsOyB9XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuZGVmaW5pdGlvbnMgPSBkZWZpbml0aW9ucztcbiAgICB9XG4gICAgcmV0dXJuIENvbXBpbGVBbmltYXRpb25FbnRyeU1ldGFkYXRhO1xufSgpKTtcbi8qKlxuICogQGFic3RyYWN0XG4gKi9cbnZhciBDb21waWxlQW5pbWF0aW9uU3RhdGVNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29tcGlsZUFuaW1hdGlvblN0YXRlTWV0YWRhdGEoKSB7XG4gICAgfVxuICAgIHJldHVybiBDb21waWxlQW5pbWF0aW9uU3RhdGVNZXRhZGF0YTtcbn0oKSk7XG52YXIgQ29tcGlsZUFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQ29tcGlsZUFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXRlTmFtZUV4cHJcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbXBpbGVBbmltYXRpb25TdGF0ZURlY2xhcmF0aW9uTWV0YWRhdGEoc3RhdGVOYW1lRXhwciwgc3R5bGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0YXRlTmFtZUV4cHIgPSBzdGF0ZU5hbWVFeHByO1xuICAgICAgICBfdGhpcy5zdHlsZXMgPSBzdHlsZXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENvbXBpbGVBbmltYXRpb25TdGF0ZURlY2xhcmF0aW9uTWV0YWRhdGE7XG59KENvbXBpbGVBbmltYXRpb25TdGF0ZU1ldGFkYXRhKSk7XG52YXIgQ29tcGlsZUFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbk1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhDb21waWxlQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uTWV0YWRhdGEsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGF0ZUNoYW5nZUV4cHJcbiAgICAgKiBAcGFyYW0gez99IHN0ZXBzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tcGlsZUFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbk1ldGFkYXRhKHN0YXRlQ2hhbmdlRXhwciwgc3RlcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RhdGVDaGFuZ2VFeHByID0gc3RhdGVDaGFuZ2VFeHByO1xuICAgICAgICBfdGhpcy5zdGVwcyA9IHN0ZXBzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDb21waWxlQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uTWV0YWRhdGE7XG59KENvbXBpbGVBbmltYXRpb25TdGF0ZU1ldGFkYXRhKSk7XG4vKipcbiAqIEBhYnN0cmFjdFxuICovXG52YXIgQ29tcGlsZUFuaW1hdGlvbk1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21waWxlQW5pbWF0aW9uTWV0YWRhdGEoKSB7XG4gICAgfVxuICAgIHJldHVybiBDb21waWxlQW5pbWF0aW9uTWV0YWRhdGE7XG59KCkpO1xudmFyIENvbXBpbGVBbmltYXRpb25LZXlmcmFtZXNTZXF1ZW5jZU1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhDb21waWxlQW5pbWF0aW9uS2V5ZnJhbWVzU2VxdWVuY2VNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBzdGVwc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbXBpbGVBbmltYXRpb25LZXlmcmFtZXNTZXF1ZW5jZU1ldGFkYXRhKHN0ZXBzKSB7XG4gICAgICAgIGlmIChzdGVwcyA9PT0gdm9pZCAwKSB7IHN0ZXBzID0gW107IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RlcHMgPSBzdGVwcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ29tcGlsZUFuaW1hdGlvbktleWZyYW1lc1NlcXVlbmNlTWV0YWRhdGE7XG59KENvbXBpbGVBbmltYXRpb25NZXRhZGF0YSkpO1xudmFyIENvbXBpbGVBbmltYXRpb25TdHlsZU1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhDb21waWxlQW5pbWF0aW9uU3R5bGVNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG9mZnNldFxuICAgICAqIEBwYXJhbSB7Pz19IHN0eWxlc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbXBpbGVBbmltYXRpb25TdHlsZU1ldGFkYXRhKG9mZnNldCwgc3R5bGVzKSB7XG4gICAgICAgIGlmIChzdHlsZXMgPT09IHZvaWQgMCkgeyBzdHlsZXMgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgX3RoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDb21waWxlQW5pbWF0aW9uU3R5bGVNZXRhZGF0YTtcbn0oQ29tcGlsZUFuaW1hdGlvbk1ldGFkYXRhKSk7XG52YXIgQ29tcGlsZUFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQ29tcGlsZUFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSB0aW1pbmdzXG4gICAgICogQHBhcmFtIHs/PX0gc3R5bGVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tcGlsZUFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YSh0aW1pbmdzLCBzdHlsZXMpIHtcbiAgICAgICAgaWYgKHRpbWluZ3MgPT09IHZvaWQgMCkgeyB0aW1pbmdzID0gMDsgfVxuICAgICAgICBpZiAoc3R5bGVzID09PSB2b2lkIDApIHsgc3R5bGVzID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50aW1pbmdzID0gdGltaW5ncztcbiAgICAgICAgX3RoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDb21waWxlQW5pbWF0aW9uQW5pbWF0ZU1ldGFkYXRhO1xufShDb21waWxlQW5pbWF0aW9uTWV0YWRhdGEpKTtcbi8qKlxuICogQGFic3RyYWN0XG4gKi9cbnZhciBDb21waWxlQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKENvbXBpbGVBbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBzdGVwc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbXBpbGVBbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YShzdGVwcykge1xuICAgICAgICBpZiAoc3RlcHMgPT09IHZvaWQgMCkgeyBzdGVwcyA9IG51bGw7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RlcHMgPSBzdGVwcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ29tcGlsZUFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhO1xufShDb21waWxlQW5pbWF0aW9uTWV0YWRhdGEpKTtcbnZhciBDb21waWxlQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQ29tcGlsZUFuaW1hdGlvblNlcXVlbmNlTWV0YWRhdGEsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gc3RlcHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb21waWxlQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YShzdGVwcykge1xuICAgICAgICBpZiAoc3RlcHMgPT09IHZvaWQgMCkgeyBzdGVwcyA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHN0ZXBzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ29tcGlsZUFuaW1hdGlvblNlcXVlbmNlTWV0YWRhdGE7XG59KENvbXBpbGVBbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YSkpO1xudmFyIENvbXBpbGVBbmltYXRpb25Hcm91cE1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhDb21waWxlQW5pbWF0aW9uR3JvdXBNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBzdGVwc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbXBpbGVBbmltYXRpb25Hcm91cE1ldGFkYXRhKHN0ZXBzKSB7XG4gICAgICAgIGlmIChzdGVwcyA9PT0gdm9pZCAwKSB7IHN0ZXBzID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgc3RlcHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBDb21waWxlQW5pbWF0aW9uR3JvdXBNZXRhZGF0YTtcbn0oQ29tcGlsZUFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gbmFtZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX3Nhbml0aXplSWRlbnRpZmllcihuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUucmVwbGFjZSgvXFxXL2csICdfJyk7XG59XG52YXIgX2Fub255bW91c1R5cGVJbmRleCA9IDA7XG4vKipcbiAqIEBwYXJhbSB7P30gY29tcGlsZUlkZW50aWZpZXJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlkZW50aWZpZXJOYW1lKGNvbXBpbGVJZGVudGlmaWVyKSB7XG4gICAgaWYgKCFjb21waWxlSWRlbnRpZmllciB8fCAhY29tcGlsZUlkZW50aWZpZXIucmVmZXJlbmNlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWYgPSBjb21waWxlSWRlbnRpZmllci5yZWZlcmVuY2U7XG4gICAgaWYgKHJlZiBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICByZXR1cm4gcmVmLm5hbWU7XG4gICAgfVxuICAgIGlmIChyZWZbJ19fYW5vbnltb3VzVHlwZSddKSB7XG4gICAgICAgIHJldHVybiByZWZbJ19fYW5vbnltb3VzVHlwZSddO1xuICAgIH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpZGVudGlmaWVyID0gybVzdHJpbmdpZnkocmVmKTtcbiAgICBpZiAoaWRlbnRpZmllci5pbmRleE9mKCcoJykgPj0gMCkge1xuICAgICAgICAvLyBjYXNlOiBhbm9ueW1vdXMgZnVuY3Rpb25zIVxuICAgICAgICBpZGVudGlmaWVyID0gXCJhbm9ueW1vdXNfXCIgKyBfYW5vbnltb3VzVHlwZUluZGV4Kys7XG4gICAgICAgIHJlZlsnX19hbm9ueW1vdXNUeXBlJ10gPSBpZGVudGlmaWVyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWRlbnRpZmllciA9IF9zYW5pdGl6ZUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgfVxuICAgIHJldHVybiBpZGVudGlmaWVyO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGNvbXBpbGVJZGVudGlmaWVyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpZGVudGlmaWVyTW9kdWxlVXJsKGNvbXBpbGVJZGVudGlmaWVyKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVmID0gY29tcGlsZUlkZW50aWZpZXIucmVmZXJlbmNlO1xuICAgIGlmIChyZWYgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIHJlZi5maWxlUGF0aDtcbiAgICB9XG4gICAgLy8gUnVudGltZSB0eXBlXG4gICAgcmV0dXJuIFwiLi9cIiArIMm1c3RyaW5naWZ5KHJlZik7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gY29tcFR5cGVcbiAqIEBwYXJhbSB7P30gZW1iZWRkZWRUZW1wbGF0ZUluZGV4XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB2aWV3Q2xhc3NOYW1lKGNvbXBUeXBlLCBlbWJlZGRlZFRlbXBsYXRlSW5kZXgpIHtcbiAgICByZXR1cm4gXCJWaWV3X1wiICsgaWRlbnRpZmllck5hbWUoeyByZWZlcmVuY2U6IGNvbXBUeXBlIH0pICsgXCJfXCIgKyBlbWJlZGRlZFRlbXBsYXRlSW5kZXg7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gY29tcFR5cGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHJlbmRlcmVyVHlwZU5hbWUoY29tcFR5cGUpIHtcbiAgICByZXR1cm4gXCJSZW5kZXJUeXBlX1wiICsgaWRlbnRpZmllck5hbWUoeyByZWZlcmVuY2U6IGNvbXBUeXBlIH0pO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGNvbXBUeXBlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBob3N0Vmlld0NsYXNzTmFtZShjb21wVHlwZSkge1xuICAgIHJldHVybiBcIkhvc3RWaWV3X1wiICsgaWRlbnRpZmllck5hbWUoeyByZWZlcmVuY2U6IGNvbXBUeXBlIH0pO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGNvbXBUeXBlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjb21wb25lbnRGYWN0b3J5TmFtZShjb21wVHlwZSkge1xuICAgIHJldHVybiBpZGVudGlmaWVyTmFtZSh7IHJlZmVyZW5jZTogY29tcFR5cGUgfSkgKyBcIk5nRmFjdG9yeVwiO1xufVxudmFyIENvbXBpbGVTdW1tYXJ5S2luZCA9IHt9O1xuQ29tcGlsZVN1bW1hcnlLaW5kLlBpcGUgPSAwO1xuQ29tcGlsZVN1bW1hcnlLaW5kLkRpcmVjdGl2ZSA9IDE7XG5Db21waWxlU3VtbWFyeUtpbmQuTmdNb2R1bGUgPSAyO1xuQ29tcGlsZVN1bW1hcnlLaW5kLkluamVjdGFibGUgPSAzO1xuQ29tcGlsZVN1bW1hcnlLaW5kW0NvbXBpbGVTdW1tYXJ5S2luZC5QaXBlXSA9IFwiUGlwZVwiO1xuQ29tcGlsZVN1bW1hcnlLaW5kW0NvbXBpbGVTdW1tYXJ5S2luZC5EaXJlY3RpdmVdID0gXCJEaXJlY3RpdmVcIjtcbkNvbXBpbGVTdW1tYXJ5S2luZFtDb21waWxlU3VtbWFyeUtpbmQuTmdNb2R1bGVdID0gXCJOZ01vZHVsZVwiO1xuQ29tcGlsZVN1bW1hcnlLaW5kW0NvbXBpbGVTdW1tYXJ5S2luZC5JbmplY3RhYmxlXSA9IFwiSW5qZWN0YWJsZVwiO1xuLyoqXG4gKiBAcGFyYW0gez99IHRva2VuXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB0b2tlbk5hbWUodG9rZW4pIHtcbiAgICByZXR1cm4gdG9rZW4udmFsdWUgIT0gbnVsbCA/IF9zYW5pdGl6ZUlkZW50aWZpZXIodG9rZW4udmFsdWUpIDogaWRlbnRpZmllck5hbWUodG9rZW4uaWRlbnRpZmllcik7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdG9rZW5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHRva2VuUmVmZXJlbmNlKHRva2VuKSB7XG4gICAgaWYgKHRva2VuLmlkZW50aWZpZXIgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdG9rZW4uaWRlbnRpZmllci5yZWZlcmVuY2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdG9rZW4udmFsdWU7XG4gICAgfVxufVxuLyoqXG4gKiBNZXRhZGF0YSBhYm91dCBhIHN0eWxlc2hlZXRcbiAqL1xudmFyIENvbXBpbGVTdHlsZXNoZWV0TWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IF9fMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbXBpbGVTdHlsZXNoZWV0TWV0YWRhdGEoX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG1vZHVsZVVybCA9IF9iLm1vZHVsZVVybCwgc3R5bGVzID0gX2Iuc3R5bGVzLCBzdHlsZVVybHMgPSBfYi5zdHlsZVVybHM7XG4gICAgICAgIHRoaXMubW9kdWxlVXJsID0gbW9kdWxlVXJsIHx8IG51bGw7XG4gICAgICAgIHRoaXMuc3R5bGVzID0gX25vcm1hbGl6ZUFycmF5KHN0eWxlcyk7XG4gICAgICAgIHRoaXMuc3R5bGVVcmxzID0gX25vcm1hbGl6ZUFycmF5KHN0eWxlVXJscyk7XG4gICAgfVxuICAgIHJldHVybiBDb21waWxlU3R5bGVzaGVldE1ldGFkYXRhO1xufSgpKTtcbi8qKlxuICogTWV0YWRhdGEgcmVnYXJkaW5nIGNvbXBpbGF0aW9uIG9mIGEgdGVtcGxhdGUuXG4gKi9cbnZhciBDb21waWxlVGVtcGxhdGVNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfXzBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb21waWxlVGVtcGxhdGVNZXRhZGF0YShfYSkge1xuICAgICAgICB2YXIgZW5jYXBzdWxhdGlvbiA9IF9hLmVuY2Fwc3VsYXRpb24sIHRlbXBsYXRlID0gX2EudGVtcGxhdGUsIHRlbXBsYXRlVXJsID0gX2EudGVtcGxhdGVVcmwsIHN0eWxlcyA9IF9hLnN0eWxlcywgc3R5bGVVcmxzID0gX2Euc3R5bGVVcmxzLCBleHRlcm5hbFN0eWxlc2hlZXRzID0gX2EuZXh0ZXJuYWxTdHlsZXNoZWV0cywgYW5pbWF0aW9ucyA9IF9hLmFuaW1hdGlvbnMsIG5nQ29udGVudFNlbGVjdG9ycyA9IF9hLm5nQ29udGVudFNlbGVjdG9ycywgaW50ZXJwb2xhdGlvbiA9IF9hLmludGVycG9sYXRpb24sIGlzSW5saW5lID0gX2EuaXNJbmxpbmU7XG4gICAgICAgIHRoaXMuZW5jYXBzdWxhdGlvbiA9IGVuY2Fwc3VsYXRpb247XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVVybCA9IHRlbXBsYXRlVXJsO1xuICAgICAgICB0aGlzLnN0eWxlcyA9IF9ub3JtYWxpemVBcnJheShzdHlsZXMpO1xuICAgICAgICB0aGlzLnN0eWxlVXJscyA9IF9ub3JtYWxpemVBcnJheShzdHlsZVVybHMpO1xuICAgICAgICB0aGlzLmV4dGVybmFsU3R5bGVzaGVldHMgPSBfbm9ybWFsaXplQXJyYXkoZXh0ZXJuYWxTdHlsZXNoZWV0cyk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IGFuaW1hdGlvbnMgPyBmbGF0dGVuKGFuaW1hdGlvbnMpIDogW107XG4gICAgICAgIHRoaXMubmdDb250ZW50U2VsZWN0b3JzID0gbmdDb250ZW50U2VsZWN0b3JzIHx8IFtdO1xuICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbiAmJiBpbnRlcnBvbGF0aW9uLmxlbmd0aCAhPSAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCInaW50ZXJwb2xhdGlvbicgc2hvdWxkIGhhdmUgYSBzdGFydCBhbmQgYW4gZW5kIHN5bWJvbC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnRlcnBvbGF0aW9uID0gaW50ZXJwb2xhdGlvbjtcbiAgICAgICAgdGhpcy5pc0lubGluZSA9IGlzSW5saW5lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhLnByb3RvdHlwZS50b1N1bW1hcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhbmltYXRpb25zOiB0aGlzLmFuaW1hdGlvbnMubWFwKGZ1bmN0aW9uIChhbmltKSB7IHJldHVybiBhbmltLm5hbWU7IH0pLFxuICAgICAgICAgICAgbmdDb250ZW50U2VsZWN0b3JzOiB0aGlzLm5nQ29udGVudFNlbGVjdG9ycyxcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IHRoaXMuZW5jYXBzdWxhdGlvbixcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBDb21waWxlVGVtcGxhdGVNZXRhZGF0YTtcbn0oKSk7XG4vKipcbiAqIE1ldGFkYXRhIHJlZ2FyZGluZyBjb21waWxhdGlvbiBvZiBhIGRpcmVjdGl2ZS5cbiAqL1xudmFyIENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfXzBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEoX2EpIHtcbiAgICAgICAgdmFyIGlzSG9zdCA9IF9hLmlzSG9zdCwgdHlwZSA9IF9hLnR5cGUsIGlzQ29tcG9uZW50ID0gX2EuaXNDb21wb25lbnQsIHNlbGVjdG9yID0gX2Euc2VsZWN0b3IsIGV4cG9ydEFzID0gX2EuZXhwb3J0QXMsIGNoYW5nZURldGVjdGlvbiA9IF9hLmNoYW5nZURldGVjdGlvbiwgaW5wdXRzID0gX2EuaW5wdXRzLCBvdXRwdXRzID0gX2Eub3V0cHV0cywgaG9zdExpc3RlbmVycyA9IF9hLmhvc3RMaXN0ZW5lcnMsIGhvc3RQcm9wZXJ0aWVzID0gX2EuaG9zdFByb3BlcnRpZXMsIGhvc3RBdHRyaWJ1dGVzID0gX2EuaG9zdEF0dHJpYnV0ZXMsIHByb3ZpZGVycyA9IF9hLnByb3ZpZGVycywgdmlld1Byb3ZpZGVycyA9IF9hLnZpZXdQcm92aWRlcnMsIHF1ZXJpZXMgPSBfYS5xdWVyaWVzLCB2aWV3UXVlcmllcyA9IF9hLnZpZXdRdWVyaWVzLCBlbnRyeUNvbXBvbmVudHMgPSBfYS5lbnRyeUNvbXBvbmVudHMsIHRlbXBsYXRlID0gX2EudGVtcGxhdGUsIGNvbXBvbmVudFZpZXdUeXBlID0gX2EuY29tcG9uZW50Vmlld1R5cGUsIHJlbmRlcmVyVHlwZSA9IF9hLnJlbmRlcmVyVHlwZSwgY29tcG9uZW50RmFjdG9yeSA9IF9hLmNvbXBvbmVudEZhY3Rvcnk7XG4gICAgICAgIHRoaXMuaXNIb3N0ID0gISFpc0hvc3Q7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuaXNDb21wb25lbnQgPSBpc0NvbXBvbmVudDtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICB0aGlzLmV4cG9ydEFzID0gZXhwb3J0QXM7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0aW9uID0gY2hhbmdlRGV0ZWN0aW9uO1xuICAgICAgICB0aGlzLmlucHV0cyA9IGlucHV0cztcbiAgICAgICAgdGhpcy5vdXRwdXRzID0gb3V0cHV0cztcbiAgICAgICAgdGhpcy5ob3N0TGlzdGVuZXJzID0gaG9zdExpc3RlbmVycztcbiAgICAgICAgdGhpcy5ob3N0UHJvcGVydGllcyA9IGhvc3RQcm9wZXJ0aWVzO1xuICAgICAgICB0aGlzLmhvc3RBdHRyaWJ1dGVzID0gaG9zdEF0dHJpYnV0ZXM7XG4gICAgICAgIHRoaXMucHJvdmlkZXJzID0gX25vcm1hbGl6ZUFycmF5KHByb3ZpZGVycyk7XG4gICAgICAgIHRoaXMudmlld1Byb3ZpZGVycyA9IF9ub3JtYWxpemVBcnJheSh2aWV3UHJvdmlkZXJzKTtcbiAgICAgICAgdGhpcy5xdWVyaWVzID0gX25vcm1hbGl6ZUFycmF5KHF1ZXJpZXMpO1xuICAgICAgICB0aGlzLnZpZXdRdWVyaWVzID0gX25vcm1hbGl6ZUFycmF5KHZpZXdRdWVyaWVzKTtcbiAgICAgICAgdGhpcy5lbnRyeUNvbXBvbmVudHMgPSBfbm9ybWFsaXplQXJyYXkoZW50cnlDb21wb25lbnRzKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgICAgICB0aGlzLmNvbXBvbmVudFZpZXdUeXBlID0gY29tcG9uZW50Vmlld1R5cGU7XG4gICAgICAgIHRoaXMucmVuZGVyZXJUeXBlID0gcmVuZGVyZXJUeXBlO1xuICAgICAgICB0aGlzLmNvbXBvbmVudEZhY3RvcnkgPSBjb21wb25lbnRGYWN0b3J5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9fMFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhLmNyZWF0ZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgaXNIb3N0ID0gX2EuaXNIb3N0LCB0eXBlID0gX2EudHlwZSwgaXNDb21wb25lbnQgPSBfYS5pc0NvbXBvbmVudCwgc2VsZWN0b3IgPSBfYS5zZWxlY3RvciwgZXhwb3J0QXMgPSBfYS5leHBvcnRBcywgY2hhbmdlRGV0ZWN0aW9uID0gX2EuY2hhbmdlRGV0ZWN0aW9uLCBpbnB1dHMgPSBfYS5pbnB1dHMsIG91dHB1dHMgPSBfYS5vdXRwdXRzLCBob3N0ID0gX2EuaG9zdCwgcHJvdmlkZXJzID0gX2EucHJvdmlkZXJzLCB2aWV3UHJvdmlkZXJzID0gX2Eudmlld1Byb3ZpZGVycywgcXVlcmllcyA9IF9hLnF1ZXJpZXMsIHZpZXdRdWVyaWVzID0gX2Eudmlld1F1ZXJpZXMsIGVudHJ5Q29tcG9uZW50cyA9IF9hLmVudHJ5Q29tcG9uZW50cywgdGVtcGxhdGUgPSBfYS50ZW1wbGF0ZSwgY29tcG9uZW50Vmlld1R5cGUgPSBfYS5jb21wb25lbnRWaWV3VHlwZSwgcmVuZGVyZXJUeXBlID0gX2EucmVuZGVyZXJUeXBlLCBjb21wb25lbnRGYWN0b3J5ID0gX2EuY29tcG9uZW50RmFjdG9yeTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaG9zdExpc3RlbmVycyA9IHt9O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBob3N0UHJvcGVydGllcyA9IHt9O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBob3N0QXR0cmlidXRlcyA9IHt9O1xuICAgICAgICBpZiAoaG9zdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhob3N0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IGhvc3Rba2V5XTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXRjaGVzID0ga2V5Lm1hdGNoKEhPU1RfUkVHX0VYUCk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdEF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXRjaGVzWzFdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdFByb3BlcnRpZXNbbWF0Y2hlc1sxXV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2hlc1syXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3RMaXN0ZW5lcnNbbWF0Y2hlc1syXV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnB1dHNNYXAgPSB7fTtcbiAgICAgICAgaWYgKGlucHV0cyAhPSBudWxsKSB7XG4gICAgICAgICAgICBpbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAoYmluZENvbmZpZykge1xuICAgICAgICAgICAgICAgIC8vIGNhbm9uaWNhbCBzeW50YXg6IGBkaXJQcm9wOiBlbFByb3BgXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gYDpgLCB1c2UgZGlyUHJvcCA9IGVsUHJvcFxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnRzID0gc3BsaXRBdENvbG9uKGJpbmRDb25maWcsIFtiaW5kQ29uZmlnLCBiaW5kQ29uZmlnXSk7XG4gICAgICAgICAgICAgICAgaW5wdXRzTWFwW3BhcnRzWzBdXSA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3V0cHV0c01hcCA9IHt9O1xuICAgICAgICBpZiAob3V0cHV0cyAhPSBudWxsKSB7XG4gICAgICAgICAgICBvdXRwdXRzLmZvckVhY2goZnVuY3Rpb24gKGJpbmRDb25maWcpIHtcbiAgICAgICAgICAgICAgICAvLyBjYW5vbmljYWwgc3ludGF4OiBgZGlyUHJvcDogZWxQcm9wYFxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGA6YCwgdXNlIGRpclByb3AgPSBlbFByb3BcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJ0cyA9IHNwbGl0QXRDb2xvbihiaW5kQ29uZmlnLCBbYmluZENvbmZpZywgYmluZENvbmZpZ10pO1xuICAgICAgICAgICAgICAgIG91dHB1dHNNYXBbcGFydHNbMF1dID0gcGFydHNbMV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YSh7XG4gICAgICAgICAgICBpc0hvc3Q6IGlzSG9zdCxcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBpc0NvbXBvbmVudDogISFpc0NvbXBvbmVudCwgc2VsZWN0b3I6IHNlbGVjdG9yLCBleHBvcnRBczogZXhwb3J0QXMsIGNoYW5nZURldGVjdGlvbjogY2hhbmdlRGV0ZWN0aW9uLFxuICAgICAgICAgICAgaW5wdXRzOiBpbnB1dHNNYXAsXG4gICAgICAgICAgICBvdXRwdXRzOiBvdXRwdXRzTWFwLFxuICAgICAgICAgICAgaG9zdExpc3RlbmVyczogaG9zdExpc3RlbmVycyxcbiAgICAgICAgICAgIGhvc3RQcm9wZXJ0aWVzOiBob3N0UHJvcGVydGllcyxcbiAgICAgICAgICAgIGhvc3RBdHRyaWJ1dGVzOiBob3N0QXR0cmlidXRlcyxcbiAgICAgICAgICAgIHByb3ZpZGVyczogcHJvdmlkZXJzLFxuICAgICAgICAgICAgdmlld1Byb3ZpZGVyczogdmlld1Byb3ZpZGVycyxcbiAgICAgICAgICAgIHF1ZXJpZXM6IHF1ZXJpZXMsXG4gICAgICAgICAgICB2aWV3UXVlcmllczogdmlld1F1ZXJpZXMsXG4gICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IGVudHJ5Q29tcG9uZW50cyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcbiAgICAgICAgICAgIGNvbXBvbmVudFZpZXdUeXBlOiBjb21wb25lbnRWaWV3VHlwZSxcbiAgICAgICAgICAgIHJlbmRlcmVyVHlwZTogcmVuZGVyZXJUeXBlLFxuICAgICAgICAgICAgY29tcG9uZW50RmFjdG9yeTogY29tcG9uZW50RmFjdG9yeSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YS5wcm90b3R5cGUudG9TdW1tYXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VtbWFyeUtpbmQ6IENvbXBpbGVTdW1tYXJ5S2luZC5EaXJlY3RpdmUsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICBpc0NvbXBvbmVudDogdGhpcy5pc0NvbXBvbmVudCxcbiAgICAgICAgICAgIHNlbGVjdG9yOiB0aGlzLnNlbGVjdG9yLFxuICAgICAgICAgICAgZXhwb3J0QXM6IHRoaXMuZXhwb3J0QXMsXG4gICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLFxuICAgICAgICAgICAgb3V0cHV0czogdGhpcy5vdXRwdXRzLFxuICAgICAgICAgICAgaG9zdExpc3RlbmVyczogdGhpcy5ob3N0TGlzdGVuZXJzLFxuICAgICAgICAgICAgaG9zdFByb3BlcnRpZXM6IHRoaXMuaG9zdFByb3BlcnRpZXMsXG4gICAgICAgICAgICBob3N0QXR0cmlidXRlczogdGhpcy5ob3N0QXR0cmlidXRlcyxcbiAgICAgICAgICAgIHByb3ZpZGVyczogdGhpcy5wcm92aWRlcnMsXG4gICAgICAgICAgICB2aWV3UHJvdmlkZXJzOiB0aGlzLnZpZXdQcm92aWRlcnMsXG4gICAgICAgICAgICBxdWVyaWVzOiB0aGlzLnF1ZXJpZXMsXG4gICAgICAgICAgICB2aWV3UXVlcmllczogdGhpcy52aWV3UXVlcmllcyxcbiAgICAgICAgICAgIGVudHJ5Q29tcG9uZW50czogdGhpcy5lbnRyeUNvbXBvbmVudHMsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IHRoaXMuY2hhbmdlRGV0ZWN0aW9uLFxuICAgICAgICAgICAgdGVtcGxhdGU6IHRoaXMudGVtcGxhdGUgJiYgdGhpcy50ZW1wbGF0ZS50b1N1bW1hcnkoKSxcbiAgICAgICAgICAgIGNvbXBvbmVudFZpZXdUeXBlOiB0aGlzLmNvbXBvbmVudFZpZXdUeXBlLFxuICAgICAgICAgICAgcmVuZGVyZXJUeXBlOiB0aGlzLnJlbmRlcmVyVHlwZSxcbiAgICAgICAgICAgIGNvbXBvbmVudEZhY3Rvcnk6IHRoaXMuY29tcG9uZW50RmFjdG9yeVxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YTtcbn0oKSk7XG4vKipcbiAqIENvbnN0cnVjdCB7XFxAbGluayBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGF9IGZyb20ge1xcQGxpbmsgQ29tcG9uZW50VHlwZU1ldGFkYXRhfSBhbmQgYSBzZWxlY3Rvci5cbiAqIEBwYXJhbSB7P30gaG9zdFR5cGVSZWZlcmVuY2VcbiAqIEBwYXJhbSB7P30gY29tcE1ldGFcbiAqIEBwYXJhbSB7P30gaG9zdFZpZXdUeXBlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjcmVhdGVIb3N0Q29tcG9uZW50TWV0YShob3N0VHlwZVJlZmVyZW5jZSwgY29tcE1ldGEsIGhvc3RWaWV3VHlwZSkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlbXBsYXRlID0gQ3NzU2VsZWN0b3IucGFyc2UoLyoqIEB0eXBlIHs/fSAqLyAoKGNvbXBNZXRhLnNlbGVjdG9yKSkpWzBdLmdldE1hdGNoaW5nRWxlbWVudFRlbXBsYXRlKCk7XG4gICAgcmV0dXJuIENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YS5jcmVhdGUoe1xuICAgICAgICBpc0hvc3Q6IHRydWUsXG4gICAgICAgIHR5cGU6IHsgcmVmZXJlbmNlOiBob3N0VHlwZVJlZmVyZW5jZSwgZGlEZXBzOiBbXSwgbGlmZWN5Y2xlSG9va3M6IFtdIH0sXG4gICAgICAgIHRlbXBsYXRlOiBuZXcgQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEoe1xuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnJyxcbiAgICAgICAgICAgIHN0eWxlczogW10sXG4gICAgICAgICAgICBzdHlsZVVybHM6IFtdLFxuICAgICAgICAgICAgbmdDb250ZW50U2VsZWN0b3JzOiBbXSxcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IFtdLFxuICAgICAgICAgICAgaXNJbmxpbmU6IHRydWUsXG4gICAgICAgICAgICBleHRlcm5hbFN0eWxlc2hlZXRzOiBbXSxcbiAgICAgICAgICAgIGludGVycG9sYXRpb246IG51bGxcbiAgICAgICAgfSksXG4gICAgICAgIGV4cG9ydEFzOiBudWxsLFxuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LkRlZmF1bHQsXG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG91dHB1dHM6IFtdLFxuICAgICAgICBob3N0OiB7fSxcbiAgICAgICAgaXNDb21wb25lbnQ6IHRydWUsXG4gICAgICAgIHNlbGVjdG9yOiAnKicsXG4gICAgICAgIHByb3ZpZGVyczogW10sXG4gICAgICAgIHZpZXdQcm92aWRlcnM6IFtdLFxuICAgICAgICBxdWVyaWVzOiBbXSxcbiAgICAgICAgdmlld1F1ZXJpZXM6IFtdLFxuICAgICAgICBjb21wb25lbnRWaWV3VHlwZTogaG9zdFZpZXdUeXBlLFxuICAgICAgICByZW5kZXJlclR5cGU6IHsgaWQ6ICdfX0hvc3RfXycsIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsIHN0eWxlczogW10sIGRhdGE6IHt9IH0sXG4gICAgICAgIGVudHJ5Q29tcG9uZW50czogW10sXG4gICAgICAgIGNvbXBvbmVudEZhY3Rvcnk6IG51bGxcbiAgICB9KTtcbn1cbnZhciBDb21waWxlUGlwZU1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9fMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbXBpbGVQaXBlTWV0YWRhdGEoX2EpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBfYS50eXBlLCBuYW1lID0gX2EubmFtZSwgcHVyZSA9IF9hLnB1cmU7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucHVyZSA9ICEhcHVyZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlUGlwZU1ldGFkYXRhLnByb3RvdHlwZS50b1N1bW1hcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdW1tYXJ5S2luZDogQ29tcGlsZVN1bW1hcnlLaW5kLlBpcGUsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBwdXJlOiB0aGlzLnB1cmVcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBDb21waWxlUGlwZU1ldGFkYXRhO1xufSgpKTtcbi8qKlxuICogTWV0YWRhdGEgcmVnYXJkaW5nIGNvbXBpbGF0aW9uIG9mIGEgbW9kdWxlLlxuICovXG52YXIgQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX18wXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEoX2EpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBfYS50eXBlLCBwcm92aWRlcnMgPSBfYS5wcm92aWRlcnMsIGRlY2xhcmVkRGlyZWN0aXZlcyA9IF9hLmRlY2xhcmVkRGlyZWN0aXZlcywgZXhwb3J0ZWREaXJlY3RpdmVzID0gX2EuZXhwb3J0ZWREaXJlY3RpdmVzLCBkZWNsYXJlZFBpcGVzID0gX2EuZGVjbGFyZWRQaXBlcywgZXhwb3J0ZWRQaXBlcyA9IF9hLmV4cG9ydGVkUGlwZXMsIGVudHJ5Q29tcG9uZW50cyA9IF9hLmVudHJ5Q29tcG9uZW50cywgYm9vdHN0cmFwQ29tcG9uZW50cyA9IF9hLmJvb3RzdHJhcENvbXBvbmVudHMsIGltcG9ydGVkTW9kdWxlcyA9IF9hLmltcG9ydGVkTW9kdWxlcywgZXhwb3J0ZWRNb2R1bGVzID0gX2EuZXhwb3J0ZWRNb2R1bGVzLCBzY2hlbWFzID0gX2Euc2NoZW1hcywgdHJhbnNpdGl2ZU1vZHVsZSA9IF9hLnRyYW5zaXRpdmVNb2R1bGUsIGlkID0gX2EuaWQ7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5kZWNsYXJlZERpcmVjdGl2ZXMgPSBfbm9ybWFsaXplQXJyYXkoZGVjbGFyZWREaXJlY3RpdmVzKTtcbiAgICAgICAgdGhpcy5leHBvcnRlZERpcmVjdGl2ZXMgPSBfbm9ybWFsaXplQXJyYXkoZXhwb3J0ZWREaXJlY3RpdmVzKTtcbiAgICAgICAgdGhpcy5kZWNsYXJlZFBpcGVzID0gX25vcm1hbGl6ZUFycmF5KGRlY2xhcmVkUGlwZXMpO1xuICAgICAgICB0aGlzLmV4cG9ydGVkUGlwZXMgPSBfbm9ybWFsaXplQXJyYXkoZXhwb3J0ZWRQaXBlcyk7XG4gICAgICAgIHRoaXMucHJvdmlkZXJzID0gX25vcm1hbGl6ZUFycmF5KHByb3ZpZGVycyk7XG4gICAgICAgIHRoaXMuZW50cnlDb21wb25lbnRzID0gX25vcm1hbGl6ZUFycmF5KGVudHJ5Q29tcG9uZW50cyk7XG4gICAgICAgIHRoaXMuYm9vdHN0cmFwQ29tcG9uZW50cyA9IF9ub3JtYWxpemVBcnJheShib290c3RyYXBDb21wb25lbnRzKTtcbiAgICAgICAgdGhpcy5pbXBvcnRlZE1vZHVsZXMgPSBfbm9ybWFsaXplQXJyYXkoaW1wb3J0ZWRNb2R1bGVzKTtcbiAgICAgICAgdGhpcy5leHBvcnRlZE1vZHVsZXMgPSBfbm9ybWFsaXplQXJyYXkoZXhwb3J0ZWRNb2R1bGVzKTtcbiAgICAgICAgdGhpcy5zY2hlbWFzID0gX25vcm1hbGl6ZUFycmF5KHNjaGVtYXMpO1xuICAgICAgICB0aGlzLmlkID0gaWQgfHwgbnVsbDtcbiAgICAgICAgdGhpcy50cmFuc2l0aXZlTW9kdWxlID0gdHJhbnNpdGl2ZU1vZHVsZSB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVOZ01vZHVsZU1ldGFkYXRhLnByb3RvdHlwZS50b1N1bW1hcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1vZHVsZSA9ICgodGhpcy50cmFuc2l0aXZlTW9kdWxlKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdW1tYXJ5S2luZDogQ29tcGlsZVN1bW1hcnlLaW5kLk5nTW9kdWxlLFxuICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgZW50cnlDb21wb25lbnRzOiBtb2R1bGUuZW50cnlDb21wb25lbnRzLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBtb2R1bGUucHJvdmlkZXJzLFxuICAgICAgICAgICAgbW9kdWxlczogbW9kdWxlLm1vZHVsZXMsXG4gICAgICAgICAgICBleHBvcnRlZERpcmVjdGl2ZXM6IG1vZHVsZS5leHBvcnRlZERpcmVjdGl2ZXMsXG4gICAgICAgICAgICBleHBvcnRlZFBpcGVzOiBtb2R1bGUuZXhwb3J0ZWRQaXBlc1xuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIENvbXBpbGVOZ01vZHVsZU1ldGFkYXRhO1xufSgpKTtcbnZhciBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRyYW5zaXRpdmVDb21waWxlTmdNb2R1bGVNZXRhZGF0YSgpIHtcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzU2V0ID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5leHBvcnRlZERpcmVjdGl2ZXNTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuZXhwb3J0ZWREaXJlY3RpdmVzID0gW107XG4gICAgICAgIHRoaXMucGlwZXNTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMucGlwZXMgPSBbXTtcbiAgICAgICAgdGhpcy5leHBvcnRlZFBpcGVzU2V0ID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmV4cG9ydGVkUGlwZXMgPSBbXTtcbiAgICAgICAgdGhpcy5tb2R1bGVzU2V0ID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLm1vZHVsZXMgPSBbXTtcbiAgICAgICAgdGhpcy5lbnRyeUNvbXBvbmVudHNTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuZW50cnlDb21wb25lbnRzID0gW107XG4gICAgICAgIHRoaXMucHJvdmlkZXJzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJvdmlkZXJcbiAgICAgKiBAcGFyYW0gez99IG1vZHVsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGl2ZUNvbXBpbGVOZ01vZHVsZU1ldGFkYXRhLnByb3RvdHlwZS5hZGRQcm92aWRlciA9IGZ1bmN0aW9uIChwcm92aWRlciwgbW9kdWxlKSB7XG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnB1c2goeyBwcm92aWRlcjogcHJvdmlkZXIsIG1vZHVsZTogbW9kdWxlIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGl2ZUNvbXBpbGVOZ01vZHVsZU1ldGFkYXRhLnByb3RvdHlwZS5hZGREaXJlY3RpdmUgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpcmVjdGl2ZXNTZXQuaGFzKGlkLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlc1NldC5hZGQoaWQucmVmZXJlbmNlKTtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcy5wdXNoKGlkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGl2ZUNvbXBpbGVOZ01vZHVsZU1ldGFkYXRhLnByb3RvdHlwZS5hZGRFeHBvcnRlZERpcmVjdGl2ZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAoIXRoaXMuZXhwb3J0ZWREaXJlY3RpdmVzU2V0LmhhcyhpZC5yZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICB0aGlzLmV4cG9ydGVkRGlyZWN0aXZlc1NldC5hZGQoaWQucmVmZXJlbmNlKTtcbiAgICAgICAgICAgIHRoaXMuZXhwb3J0ZWREaXJlY3RpdmVzLnB1c2goaWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEucHJvdG90eXBlLmFkZFBpcGUgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBpcGVzU2V0LmhhcyhpZC5yZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICB0aGlzLnBpcGVzU2V0LmFkZChpZC5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgdGhpcy5waXBlcy5wdXNoKGlkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGl2ZUNvbXBpbGVOZ01vZHVsZU1ldGFkYXRhLnByb3RvdHlwZS5hZGRFeHBvcnRlZFBpcGUgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmV4cG9ydGVkUGlwZXNTZXQuaGFzKGlkLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwb3J0ZWRQaXBlc1NldC5hZGQoaWQucmVmZXJlbmNlKTtcbiAgICAgICAgICAgIHRoaXMuZXhwb3J0ZWRQaXBlcy5wdXNoKGlkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGl2ZUNvbXBpbGVOZ01vZHVsZU1ldGFkYXRhLnByb3RvdHlwZS5hZGRNb2R1bGUgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1vZHVsZXNTZXQuaGFzKGlkLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgIHRoaXMubW9kdWxlc1NldC5hZGQoaWQucmVmZXJlbmNlKTtcbiAgICAgICAgICAgIHRoaXMubW9kdWxlcy5wdXNoKGlkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlY1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGl2ZUNvbXBpbGVOZ01vZHVsZU1ldGFkYXRhLnByb3RvdHlwZS5hZGRFbnRyeUNvbXBvbmVudCA9IGZ1bmN0aW9uIChlYykge1xuICAgICAgICBpZiAoIXRoaXMuZW50cnlDb21wb25lbnRzU2V0LmhhcyhlYy5jb21wb25lbnRUeXBlKSkge1xuICAgICAgICAgICAgdGhpcy5lbnRyeUNvbXBvbmVudHNTZXQuYWRkKGVjLmNvbXBvbmVudFR5cGUpO1xuICAgICAgICAgICAgdGhpcy5lbnRyeUNvbXBvbmVudHMucHVzaChlYyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGE7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IG9ialxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX25vcm1hbGl6ZUFycmF5KG9iaikge1xuICAgIHJldHVybiBvYmogfHwgW107XG59XG52YXIgUHJvdmlkZXJNZXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRva2VuXG4gICAgICogQHBhcmFtIHs/fSBfXzFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQcm92aWRlck1ldGEodG9rZW4sIF9hKSB7XG4gICAgICAgIHZhciB1c2VDbGFzcyA9IF9hLnVzZUNsYXNzLCB1c2VWYWx1ZSA9IF9hLnVzZVZhbHVlLCB1c2VFeGlzdGluZyA9IF9hLnVzZUV4aXN0aW5nLCB1c2VGYWN0b3J5ID0gX2EudXNlRmFjdG9yeSwgZGVwcyA9IF9hLmRlcHMsIG11bHRpID0gX2EubXVsdGk7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy51c2VDbGFzcyA9IHVzZUNsYXNzIHx8IG51bGw7XG4gICAgICAgIHRoaXMudXNlVmFsdWUgPSB1c2VWYWx1ZTtcbiAgICAgICAgdGhpcy51c2VFeGlzdGluZyA9IHVzZUV4aXN0aW5nO1xuICAgICAgICB0aGlzLnVzZUZhY3RvcnkgPSB1c2VGYWN0b3J5IHx8IG51bGw7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gZGVwcyB8fCBudWxsO1xuICAgICAgICB0aGlzLm11bHRpID0gISFtdWx0aTtcbiAgICB9XG4gICAgcmV0dXJuIFByb3ZpZGVyTWV0YTtcbn0oKSk7XG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0gez99IGxpc3RcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW4obGlzdCkge1xuICAgIHJldHVybiBsaXN0LnJlZHVjZShmdW5jdGlvbiAoZmxhdCwgaXRlbSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmbGF0SXRlbSA9IEFycmF5LmlzQXJyYXkoaXRlbSkgPyBmbGF0dGVuKGl0ZW0pIDogaXRlbTtcbiAgICAgICAgcmV0dXJuICgoZmxhdCkpLmNvbmNhdChmbGF0SXRlbSk7XG4gICAgfSwgW10pO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHVybFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc291cmNlVXJsKHVybCkge1xuICAgIC8vIE5vdGU6IFdlIG5lZWQgMyBcIi9cIiBzbyB0aGF0IG5nIHNob3dzIHVwIGFzIGEgc2VwYXJhdGUgZG9tYWluXG4gICAgLy8gaW4gdGhlIGNocm9tZSBkZXYgdG9vbHMuXG4gICAgcmV0dXJuIHVybC5yZXBsYWNlKC8oXFx3KzpcXC9cXC9bXFx3Oi1dKyk/KFxcLyspPy8sICduZzovLy8nKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBuZ01vZHVsZVR5cGVcbiAqIEBwYXJhbSB7P30gY29tcE1ldGFcbiAqIEBwYXJhbSB7P30gdGVtcGxhdGVNZXRhXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB0ZW1wbGF0ZVNvdXJjZVVybChuZ01vZHVsZVR5cGUsIGNvbXBNZXRhLCB0ZW1wbGF0ZU1ldGEpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1cmw7XG4gICAgaWYgKHRlbXBsYXRlTWV0YS5pc0lubGluZSkge1xuICAgICAgICBpZiAoY29tcE1ldGEudHlwZS5yZWZlcmVuY2UgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgICAgIC8vIE5vdGU6IGEgLnRzIGZpbGUgbWlnaHQgY29udGFpbiBtdWx0aXBsZSBjb21wb25lbnRzIHdpdGggaW5saW5lIHRlbXBsYXRlcyxcbiAgICAgICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gZ2l2ZSB0aGVtIHVuaXF1ZSB1cmxzLCBhcyB0aGVzZSB3aWxsIGJlIHVzZWQgZm9yIHNvdXJjZW1hcHMuXG4gICAgICAgICAgICB1cmwgPSBjb21wTWV0YS50eXBlLnJlZmVyZW5jZS5maWxlUGF0aCArIFwiLlwiICsgY29tcE1ldGEudHlwZS5yZWZlcmVuY2UubmFtZSArIFwiLmh0bWxcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVybCA9IGlkZW50aWZpZXJOYW1lKG5nTW9kdWxlVHlwZSkgKyBcIi9cIiArIGlkZW50aWZpZXJOYW1lKGNvbXBNZXRhLnR5cGUpICsgXCIuaHRtbFwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB1cmwgPSAoKHRlbXBsYXRlTWV0YS50ZW1wbGF0ZVVybCkpO1xuICAgIH1cbiAgICAvLyBhbHdheXMgcHJlcGVuZCBuZzovLyB0byBtYWtlIGFuZ3VsYXIgcmVzb3VyY2VzIGVhc3kgdG8gZmluZCBhbmQgbm90IGNsb2JiZXJcbiAgICAvLyB1c2VyIHJlc291cmNlcy5cbiAgICByZXR1cm4gc291cmNlVXJsKHVybCk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gbWV0YVxuICogQHBhcmFtIHs/fSBpZFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc2hhcmVkU3R5bGVzaGVldEppdFVybChtZXRhLCBpZCkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhdGhQYXJ0cyA9ICgobWV0YS5tb2R1bGVVcmwpKS5zcGxpdCgvXFwvXFxcXC9nKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiYXNlTmFtZSA9IHBhdGhQYXJ0c1twYXRoUGFydHMubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIHNvdXJjZVVybChcImNzcy9cIiArIGlkICsgYmFzZU5hbWUgKyBcIi5uZ3N0eWxlLmpzXCIpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IG1vZHVsZU1ldGFcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG5nTW9kdWxlSml0VXJsKG1vZHVsZU1ldGEpIHtcbiAgICByZXR1cm4gc291cmNlVXJsKGlkZW50aWZpZXJOYW1lKG1vZHVsZU1ldGEudHlwZSkgKyBcIi9tb2R1bGUubmdmYWN0b3J5LmpzXCIpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IG5nTW9kdWxlVHlwZVxuICogQHBhcmFtIHs/fSBjb21wTWV0YVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdGVtcGxhdGVKaXRVcmwobmdNb2R1bGVUeXBlLCBjb21wTWV0YSkge1xuICAgIHJldHVybiBzb3VyY2VVcmwoaWRlbnRpZmllck5hbWUobmdNb2R1bGVUeXBlKSArIFwiL1wiICsgaWRlbnRpZmllck5hbWUoY29tcE1ldGEudHlwZSkgKyBcIi5uZ2ZhY3RvcnkuanNcIik7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIFByb3ZpZGVzIGFjY2VzcyB0byByZWZsZWN0aW9uIGRhdGEgYWJvdXQgc3ltYm9scyB0aGF0IHRoZSBjb21waWxlciBuZWVkcy5cbiAqIEBhYnN0cmFjdFxuICovXG52YXIgQ29tcGlsZVJlZmxlY3RvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29tcGlsZVJlZmxlY3RvcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSB0eXBlT3JGdW5jXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlUmVmbGVjdG9yLnByb3RvdHlwZS5wYXJhbWV0ZXJzID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IHR5cGVPckZ1bmNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVSZWZsZWN0b3IucHJvdG90eXBlLmFubm90YXRpb25zID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IHR5cGVPckZ1bmNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVSZWZsZWN0b3IucHJvdG90eXBlLnByb3BNZXRhZGF0YSA9IGZ1bmN0aW9uICh0eXBlT3JGdW5jKSB7IH07XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHBhcmFtIHs/fSBsY1Byb3BlcnR5XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlUmVmbGVjdG9yLnByb3RvdHlwZS5oYXNMaWZlY3ljbGVIb29rID0gZnVuY3Rpb24gKHR5cGUsIGxjUHJvcGVydHkpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez99IGNtcE1ldGFkYXRhXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlUmVmbGVjdG9yLnByb3RvdHlwZS5jb21wb25lbnRNb2R1bGVVcmwgPSBmdW5jdGlvbiAodHlwZSwgY21wTWV0YWRhdGEpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IHJlZlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZVJlZmxlY3Rvci5wcm90b3R5cGUucmVzb2x2ZUV4dGVybmFsUmVmZXJlbmNlID0gZnVuY3Rpb24gKHJlZikgeyB9O1xuICAgIHJldHVybiBDb21waWxlUmVmbGVjdG9yO1xufSgpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBDb21waWxlckNvbmZpZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gX18wXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tcGlsZXJDb25maWcoX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9jID0gX2IuZGVmYXVsdEVuY2Fwc3VsYXRpb24sIGRlZmF1bHRFbmNhcHN1bGF0aW9uID0gX2MgPT09IHZvaWQgMCA/IFZpZXdFbmNhcHN1bGF0aW9uLkVtdWxhdGVkIDogX2MsIF9kID0gX2IudXNlSml0LCB1c2VKaXQgPSBfZCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9kLCBtaXNzaW5nVHJhbnNsYXRpb24gPSBfYi5taXNzaW5nVHJhbnNsYXRpb24sIGVuYWJsZUxlZ2FjeVRlbXBsYXRlID0gX2IuZW5hYmxlTGVnYWN5VGVtcGxhdGU7XG4gICAgICAgIHRoaXMuZGVmYXVsdEVuY2Fwc3VsYXRpb24gPSBkZWZhdWx0RW5jYXBzdWxhdGlvbjtcbiAgICAgICAgdGhpcy51c2VKaXQgPSAhIXVzZUppdDtcbiAgICAgICAgdGhpcy5taXNzaW5nVHJhbnNsYXRpb24gPSBtaXNzaW5nVHJhbnNsYXRpb24gfHwgbnVsbDtcbiAgICAgICAgdGhpcy5lbmFibGVMZWdhY3lUZW1wbGF0ZSA9IGVuYWJsZUxlZ2FjeVRlbXBsYXRlICE9PSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIENvbXBpbGVyQ29uZmlnO1xufSgpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBQYXJzZXJFcnJvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHs/fSBpbnB1dFxuICAgICAqIEBwYXJhbSB7P30gZXJyTG9jYXRpb25cbiAgICAgKiBAcGFyYW0gez89fSBjdHhMb2NhdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBhcnNlckVycm9yKG1lc3NhZ2UsIGlucHV0LCBlcnJMb2NhdGlvbiwgY3R4TG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLmVyckxvY2F0aW9uID0gZXJyTG9jYXRpb247XG4gICAgICAgIHRoaXMuY3R4TG9jYXRpb24gPSBjdHhMb2NhdGlvbjtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJQYXJzZXIgRXJyb3I6IFwiICsgbWVzc2FnZSArIFwiIFwiICsgZXJyTG9jYXRpb24gKyBcIiBbXCIgKyBpbnB1dCArIFwiXSBpbiBcIiArIGN0eExvY2F0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gUGFyc2VyRXJyb3I7XG59KCkpO1xudmFyIFBhcnNlU3BhbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGFydFxuICAgICAqIEBwYXJhbSB7P30gZW5kXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGFyc2VTcGFuKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICB9XG4gICAgcmV0dXJuIFBhcnNlU3Bhbjtcbn0oKSk7XG52YXIgQVNUID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBU1Qoc3Bhbikge1xuICAgICAgICB0aGlzLnNwYW4gPSBzcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBU1QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQVNULnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdBU1QnOyB9O1xuICAgIHJldHVybiBBU1Q7XG59KCkpO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgcXVvdGVkIGV4cHJlc3Npb24gb2YgdGhlIGZvcm06XG4gKlxuICogcXVvdGUgPSBwcmVmaXggYDpgIHVuaW50ZXJwcmV0ZWRFeHByZXNzaW9uXG4gKiBwcmVmaXggPSBpZGVudGlmaWVyXG4gKiB1bmludGVycHJldGVkRXhwcmVzc2lvbiA9IGFyYml0cmFyeSBzdHJpbmdcbiAqXG4gKiBBIHF1b3RlZCBleHByZXNzaW9uIGlzIG1lYW50IHRvIGJlIHByZS1wcm9jZXNzZWQgYnkgYW4gQVNUIHRyYW5zZm9ybWVyIHRoYXRcbiAqIGNvbnZlcnRzIGl0IGludG8gYW5vdGhlciBBU1QgdGhhdCBubyBsb25nZXIgY29udGFpbnMgcXVvdGVkIGV4cHJlc3Npb25zLlxuICogSXQgaXMgbWVhbnQgdG8gYWxsb3cgdGhpcmQtcGFydHkgZGV2ZWxvcGVycyB0byBleHRlbmQgQW5ndWxhciB0ZW1wbGF0ZVxuICogZXhwcmVzc2lvbiBsYW5ndWFnZS4gVGhlIGB1bmludGVycHJldGVkRXhwcmVzc2lvbmAgcGFydCBvZiB0aGUgcXVvdGUgaXNcbiAqIHRoZXJlZm9yZSBub3QgaW50ZXJwcmV0ZWQgYnkgdGhlIEFuZ3VsYXIncyBvd24gZXhwcmVzc2lvbiBwYXJzZXIuXG4gKi9cbnZhciBRdW90ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoUXVvdGUsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcGFuXG4gICAgICogQHBhcmFtIHs/fSBwcmVmaXhcbiAgICAgKiBAcGFyYW0gez99IHVuaW50ZXJwcmV0ZWRFeHByZXNzaW9uXG4gICAgICogQHBhcmFtIHs/fSBsb2NhdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFF1b3RlKHNwYW4sIHByZWZpeCwgdW5pbnRlcnByZXRlZEV4cHJlc3Npb24sIGxvY2F0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnByZWZpeCA9IHByZWZpeDtcbiAgICAgICAgX3RoaXMudW5pbnRlcnByZXRlZEV4cHJlc3Npb24gPSB1bmludGVycHJldGVkRXhwcmVzc2lvbjtcbiAgICAgICAgX3RoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBRdW90ZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UXVvdGUodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFF1b3RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdRdW90ZSc7IH07XG4gICAgcmV0dXJuIFF1b3RlO1xufShBU1QpKTtcbnZhciBFbXB0eUV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEVtcHR5RXhwciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFbXB0eUV4cHIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRW1wdHlFeHByLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH07XG4gICAgcmV0dXJuIEVtcHR5RXhwcjtcbn0oQVNUKSk7XG52YXIgSW1wbGljaXRSZWNlaXZlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSW1wbGljaXRSZWNlaXZlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbXBsaWNpdFJlY2VpdmVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEltcGxpY2l0UmVjZWl2ZXIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEltcGxpY2l0UmVjZWl2ZXIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gSW1wbGljaXRSZWNlaXZlcjtcbn0oQVNUKSk7XG4vKipcbiAqIE11bHRpcGxlIGV4cHJlc3Npb25zIHNlcGFyYXRlZCBieSBhIHNlbWljb2xvbi5cbiAqL1xudmFyIENoYWluID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhDaGFpbiwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IGV4cHJlc3Npb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2hhaW4oc3BhbiwgZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDaGFpbi5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hhaW4odGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2hhaW47XG59KEFTVCkpO1xudmFyIENvbmRpdGlvbmFsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhDb25kaXRpb25hbCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IGNvbmRpdGlvblxuICAgICAqIEBwYXJhbSB7P30gdHJ1ZUV4cFxuICAgICAqIEBwYXJhbSB7P30gZmFsc2VFeHBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb25kaXRpb25hbChzcGFuLCBjb25kaXRpb24sIHRydWVFeHAsIGZhbHNlRXhwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICAgICAgX3RoaXMudHJ1ZUV4cCA9IHRydWVFeHA7XG4gICAgICAgIF90aGlzLmZhbHNlRXhwID0gZmFsc2VFeHA7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29uZGl0aW9uYWwucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENvbmRpdGlvbmFsKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbmRpdGlvbmFsO1xufShBU1QpKTtcbnZhciBQcm9wZXJ0eVJlYWQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFByb3BlcnR5UmVhZCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IHJlY2VpdmVyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICovXG4gICAgZnVuY3Rpb24gUHJvcGVydHlSZWFkKHNwYW4sIHJlY2VpdmVyLCBuYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFByb3BlcnR5UmVhZC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UHJvcGVydHlSZWFkKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFByb3BlcnR5UmVhZDtcbn0oQVNUKSk7XG52YXIgUHJvcGVydHlXcml0ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoUHJvcGVydHlXcml0ZSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IHJlY2VpdmVyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFByb3BlcnR5V3JpdGUoc3BhbiwgcmVjZWl2ZXIsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFByb3BlcnR5V3JpdGUucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFByb3BlcnR5V3JpdGUodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gUHJvcGVydHlXcml0ZTtcbn0oQVNUKSk7XG52YXIgU2FmZVByb3BlcnR5UmVhZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoU2FmZVByb3BlcnR5UmVhZCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IHJlY2VpdmVyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2FmZVByb3BlcnR5UmVhZChzcGFuLCByZWNlaXZlciwgbmFtZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTYWZlUHJvcGVydHlSZWFkLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRTYWZlUHJvcGVydHlSZWFkKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFNhZmVQcm9wZXJ0eVJlYWQ7XG59KEFTVCkpO1xudmFyIEtleWVkUmVhZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoS2V5ZWRSZWFkLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3BhblxuICAgICAqIEBwYXJhbSB7P30gb2JqXG4gICAgICogQHBhcmFtIHs/fSBrZXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBLZXllZFJlYWQoc3Bhbiwgb2JqLCBrZXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMub2JqID0gb2JqO1xuICAgICAgICBfdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgS2V5ZWRSZWFkLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRLZXllZFJlYWQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gS2V5ZWRSZWFkO1xufShBU1QpKTtcbnZhciBLZXllZFdyaXRlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhLZXllZFdyaXRlLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3BhblxuICAgICAqIEBwYXJhbSB7P30gb2JqXG4gICAgICogQHBhcmFtIHs/fSBrZXlcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gS2V5ZWRXcml0ZShzcGFuLCBvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMub2JqID0gb2JqO1xuICAgICAgICBfdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgS2V5ZWRXcml0ZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0S2V5ZWRXcml0ZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBLZXllZFdyaXRlO1xufShBU1QpKTtcbnZhciBCaW5kaW5nUGlwZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQmluZGluZ1BpcGUsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcGFuXG4gICAgICogQHBhcmFtIHs/fSBleHBcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IGFyZ3NcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCaW5kaW5nUGlwZShzcGFuLCBleHAsIG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZXhwID0gZXhwO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmluZGluZ1BpcGUucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFBpcGUodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQmluZGluZ1BpcGU7XG59KEFTVCkpO1xudmFyIExpdGVyYWxQcmltaXRpdmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKExpdGVyYWxQcmltaXRpdmUsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcGFuXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExpdGVyYWxQcmltaXRpdmUoc3BhbiwgdmFsdWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBMaXRlcmFsUHJpbWl0aXZlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRMaXRlcmFsUHJpbWl0aXZlKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIExpdGVyYWxQcmltaXRpdmU7XG59KEFTVCkpO1xudmFyIExpdGVyYWxBcnJheSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTGl0ZXJhbEFycmF5LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3BhblxuICAgICAqIEBwYXJhbSB7P30gZXhwcmVzc2lvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMaXRlcmFsQXJyYXkoc3BhbiwgZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBMaXRlcmFsQXJyYXkucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdExpdGVyYWxBcnJheSh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBMaXRlcmFsQXJyYXk7XG59KEFTVCkpO1xudmFyIExpdGVyYWxNYXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKExpdGVyYWxNYXAsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcGFuXG4gICAgICogQHBhcmFtIHs/fSBrZXlzXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMaXRlcmFsTWFwKHNwYW4sIGtleXMsIHZhbHVlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5rZXlzID0ga2V5cztcbiAgICAgICAgX3RoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIExpdGVyYWxNYXAucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdExpdGVyYWxNYXAodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gTGl0ZXJhbE1hcDtcbn0oQVNUKSk7XG52YXIgSW50ZXJwb2xhdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSW50ZXJwb2xhdGlvbiwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IHN0cmluZ3NcbiAgICAgKiBAcGFyYW0gez99IGV4cHJlc3Npb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gSW50ZXJwb2xhdGlvbihzcGFuLCBzdHJpbmdzLCBleHByZXNzaW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdHJpbmdzID0gc3RyaW5ncztcbiAgICAgICAgX3RoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBJbnRlcnBvbGF0aW9uLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRJbnRlcnBvbGF0aW9uKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEludGVycG9sYXRpb247XG59KEFTVCkpO1xudmFyIEJpbmFyeSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQmluYXJ5LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3BhblxuICAgICAqIEBwYXJhbSB7P30gb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHs/fSBsZWZ0XG4gICAgICogQHBhcmFtIHs/fSByaWdodFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJpbmFyeShzcGFuLCBvcGVyYXRpb24sIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9wZXJhdGlvbiA9IG9wZXJhdGlvbjtcbiAgICAgICAgX3RoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgIF90aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmluYXJ5LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRCaW5hcnkodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQmluYXJ5O1xufShBU1QpKTtcbnZhciBQcmVmaXhOb3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFByZWZpeE5vdCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IGV4cHJlc3Npb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQcmVmaXhOb3Qoc3BhbiwgZXhwcmVzc2lvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQcmVmaXhOb3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFByZWZpeE5vdCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBQcmVmaXhOb3Q7XG59KEFTVCkpO1xudmFyIE5vbk51bGxBc3NlcnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKE5vbk51bGxBc3NlcnQsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcGFuXG4gICAgICogQHBhcmFtIHs/fSBleHByZXNzaW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gTm9uTnVsbEFzc2VydChzcGFuLCBleHByZXNzaW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5vbk51bGxBc3NlcnQucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdE5vbk51bGxBc3NlcnQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gTm9uTnVsbEFzc2VydDtcbn0oQVNUKSk7XG52YXIgTWV0aG9kQ2FsbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTWV0aG9kQ2FsbCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IHJlY2VpdmVyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBhcmdzXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWV0aG9kQ2FsbChzcGFuLCByZWNlaXZlciwgbmFtZSwgYXJncykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWV0aG9kQ2FsbC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TWV0aG9kQ2FsbCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBNZXRob2RDYWxsO1xufShBU1QpKTtcbnZhciBTYWZlTWV0aG9kQ2FsbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoU2FmZU1ldGhvZENhbGwsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcGFuXG4gICAgICogQHBhcmFtIHs/fSByZWNlaXZlclxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gYXJnc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNhZmVNZXRob2RDYWxsKHNwYW4sIHJlY2VpdmVyLCBuYW1lLCBhcmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTYWZlTWV0aG9kQ2FsbC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0U2FmZU1ldGhvZENhbGwodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gU2FmZU1ldGhvZENhbGw7XG59KEFTVCkpO1xudmFyIEZ1bmN0aW9uQ2FsbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRnVuY3Rpb25DYWxsLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3BhblxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0XG4gICAgICogQHBhcmFtIHs/fSBhcmdzXG4gICAgICovXG4gICAgZnVuY3Rpb24gRnVuY3Rpb25DYWxsKHNwYW4sIHRhcmdldCwgYXJncykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIF90aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEZ1bmN0aW9uQ2FsbC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RnVuY3Rpb25DYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEZ1bmN0aW9uQ2FsbDtcbn0oQVNUKSk7XG52YXIgQVNUV2l0aFNvdXJjZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQVNUV2l0aFNvdXJjZSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gc291cmNlXG4gICAgICogQHBhcmFtIHs/fSBsb2NhdGlvblxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQVNUV2l0aFNvdXJjZShhc3QsIHNvdXJjZSwgbG9jYXRpb24sIGVycm9ycykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuZXcgUGFyc2VTcGFuKDAsIHNvdXJjZSA9PSBudWxsID8gMCA6IHNvdXJjZS5sZW5ndGgpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5hc3QgPSBhc3Q7XG4gICAgICAgIF90aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgX3RoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgX3RoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFTVFdpdGhTb3VyY2UucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdGhpcy5hc3QudmlzaXQodmlzaXRvciwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFTVFdpdGhTb3VyY2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5zb3VyY2UgKyBcIiBpbiBcIiArIHRoaXMubG9jYXRpb247IH07XG4gICAgcmV0dXJuIEFTVFdpdGhTb3VyY2U7XG59KEFTVCkpO1xudmFyIFRlbXBsYXRlQmluZGluZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcGFuXG4gICAgICogQHBhcmFtIHs/fSBrZXlcbiAgICAgKiBAcGFyYW0gez99IGtleUlzVmFyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBleHByZXNzaW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gVGVtcGxhdGVCaW5kaW5nKHNwYW4sIGtleSwga2V5SXNWYXIsIG5hbWUsIGV4cHJlc3Npb24pIHtcbiAgICAgICAgdGhpcy5zcGFuID0gc3BhbjtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMua2V5SXNWYXIgPSBrZXlJc1ZhcjtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICB9XG4gICAgcmV0dXJuIFRlbXBsYXRlQmluZGluZztcbn0oKSk7XG52YXIgTnVsbEFzdFZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE51bGxBc3RWaXNpdG9yKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTnVsbEFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0QmluYXJ5ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOdWxsQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRDaGFpbiA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTnVsbEFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29uZGl0aW9uYWwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE51bGxBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEZ1bmN0aW9uQ2FsbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTnVsbEFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW1wbGljaXRSZWNlaXZlciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTnVsbEFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTnVsbEFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0S2V5ZWRSZWFkID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOdWxsQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRLZXllZFdyaXRlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOdWxsQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE51bGxBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXAgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE51bGxBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxQcmltaXRpdmUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE51bGxBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdE1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE51bGxBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFBpcGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE51bGxBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFByZWZpeE5vdCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTnVsbEFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0Tm9uTnVsbEFzc2VydCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTnVsbEFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0UHJvcGVydHlSZWFkID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOdWxsQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVdyaXRlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOdWxsQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRRdW90ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTnVsbEFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0U2FmZU1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE51bGxBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFNhZmVQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgcmV0dXJuIE51bGxBc3RWaXNpdG9yO1xufSgpKTtcbnZhciBSZWN1cnNpdmVBc3RWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWN1cnNpdmVBc3RWaXNpdG9yKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRCaW5hcnkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5sZWZ0LnZpc2l0KHRoaXMpO1xuICAgICAgICBhc3QucmlnaHQudmlzaXQodGhpcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q2hhaW4gPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucywgY29udGV4dCk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29uZGl0aW9uYWwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5jb25kaXRpb24udmlzaXQodGhpcyk7XG4gICAgICAgIGFzdC50cnVlRXhwLnZpc2l0KHRoaXMpO1xuICAgICAgICBhc3QuZmFsc2VFeHAudmlzaXQodGhpcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0UGlwZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LmV4cC52aXNpdCh0aGlzKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbChhc3QuYXJncywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25DYWxsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAoKGFzdC50YXJnZXQpKS52aXNpdCh0aGlzKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbChhc3QuYXJncywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW1wbGljaXRSZWNlaXZlciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEtleWVkUmVhZCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0Lm9iai52aXNpdCh0aGlzKTtcbiAgICAgICAgYXN0LmtleS52aXNpdCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRLZXllZFdyaXRlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3Qub2JqLnZpc2l0KHRoaXMpO1xuICAgICAgICBhc3Qua2V5LnZpc2l0KHRoaXMpO1xuICAgICAgICBhc3QudmFsdWUudmlzaXQodGhpcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbE1hcCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIHRoaXMudmlzaXRBbGwoYXN0LnZhbHVlcywgY29udGV4dCk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbFByaW1pdGl2ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0TWV0aG9kQ2FsbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsbChhc3QuYXJncywgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRQcmVmaXhOb3QgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5leHByZXNzaW9uLnZpc2l0KHRoaXMpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdE5vbk51bGxBc3NlcnQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5leHByZXNzaW9uLnZpc2l0KHRoaXMpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFByb3BlcnR5UmVhZCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFByb3BlcnR5V3JpdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKTtcbiAgICAgICAgYXN0LnZhbHVlLnZpc2l0KHRoaXMpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFNhZmVQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRTYWZlTWV0aG9kQ2FsbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsbChhc3QuYXJncywgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdHNcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0QWxsID0gZnVuY3Rpb24gKGFzdHMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgYXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGFzdC52aXNpdChfdGhpcywgY29udGV4dCk7IH0pO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFF1b3RlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICByZXR1cm4gUmVjdXJzaXZlQXN0VmlzaXRvcjtcbn0oKSk7XG52YXIgQXN0VHJhbnNmb3JtZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFzdFRyYW5zZm9ybWVyKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0SW1wbGljaXRSZWNlaXZlciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIGFzdDsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0SW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnRlcnBvbGF0aW9uKGFzdC5zcGFuLCBhc3Quc3RyaW5ncywgdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRMaXRlcmFsUHJpbWl0aXZlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxQcmltaXRpdmUoYXN0LnNwYW4sIGFzdC52YWx1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0UHJvcGVydHlSZWFkID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5UmVhZChhc3Quc3BhbiwgYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpLCBhc3QubmFtZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0UHJvcGVydHlXcml0ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wZXJ0eVdyaXRlKGFzdC5zcGFuLCBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyksIGFzdC5uYW1lLCBhc3QudmFsdWUudmlzaXQodGhpcykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFNhZmVQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgU2FmZVByb3BlcnR5UmVhZChhc3Quc3BhbiwgYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpLCBhc3QubmFtZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0TWV0aG9kQ2FsbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNZXRob2RDYWxsKGFzdC5zcGFuLCBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyksIGFzdC5uYW1lLCB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0U2FmZU1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgU2FmZU1ldGhvZENhbGwoYXN0LnNwYW4sIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKSwgYXN0Lm5hbWUsIHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkNhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25DYWxsKGFzdC5zcGFuLCAvKiogQHR5cGUgez99ICovICgoYXN0LnRhcmdldCkpLnZpc2l0KHRoaXMpLCB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxBcnJheShhc3Quc3BhbiwgdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRMaXRlcmFsTWFwID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxNYXAoYXN0LnNwYW4sIGFzdC5rZXlzLCB0aGlzLnZpc2l0QWxsKGFzdC52YWx1ZXMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRCaW5hcnkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5KGFzdC5zcGFuLCBhc3Qub3BlcmF0aW9uLCBhc3QubGVmdC52aXNpdCh0aGlzKSwgYXN0LnJpZ2h0LnZpc2l0KHRoaXMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRQcmVmaXhOb3QgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJlZml4Tm90KGFzdC5zcGFuLCBhc3QuZXhwcmVzc2lvbi52aXNpdCh0aGlzKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0Tm9uTnVsbEFzc2VydCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb25OdWxsQXNzZXJ0KGFzdC5zcGFuLCBhc3QuZXhwcmVzc2lvbi52aXNpdCh0aGlzKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0Q29uZGl0aW9uYWwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29uZGl0aW9uYWwoYXN0LnNwYW4sIGFzdC5jb25kaXRpb24udmlzaXQodGhpcyksIGFzdC50cnVlRXhwLnZpc2l0KHRoaXMpLCBhc3QuZmFsc2VFeHAudmlzaXQodGhpcykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFBpcGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluZGluZ1BpcGUoYXN0LnNwYW4sIGFzdC5leHAudmlzaXQodGhpcyksIGFzdC5uYW1lLCB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0S2V5ZWRSZWFkID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEtleWVkUmVhZChhc3Quc3BhbiwgYXN0Lm9iai52aXNpdCh0aGlzKSwgYXN0LmtleS52aXNpdCh0aGlzKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0S2V5ZWRXcml0ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBLZXllZFdyaXRlKGFzdC5zcGFuLCBhc3Qub2JqLnZpc2l0KHRoaXMpLCBhc3Qua2V5LnZpc2l0KHRoaXMpLCBhc3QudmFsdWUudmlzaXQodGhpcykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRBbGwgPSBmdW5jdGlvbiAoYXN0cykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXMgPSBuZXcgQXJyYXkoYXN0cy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgYXN0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzW2ldID0gYXN0c1tpXS52aXNpdCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdENoYWluID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IENoYWluKGFzdC5zcGFuLCB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFF1b3RlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFF1b3RlKGFzdC5zcGFuLCBhc3QucHJlZml4LCBhc3QudW5pbnRlcnByZXRlZEV4cHJlc3Npb24sIGFzdC5sb2NhdGlvbik7XG4gICAgfTtcbiAgICByZXR1cm4gQXN0VHJhbnNmb3JtZXI7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IGFzdFxuICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gKiBAcGFyYW0gez89fSBjb250ZXh0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB2aXNpdEFzdENoaWxkcmVuKGFzdCwgdmlzaXRvciwgY29udGV4dCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2aXNpdChhc3QpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdCAmJiB2aXNpdG9yLnZpc2l0KGFzdCwgY29udGV4dCkgfHwgYXN0LnZpc2l0KHZpc2l0b3IsIGNvbnRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGVtcGxhdGUgVFxuICAgICAqIEBwYXJhbSB7P30gYXN0c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gdmlzaXRBbGwoYXN0cykgeyBhc3RzLmZvckVhY2godmlzaXQpOyB9XG4gICAgYXN0LnZpc2l0KHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICB2aXNpdEJpbmFyeTogZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICAgICAgdmlzaXQoYXN0LmxlZnQpO1xuICAgICAgICAgICAgdmlzaXQoYXN0LnJpZ2h0KTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICB2aXNpdENoYWluOiBmdW5jdGlvbiAoYXN0KSB7IHZpc2l0QWxsKGFzdC5leHByZXNzaW9ucyk7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgdmlzaXRDb25kaXRpb25hbDogZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICAgICAgdmlzaXQoYXN0LmNvbmRpdGlvbik7XG4gICAgICAgICAgICB2aXNpdChhc3QudHJ1ZUV4cCk7XG4gICAgICAgICAgICB2aXNpdChhc3QuZmFsc2VFeHApO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHZpc2l0RnVuY3Rpb25DYWxsOiBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgICBpZiAoYXN0LnRhcmdldCkge1xuICAgICAgICAgICAgICAgIHZpc2l0KGFzdC50YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmlzaXRBbGwoYXN0LmFyZ3MpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHZpc2l0SW1wbGljaXRSZWNlaXZlcjogZnVuY3Rpb24gKGFzdCkgeyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHZpc2l0SW50ZXJwb2xhdGlvbjogZnVuY3Rpb24gKGFzdCkgeyB2aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMpOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHZpc2l0S2V5ZWRSZWFkOiBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgICB2aXNpdChhc3Qub2JqKTtcbiAgICAgICAgICAgIHZpc2l0KGFzdC5rZXkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHZpc2l0S2V5ZWRXcml0ZTogZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICAgICAgdmlzaXQoYXN0Lm9iaik7XG4gICAgICAgICAgICB2aXNpdChhc3Qua2V5KTtcbiAgICAgICAgICAgIHZpc2l0KGFzdC5vYmopO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHZpc2l0TGl0ZXJhbEFycmF5OiBmdW5jdGlvbiAoYXN0KSB7IHZpc2l0QWxsKGFzdC5leHByZXNzaW9ucyk7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgdmlzaXRMaXRlcmFsTWFwOiBmdW5jdGlvbiAoYXN0KSB7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgdmlzaXRMaXRlcmFsUHJpbWl0aXZlOiBmdW5jdGlvbiAoYXN0KSB7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgdmlzaXRNZXRob2RDYWxsOiBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgICB2aXNpdChhc3QucmVjZWl2ZXIpO1xuICAgICAgICAgICAgdmlzaXRBbGwoYXN0LmFyZ3MpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHZpc2l0UGlwZTogZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICAgICAgdmlzaXQoYXN0LmV4cCk7XG4gICAgICAgICAgICB2aXNpdEFsbChhc3QuYXJncyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgdmlzaXRQcmVmaXhOb3Q6IGZ1bmN0aW9uIChhc3QpIHsgdmlzaXQoYXN0LmV4cHJlc3Npb24pOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHZpc2l0Tm9uTnVsbEFzc2VydDogZnVuY3Rpb24gKGFzdCkgeyB2aXNpdChhc3QuZXhwcmVzc2lvbik7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgdmlzaXRQcm9wZXJ0eVJlYWQ6IGZ1bmN0aW9uIChhc3QpIHsgdmlzaXQoYXN0LnJlY2VpdmVyKTsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICB2aXNpdFByb3BlcnR5V3JpdGU6IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICAgIHZpc2l0KGFzdC5yZWNlaXZlcik7XG4gICAgICAgICAgICB2aXNpdChhc3QudmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHZpc2l0UXVvdGU6IGZ1bmN0aW9uIChhc3QpIHsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICB2aXNpdFNhZmVNZXRob2RDYWxsOiBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgICB2aXNpdChhc3QucmVjZWl2ZXIpO1xuICAgICAgICAgICAgdmlzaXRBbGwoYXN0LmFyZ3MpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHZpc2l0U2FmZVByb3BlcnR5UmVhZDogZnVuY3Rpb24gKGFzdCkgeyB2aXNpdChhc3QucmVjZWl2ZXIpOyB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyICRFT0YgPSAwO1xudmFyICRUQUIgPSA5O1xudmFyICRMRiA9IDEwO1xudmFyICRWVEFCID0gMTE7XG52YXIgJEZGID0gMTI7XG52YXIgJENSID0gMTM7XG52YXIgJFNQQUNFID0gMzI7XG52YXIgJEJBTkcgPSAzMztcbnZhciAkRFEgPSAzNDtcbnZhciAkSEFTSCA9IDM1O1xudmFyICQkID0gMzY7XG52YXIgJFBFUkNFTlQgPSAzNztcbnZhciAkQU1QRVJTQU5EID0gMzg7XG52YXIgJFNRID0gMzk7XG52YXIgJExQQVJFTiA9IDQwO1xudmFyICRSUEFSRU4gPSA0MTtcbnZhciAkU1RBUiA9IDQyO1xudmFyICRQTFVTID0gNDM7XG52YXIgJENPTU1BID0gNDQ7XG52YXIgJE1JTlVTID0gNDU7XG52YXIgJFBFUklPRCA9IDQ2O1xudmFyICRTTEFTSCA9IDQ3O1xudmFyICRDT0xPTiA9IDU4O1xudmFyICRTRU1JQ09MT04gPSA1OTtcbnZhciAkTFQgPSA2MDtcbnZhciAkRVEgPSA2MTtcbnZhciAkR1QgPSA2MjtcbnZhciAkUVVFU1RJT04gPSA2MztcbnZhciAkMCA9IDQ4O1xudmFyICQ5ID0gNTc7XG52YXIgJEEgPSA2NTtcbnZhciAkRSA9IDY5O1xudmFyICRGID0gNzA7XG52YXIgJFggPSA4ODtcbnZhciAkWiA9IDkwO1xudmFyICRMQlJBQ0tFVCA9IDkxO1xudmFyICRCQUNLU0xBU0ggPSA5MjtcbnZhciAkUkJSQUNLRVQgPSA5MztcbnZhciAkQ0FSRVQgPSA5NDtcbnZhciAkXyA9IDk1O1xudmFyICRhID0gOTc7XG52YXIgJGUgPSAxMDE7XG52YXIgJGYgPSAxMDI7XG52YXIgJG4gPSAxMTA7XG52YXIgJHIgPSAxMTQ7XG52YXIgJHQgPSAxMTY7XG52YXIgJHUgPSAxMTc7XG52YXIgJHYgPSAxMTg7XG52YXIgJHggPSAxMjA7XG52YXIgJHogPSAxMjI7XG52YXIgJExCUkFDRSA9IDEyMztcbnZhciAkQkFSID0gMTI0O1xudmFyICRSQlJBQ0UgPSAxMjU7XG52YXIgJE5CU1AgPSAxNjA7XG52YXIgJEJUID0gOTY7XG4vKipcbiAqIEBwYXJhbSB7P30gY29kZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKGNvZGUpIHtcbiAgICByZXR1cm4gKGNvZGUgPj0gJFRBQiAmJiBjb2RlIDw9ICRTUEFDRSkgfHwgKGNvZGUgPT0gJE5CU1ApO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGNvZGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzRGlnaXQoY29kZSkge1xuICAgIHJldHVybiAkMCA8PSBjb2RlICYmIGNvZGUgPD0gJDk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gY29kZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNBc2NpaUxldHRlcihjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPj0gJGEgJiYgY29kZSA8PSAkeiB8fCBjb2RlID49ICRBICYmIGNvZGUgPD0gJFo7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gY29kZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNBc2NpaUhleERpZ2l0KGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA+PSAkYSAmJiBjb2RlIDw9ICRmIHx8IGNvZGUgPj0gJEEgJiYgY29kZSA8PSAkRiB8fCBpc0RpZ2l0KGNvZGUpO1xufVxuLyoqXG4gKiBBIHJlcGxhY2VtZW50IGZvciBcXEBJbmplY3RhYmxlIHRvIGJlIHVzZWQgaW4gdGhlIGNvbXBpbGVyLCBzbyB0aGF0XG4gKiB3ZSBkb24ndCB0cnkgdG8gZXZhbHVhdGUgdGhlIG1ldGFkYXRhIGluIHRoZSBjb21waWxlciBkdXJpbmcgQW9ULlxuICogVGhpcyBkZWNvcmF0b3IgaXMgZW5vdWdoIHRvIG1ha2UgdGhlIGNvbXBpbGVyIHdvcmsgd2l0aCB0aGUgUmVmbGVjdGl2ZUluamVjdG9yIHRob3VnaC5cbiAqIFxcQEFubm90YXRpb25cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIENvbXBpbGVySW5qZWN0YWJsZSgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH07XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEBwYXJhbSB7P30gaWRlbnRpZmllclxuICogQHBhcmFtIHs/fSB2YWx1ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0QXJyYXlPZlN0cmluZ3MoaWRlbnRpZmllciwgdmFsdWUpIHtcbiAgICBpZiAoIWlzRGV2TW9kZSgpIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkICdcIiArIGlkZW50aWZpZXIgKyBcIicgdG8gYmUgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cIik7XG4gICAgfVxuICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgJ1wiICsgaWRlbnRpZmllciArIFwiJyB0byBiZSBhbiBhcnJheSBvZiBzdHJpbmdzLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbnZhciBJTlRFUlBPTEFUSU9OX0JMQUNLTElTVF9SRUdFWFBTID0gW1xuICAgIC9eXFxzKiQvLFxuICAgIC9bPD5dLyxcbiAgICAvXlt7fV0kLyxcbiAgICAvJigjfFthLXpdKS9pLFxuICAgIC9eXFwvXFwvLyxcbl07XG4vKipcbiAqIEBwYXJhbSB7P30gaWRlbnRpZmllclxuICogQHBhcmFtIHs/fSB2YWx1ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SW50ZXJwb2xhdGlvblN5bWJvbHMoaWRlbnRpZmllciwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiAhKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PSAyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCAnXCIgKyBpZGVudGlmaWVyICsgXCInIHRvIGJlIGFuIGFycmF5LCBbc3RhcnQsIGVuZF0uXCIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0Rldk1vZGUoKSAmJiB2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0XzEgPSAodmFsdWVbMF0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbmRfMSA9ICh2YWx1ZVsxXSk7XG4gICAgICAgIC8vIGJsYWNrIGxpc3QgY2hlY2tpbmdcbiAgICAgICAgSU5URVJQT0xBVElPTl9CTEFDS0xJU1RfUkVHRVhQUy5mb3JFYWNoKGZ1bmN0aW9uIChyZWdleHApIHtcbiAgICAgICAgICAgIGlmIChyZWdleHAudGVzdChzdGFydF8xKSB8fCByZWdleHAudGVzdChlbmRfMSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbJ1wiICsgc3RhcnRfMSArIFwiJywgJ1wiICsgZW5kXzEgKyBcIiddIGNvbnRhaW5zIHVudXNhYmxlIGludGVycG9sYXRpb24gc3ltYm9sLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEludGVycG9sYXRpb25Db25maWcgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RhcnRcbiAgICAgKiBAcGFyYW0gez99IGVuZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEludGVycG9sYXRpb25Db25maWcoc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1hcmtlcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEludGVycG9sYXRpb25Db25maWcuZnJvbUFycmF5ID0gZnVuY3Rpb24gKG1hcmtlcnMpIHtcbiAgICAgICAgaWYgKCFtYXJrZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRztcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRJbnRlcnBvbGF0aW9uU3ltYm9scygnaW50ZXJwb2xhdGlvbicsIG1hcmtlcnMpO1xuICAgICAgICByZXR1cm4gbmV3IEludGVycG9sYXRpb25Db25maWcobWFya2Vyc1swXSwgbWFya2Vyc1sxXSk7XG4gICAgfTtcbiAgICA7XG4gICAgcmV0dXJuIEludGVycG9sYXRpb25Db25maWc7XG59KCkpO1xudmFyIERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUcgPSBuZXcgSW50ZXJwb2xhdGlvbkNvbmZpZygne3snLCAnfX0nKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBUb2tlblR5cGUgPSB7fTtcblRva2VuVHlwZS5DaGFyYWN0ZXIgPSAwO1xuVG9rZW5UeXBlLklkZW50aWZpZXIgPSAxO1xuVG9rZW5UeXBlLktleXdvcmQgPSAyO1xuVG9rZW5UeXBlLlN0cmluZyA9IDM7XG5Ub2tlblR5cGUuT3BlcmF0b3IgPSA0O1xuVG9rZW5UeXBlLk51bWJlciA9IDU7XG5Ub2tlblR5cGUuRXJyb3IgPSA2O1xuVG9rZW5UeXBlW1Rva2VuVHlwZS5DaGFyYWN0ZXJdID0gXCJDaGFyYWN0ZXJcIjtcblRva2VuVHlwZVtUb2tlblR5cGUuSWRlbnRpZmllcl0gPSBcIklkZW50aWZpZXJcIjtcblRva2VuVHlwZVtUb2tlblR5cGUuS2V5d29yZF0gPSBcIktleXdvcmRcIjtcblRva2VuVHlwZVtUb2tlblR5cGUuU3RyaW5nXSA9IFwiU3RyaW5nXCI7XG5Ub2tlblR5cGVbVG9rZW5UeXBlLk9wZXJhdG9yXSA9IFwiT3BlcmF0b3JcIjtcblRva2VuVHlwZVtUb2tlblR5cGUuTnVtYmVyXSA9IFwiTnVtYmVyXCI7XG5Ub2tlblR5cGVbVG9rZW5UeXBlLkVycm9yXSA9IFwiRXJyb3JcIjtcbnZhciBLRVlXT1JEUyA9IFsndmFyJywgJ2xldCcsICdhcycsICdudWxsJywgJ3VuZGVmaW5lZCcsICd0cnVlJywgJ2ZhbHNlJywgJ2lmJywgJ2Vsc2UnLCAndGhpcyddO1xudmFyIExleGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMZXhlcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBMZXhlci5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzY2FubmVyID0gbmV3IF9TY2FubmVyKHRleHQpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b2tlbnMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9rZW4gPSBzY2FubmVyLnNjYW5Ub2tlbigpO1xuICAgICAgICB3aGlsZSAodG9rZW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgdG9rZW4gPSBzY2FubmVyLnNjYW5Ub2tlbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfTtcbiAgICByZXR1cm4gTGV4ZXI7XG59KCkpO1xuTGV4ZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBpbGVySW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTGV4ZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbnZhciBUb2tlbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbmRleFxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7P30gbnVtVmFsdWVcbiAgICAgKiBAcGFyYW0gez99IHN0clZhbHVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gVG9rZW4oaW5kZXgsIHR5cGUsIG51bVZhbHVlLCBzdHJWYWx1ZSkge1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMubnVtVmFsdWUgPSBudW1WYWx1ZTtcbiAgICAgICAgdGhpcy5zdHJWYWx1ZSA9IHN0clZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRva2VuLnByb3RvdHlwZS5pc0NoYXJhY3RlciA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLkNoYXJhY3RlciAmJiB0aGlzLm51bVZhbHVlID09IGNvZGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRva2VuLnByb3RvdHlwZS5pc051bWJlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuTnVtYmVyOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVG9rZW4ucHJvdG90eXBlLmlzU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZS5TdHJpbmc7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBvcGVyYXRlclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVG9rZW4ucHJvdG90eXBlLmlzT3BlcmF0b3IgPSBmdW5jdGlvbiAob3BlcmF0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuT3BlcmF0b3IgJiYgdGhpcy5zdHJWYWx1ZSA9PSBvcGVyYXRlcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVG9rZW4ucHJvdG90eXBlLmlzSWRlbnRpZmllciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuSWRlbnRpZmllcjsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRva2VuLnByb3RvdHlwZS5pc0tleXdvcmQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLktleXdvcmQ7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUb2tlbi5wcm90b3R5cGUuaXNLZXl3b3JkTGV0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gJ2xldCc7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUb2tlbi5wcm90b3R5cGUuaXNLZXl3b3JkQXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLktleXdvcmQgJiYgdGhpcy5zdHJWYWx1ZSA9PSAnYXMnOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVG9rZW4ucHJvdG90eXBlLmlzS2V5d29yZE51bGwgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLktleXdvcmQgJiYgdGhpcy5zdHJWYWx1ZSA9PSAnbnVsbCc7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUb2tlbi5wcm90b3R5cGUuaXNLZXl3b3JkVW5kZWZpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gJ3VuZGVmaW5lZCc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRva2VuLnByb3RvdHlwZS5pc0tleXdvcmRUcnVlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gJ3RydWUnOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVG9rZW4ucHJvdG90eXBlLmlzS2V5d29yZEZhbHNlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gJ2ZhbHNlJzsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRva2VuLnByb3RvdHlwZS5pc0tleXdvcmRUaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gJ3RoaXMnOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVG9rZW4ucHJvdG90eXBlLmlzRXJyb3IgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLkVycm9yOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVG9rZW4ucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZS5OdW1iZXIgPyB0aGlzLm51bVZhbHVlIDogLTE7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUb2tlbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFRva2VuVHlwZS5DaGFyYWN0ZXI6XG4gICAgICAgICAgICBjYXNlIFRva2VuVHlwZS5JZGVudGlmaWVyOlxuICAgICAgICAgICAgY2FzZSBUb2tlblR5cGUuS2V5d29yZDpcbiAgICAgICAgICAgIGNhc2UgVG9rZW5UeXBlLk9wZXJhdG9yOlxuICAgICAgICAgICAgY2FzZSBUb2tlblR5cGUuU3RyaW5nOlxuICAgICAgICAgICAgY2FzZSBUb2tlblR5cGUuRXJyb3I6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyVmFsdWU7XG4gICAgICAgICAgICBjYXNlIFRva2VuVHlwZS5OdW1iZXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUb2tlbjtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gaW5kZXhcbiAqIEBwYXJhbSB7P30gY29kZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gbmV3Q2hhcmFjdGVyVG9rZW4oaW5kZXgsIGNvZGUpIHtcbiAgICByZXR1cm4gbmV3IFRva2VuKGluZGV4LCBUb2tlblR5cGUuQ2hhcmFjdGVyLCBjb2RlLCBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBpbmRleFxuICogQHBhcmFtIHs/fSB0ZXh0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBuZXdJZGVudGlmaWVyVG9rZW4oaW5kZXgsIHRleHQpIHtcbiAgICByZXR1cm4gbmV3IFRva2VuKGluZGV4LCBUb2tlblR5cGUuSWRlbnRpZmllciwgMCwgdGV4dCk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gaW5kZXhcbiAqIEBwYXJhbSB7P30gdGV4dFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gbmV3S2V5d29yZFRva2VuKGluZGV4LCB0ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbihpbmRleCwgVG9rZW5UeXBlLktleXdvcmQsIDAsIHRleHQpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGluZGV4XG4gKiBAcGFyYW0gez99IHRleHRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG5ld09wZXJhdG9yVG9rZW4oaW5kZXgsIHRleHQpIHtcbiAgICByZXR1cm4gbmV3IFRva2VuKGluZGV4LCBUb2tlblR5cGUuT3BlcmF0b3IsIDAsIHRleHQpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGluZGV4XG4gKiBAcGFyYW0gez99IHRleHRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG5ld1N0cmluZ1Rva2VuKGluZGV4LCB0ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbihpbmRleCwgVG9rZW5UeXBlLlN0cmluZywgMCwgdGV4dCk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gaW5kZXhcbiAqIEBwYXJhbSB7P30gblxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gbmV3TnVtYmVyVG9rZW4oaW5kZXgsIG4pIHtcbiAgICByZXR1cm4gbmV3IFRva2VuKGluZGV4LCBUb2tlblR5cGUuTnVtYmVyLCBuLCAnJyk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gaW5kZXhcbiAqIEBwYXJhbSB7P30gbWVzc2FnZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gbmV3RXJyb3JUb2tlbihpbmRleCwgbWVzc2FnZSkge1xuICAgIHJldHVybiBuZXcgVG9rZW4oaW5kZXgsIFRva2VuVHlwZS5FcnJvciwgMCwgbWVzc2FnZSk7XG59XG52YXIgRU9GID0gbmV3IFRva2VuKC0xLCBUb2tlblR5cGUuQ2hhcmFjdGVyLCAwLCAnJyk7XG52YXIgX1NjYW5uZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW5wdXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfU2Nhbm5lcihpbnB1dCkge1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMucGVlayA9IDA7XG4gICAgICAgIHRoaXMuaW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9TY2FubmVyLnByb3RvdHlwZS5hZHZhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBlZWsgPSArK3RoaXMuaW5kZXggPj0gdGhpcy5sZW5ndGggPyAkRU9GIDogdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfU2Nhbm5lci5wcm90b3R5cGUuc2NhblRva2VuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnB1dCA9IHRoaXMuaW5wdXQsIC8qKiBAdHlwZSB7P30gKi8gbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBlZWsgPSB0aGlzLnBlZWssIC8qKiBAdHlwZSB7P30gKi8gaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICAvLyBTa2lwIHdoaXRlc3BhY2UuXG4gICAgICAgIHdoaWxlIChwZWVrIDw9ICRTUEFDRSkge1xuICAgICAgICAgICAgaWYgKCsraW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcGVlayA9ICRFT0Y7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWVrID0gaW5wdXQuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZWVrID0gcGVlaztcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICBpZiAoaW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgaWRlbnRpZmllcnMgYW5kIG51bWJlcnMuXG4gICAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChwZWVrKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5JZGVudGlmaWVyKCk7XG4gICAgICAgIGlmIChpc0RpZ2l0KHBlZWspKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nhbk51bWJlcihpbmRleCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0ID0gaW5kZXg7XG4gICAgICAgIHN3aXRjaCAocGVlaykge1xuICAgICAgICAgICAgY2FzZSAkUEVSSU9EOlxuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0RpZ2l0KHRoaXMucGVlaykgPyB0aGlzLnNjYW5OdW1iZXIoc3RhcnQpIDpcbiAgICAgICAgICAgICAgICAgICAgbmV3Q2hhcmFjdGVyVG9rZW4oc3RhcnQsICRQRVJJT0QpO1xuICAgICAgICAgICAgY2FzZSAkTFBBUkVOOlxuICAgICAgICAgICAgY2FzZSAkUlBBUkVOOlxuICAgICAgICAgICAgY2FzZSAkTEJSQUNFOlxuICAgICAgICAgICAgY2FzZSAkUkJSQUNFOlxuICAgICAgICAgICAgY2FzZSAkTEJSQUNLRVQ6XG4gICAgICAgICAgICBjYXNlICRSQlJBQ0tFVDpcbiAgICAgICAgICAgIGNhc2UgJENPTU1BOlxuICAgICAgICAgICAgY2FzZSAkQ09MT046XG4gICAgICAgICAgICBjYXNlICRTRU1JQ09MT046XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkNoYXJhY3RlcihzdGFydCwgcGVlayk7XG4gICAgICAgICAgICBjYXNlICRTUTpcbiAgICAgICAgICAgIGNhc2UgJERROlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5TdHJpbmcoKTtcbiAgICAgICAgICAgIGNhc2UgJEhBU0g6XG4gICAgICAgICAgICBjYXNlICRQTFVTOlxuICAgICAgICAgICAgY2FzZSAkTUlOVVM6XG4gICAgICAgICAgICBjYXNlICRTVEFSOlxuICAgICAgICAgICAgY2FzZSAkU0xBU0g6XG4gICAgICAgICAgICBjYXNlICRQRVJDRU5UOlxuICAgICAgICAgICAgY2FzZSAkQ0FSRVQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nhbk9wZXJhdG9yKHN0YXJ0LCBTdHJpbmcuZnJvbUNoYXJDb2RlKHBlZWspKTtcbiAgICAgICAgICAgIGNhc2UgJFFVRVNUSU9OOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5Db21wbGV4T3BlcmF0b3Ioc3RhcnQsICc/JywgJFBFUklPRCwgJy4nKTtcbiAgICAgICAgICAgIGNhc2UgJExUOlxuICAgICAgICAgICAgY2FzZSAkR1Q6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkNvbXBsZXhPcGVyYXRvcihzdGFydCwgU3RyaW5nLmZyb21DaGFyQ29kZShwZWVrKSwgJEVRLCAnPScpO1xuICAgICAgICAgICAgY2FzZSAkQkFORzpcbiAgICAgICAgICAgIGNhc2UgJEVROlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5Db21wbGV4T3BlcmF0b3Ioc3RhcnQsIFN0cmluZy5mcm9tQ2hhckNvZGUocGVlayksICRFUSwgJz0nLCAkRVEsICc9Jyk7XG4gICAgICAgICAgICBjYXNlICRBTVBFUlNBTkQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkNvbXBsZXhPcGVyYXRvcihzdGFydCwgJyYnLCAkQU1QRVJTQU5ELCAnJicpO1xuICAgICAgICAgICAgY2FzZSAkQkFSOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5Db21wbGV4T3BlcmF0b3Ioc3RhcnQsICd8JywgJEJBUiwgJ3wnKTtcbiAgICAgICAgICAgIGNhc2UgJE5CU1A6XG4gICAgICAgICAgICAgICAgd2hpbGUgKGlzV2hpdGVzcGFjZSh0aGlzLnBlZWspKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuVG9rZW4oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoXCJVbmV4cGVjdGVkIGNoYXJhY3RlciBbXCIgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKHBlZWspICsgXCJdXCIsIDApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGFydFxuICAgICAqIEBwYXJhbSB7P30gY29kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1NjYW5uZXIucHJvdG90eXBlLnNjYW5DaGFyYWN0ZXIgPSBmdW5jdGlvbiAoc3RhcnQsIGNvZGUpIHtcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIHJldHVybiBuZXdDaGFyYWN0ZXJUb2tlbihzdGFydCwgY29kZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXJ0XG4gICAgICogQHBhcmFtIHs/fSBzdHJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9TY2FubmVyLnByb3RvdHlwZS5zY2FuT3BlcmF0b3IgPSBmdW5jdGlvbiAoc3RhcnQsIHN0cikge1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgcmV0dXJuIG5ld09wZXJhdG9yVG9rZW4oc3RhcnQsIHN0cik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUb2tlbml6ZSBhIDIvMyBjaGFyIGxvbmcgb3BlcmF0b3JcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gc3RhcnQgc3RhcnQgaW5kZXggaW4gdGhlIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0gez99IG9uZSBmaXJzdCBzeW1ib2wgKGFsd2F5cyBwYXJ0IG9mIHRoZSBvcGVyYXRvcilcbiAgICAgKiBAcGFyYW0gez99IHR3b0NvZGUgY29kZSBwb2ludCBmb3IgdGhlIHNlY29uZCBzeW1ib2xcbiAgICAgKiBAcGFyYW0gez99IHR3byBzZWNvbmQgc3ltYm9sIChwYXJ0IG9mIHRoZSBvcGVyYXRvciB3aGVuIHRoZSBzZWNvbmQgY29kZSBwb2ludCBtYXRjaGVzKVxuICAgICAqIEBwYXJhbSB7Pz19IHRocmVlQ29kZSBjb2RlIHBvaW50IGZvciB0aGUgdGhpcmQgc3ltYm9sXG4gICAgICogQHBhcmFtIHs/PX0gdGhyZWUgdGhpcmQgc3ltYm9sIChwYXJ0IG9mIHRoZSBvcGVyYXRvciB3aGVuIHByb3ZpZGVkIGFuZCBtYXRjaGVzIHNvdXJjZSBleHByZXNzaW9uKVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1NjYW5uZXIucHJvdG90eXBlLnNjYW5Db21wbGV4T3BlcmF0b3IgPSBmdW5jdGlvbiAoc3RhcnQsIG9uZSwgdHdvQ29kZSwgdHdvLCB0aHJlZUNvZGUsIHRocmVlKSB7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHIgPSBvbmU7XG4gICAgICAgIGlmICh0aGlzLnBlZWsgPT0gdHdvQ29kZSkge1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICBzdHIgKz0gdHdvO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aHJlZUNvZGUgIT0gbnVsbCAmJiB0aGlzLnBlZWsgPT0gdGhyZWVDb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHN0ciArPSB0aHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3T3BlcmF0b3JUb2tlbihzdGFydCwgc3RyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1NjYW5uZXIucHJvdG90eXBlLnNjYW5JZGVudGlmaWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICB3aGlsZSAoaXNJZGVudGlmaWVyUGFydCh0aGlzLnBlZWspKVxuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0ciA9IHRoaXMuaW5wdXQuc3Vic3RyaW5nKHN0YXJ0LCB0aGlzLmluZGV4KTtcbiAgICAgICAgcmV0dXJuIEtFWVdPUkRTLmluZGV4T2Yoc3RyKSA+IC0xID8gbmV3S2V5d29yZFRva2VuKHN0YXJ0LCBzdHIpIDpcbiAgICAgICAgICAgIG5ld0lkZW50aWZpZXJUb2tlbihzdGFydCwgc3RyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RhcnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9TY2FubmVyLnByb3RvdHlwZS5zY2FuTnVtYmVyID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNpbXBsZSA9ICh0aGlzLmluZGV4ID09PSBzdGFydCk7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpOyAvLyBTa2lwIGluaXRpYWwgZGlnaXQuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAoaXNEaWdpdCh0aGlzLnBlZWspKSB7XG4gICAgICAgICAgICAgICAgLy8gRG8gbm90aGluZy5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucGVlayA9PSAkUEVSSU9EKSB7XG4gICAgICAgICAgICAgICAgc2ltcGxlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0V4cG9uZW50U3RhcnQodGhpcy5wZWVrKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIGlmIChpc0V4cG9uZW50U2lnbih0aGlzLnBlZWspKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRGlnaXQodGhpcy5wZWVrKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoJ0ludmFsaWQgZXhwb25lbnQnLCAtMSk7XG4gICAgICAgICAgICAgICAgc2ltcGxlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0ciA9IHRoaXMuaW5wdXQuc3Vic3RyaW5nKHN0YXJ0LCB0aGlzLmluZGV4KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSBzaW1wbGUgPyBwYXJzZUludEF1dG9SYWRpeChzdHIpIDogcGFyc2VGbG9hdChzdHIpO1xuICAgICAgICByZXR1cm4gbmV3TnVtYmVyVG9rZW4oc3RhcnQsIHZhbHVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1NjYW5uZXIucHJvdG90eXBlLnNjYW5TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0ID0gdGhpcy5pbmRleDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVvdGUgPSB0aGlzLnBlZWs7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpOyAvLyBTa2lwIGluaXRpYWwgcXVvdGUuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJ1ZmZlciA9ICcnO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXJrZXIgPSB0aGlzLmluZGV4O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnB1dCA9IHRoaXMuaW5wdXQ7XG4gICAgICAgIHdoaWxlICh0aGlzLnBlZWsgIT0gcXVvdGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlZWsgPT0gJEJBQ0tTTEFTSCkge1xuICAgICAgICAgICAgICAgIGJ1ZmZlciArPSBpbnB1dC5zdWJzdHJpbmcobWFya2VyLCB0aGlzLmluZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1bmVzY2FwZWRDb2RlID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIFRTMi4xLWludHJvZHVjZWQgdHlwZSBzdHJpY3RuZXNzXG4gICAgICAgICAgICAgICAgdGhpcy5wZWVrID0gdGhpcy5wZWVrO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlZWsgPT0gJHUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gNCBjaGFyYWN0ZXIgaGV4IGNvZGUgZm9yIHVuaWNvZGUgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoZXggPSBpbnB1dC5zdWJzdHJpbmcodGhpcy5pbmRleCArIDEsIHRoaXMuaW5kZXggKyA1KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKC9eWzAtOWEtZl0rJC9pLnRlc3QoaGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5lc2NhcGVkQ29kZSA9IHBhcnNlSW50KGhleCwgMTYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoXCJJbnZhbGlkIHVuaWNvZGUgZXNjYXBlIFtcXFxcdVwiICsgaGV4ICsgXCJdXCIsIDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1bmVzY2FwZWRDb2RlID0gdW5lc2NhcGUodGhpcy5wZWVrKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJ1ZmZlciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHVuZXNjYXBlZENvZGUpO1xuICAgICAgICAgICAgICAgIG1hcmtlciA9IHRoaXMuaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnBlZWsgPT0gJEVPRikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKCdVbnRlcm1pbmF0ZWQgcXVvdGUnLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxhc3QgPSBpbnB1dC5zdWJzdHJpbmcobWFya2VyLCB0aGlzLmluZGV4KTtcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7IC8vIFNraXAgdGVybWluYXRpbmcgcXVvdGUuXG4gICAgICAgIHJldHVybiBuZXdTdHJpbmdUb2tlbihzdGFydCwgYnVmZmVyICsgbGFzdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gez99IG9mZnNldFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1NjYW5uZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIG9mZnNldCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwb3NpdGlvbiA9IHRoaXMuaW5kZXggKyBvZmZzZXQ7XG4gICAgICAgIHJldHVybiBuZXdFcnJvclRva2VuKHBvc2l0aW9uLCBcIkxleGVyIEVycm9yOiBcIiArIG1lc3NhZ2UgKyBcIiBhdCBjb2x1bW4gXCIgKyBwb3NpdGlvbiArIFwiIGluIGV4cHJlc3Npb24gW1wiICsgdGhpcy5pbnB1dCArIFwiXVwiKTtcbiAgICB9O1xuICAgIHJldHVybiBfU2Nhbm5lcjtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gY29kZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnQoY29kZSkge1xuICAgIHJldHVybiAoJGEgPD0gY29kZSAmJiBjb2RlIDw9ICR6KSB8fCAoJEEgPD0gY29kZSAmJiBjb2RlIDw9ICRaKSB8fFxuICAgICAgICAoY29kZSA9PSAkXykgfHwgKGNvZGUgPT0gJCQpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGlucHV0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc0lkZW50aWZpZXIoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzY2FubmVyID0gbmV3IF9TY2FubmVyKGlucHV0KTtcbiAgICBpZiAoIWlzSWRlbnRpZmllclN0YXJ0KHNjYW5uZXIucGVlaykpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBzY2FubmVyLmFkdmFuY2UoKTtcbiAgICB3aGlsZSAoc2Nhbm5lci5wZWVrICE9PSAkRU9GKSB7XG4gICAgICAgIGlmICghaXNJZGVudGlmaWVyUGFydChzY2FubmVyLnBlZWspKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBzY2FubmVyLmFkdmFuY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gY29kZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNJZGVudGlmaWVyUGFydChjb2RlKSB7XG4gICAgcmV0dXJuIGlzQXNjaWlMZXR0ZXIoY29kZSkgfHwgaXNEaWdpdChjb2RlKSB8fCAoY29kZSA9PSAkXykgfHxcbiAgICAgICAgKGNvZGUgPT0gJCQpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGNvZGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzRXhwb25lbnRTdGFydChjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPT0gJGUgfHwgY29kZSA9PSAkRTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBjb2RlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc0V4cG9uZW50U2lnbihjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPT0gJE1JTlVTIHx8IGNvZGUgPT0gJFBMVVM7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gY29kZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNRdW90ZShjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPT09ICRTUSB8fCBjb2RlID09PSAkRFEgfHwgY29kZSA9PT0gJEJUO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGNvZGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHVuZXNjYXBlKGNvZGUpIHtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgY2FzZSAkbjpcbiAgICAgICAgICAgIHJldHVybiAkTEY7XG4gICAgICAgIGNhc2UgJGY6XG4gICAgICAgICAgICByZXR1cm4gJEZGO1xuICAgICAgICBjYXNlICRyOlxuICAgICAgICAgICAgcmV0dXJuICRDUjtcbiAgICAgICAgY2FzZSAkdDpcbiAgICAgICAgICAgIHJldHVybiAkVEFCO1xuICAgICAgICBjYXNlICR2OlxuICAgICAgICAgICAgcmV0dXJuICRWVEFCO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxufVxuLyoqXG4gKiBAcGFyYW0gez99IHRleHRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHBhcnNlSW50QXV0b1JhZGl4KHRleHQpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSBwYXJzZUludCh0ZXh0KTtcbiAgICBpZiAoaXNOYU4ocmVzdWx0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW50ZWdlciBsaXRlcmFsIHdoZW4gcGFyc2luZyAnICsgdGV4dCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgU3BsaXRJbnRlcnBvbGF0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0cmluZ3NcbiAgICAgKiBAcGFyYW0gez99IGV4cHJlc3Npb25zXG4gICAgICogQHBhcmFtIHs/fSBvZmZzZXRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3BsaXRJbnRlcnBvbGF0aW9uKHN0cmluZ3MsIGV4cHJlc3Npb25zLCBvZmZzZXRzKSB7XG4gICAgICAgIHRoaXMuc3RyaW5ncyA9IHN0cmluZ3M7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcbiAgICAgICAgdGhpcy5vZmZzZXRzID0gb2Zmc2V0cztcbiAgICB9XG4gICAgcmV0dXJuIFNwbGl0SW50ZXJwb2xhdGlvbjtcbn0oKSk7XG52YXIgVGVtcGxhdGVCaW5kaW5nUGFyc2VSZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGVtcGxhdGVCaW5kaW5nc1xuICAgICAqIEBwYXJhbSB7P30gd2FybmluZ3NcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRlbXBsYXRlQmluZGluZ1BhcnNlUmVzdWx0KHRlbXBsYXRlQmluZGluZ3MsIHdhcm5pbmdzLCBlcnJvcnMpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZUJpbmRpbmdzID0gdGVtcGxhdGVCaW5kaW5ncztcbiAgICAgICAgdGhpcy53YXJuaW5ncyA9IHdhcm5pbmdzO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB9XG4gICAgcmV0dXJuIFRlbXBsYXRlQmluZGluZ1BhcnNlUmVzdWx0O1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBjb25maWdcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9jcmVhdGVJbnRlcnBvbGF0ZVJlZ0V4cChjb25maWcpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXR0ZXJuID0gZXNjYXBlUmVnRXhwKGNvbmZpZy5zdGFydCkgKyAnKFtcXFxcc1xcXFxTXSo/KScgKyBlc2NhcGVSZWdFeHAoY29uZmlnLmVuZCk7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAocGF0dGVybiwgJ2cnKTtcbn1cbnZhciBQYXJzZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2xleGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGFyc2VyKF9sZXhlcikge1xuICAgICAgICB0aGlzLl9sZXhlciA9IF9sZXhlcjtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbnB1dFxuICAgICAqIEBwYXJhbSB7P30gbG9jYXRpb25cbiAgICAgKiBAcGFyYW0gez89fSBpbnRlcnBvbGF0aW9uQ29uZmlnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQWN0aW9uID0gZnVuY3Rpb24gKGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbkNvbmZpZyA9PT0gdm9pZCAwKSB7IGludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHOyB9XG4gICAgICAgIHRoaXMuX2NoZWNrTm9JbnRlcnBvbGF0aW9uKGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvdXJjZVRvTGV4ID0gdGhpcy5fc3RyaXBDb21tZW50cyhpbnB1dCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRva2VucyA9IHRoaXMuX2xleGVyLnRva2VuaXplKHRoaXMuX3N0cmlwQ29tbWVudHMoaW5wdXQpKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0ID0gbmV3IF9QYXJzZUFTVChpbnB1dCwgbG9jYXRpb24sIHRva2Vucywgc291cmNlVG9MZXgubGVuZ3RoLCB0cnVlLCB0aGlzLmVycm9ycywgaW5wdXQubGVuZ3RoIC0gc291cmNlVG9MZXgubGVuZ3RoKVxuICAgICAgICAgICAgLnBhcnNlQ2hhaW4oKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RXaXRoU291cmNlKGFzdCwgaW5wdXQsIGxvY2F0aW9uLCB0aGlzLmVycm9ycyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlucHV0XG4gICAgICogQHBhcmFtIHs/fSBsb2NhdGlvblxuICAgICAqIEBwYXJhbSB7Pz19IGludGVycG9sYXRpb25Db25maWdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VCaW5kaW5nID0gZnVuY3Rpb24gKGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbkNvbmZpZyA9PT0gdm9pZCAwKSB7IGludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdCA9IHRoaXMuX3BhcnNlQmluZGluZ0FzdChpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICByZXR1cm4gbmV3IEFTVFdpdGhTb3VyY2UoYXN0LCBpbnB1dCwgbG9jYXRpb24sIHRoaXMuZXJyb3JzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW5wdXRcbiAgICAgKiBAcGFyYW0gez99IGxvY2F0aW9uXG4gICAgICogQHBhcmFtIHs/PX0gaW50ZXJwb2xhdGlvbkNvbmZpZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVNpbXBsZUJpbmRpbmcgPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIGlmIChpbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0ID0gdGhpcy5fcGFyc2VCaW5kaW5nQXN0KGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9ycyA9IFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLmNoZWNrKGFzdCk7XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJIb3N0IGJpbmRpbmcgZXhwcmVzc2lvbiBjYW5ub3QgY29udGFpbiBcIiArIGVycm9ycy5qb2luKCcgJyksIGlucHV0LCBsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBU1RXaXRoU291cmNlKGFzdCwgaW5wdXQsIGxvY2F0aW9uLCB0aGlzLmVycm9ycyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gez99IGlucHV0XG4gICAgICogQHBhcmFtIHs/fSBlcnJMb2NhdGlvblxuICAgICAqIEBwYXJhbSB7Pz19IGN0eExvY2F0aW9uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLl9yZXBvcnRFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBpbnB1dCwgZXJyTG9jYXRpb24sIGN0eExvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IFBhcnNlckVycm9yKG1lc3NhZ2UsIGlucHV0LCBlcnJMb2NhdGlvbiwgY3R4TG9jYXRpb24pKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW5wdXRcbiAgICAgKiBAcGFyYW0gez99IGxvY2F0aW9uXG4gICAgICogQHBhcmFtIHs/fSBpbnRlcnBvbGF0aW9uQ29uZmlnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLl9wYXJzZUJpbmRpbmdBc3QgPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIC8vIFF1b3RlcyBleHByZXNzaW9ucyB1c2UgM3JkLXBhcnR5IGV4cHJlc3Npb24gbGFuZ3VhZ2UuIFdlIGRvbid0IHdhbnQgdG8gdXNlXG4gICAgICAgIC8vIG91ciBsZXhlciBvciBwYXJzZXIgZm9yIHRoYXQsIHNvIHdlIGNoZWNrIGZvciB0aGF0IGFoZWFkIG9mIHRpbWUuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1b3RlID0gdGhpcy5fcGFyc2VRdW90ZShpbnB1dCwgbG9jYXRpb24pO1xuICAgICAgICBpZiAocXVvdGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHF1b3RlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NoZWNrTm9JbnRlcnBvbGF0aW9uKGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvdXJjZVRvTGV4ID0gdGhpcy5fc3RyaXBDb21tZW50cyhpbnB1dCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRva2VucyA9IHRoaXMuX2xleGVyLnRva2VuaXplKHNvdXJjZVRvTGV4KTtcbiAgICAgICAgcmV0dXJuIG5ldyBfUGFyc2VBU1QoaW5wdXQsIGxvY2F0aW9uLCB0b2tlbnMsIHNvdXJjZVRvTGV4Lmxlbmd0aCwgZmFsc2UsIHRoaXMuZXJyb3JzLCBpbnB1dC5sZW5ndGggLSBzb3VyY2VUb0xleC5sZW5ndGgpXG4gICAgICAgICAgICAucGFyc2VDaGFpbigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbnB1dFxuICAgICAqIEBwYXJhbSB7P30gbG9jYXRpb25cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlci5wcm90b3R5cGUuX3BhcnNlUXVvdGUgPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uKSB7XG4gICAgICAgIGlmIChpbnB1dCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZWZpeFNlcGFyYXRvckluZGV4ID0gaW5wdXQuaW5kZXhPZignOicpO1xuICAgICAgICBpZiAocHJlZml4U2VwYXJhdG9ySW5kZXggPT0gLTEpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlZml4ID0gaW5wdXQuc3Vic3RyaW5nKDAsIHByZWZpeFNlcGFyYXRvckluZGV4KS50cmltKCk7XG4gICAgICAgIGlmICghaXNJZGVudGlmaWVyKHByZWZpeCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdW5pbnRlcnByZXRlZEV4cHJlc3Npb24gPSBpbnB1dC5zdWJzdHJpbmcocHJlZml4U2VwYXJhdG9ySW5kZXggKyAxKTtcbiAgICAgICAgcmV0dXJuIG5ldyBRdW90ZShuZXcgUGFyc2VTcGFuKDAsIGlucHV0Lmxlbmd0aCksIHByZWZpeCwgdW5pbnRlcnByZXRlZEV4cHJlc3Npb24sIGxvY2F0aW9uKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJlZml4VG9rZW5cbiAgICAgKiBAcGFyYW0gez99IGlucHV0XG4gICAgICogQHBhcmFtIHs/fSBsb2NhdGlvblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRlbXBsYXRlQmluZGluZ3MgPSBmdW5jdGlvbiAocHJlZml4VG9rZW4sIGlucHV0LCBsb2NhdGlvbikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b2tlbnMgPSB0aGlzLl9sZXhlci50b2tlbml6ZShpbnB1dCk7XG4gICAgICAgIGlmIChwcmVmaXhUb2tlbikge1xuICAgICAgICAgICAgLy8gUHJlZml4IHRoZSB0b2tlbnMgd2l0aCB0aGUgdG9rZW5zIGZyb20gcHJlZml4VG9rZW4gYnV0IGhhdmUgdGhlbSB0YWtlIG5vIHNwYWNlICgwIGluZGV4KS5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZWZpeFRva2VucyA9IHRoaXMuX2xleGVyLnRva2VuaXplKHByZWZpeFRva2VuKS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICB0LmluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdG9rZW5zLnVuc2hpZnQuYXBwbHkodG9rZW5zLCBwcmVmaXhUb2tlbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgX1BhcnNlQVNUKGlucHV0LCBsb2NhdGlvbiwgdG9rZW5zLCBpbnB1dC5sZW5ndGgsIGZhbHNlLCB0aGlzLmVycm9ycywgMClcbiAgICAgICAgICAgIC5wYXJzZVRlbXBsYXRlQmluZGluZ3MoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW5wdXRcbiAgICAgKiBAcGFyYW0gez99IGxvY2F0aW9uXG4gICAgICogQHBhcmFtIHs/PX0gaW50ZXJwb2xhdGlvbkNvbmZpZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIGlmIChpbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3BsaXQgPSB0aGlzLnNwbGl0SW50ZXJwb2xhdGlvbihpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICBpZiAoc3BsaXQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHByZXNzaW9ucyA9IFtdO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgc3BsaXQuZXhwcmVzc2lvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cHJlc3Npb25UZXh0ID0gc3BsaXQuZXhwcmVzc2lvbnNbaV07XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzb3VyY2VUb0xleCA9IHRoaXMuX3N0cmlwQ29tbWVudHMoZXhwcmVzc2lvblRleHQpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9rZW5zID0gdGhpcy5fbGV4ZXIudG9rZW5pemUoc291cmNlVG9MZXgpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0ID0gbmV3IF9QYXJzZUFTVChpbnB1dCwgbG9jYXRpb24sIHRva2Vucywgc291cmNlVG9MZXgubGVuZ3RoLCBmYWxzZSwgdGhpcy5lcnJvcnMsIHNwbGl0Lm9mZnNldHNbaV0gKyAoZXhwcmVzc2lvblRleHQubGVuZ3RoIC0gc291cmNlVG9MZXgubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAucGFyc2VDaGFpbigpO1xuICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChhc3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQVNUV2l0aFNvdXJjZShuZXcgSW50ZXJwb2xhdGlvbihuZXcgUGFyc2VTcGFuKDAsIGlucHV0ID09IG51bGwgPyAwIDogaW5wdXQubGVuZ3RoKSwgc3BsaXQuc3RyaW5ncywgZXhwcmVzc2lvbnMpLCBpbnB1dCwgbG9jYXRpb24sIHRoaXMuZXJyb3JzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW5wdXRcbiAgICAgKiBAcGFyYW0gez99IGxvY2F0aW9uXG4gICAgICogQHBhcmFtIHs/PX0gaW50ZXJwb2xhdGlvbkNvbmZpZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5zcGxpdEludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIGlmIChpbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVnZXhwID0gX2NyZWF0ZUludGVycG9sYXRlUmVnRXhwKGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJ0cyA9IGlucHV0LnNwbGl0KHJlZ2V4cCk7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RyaW5ncyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHByZXNzaW9ucyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvZmZzZXRzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9mZnNldCA9IDA7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFydCA9IHBhcnRzW2ldO1xuICAgICAgICAgICAgaWYgKGkgJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gZml4ZWQgc3RyaW5nXG4gICAgICAgICAgICAgICAgc3RyaW5ncy5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBwYXJ0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcnQudHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gaW50ZXJwb2xhdGlvbkNvbmZpZy5zdGFydC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChwYXJ0KTtcbiAgICAgICAgICAgICAgICBvZmZzZXRzLnB1c2gob2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gcGFydC5sZW5ndGggKyBpbnRlcnBvbGF0aW9uQ29uZmlnLmVuZC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcignQmxhbmsgZXhwcmVzc2lvbnMgYXJlIG5vdCBhbGxvd2VkIGluIGludGVycG9sYXRlZCBzdHJpbmdzJywgaW5wdXQsIFwiYXQgY29sdW1uIFwiICsgdGhpcy5fZmluZEludGVycG9sYXRpb25FcnJvckNvbHVtbihwYXJ0cywgaSwgaW50ZXJwb2xhdGlvbkNvbmZpZykgKyBcIiBpblwiLCBsb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaCgnJGltcGxpY3QnKTtcbiAgICAgICAgICAgICAgICBvZmZzZXRzLnB1c2gob2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNwbGl0SW50ZXJwb2xhdGlvbihzdHJpbmdzLCBleHByZXNzaW9ucywgb2Zmc2V0cyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlucHV0XG4gICAgICogQHBhcmFtIHs/fSBsb2NhdGlvblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS53cmFwTGl0ZXJhbFByaW1pdGl2ZSA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RXaXRoU291cmNlKG5ldyBMaXRlcmFsUHJpbWl0aXZlKG5ldyBQYXJzZVNwYW4oMCwgaW5wdXQgPT0gbnVsbCA/IDAgOiBpbnB1dC5sZW5ndGgpLCBpbnB1dCksIGlucHV0LCBsb2NhdGlvbiwgdGhpcy5lcnJvcnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbnB1dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5fc3RyaXBDb21tZW50cyA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gdGhpcy5fY29tbWVudFN0YXJ0KGlucHV0KTtcbiAgICAgICAgcmV0dXJuIGkgIT0gbnVsbCA/IGlucHV0LnN1YnN0cmluZygwLCBpKS50cmltKCkgOiBpbnB1dDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW5wdXRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlci5wcm90b3R5cGUuX2NvbW1lbnRTdGFydCA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvdXRlclF1b3RlID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hhciA9IGlucHV0LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZXh0Q2hhciA9IGlucHV0LmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgICAgICAgaWYgKGNoYXIgPT09ICRTTEFTSCAmJiBuZXh0Q2hhciA9PSAkU0xBU0ggJiYgb3V0ZXJRdW90ZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgaWYgKG91dGVyUXVvdGUgPT09IGNoYXIpIHtcbiAgICAgICAgICAgICAgICBvdXRlclF1b3RlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG91dGVyUXVvdGUgPT0gbnVsbCAmJiBpc1F1b3RlKGNoYXIpKSB7XG4gICAgICAgICAgICAgICAgb3V0ZXJRdW90ZSA9IGNoYXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlucHV0XG4gICAgICogQHBhcmFtIHs/fSBsb2NhdGlvblxuICAgICAqIEBwYXJhbSB7P30gaW50ZXJwb2xhdGlvbkNvbmZpZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5fY2hlY2tOb0ludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlZ2V4cCA9IF9jcmVhdGVJbnRlcnBvbGF0ZVJlZ0V4cChpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFydHMgPSBpbnB1dC5zcGxpdChyZWdleHApO1xuICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJHb3QgaW50ZXJwb2xhdGlvbiAoXCIgKyBpbnRlcnBvbGF0aW9uQ29uZmlnLnN0YXJ0ICsgaW50ZXJwb2xhdGlvbkNvbmZpZy5lbmQgKyBcIikgd2hlcmUgZXhwcmVzc2lvbiB3YXMgZXhwZWN0ZWRcIiwgaW5wdXQsIFwiYXQgY29sdW1uIFwiICsgdGhpcy5fZmluZEludGVycG9sYXRpb25FcnJvckNvbHVtbihwYXJ0cywgMSwgaW50ZXJwb2xhdGlvbkNvbmZpZykgKyBcIiBpblwiLCBsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGFydHNcbiAgICAgKiBAcGFyYW0gez99IHBhcnRJbkVycklkeFxuICAgICAqIEBwYXJhbSB7P30gaW50ZXJwb2xhdGlvbkNvbmZpZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5fZmluZEludGVycG9sYXRpb25FcnJvckNvbHVtbiA9IGZ1bmN0aW9uIChwYXJ0cywgcGFydEluRXJySWR4LCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVyckxvY2F0aW9uID0gJyc7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaiA9IDA7IGogPCBwYXJ0SW5FcnJJZHg7IGorKykge1xuICAgICAgICAgICAgZXJyTG9jYXRpb24gKz0gaiAlIDIgPT09IDAgP1xuICAgICAgICAgICAgICAgIHBhcnRzW2pdIDpcbiAgICAgICAgICAgICAgICBcIlwiICsgaW50ZXJwb2xhdGlvbkNvbmZpZy5zdGFydCArIHBhcnRzW2pdICsgaW50ZXJwb2xhdGlvbkNvbmZpZy5lbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVyckxvY2F0aW9uLmxlbmd0aDtcbiAgICB9O1xuICAgIHJldHVybiBQYXJzZXI7XG59KCkpO1xuUGFyc2VyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21waWxlckluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cblBhcnNlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IExleGVyLCB9LFxuXTsgfTtcbnZhciBfUGFyc2VBU1QgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW5wdXRcbiAgICAgKiBAcGFyYW0gez99IGxvY2F0aW9uXG4gICAgICogQHBhcmFtIHs/fSB0b2tlbnNcbiAgICAgKiBAcGFyYW0gez99IGlucHV0TGVuZ3RoXG4gICAgICogQHBhcmFtIHs/fSBwYXJzZUFjdGlvblxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICogQHBhcmFtIHs/fSBvZmZzZXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfUGFyc2VBU1QoaW5wdXQsIGxvY2F0aW9uLCB0b2tlbnMsIGlucHV0TGVuZ3RoLCBwYXJzZUFjdGlvbiwgZXJyb3JzLCBvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudG9rZW5zID0gdG9rZW5zO1xuICAgICAgICB0aGlzLmlucHV0TGVuZ3RoID0gaW5wdXRMZW5ndGg7XG4gICAgICAgIHRoaXMucGFyc2VBY3Rpb24gPSBwYXJzZUFjdGlvbjtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLnJwYXJlbnNFeHBlY3RlZCA9IDA7XG4gICAgICAgIHRoaXMucmJyYWNrZXRzRXhwZWN0ZWQgPSAwO1xuICAgICAgICB0aGlzLnJicmFjZXNFeHBlY3RlZCA9IDA7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG9mZnNldFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gdGhpcy5pbmRleCArIG9mZnNldDtcbiAgICAgICAgcmV0dXJuIGkgPCB0aGlzLnRva2Vucy5sZW5ndGggPyB0aGlzLnRva2Vuc1tpXSA6IEVPRjtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfUGFyc2VBU1QucHJvdG90eXBlLCBcIm5leHRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5wZWVrKDApOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX1BhcnNlQVNULnByb3RvdHlwZSwgXCJpbnB1dEluZGV4XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5pbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aCkgPyB0aGlzLm5leHQuaW5kZXggKyB0aGlzLm9mZnNldCA6XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dExlbmd0aCArIHRoaXMub2Zmc2V0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXJ0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnNwYW4gPSBmdW5jdGlvbiAoc3RhcnQpIHsgcmV0dXJuIG5ldyBQYXJzZVNwYW4oc3RhcnQsIHRoaXMuaW5wdXRJbmRleCk7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLmFkdmFuY2UgPSBmdW5jdGlvbiAoKSB7IHRoaXMuaW5kZXgrKzsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUub3B0aW9uYWxDaGFyYWN0ZXIgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICBpZiAodGhpcy5uZXh0LmlzQ2hhcmFjdGVyKGNvZGUpKSB7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGVla0tleXdvcmRMZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm5leHQuaXNLZXl3b3JkTGV0KCk7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBlZWtLZXl3b3JkQXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm5leHQuaXNLZXl3b3JkQXMoKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUuZXhwZWN0Q2hhcmFjdGVyID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoY29kZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuZXJyb3IoXCJNaXNzaW5nIGV4cGVjdGVkIFwiICsgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG9wXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLm9wdGlvbmFsT3BlcmF0b3IgPSBmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dC5pc09wZXJhdG9yKG9wKSkge1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBvcGVyYXRvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5leHBlY3RPcGVyYXRvciA9IGZ1bmN0aW9uIChvcGVyYXRvcikge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKG9wZXJhdG9yKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5lcnJvcihcIk1pc3NpbmcgZXhwZWN0ZWQgb3BlcmF0b3IgXCIgKyBvcGVyYXRvcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUuZXhwZWN0SWRlbnRpZmllck9yS2V5d29yZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbiA9IHRoaXMubmV4dDtcbiAgICAgICAgaWYgKCFuLmlzSWRlbnRpZmllcigpICYmICFuLmlzS2V5d29yZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKFwiVW5leHBlY3RlZCB0b2tlbiBcIiArIG4gKyBcIiwgZXhwZWN0ZWQgaWRlbnRpZmllciBvciBrZXl3b3JkXCIpO1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICByZXR1cm4gKG4udG9TdHJpbmcoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUuZXhwZWN0SWRlbnRpZmllck9yS2V5d29yZE9yU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuID0gdGhpcy5uZXh0O1xuICAgICAgICBpZiAoIW4uaXNJZGVudGlmaWVyKCkgJiYgIW4uaXNLZXl3b3JkKCkgJiYgIW4uaXNTdHJpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihcIlVuZXhwZWN0ZWQgdG9rZW4gXCIgKyBuICsgXCIsIGV4cGVjdGVkIGlkZW50aWZpZXIsIGtleXdvcmQsIG9yIHN0cmluZ1wiKTtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgcmV0dXJuIChuLnRvU3RyaW5nKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlQ2hhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cHJzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICB3aGlsZSAodGhpcy5pbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwciA9IHRoaXMucGFyc2VQaXBlKCk7XG4gICAgICAgICAgICBleHBycy5wdXNoKGV4cHIpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJFNFTUlDT0xPTikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucGFyc2VBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcignQmluZGluZyBleHByZXNzaW9uIGNhbm5vdCBjb250YWluIGNoYWluZWQgZXhwcmVzc2lvbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkU0VNSUNPTE9OKSkge1xuICAgICAgICAgICAgICAgIH0gLy8gcmVhZCBhbGwgc2VtaWNvbG9uc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJVbmV4cGVjdGVkIHRva2VuICdcIiArIHRoaXMubmV4dCArIFwiJ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwcnMubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gbmV3IEVtcHR5RXhwcih0aGlzLnNwYW4oc3RhcnQpKTtcbiAgICAgICAgaWYgKGV4cHJzLmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgcmV0dXJuIGV4cHJzWzBdO1xuICAgICAgICByZXR1cm4gbmV3IENoYWluKHRoaXMuc3BhbihzdGFydCksIGV4cHJzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZVBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJ3wnKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyc2VBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKCdDYW5ub3QgaGF2ZSBhIHBpcGUgaW4gYW4gYWN0aW9uIGV4cHJlc3Npb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lID0gdGhpcy5leHBlY3RJZGVudGlmaWVyT3JLZXl3b3JkKCk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRDT0xPTikpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKHRoaXMucGFyc2VFeHByZXNzaW9uKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQmluZGluZ1BpcGUodGhpcy5zcGFuKHJlc3VsdC5zcGFuLnN0YXJ0KSwgcmVzdWx0LCBuYW1lLCBhcmdzKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignfCcpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucGFyc2VDb25kaXRpb25hbCgpOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUNvbmRpdGlvbmFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gdGhpcy5wYXJzZUxvZ2ljYWxPcigpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCc/JykpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHllcyA9IHRoaXMucGFyc2VQaXBlKCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBubyA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25hbENoYXJhY3RlcigkQ09MT04pKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW5kID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cHJlc3Npb24gPSB0aGlzLmlucHV0LnN1YnN0cmluZyhzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKFwiQ29uZGl0aW9uYWwgZXhwcmVzc2lvbiBcIiArIGV4cHJlc3Npb24gKyBcIiByZXF1aXJlcyBhbGwgMyBleHByZXNzaW9uc1wiKTtcbiAgICAgICAgICAgICAgICBubyA9IG5ldyBFbXB0eUV4cHIodGhpcy5zcGFuKHN0YXJ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBubyA9IHRoaXMucGFyc2VQaXBlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbmRpdGlvbmFsKHRoaXMuc3BhbihzdGFydCksIHJlc3VsdCwgeWVzLCBubyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VMb2dpY2FsT3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vICd8fCdcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gdGhpcy5wYXJzZUxvZ2ljYWxBbmQoKTtcbiAgICAgICAgd2hpbGUgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignfHwnKSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmlnaHQgPSB0aGlzLnBhcnNlTG9naWNhbEFuZCgpO1xuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJpbmFyeSh0aGlzLnNwYW4ocmVzdWx0LnNwYW4uc3RhcnQpLCAnfHwnLCByZXN1bHQsIHJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlTG9naWNhbEFuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gJyYmJ1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSB0aGlzLnBhcnNlRXF1YWxpdHkoKTtcbiAgICAgICAgd2hpbGUgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignJiYnKSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmlnaHQgPSB0aGlzLnBhcnNlRXF1YWxpdHkoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCaW5hcnkodGhpcy5zcGFuKHJlc3VsdC5zcGFuLnN0YXJ0KSwgJyYmJywgcmVzdWx0LCByaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUVxdWFsaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyAnPT0nLCchPScsJz09PScsJyE9PSdcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gdGhpcy5wYXJzZVJlbGF0aW9uYWwoKTtcbiAgICAgICAgd2hpbGUgKHRoaXMubmV4dC50eXBlID09IFRva2VuVHlwZS5PcGVyYXRvcikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3BlcmF0b3IgPSB0aGlzLm5leHQuc3RyVmFsdWU7XG4gICAgICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnPT0nOlxuICAgICAgICAgICAgICAgIGNhc2UgJz09PSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnIT0nOlxuICAgICAgICAgICAgICAgIGNhc2UgJyE9PSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByaWdodCA9IHRoaXMucGFyc2VSZWxhdGlvbmFsKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCaW5hcnkodGhpcy5zcGFuKHJlc3VsdC5zcGFuLnN0YXJ0KSwgb3BlcmF0b3IsIHJlc3VsdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VSZWxhdGlvbmFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyAnPCcsICc+JywgJzw9JywgJz49J1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSB0aGlzLnBhcnNlQWRkaXRpdmUoKTtcbiAgICAgICAgd2hpbGUgKHRoaXMubmV4dC50eXBlID09IFRva2VuVHlwZS5PcGVyYXRvcikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3BlcmF0b3IgPSB0aGlzLm5leHQuc3RyVmFsdWU7XG4gICAgICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICAgICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJpZ2h0ID0gdGhpcy5wYXJzZUFkZGl0aXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCaW5hcnkodGhpcy5zcGFuKHJlc3VsdC5zcGFuLnN0YXJ0KSwgb3BlcmF0b3IsIHJlc3VsdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VBZGRpdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gJysnLCAnLSdcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gdGhpcy5wYXJzZU11bHRpcGxpY2F0aXZlKCk7XG4gICAgICAgIHdoaWxlICh0aGlzLm5leHQudHlwZSA9PSBUb2tlblR5cGUuT3BlcmF0b3IpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9wZXJhdG9yID0gdGhpcy5uZXh0LnN0clZhbHVlO1xuICAgICAgICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmlnaHQgPSB0aGlzLnBhcnNlTXVsdGlwbGljYXRpdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJpbmFyeSh0aGlzLnNwYW4ocmVzdWx0LnNwYW4uc3RhcnQpLCBvcGVyYXRvciwgcmVzdWx0LCByaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZU11bHRpcGxpY2F0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyAnKicsICclJywgJy8nXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHRoaXMucGFyc2VQcmVmaXgoKTtcbiAgICAgICAgd2hpbGUgKHRoaXMubmV4dC50eXBlID09IFRva2VuVHlwZS5PcGVyYXRvcikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3BlcmF0b3IgPSB0aGlzLm5leHQuc3RyVmFsdWU7XG4gICAgICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByaWdodCA9IHRoaXMucGFyc2VQcmVmaXgoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJpbmFyeSh0aGlzLnNwYW4ocmVzdWx0LnNwYW4uc3RhcnQpLCBvcGVyYXRvciwgcmVzdWx0LCByaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZVByZWZpeCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dC50eXBlID09IFRva2VuVHlwZS5PcGVyYXRvcikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcGVyYXRvciA9IHRoaXMubmV4dC5zdHJWYWx1ZTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgICAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlUHJlZml4KCk7XG4gICAgICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnBhcnNlUHJlZml4KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5KHRoaXMuc3BhbihzdGFydCksIG9wZXJhdG9yLCBuZXcgTGl0ZXJhbFByaW1pdGl2ZShuZXcgUGFyc2VTcGFuKHN0YXJ0LCBzdGFydCksIDApLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIGNhc2UgJyEnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZVByZWZpeCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByZWZpeE5vdCh0aGlzLnNwYW4oc3RhcnQpLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2FsbENoYWluKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VDYWxsQ2hhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHRoaXMucGFyc2VQcmltYXJ5KCk7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkUEVSSU9EKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VBY2Nlc3NNZW1iZXJPck1ldGhvZENhbGwocmVzdWx0LCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJz8uJykpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnBhcnNlQWNjZXNzTWVtYmVyT3JNZXRob2RDYWxsKHJlc3VsdCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRMQlJBQ0tFVCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJicmFja2V0c0V4cGVjdGVkKys7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ga2V5ID0gdGhpcy5wYXJzZVBpcGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJicmFja2V0c0V4cGVjdGVkLS07XG4gICAgICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIoJFJCUkFDS0VUKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCc9JykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSB0aGlzLnBhcnNlQ29uZGl0aW9uYWwoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEtleWVkV3JpdGUodGhpcy5zcGFuKHJlc3VsdC5zcGFuLnN0YXJ0KSwgcmVzdWx0LCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBLZXllZFJlYWQodGhpcy5zcGFuKHJlc3VsdC5zcGFuLnN0YXJ0KSwgcmVzdWx0LCBrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJExQQVJFTikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJwYXJlbnNFeHBlY3RlZCsrO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFyZ3MgPSB0aGlzLnBhcnNlQ2FsbEFyZ3VtZW50cygpO1xuICAgICAgICAgICAgICAgIHRoaXMucnBhcmVuc0V4cGVjdGVkLS07XG4gICAgICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIoJFJQQVJFTik7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEZ1bmN0aW9uQ2FsbCh0aGlzLnNwYW4ocmVzdWx0LnNwYW4uc3RhcnQpLCByZXN1bHQsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCchJykpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgTm9uTnVsbEFzc2VydCh0aGlzLnNwYW4ocmVzdWx0LnNwYW4uc3RhcnQpLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlUHJpbWFyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRMUEFSRU4pKSB7XG4gICAgICAgICAgICB0aGlzLnJwYXJlbnNFeHBlY3RlZCsrO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gdGhpcy5wYXJzZVBpcGUoKTtcbiAgICAgICAgICAgIHRoaXMucnBhcmVuc0V4cGVjdGVkLS07XG4gICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcigkUlBBUkVOKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzS2V5d29yZE51bGwoKSkge1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxQcmltaXRpdmUodGhpcy5zcGFuKHN0YXJ0KSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzS2V5d29yZFVuZGVmaW5lZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbFByaW1pdGl2ZSh0aGlzLnNwYW4oc3RhcnQpLCB2b2lkIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0tleXdvcmRUcnVlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsUHJpbWl0aXZlKHRoaXMuc3BhbihzdGFydCksIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0tleXdvcmRGYWxzZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbFByaW1pdGl2ZSh0aGlzLnNwYW4oc3RhcnQpLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzS2V5d29yZFRoaXMoKSkge1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEltcGxpY2l0UmVjZWl2ZXIodGhpcy5zcGFuKHN0YXJ0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkTEJSQUNLRVQpKSB7XG4gICAgICAgICAgICB0aGlzLnJicmFja2V0c0V4cGVjdGVkKys7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50cyA9IHRoaXMucGFyc2VFeHByZXNzaW9uTGlzdCgkUkJSQUNLRVQpO1xuICAgICAgICAgICAgdGhpcy5yYnJhY2tldHNFeHBlY3RlZC0tO1xuICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIoJFJCUkFDS0VUKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbEFycmF5KHRoaXMuc3BhbihzdGFydCksIGVsZW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNDaGFyYWN0ZXIoJExCUkFDRSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0lkZW50aWZpZXIoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBY2Nlc3NNZW1iZXJPck1ldGhvZENhbGwobmV3IEltcGxpY2l0UmVjZWl2ZXIodGhpcy5zcGFuKHN0YXJ0KSksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNOdW1iZXIoKSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSB0aGlzLm5leHQudG9OdW1iZXIoKTtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsUHJpbWl0aXZlKHRoaXMuc3BhbihzdGFydCksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNTdHJpbmcoKSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGl0ZXJhbFZhbHVlID0gdGhpcy5uZXh0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbFByaW1pdGl2ZSh0aGlzLnNwYW4oc3RhcnQpLCBsaXRlcmFsVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaW5kZXggPj0gdGhpcy50b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKFwiVW5leHBlY3RlZCBlbmQgb2YgZXhwcmVzc2lvbjogXCIgKyB0aGlzLmlucHV0KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRW1wdHlFeHByKHRoaXMuc3BhbihzdGFydCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihcIlVuZXhwZWN0ZWQgdG9rZW4gXCIgKyB0aGlzLm5leHQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eUV4cHIodGhpcy5zcGFuKHN0YXJ0KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGVybWluYXRvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUV4cHJlc3Npb25MaXN0ID0gZnVuY3Rpb24gKHRlcm1pbmF0b3IpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gW107XG4gICAgICAgIGlmICghdGhpcy5uZXh0LmlzQ2hhcmFjdGVyKHRlcm1pbmF0b3IpKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5wYXJzZVBpcGUoKSk7XG4gICAgICAgICAgICB9IHdoaWxlICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRDT01NQSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VMaXRlcmFsTWFwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZXlzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlcyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIoJExCUkFDRSk7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25hbENoYXJhY3RlcigkUkJSQUNFKSkge1xuICAgICAgICAgICAgdGhpcy5yYnJhY2VzRXhwZWN0ZWQrKztcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdW90ZWQgPSB0aGlzLm5leHQuaXNTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZXkgPSB0aGlzLmV4cGVjdElkZW50aWZpZXJPcktleXdvcmRPclN0cmluZygpO1xuICAgICAgICAgICAgICAgIGtleXMucHVzaCh7IGtleToga2V5LCBxdW90ZWQ6IHF1b3RlZCB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcigkQ09MT04pO1xuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHRoaXMucGFyc2VQaXBlKCkpO1xuICAgICAgICAgICAgfSB3aGlsZSAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkQ09NTUEpKTtcbiAgICAgICAgICAgIHRoaXMucmJyYWNlc0V4cGVjdGVkLS07XG4gICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcigkUkJSQUNFKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxNYXAodGhpcy5zcGFuKHN0YXJ0KSwga2V5cywgdmFsdWVzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVjZWl2ZXJcbiAgICAgKiBAcGFyYW0gez89fSBpc1NhZmVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VBY2Nlc3NNZW1iZXJPck1ldGhvZENhbGwgPSBmdW5jdGlvbiAocmVjZWl2ZXIsIGlzU2FmZSkge1xuICAgICAgICBpZiAoaXNTYWZlID09PSB2b2lkIDApIHsgaXNTYWZlID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnQgPSByZWNlaXZlci5zcGFuLnN0YXJ0O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpZCA9IHRoaXMuZXhwZWN0SWRlbnRpZmllck9yS2V5d29yZCgpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkTFBBUkVOKSkge1xuICAgICAgICAgICAgdGhpcy5ycGFyZW5zRXhwZWN0ZWQrKztcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFyZ3MgPSB0aGlzLnBhcnNlQ2FsbEFyZ3VtZW50cygpO1xuICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIoJFJQQVJFTik7XG4gICAgICAgICAgICB0aGlzLnJwYXJlbnNFeHBlY3RlZC0tO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3BhbiA9IHRoaXMuc3BhbihzdGFydCk7XG4gICAgICAgICAgICByZXR1cm4gaXNTYWZlID8gbmV3IFNhZmVNZXRob2RDYWxsKHNwYW4sIHJlY2VpdmVyLCBpZCwgYXJncykgOlxuICAgICAgICAgICAgICAgIG5ldyBNZXRob2RDYWxsKHNwYW4sIHJlY2VpdmVyLCBpZCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXNTYWZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignPScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoJ1RoZSBcXCc/LlxcJyBvcGVyYXRvciBjYW5ub3QgYmUgdXNlZCBpbiB0aGUgYXNzaWdubWVudCcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVtcHR5RXhwcih0aGlzLnNwYW4oc3RhcnQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2FmZVByb3BlcnR5UmVhZCh0aGlzLnNwYW4oc3RhcnQpLCByZWNlaXZlciwgaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJz0nKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucGFyc2VBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoJ0JpbmRpbmdzIGNhbm5vdCBjb250YWluIGFzc2lnbm1lbnRzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVtcHR5RXhwcih0aGlzLnNwYW4oc3RhcnQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IHRoaXMucGFyc2VDb25kaXRpb25hbCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5V3JpdGUodGhpcy5zcGFuKHN0YXJ0KSwgcmVjZWl2ZXIsIGlkLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5UmVhZCh0aGlzLnNwYW4oc3RhcnQpLCByZWNlaXZlciwgaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlQ2FsbEFyZ3VtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dC5pc0NoYXJhY3RlcigkUlBBUkVOKSlcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcG9zaXRpb25hbHMgPSBbXTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcG9zaXRpb25hbHMucHVzaCh0aGlzLnBhcnNlUGlwZSgpKTtcbiAgICAgICAgfSB3aGlsZSAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkQ09NTUEpKTtcbiAgICAgICAgcmV0dXJuIChwb3NpdGlvbmFscyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBbiBpZGVudGlmaWVyLCBhIGtleXdvcmQsIGEgc3RyaW5nIHdpdGggYW4gb3B0aW9uYWwgYC1gIGluYmV0d2Vlbi5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUuZXhwZWN0VGVtcGxhdGVCaW5kaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSAnJztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3BlcmF0b3JGb3VuZCA9IGZhbHNlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5leHBlY3RJZGVudGlmaWVyT3JLZXl3b3JkT3JTdHJpbmcoKTtcbiAgICAgICAgICAgIG9wZXJhdG9yRm91bmQgPSB0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJy0nKTtcbiAgICAgICAgICAgIGlmIChvcGVyYXRvckZvdW5kKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICctJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAob3BlcmF0b3JGb3VuZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQudG9TdHJpbmcoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZVRlbXBsYXRlQmluZGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJpbmRpbmdzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZWZpeCA9ICgobnVsbCkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB3YXJuaW5ncyA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5pbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZXlJc1ZhciA9IHRoaXMucGVla0tleXdvcmRMZXQoKTtcbiAgICAgICAgICAgIGlmIChrZXlJc1Zhcikge1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmF3S2V5ID0gdGhpcy5leHBlY3RUZW1wbGF0ZUJpbmRpbmdLZXkoKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGtleSA9IHJhd0tleTtcbiAgICAgICAgICAgIGlmICgha2V5SXNWYXIpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJlZml4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4ID0ga2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gcHJlZml4ICsga2V5WzBdLnRvVXBwZXJDYXNlKCkgKyBrZXkuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJENPTE9OKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWUgPSAoKG51bGwpKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cHJlc3Npb24gPSAoKG51bGwpKTtcbiAgICAgICAgICAgIGlmIChrZXlJc1Zhcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJz0nKSkge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gdGhpcy5leHBlY3RUZW1wbGF0ZUJpbmRpbmdLZXkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSAnXFwkaW1wbGljaXQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucGVla0tleXdvcmRBcygpKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGV0U3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7IC8vIGNvbnN1bWUgYGFzYFxuICAgICAgICAgICAgICAgIG5hbWUgPSByYXdLZXk7XG4gICAgICAgICAgICAgICAga2V5ID0gdGhpcy5leHBlY3RUZW1wbGF0ZUJpbmRpbmdLZXkoKTsgLy8gcmVhZCBsb2NhbCB2YXIgbmFtZVxuICAgICAgICAgICAgICAgIGtleUlzVmFyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dCAhPT0gRU9GICYmICF0aGlzLnBlZWtLZXl3b3JkTGV0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydF8yID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdCA9IHRoaXMucGFyc2VQaXBlKCk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlID0gdGhpcy5pbnB1dC5zdWJzdHJpbmcoc3RhcnRfMiAtIHRoaXMub2Zmc2V0LCB0aGlzLmlucHV0SW5kZXggLSB0aGlzLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IG5ldyBBU1RXaXRoU291cmNlKGFzdCwgc291cmNlLCB0aGlzLmxvY2F0aW9uLCB0aGlzLmVycm9ycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiaW5kaW5ncy5wdXNoKG5ldyBUZW1wbGF0ZUJpbmRpbmcodGhpcy5zcGFuKHN0YXJ0KSwga2V5LCBrZXlJc1ZhciwgbmFtZSwgZXhwcmVzc2lvbikpO1xuICAgICAgICAgICAgaWYgKHRoaXMucGVla0tleXdvcmRBcygpICYmICFrZXlJc1Zhcikge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxldFN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpOyAvLyBjb25zdW1lIGBhc2BcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsZXROYW1lID0gdGhpcy5leHBlY3RUZW1wbGF0ZUJpbmRpbmdLZXkoKTsgLy8gcmVhZCBsb2NhbCB2YXIgbmFtZVxuICAgICAgICAgICAgICAgIGJpbmRpbmdzLnB1c2gobmV3IFRlbXBsYXRlQmluZGluZyh0aGlzLnNwYW4obGV0U3RhcnQpLCBsZXROYW1lLCB0cnVlLCBrZXksIC8qKiBAdHlwZSB7P30gKi8gKChudWxsKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25hbENoYXJhY3RlcigkU0VNSUNPTE9OKSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJENPTU1BKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRlbXBsYXRlQmluZGluZ1BhcnNlUmVzdWx0KGJpbmRpbmdzLCB3YXJuaW5ncywgdGhpcy5lcnJvcnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHs/PX0gaW5kZXhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHsgaW5kZXggPSBudWxsOyB9XG4gICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IFBhcnNlckVycm9yKG1lc3NhZ2UsIHRoaXMuaW5wdXQsIHRoaXMubG9jYXRpb25UZXh0KGluZGV4KSwgdGhpcy5sb2NhdGlvbikpO1xuICAgICAgICB0aGlzLnNraXAoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IGluZGV4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLmxvY2F0aW9uVGV4dCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkgeyBpbmRleCA9IG51bGw7IH1cbiAgICAgICAgaWYgKGluZGV4ID09IG51bGwpXG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIHJldHVybiAoaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGgpID8gXCJhdCBjb2x1bW4gXCIgKyAodGhpcy50b2tlbnNbaW5kZXhdLmluZGV4ICsgMSkgKyBcIiBpblwiIDpcbiAgICAgICAgICAgIFwiYXQgdGhlIGVuZCBvZiB0aGUgZXhwcmVzc2lvblwiO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG4gPSB0aGlzLm5leHQ7XG4gICAgICAgIHdoaWxlICh0aGlzLmluZGV4IDwgdGhpcy50b2tlbnMubGVuZ3RoICYmICFuLmlzQ2hhcmFjdGVyKCRTRU1JQ09MT04pICYmXG4gICAgICAgICAgICAodGhpcy5ycGFyZW5zRXhwZWN0ZWQgPD0gMCB8fCAhbi5pc0NoYXJhY3RlcigkUlBBUkVOKSkgJiZcbiAgICAgICAgICAgICh0aGlzLnJicmFjZXNFeHBlY3RlZCA8PSAwIHx8ICFuLmlzQ2hhcmFjdGVyKCRSQlJBQ0UpKSAmJlxuICAgICAgICAgICAgKHRoaXMucmJyYWNrZXRzRXhwZWN0ZWQgPD0gMCB8fCAhbi5pc0NoYXJhY3RlcigkUkJSQUNLRVQpKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubmV4dC5pc0Vycm9yKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBQYXJzZXJFcnJvcigvKiogQHR5cGUgez99ICovICgodGhpcy5uZXh0LnRvU3RyaW5nKCkpKSwgdGhpcy5pbnB1dCwgdGhpcy5sb2NhdGlvblRleHQoKSwgdGhpcy5sb2NhdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICBuID0gdGhpcy5uZXh0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gX1BhcnNlQVNUO1xufSgpKTtcbnZhciBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIoKSB7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5jaGVjayA9IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcyA9IG5ldyBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlcigpO1xuICAgICAgICBhc3QudmlzaXQocyk7XG4gICAgICAgIHJldHVybiBzLmVycm9ycztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRJbXBsaWNpdFJlY2VpdmVyID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsUHJpbWl0aXZlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdFByb3BlcnR5V3JpdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdFNhZmVQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdE1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdFNhZmVNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkNhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsTWFwID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB0aGlzLnZpc2l0QWxsKGFzdC52YWx1ZXMpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRCaW5hcnkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdFByZWZpeE5vdCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0Tm9uTnVsbEFzc2VydCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0Q29uZGl0aW9uYWwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdFBpcGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHRoaXMuZXJyb3JzLnB1c2goJ3BpcGVzJyk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdEtleWVkUmVhZCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0S2V5ZWRXcml0ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdEFsbCA9IGZ1bmN0aW9uIChhc3RzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBhc3RzLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcyk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdENoYWluID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRRdW90ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICByZXR1cm4gU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXI7XG59KCkpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIFBhcnNlTG9jYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZmlsZVxuICAgICAqIEBwYXJhbSB7P30gb2Zmc2V0XG4gICAgICogQHBhcmFtIHs/fSBsaW5lXG4gICAgICogQHBhcmFtIHs/fSBjb2xcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQYXJzZUxvY2F0aW9uKGZpbGUsIG9mZnNldCwgbGluZSwgY29sKSB7XG4gICAgICAgIHRoaXMuZmlsZSA9IGZpbGU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgICAgICB0aGlzLmNvbCA9IGNvbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZUxvY2F0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0ICE9IG51bGwgPyB0aGlzLmZpbGUudXJsICsgXCJAXCIgKyB0aGlzLmxpbmUgKyBcIjpcIiArIHRoaXMuY29sIDogdGhpcy5maWxlLnVybDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGVsdGFcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlTG9jYXRpb24ucHJvdG90eXBlLm1vdmVCeSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzb3VyY2UgPSB0aGlzLmZpbGUuY29udGVudDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGVuID0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxpbmUgPSB0aGlzLmxpbmU7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbCA9IHRoaXMuY29sO1xuICAgICAgICB3aGlsZSAob2Zmc2V0ID4gMCAmJiBkZWx0YSA8IDApIHtcbiAgICAgICAgICAgIG9mZnNldC0tO1xuICAgICAgICAgICAgZGVsdGErKztcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNoID0gc291cmNlLmNoYXJDb2RlQXQob2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChjaCA9PSAkTEYpIHtcbiAgICAgICAgICAgICAgICBsaW5lLS07XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJpb3JMaW5lID0gc291cmNlLnN1YnN0cigwLCBvZmZzZXQgLSAxKS5sYXN0SW5kZXhPZihTdHJpbmcuZnJvbUNoYXJDb2RlKCRMRikpO1xuICAgICAgICAgICAgICAgIGNvbCA9IHByaW9yTGluZSA+IDAgPyBvZmZzZXQgLSBwcmlvckxpbmUgOiBvZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2wtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAob2Zmc2V0IDwgbGVuICYmIGRlbHRhID4gMCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2ggPSBzb3VyY2UuY2hhckNvZGVBdChvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICBkZWx0YS0tO1xuICAgICAgICAgICAgaWYgKGNoID09ICRMRikge1xuICAgICAgICAgICAgICAgIGxpbmUrKztcbiAgICAgICAgICAgICAgICBjb2wgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29sKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZUxvY2F0aW9uKHRoaXMuZmlsZSwgb2Zmc2V0LCBsaW5lLCBjb2wpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtYXhDaGFyc1xuICAgICAqIEBwYXJhbSB7P30gbWF4TGluZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlTG9jYXRpb24ucHJvdG90eXBlLmdldENvbnRleHQgPSBmdW5jdGlvbiAobWF4Q2hhcnMsIG1heExpbmVzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRlbnQgPSB0aGlzLmZpbGUuY29udGVudDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnRPZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKHN0YXJ0T2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChzdGFydE9mZnNldCA+IGNvbnRlbnQubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0T2Zmc2V0ID0gY29udGVudC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW5kT2Zmc2V0ID0gc3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdHhDaGFycyA9IDA7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdHhMaW5lcyA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoY3R4Q2hhcnMgPCBtYXhDaGFycyAmJiBzdGFydE9mZnNldCA+IDApIHtcbiAgICAgICAgICAgICAgICBzdGFydE9mZnNldC0tO1xuICAgICAgICAgICAgICAgIGN0eENoYXJzKys7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRbc3RhcnRPZmZzZXRdID09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgrK2N0eExpbmVzID09IG1heExpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eENoYXJzID0gMDtcbiAgICAgICAgICAgIGN0eExpbmVzID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChjdHhDaGFycyA8IG1heENoYXJzICYmIGVuZE9mZnNldCA8IGNvbnRlbnQubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIGVuZE9mZnNldCsrO1xuICAgICAgICAgICAgICAgIGN0eENoYXJzKys7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRbZW5kT2Zmc2V0XSA9PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKytjdHhMaW5lcyA9PSBtYXhMaW5lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJlZm9yZTogY29udGVudC5zdWJzdHJpbmcoc3RhcnRPZmZzZXQsIHRoaXMub2Zmc2V0KSxcbiAgICAgICAgICAgICAgICBhZnRlcjogY29udGVudC5zdWJzdHJpbmcodGhpcy5vZmZzZXQsIGVuZE9mZnNldCArIDEpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBQYXJzZUxvY2F0aW9uO1xufSgpKTtcbnZhciBQYXJzZVNvdXJjZUZpbGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29udGVudFxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGFyc2VTb3VyY2VGaWxlKGNvbnRlbnQsIHVybCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICB9XG4gICAgcmV0dXJuIFBhcnNlU291cmNlRmlsZTtcbn0oKSk7XG52YXIgUGFyc2VTb3VyY2VTcGFuID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXJ0XG4gICAgICogQHBhcmFtIHs/fSBlbmRcbiAgICAgKiBAcGFyYW0gez89fSBkZXRhaWxzXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGFyc2VTb3VyY2VTcGFuKHN0YXJ0LCBlbmQsIGRldGFpbHMpIHtcbiAgICAgICAgaWYgKGRldGFpbHMgPT09IHZvaWQgMCkgeyBkZXRhaWxzID0gbnVsbDsgfVxuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlU291cmNlU3Bhbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0LmZpbGUuY29udGVudC5zdWJzdHJpbmcodGhpcy5zdGFydC5vZmZzZXQsIHRoaXMuZW5kLm9mZnNldCk7XG4gICAgfTtcbiAgICByZXR1cm4gUGFyc2VTb3VyY2VTcGFuO1xufSgpKTtcbnZhciBQYXJzZUVycm9yTGV2ZWwgPSB7fTtcblBhcnNlRXJyb3JMZXZlbC5XQVJOSU5HID0gMDtcblBhcnNlRXJyb3JMZXZlbC5FUlJPUiA9IDE7XG5QYXJzZUVycm9yTGV2ZWxbUGFyc2VFcnJvckxldmVsLldBUk5JTkddID0gXCJXQVJOSU5HXCI7XG5QYXJzZUVycm9yTGV2ZWxbUGFyc2VFcnJvckxldmVsLkVSUk9SXSA9IFwiRVJST1JcIjtcbnZhciBQYXJzZUVycm9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IG1zZ1xuICAgICAqIEBwYXJhbSB7Pz19IGxldmVsXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGFyc2VFcnJvcihzcGFuLCBtc2csIGxldmVsKSB7XG4gICAgICAgIGlmIChsZXZlbCA9PT0gdm9pZCAwKSB7IGxldmVsID0gUGFyc2VFcnJvckxldmVsLkVSUk9SOyB9XG4gICAgICAgIHRoaXMuc3BhbiA9IHNwYW47XG4gICAgICAgIHRoaXMubXNnID0gbXNnO1xuICAgICAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2VFcnJvci5wcm90b3R5cGUuY29udGV4dHVhbE1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGN0eCA9IHRoaXMuc3Bhbi5zdGFydC5nZXRDb250ZXh0KDEwMCwgMyk7XG4gICAgICAgIHJldHVybiBjdHggPyBcIiAoXFxcIlwiICsgY3R4LmJlZm9yZSArIFwiW1wiICsgUGFyc2VFcnJvckxldmVsW3RoaXMubGV2ZWxdICsgXCIgLT5dXCIgKyBjdHguYWZ0ZXIgKyBcIlxcXCIpXCIgOiAnJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2VFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRldGFpbHMgPSB0aGlzLnNwYW4uZGV0YWlscyA/IFwiLCBcIiArIHRoaXMuc3Bhbi5kZXRhaWxzIDogJyc7XG4gICAgICAgIHJldHVybiBcIlwiICsgdGhpcy5tc2cgKyB0aGlzLmNvbnRleHR1YWxNZXNzYWdlKCkgKyBcIjogXCIgKyB0aGlzLnNwYW4uc3RhcnQgKyBkZXRhaWxzO1xuICAgIH07XG4gICAgcmV0dXJuIFBhcnNlRXJyb3I7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IGtpbmRcbiAqIEBwYXJhbSB7P30gdHlwZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdHlwZVNvdXJjZVNwYW4oa2luZCwgdHlwZSkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG1vZHVsZVVybCA9IGlkZW50aWZpZXJNb2R1bGVVcmwodHlwZSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlRmlsZU5hbWUgPSBtb2R1bGVVcmwgIT0gbnVsbCA/IFwiaW4gXCIgKyBraW5kICsgXCIgXCIgKyBpZGVudGlmaWVyTmFtZSh0eXBlKSArIFwiIGluIFwiICsgbW9kdWxlVXJsIDpcbiAgICAgICAgXCJpbiBcIiArIGtpbmQgKyBcIiBcIiArIGlkZW50aWZpZXJOYW1lKHR5cGUpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvdXJjZUZpbGUgPSBuZXcgUGFyc2VTb3VyY2VGaWxlKCcnLCBzb3VyY2VGaWxlTmFtZSk7XG4gICAgcmV0dXJuIG5ldyBQYXJzZVNvdXJjZVNwYW4obmV3IFBhcnNlTG9jYXRpb24oc291cmNlRmlsZSwgLTEsIC0xLCAtMSksIG5ldyBQYXJzZUxvY2F0aW9uKHNvdXJjZUZpbGUsIC0xLCAtMSwgLTEpKTtcbn1cbi8qKlxuICogQSBwYXRoIGlzIGFuIG9yZGVyZWQgc2V0IG9mIGVsZW1lbnRzLiBUeXBpY2FsbHkgYSBwYXRoIGlzIHRvICBhXG4gKiBwYXJ0aWN1bGFyIG9mZnNldCBpbiBhIHNvdXJjZSBmaWxlLiBUaGUgaGVhZCBvZiB0aGUgbGlzdCBpcyB0aGUgdG9wXG4gKiBtb3N0IG5vZGUuIFRoZSB0YWlsIGlzIHRoZSBub2RlIHRoYXQgY29udGFpbnMgdGhlIG9mZnNldCBkaXJlY3RseS5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgdGhlIGV4cHJlc2lvbiBgYSArIGIgKyBjYCBtaWdodCBoYXZlIGFuIGFzdCB0aGF0IGxvb2tzXG4gKiBsaWtlOlxuICogICAgICtcbiAqICAgIC8gXFxcbiAqICAgYSAgICtcbiAqICAgICAgLyBcXFxuICogICAgIGIgICBjXG4gKlxuICogVGhlIHBhdGggdG8gdGhlIG5vZGUgYXQgb2Zmc2V0IDkgd291bGQgYmUgYFsnKycgYXQgMS0xMCwgJysnIGF0IDctMTAsXG4gKiAnYycgYXQgOS0xMF1gIGFuZCB0aGUgcGF0aCB0aGUgbm9kZSBhdCBvZmZzZXQgMSB3b3VsZCBiZVxuICogYFsnKycgYXQgMS0xMCwgJ2EnIGF0IDEtMl1gLlxuICovXG52YXIgQXN0UGF0aCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwYXRoXG4gICAgICogQHBhcmFtIHs/PX0gcG9zaXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBc3RQYXRoKHBhdGgsIHBvc2l0aW9uKSB7XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gdm9pZCAwKSB7IHBvc2l0aW9uID0gLTE7IH1cbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXN0UGF0aC5wcm90b3R5cGUsIFwiZW1wdHlcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gIXRoaXMucGF0aCB8fCAhdGhpcy5wYXRoLmxlbmd0aDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFzdFBhdGgucHJvdG90eXBlLCBcImhlYWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5wYXRoWzBdOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXN0UGF0aC5wcm90b3R5cGUsIFwidGFpbFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnBhdGhbdGhpcy5wYXRoLmxlbmd0aCAtIDFdOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFBhdGgucHJvdG90eXBlLnBhcmVudE9mID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUgJiYgdGhpcy5wYXRoW3RoaXMucGF0aC5pbmRleE9mKG5vZGUpIC0gMV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFBhdGgucHJvdG90eXBlLmNoaWxkT2YgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gdGhpcy5wYXRoW3RoaXMucGF0aC5pbmRleE9mKG5vZGUpICsgMV07IH07XG4gICAgLyoqXG4gICAgICogQHRlbXBsYXRlIE5cbiAgICAgKiBAcGFyYW0gez99IGN0b3JcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFBhdGgucHJvdG90eXBlLmZpcnN0ID0gZnVuY3Rpb24gKGN0b3IpIHtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gdGhpcy5wYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpdGVtID0gdGhpcy5wYXRoW2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBjdG9yKVxuICAgICAgICAgICAgICAgIHJldHVybiAoaXRlbSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0UGF0aC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChub2RlKSB7IHRoaXMucGF0aC5wdXNoKG5vZGUpOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0UGF0aC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKCh0aGlzLnBhdGgucG9wKCkpKTsgfTtcbiAgICByZXR1cm4gQXN0UGF0aDtcbn0oKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgVGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRleHQodmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRleHQucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRUZXh0KHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBUZXh0O1xufSgpKTtcbnZhciBFeHBhbnNpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3dpdGNoVmFsdWVcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez99IGNhc2VzXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHBhcmFtIHs/fSBzd2l0Y2hWYWx1ZVNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFeHBhbnNpb24oc3dpdGNoVmFsdWUsIHR5cGUsIGNhc2VzLCBzb3VyY2VTcGFuLCBzd2l0Y2hWYWx1ZVNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5zd2l0Y2hWYWx1ZSA9IHN3aXRjaFZhbHVlO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmNhc2VzID0gY2FzZXM7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuc3dpdGNoVmFsdWVTb3VyY2VTcGFuID0gc3dpdGNoVmFsdWVTb3VyY2VTcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4cGFuc2lvbi5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdEV4cGFuc2lvbih0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gRXhwYW5zaW9uO1xufSgpKTtcbnZhciBFeHBhbnNpb25DYXNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVNvdXJjZVNwYW5cbiAgICAgKiBAcGFyYW0gez99IGV4cFNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFeHBhbnNpb25DYXNlKHZhbHVlLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCB2YWx1ZVNvdXJjZVNwYW4sIGV4cFNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLnZhbHVlU291cmNlU3BhbiA9IHZhbHVlU291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5leHBTb3VyY2VTcGFuID0gZXhwU291cmNlU3BhbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHBhbnNpb25DYXNlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0RXhwYW5zaW9uQ2FzZSh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gRXhwYW5zaW9uQ2FzZTtcbn0oKSk7XG52YXIgQXR0cmlidXRlJDEgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcGFyYW0gez89fSB2YWx1ZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBdHRyaWJ1dGUkMShuYW1lLCB2YWx1ZSwgc291cmNlU3BhbiwgdmFsdWVTcGFuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy52YWx1ZVNwYW4gPSB2YWx1ZVNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXR0cmlidXRlJDEucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRBdHRyaWJ1dGUodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIEF0dHJpYnV0ZSQxO1xufSgpKTtcbnZhciBFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IGF0dHJzXG4gICAgICogQHBhcmFtIHs/fSBjaGlsZHJlblxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7Pz19IHN0YXJ0U291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7Pz19IGVuZFNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFbGVtZW50KG5hbWUsIGF0dHJzLCBjaGlsZHJlbiwgc291cmNlU3Bhbiwgc3RhcnRTb3VyY2VTcGFuLCBlbmRTb3VyY2VTcGFuKSB7XG4gICAgICAgIGlmIChzdGFydFNvdXJjZVNwYW4gPT09IHZvaWQgMCkgeyBzdGFydFNvdXJjZVNwYW4gPSBudWxsOyB9XG4gICAgICAgIGlmIChlbmRTb3VyY2VTcGFuID09PSB2b2lkIDApIHsgZW5kU291cmNlU3BhbiA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuc3RhcnRTb3VyY2VTcGFuID0gc3RhcnRTb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmVuZFNvdXJjZVNwYW4gPSBlbmRTb3VyY2VTcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVsZW1lbnQucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRFbGVtZW50KHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBFbGVtZW50O1xufSgpKTtcbnZhciBDb21tZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tbWVudCh2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tbWVudC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdENvbW1lbnQodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIENvbW1lbnQ7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IHZpc2l0b3JcbiAqIEBwYXJhbSB7P30gbm9kZXNcbiAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHZpc2l0QWxsKHZpc2l0b3IsIG5vZGVzLCBjb250ZXh0KSB7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IFtdO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0ID0gdmlzaXRvci52aXNpdCA/XG4gICAgICAgIGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuICgodmlzaXRvci52aXNpdCkpKGFzdCwgY29udGV4dCkgfHwgYXN0LnZpc2l0KHZpc2l0b3IsIGNvbnRleHQpOyB9IDpcbiAgICAgICAgZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gYXN0LnZpc2l0KHZpc2l0b3IsIGNvbnRleHQpOyB9O1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3RSZXN1bHQgPSB2aXNpdChhc3QpO1xuICAgICAgICBpZiAoYXN0UmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChhc3RSZXN1bHQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBSZWN1cnNpdmVWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWN1cnNpdmVWaXNpdG9yKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0Q2hpbGRyZW4oY29udGV4dCwgZnVuY3Rpb24gKHZpc2l0KSB7XG4gICAgICAgICAgICB2aXNpdChhc3QuYXR0cnMpO1xuICAgICAgICAgICAgdmlzaXQoYXN0LmNoaWxkcmVuKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjb250ZXh0LCBmdW5jdGlvbiAodmlzaXQpIHsgdmlzaXQoYXN0LmNhc2VzKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHBhcmFtIHs/fSBjYlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlVmlzaXRvci5wcm90b3R5cGUudmlzaXRDaGlsZHJlbiA9IGZ1bmN0aW9uIChjb250ZXh0LCBjYikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHRzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHQgPSB0aGlzO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHRlbXBsYXRlIFRcbiAgICAgICAgICogQHBhcmFtIHs/fSBjaGlsZHJlblxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gdmlzaXQoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbilcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godmlzaXRBbGwodCwgY2hpbGRyZW4sIGNvbnRleHQpKTtcbiAgICAgICAgfVxuICAgICAgICBjYih2aXNpdCk7XG4gICAgICAgIHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIHJlc3VsdHMpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlY3Vyc2l2ZVZpc2l0b3I7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IGFzdFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc3Bhbk9mKGFzdCkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0ID0gYXN0LnNvdXJjZVNwYW4uc3RhcnQub2Zmc2V0O1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGVuZCA9IGFzdC5zb3VyY2VTcGFuLmVuZC5vZmZzZXQ7XG4gICAgaWYgKGFzdCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgaWYgKGFzdC5lbmRTb3VyY2VTcGFuKSB7XG4gICAgICAgICAgICBlbmQgPSBhc3QuZW5kU291cmNlU3Bhbi5lbmQub2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFzdC5jaGlsZHJlbiAmJiBhc3QuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICBlbmQgPSBzcGFuT2YoYXN0LmNoaWxkcmVuW2FzdC5jaGlsZHJlbi5sZW5ndGggLSAxXSkuZW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBub2Rlc1xuICogQHBhcmFtIHs/fSBwb3NpdGlvblxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZmluZE5vZGUobm9kZXMsIHBvc2l0aW9uKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGF0aCA9IFtdO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0b3IgPSBuZXcgKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgdHNsaWJfMS5fX2V4dGVuZHMoY2xhc3NfMSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gY2xhc3NfMSgpIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNwYW4gPSBzcGFuT2YoYXN0KTtcbiAgICAgICAgICAgIGlmIChzcGFuLnN0YXJ0IDw9IHBvc2l0aW9uICYmIHBvc2l0aW9uIDwgc3Bhbi5lbmQpIHtcbiAgICAgICAgICAgICAgICBwYXRoLnB1c2goYXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFJldHVybmluZyBhIHZhbHVlIGhlcmUgd2lsbCByZXN1bHQgaW4gdGhlIGNoaWxkcmVuIGJlaW5nIHNraXBwZWQuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjbGFzc18xO1xuICAgIH0oUmVjdXJzaXZlVmlzaXRvcikpO1xuICAgIHZpc2l0QWxsKHZpc2l0b3IsIG5vZGVzKTtcbiAgICByZXR1cm4gbmV3IEFzdFBhdGgocGF0aCwgcG9zaXRpb24pO1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIFRva2VuVHlwZSQxID0ge307XG5Ub2tlblR5cGUkMS5UQUdfT1BFTl9TVEFSVCA9IDA7XG5Ub2tlblR5cGUkMS5UQUdfT1BFTl9FTkQgPSAxO1xuVG9rZW5UeXBlJDEuVEFHX09QRU5fRU5EX1ZPSUQgPSAyO1xuVG9rZW5UeXBlJDEuVEFHX0NMT1NFID0gMztcblRva2VuVHlwZSQxLlRFWFQgPSA0O1xuVG9rZW5UeXBlJDEuRVNDQVBBQkxFX1JBV19URVhUID0gNTtcblRva2VuVHlwZSQxLlJBV19URVhUID0gNjtcblRva2VuVHlwZSQxLkNPTU1FTlRfU1RBUlQgPSA3O1xuVG9rZW5UeXBlJDEuQ09NTUVOVF9FTkQgPSA4O1xuVG9rZW5UeXBlJDEuQ0RBVEFfU1RBUlQgPSA5O1xuVG9rZW5UeXBlJDEuQ0RBVEFfRU5EID0gMTA7XG5Ub2tlblR5cGUkMS5BVFRSX05BTUUgPSAxMTtcblRva2VuVHlwZSQxLkFUVFJfVkFMVUUgPSAxMjtcblRva2VuVHlwZSQxLkRPQ19UWVBFID0gMTM7XG5Ub2tlblR5cGUkMS5FWFBBTlNJT05fRk9STV9TVEFSVCA9IDE0O1xuVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0NBU0VfVkFMVUUgPSAxNTtcblRva2VuVHlwZSQxLkVYUEFOU0lPTl9DQVNFX0VYUF9TVEFSVCA9IDE2O1xuVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0NBU0VfRVhQX0VORCA9IDE3O1xuVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0ZPUk1fRU5EID0gMTg7XG5Ub2tlblR5cGUkMS5FT0YgPSAxOTtcblRva2VuVHlwZSQxW1Rva2VuVHlwZSQxLlRBR19PUEVOX1NUQVJUXSA9IFwiVEFHX09QRU5fU1RBUlRcIjtcblRva2VuVHlwZSQxW1Rva2VuVHlwZSQxLlRBR19PUEVOX0VORF0gPSBcIlRBR19PUEVOX0VORFwiO1xuVG9rZW5UeXBlJDFbVG9rZW5UeXBlJDEuVEFHX09QRU5fRU5EX1ZPSURdID0gXCJUQUdfT1BFTl9FTkRfVk9JRFwiO1xuVG9rZW5UeXBlJDFbVG9rZW5UeXBlJDEuVEFHX0NMT1NFXSA9IFwiVEFHX0NMT1NFXCI7XG5Ub2tlblR5cGUkMVtUb2tlblR5cGUkMS5URVhUXSA9IFwiVEVYVFwiO1xuVG9rZW5UeXBlJDFbVG9rZW5UeXBlJDEuRVNDQVBBQkxFX1JBV19URVhUXSA9IFwiRVNDQVBBQkxFX1JBV19URVhUXCI7XG5Ub2tlblR5cGUkMVtUb2tlblR5cGUkMS5SQVdfVEVYVF0gPSBcIlJBV19URVhUXCI7XG5Ub2tlblR5cGUkMVtUb2tlblR5cGUkMS5DT01NRU5UX1NUQVJUXSA9IFwiQ09NTUVOVF9TVEFSVFwiO1xuVG9rZW5UeXBlJDFbVG9rZW5UeXBlJDEuQ09NTUVOVF9FTkRdID0gXCJDT01NRU5UX0VORFwiO1xuVG9rZW5UeXBlJDFbVG9rZW5UeXBlJDEuQ0RBVEFfU1RBUlRdID0gXCJDREFUQV9TVEFSVFwiO1xuVG9rZW5UeXBlJDFbVG9rZW5UeXBlJDEuQ0RBVEFfRU5EXSA9IFwiQ0RBVEFfRU5EXCI7XG5Ub2tlblR5cGUkMVtUb2tlblR5cGUkMS5BVFRSX05BTUVdID0gXCJBVFRSX05BTUVcIjtcblRva2VuVHlwZSQxW1Rva2VuVHlwZSQxLkFUVFJfVkFMVUVdID0gXCJBVFRSX1ZBTFVFXCI7XG5Ub2tlblR5cGUkMVtUb2tlblR5cGUkMS5ET0NfVFlQRV0gPSBcIkRPQ19UWVBFXCI7XG5Ub2tlblR5cGUkMVtUb2tlblR5cGUkMS5FWFBBTlNJT05fRk9STV9TVEFSVF0gPSBcIkVYUEFOU0lPTl9GT1JNX1NUQVJUXCI7XG5Ub2tlblR5cGUkMVtUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9WQUxVRV0gPSBcIkVYUEFOU0lPTl9DQVNFX1ZBTFVFXCI7XG5Ub2tlblR5cGUkMVtUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlRdID0gXCJFWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlRcIjtcblRva2VuVHlwZSQxW1Rva2VuVHlwZSQxLkVYUEFOU0lPTl9DQVNFX0VYUF9FTkRdID0gXCJFWFBBTlNJT05fQ0FTRV9FWFBfRU5EXCI7XG5Ub2tlblR5cGUkMVtUb2tlblR5cGUkMS5FWFBBTlNJT05fRk9STV9FTkRdID0gXCJFWFBBTlNJT05fRk9STV9FTkRcIjtcblRva2VuVHlwZSQxW1Rva2VuVHlwZSQxLkVPRl0gPSBcIkVPRlwiO1xudmFyIFRva2VuJDEgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7P30gcGFydHNcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUb2tlbiQxKHR5cGUsIHBhcnRzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMucGFydHMgPSBwYXJ0cztcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgcmV0dXJuIFRva2VuJDE7XG59KCkpO1xudmFyIFRva2VuRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFRva2VuRXJyb3IsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlcnJvck1zZ1xuICAgICAqIEBwYXJhbSB7P30gdG9rZW5UeXBlXG4gICAgICogQHBhcmFtIHs/fSBzcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gVG9rZW5FcnJvcihlcnJvck1zZywgdG9rZW5UeXBlLCBzcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4sIGVycm9yTXNnKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50b2tlblR5cGUgPSB0b2tlblR5cGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRva2VuRXJyb3I7XG59KFBhcnNlRXJyb3IpKTtcbnZhciBUb2tlbml6ZVJlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0b2tlbnNcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRva2VuaXplUmVzdWx0KHRva2VucywgZXJyb3JzKSB7XG4gICAgICAgIHRoaXMudG9rZW5zID0gdG9rZW5zO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB9XG4gICAgcmV0dXJuIFRva2VuaXplUmVzdWx0O1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBzb3VyY2VcbiAqIEBwYXJhbSB7P30gdXJsXG4gKiBAcGFyYW0gez99IGdldFRhZ0RlZmluaXRpb25cbiAqIEBwYXJhbSB7Pz19IHRva2VuaXplRXhwYW5zaW9uRm9ybXNcbiAqIEBwYXJhbSB7Pz19IGludGVycG9sYXRpb25Db25maWdcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHRva2VuaXplKHNvdXJjZSwgdXJsLCBnZXRUYWdEZWZpbml0aW9uLCB0b2tlbml6ZUV4cGFuc2lvbkZvcm1zLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgaWYgKHRva2VuaXplRXhwYW5zaW9uRm9ybXMgPT09IHZvaWQgMCkgeyB0b2tlbml6ZUV4cGFuc2lvbkZvcm1zID0gZmFsc2U7IH1cbiAgICBpZiAoaW50ZXJwb2xhdGlvbkNvbmZpZyA9PT0gdm9pZCAwKSB7IGludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHOyB9XG4gICAgcmV0dXJuIG5ldyBfVG9rZW5pemVyKG5ldyBQYXJzZVNvdXJjZUZpbGUoc291cmNlLCB1cmwpLCBnZXRUYWdEZWZpbml0aW9uLCB0b2tlbml6ZUV4cGFuc2lvbkZvcm1zLCBpbnRlcnBvbGF0aW9uQ29uZmlnKVxuICAgICAgICAudG9rZW5pemUoKTtcbn1cbnZhciBfQ1JfT1JfQ1JMRl9SRUdFWFAgPSAvXFxyXFxuPy9nO1xuLyoqXG4gKiBAcGFyYW0gez99IGNoYXJDb2RlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfdW5leHBlY3RlZENoYXJhY3RlckVycm9yTXNnKGNoYXJDb2RlKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hhciA9IGNoYXJDb2RlID09PSAkRU9GID8gJ0VPRicgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgICByZXR1cm4gXCJVbmV4cGVjdGVkIGNoYXJhY3RlciBcXFwiXCIgKyBjaGFyICsgXCJcXFwiXCI7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZW50aXR5U3JjXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfdW5rbm93bkVudGl0eUVycm9yTXNnKGVudGl0eVNyYykge1xuICAgIHJldHVybiBcIlVua25vd24gZW50aXR5IFxcXCJcIiArIGVudGl0eVNyYyArIFwiXFxcIiAtIHVzZSB0aGUgXFxcIiYjPGRlY2ltYWw+O1xcXCIgb3IgIFxcXCImI3g8aGV4PjtcXFwiIHN5bnRheFwiO1xufVxudmFyIF9Db250cm9sRmxvd0Vycm9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVycm9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gX0NvbnRyb2xGbG93RXJyb3IoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gX0NvbnRyb2xGbG93RXJyb3I7XG59KCkpO1xudmFyIF9Ub2tlbml6ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2ZpbGUgVGhlIGh0bWwgc291cmNlXG4gICAgICogQHBhcmFtIHs/fSBfZ2V0VGFnRGVmaW5pdGlvblxuICAgICAqIEBwYXJhbSB7P30gX3Rva2VuaXplSWN1IFdoZXRoZXIgdG8gdG9rZW5pemUgSUNVIG1lc3NhZ2VzIChjb25zaWRlcmVkIGFzIHRleHQgbm9kZXMgd2hlbiBmYWxzZSlcbiAgICAgKiBAcGFyYW0gez89fSBfaW50ZXJwb2xhdGlvbkNvbmZpZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9Ub2tlbml6ZXIoX2ZpbGUsIF9nZXRUYWdEZWZpbml0aW9uLCBfdG9rZW5pemVJY3UsIF9pbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIGlmIChfaW50ZXJwb2xhdGlvbkNvbmZpZyA9PT0gdm9pZCAwKSB7IF9pbnRlcnBvbGF0aW9uQ29uZmlnID0gREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRzsgfVxuICAgICAgICB0aGlzLl9maWxlID0gX2ZpbGU7XG4gICAgICAgIHRoaXMuX2dldFRhZ0RlZmluaXRpb24gPSBfZ2V0VGFnRGVmaW5pdGlvbjtcbiAgICAgICAgdGhpcy5fdG9rZW5pemVJY3UgPSBfdG9rZW5pemVJY3U7XG4gICAgICAgIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcgPSBfaW50ZXJwb2xhdGlvbkNvbmZpZztcbiAgICAgICAgdGhpcy5fcGVlayA9IC0xO1xuICAgICAgICB0aGlzLl9uZXh0UGVlayA9IC0xO1xuICAgICAgICB0aGlzLl9pbmRleCA9IC0xO1xuICAgICAgICB0aGlzLl9saW5lID0gMDtcbiAgICAgICAgdGhpcy5fY29sdW1uID0gLTE7XG4gICAgICAgIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLl9pbkludGVycG9sYXRpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBbXTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5faW5wdXQgPSBfZmlsZS5jb250ZW50O1xuICAgICAgICB0aGlzLl9sZW5ndGggPSBfZmlsZS5jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbnRlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9wcm9jZXNzQ2FycmlhZ2VSZXR1cm5zID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjcHJlcHJvY2Vzc2luZy10aGUtaW5wdXQtc3RyZWFtXG4gICAgICAgIC8vIEluIG9yZGVyIHRvIGtlZXAgdGhlIG9yaWdpbmFsIHBvc2l0aW9uIGluIHRoZSBzb3VyY2UsIHdlIGNhbiBub3RcbiAgICAgICAgLy8gcHJlLXByb2Nlc3MgaXQuXG4gICAgICAgIC8vIEluc3RlYWQgQ1JzIGFyZSBwcm9jZXNzZWQgcmlnaHQgYmVmb3JlIGluc3RhbnRpYXRpbmcgdGhlIHRva2Vucy5cbiAgICAgICAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZShfQ1JfT1JfQ1JMRl9SRUdFWFAsICdcXG4nKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLl9wZWVrICE9PSAkRU9GKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydCA9IHRoaXMuX2dldExvY2F0aW9uKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJExUKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRCQU5HKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkTEJSQUNLRVQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUNkYXRhKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkTUlOVVMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUNvbW1lbnQoc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZURvY1R5cGUoc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkU0xBU0gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lVGFnQ2xvc2Uoc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZVRhZ09wZW4oc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCEodGhpcy5fdG9rZW5pemVJY3UgJiYgdGhpcy5fdG9rZW5pemVFeHBhbnNpb25Gb3JtKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVUZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIF9Db250cm9sRmxvd0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2goZS5lcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkVPRik7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFtdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUb2tlbml6ZVJlc3VsdChtZXJnZVRleHRUb2tlbnModGhpcy50b2tlbnMpLCB0aGlzLmVycm9ycyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX3Rva2VuaXplRXhwYW5zaW9uRm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGlzRXhwYW5zaW9uRm9ybVN0YXJ0KHRoaXMuX2lucHV0LCB0aGlzLl9pbmRleCwgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZykpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFeHBhbnNpb25Gb3JtU3RhcnQoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0V4cGFuc2lvbkNhc2VTdGFydCh0aGlzLl9wZWVrKSAmJiB0aGlzLl9pc0luRXhwYW5zaW9uRm9ybSgpKSB7XG4gICAgICAgICAgICB0aGlzLl9jb25zdW1lRXhwYW5zaW9uQ2FzZVN0YXJ0KCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcGVlayA9PT0gJFJCUkFDRSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzSW5FeHBhbnNpb25DYXNlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lRXhwYW5zaW9uQ2FzZUVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzSW5FeHBhbnNpb25Gb3JtKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lRXhwYW5zaW9uRm9ybUVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2dldExvY2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlTG9jYXRpb24odGhpcy5fZmlsZSwgdGhpcy5faW5kZXgsIHRoaXMuX2xpbmUsIHRoaXMuX2NvbHVtbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBzdGFydFxuICAgICAqIEBwYXJhbSB7Pz19IGVuZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2dldFNwYW4gPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgeyBzdGFydCA9IHRoaXMuX2dldExvY2F0aW9uKCk7IH1cbiAgICAgICAgaWYgKGVuZCA9PT0gdm9pZCAwKSB7IGVuZCA9IHRoaXMuX2dldExvY2F0aW9uKCk7IH1cbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZVNvdXJjZVNwYW4oc3RhcnQsIGVuZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBzdGFydFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2JlZ2luVG9rZW4gPSBmdW5jdGlvbiAodHlwZSwgc3RhcnQpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHsgc3RhcnQgPSB0aGlzLl9nZXRMb2NhdGlvbigpOyB9XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUb2tlblN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUb2tlblR5cGUgPSB0eXBlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwYXJ0c1xuICAgICAqIEBwYXJhbSB7Pz19IGVuZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2VuZFRva2VuID0gZnVuY3Rpb24gKHBhcnRzLCBlbmQpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gdm9pZCAwKSB7IGVuZCA9IHRoaXMuX2dldExvY2F0aW9uKCk7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9rZW4gPSBuZXcgVG9rZW4kMSh0aGlzLl9jdXJyZW50VG9rZW5UeXBlLCBwYXJ0cywgbmV3IFBhcnNlU291cmNlU3Bhbih0aGlzLl9jdXJyZW50VG9rZW5TdGFydCwgZW5kKSk7XG4gICAgICAgIHRoaXMudG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICB0aGlzLl9jdXJyZW50VG9rZW5TdGFydCA9ICgobnVsbCkpO1xuICAgICAgICB0aGlzLl9jdXJyZW50VG9rZW5UeXBlID0gKChudWxsKSk7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbXNnXG4gICAgICogQHBhcmFtIHs/fSBzcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY3JlYXRlRXJyb3IgPSBmdW5jdGlvbiAobXNnLCBzcGFuKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0luRXhwYW5zaW9uRm9ybSgpKSB7XG4gICAgICAgICAgICBtc2cgKz0gXCIgKERvIHlvdSBoYXZlIGFuIHVuZXNjYXBlZCBcXFwie1xcXCIgaW4geW91ciB0ZW1wbGF0ZT8gVXNlIFxcXCJ7eyAneycgfX1cXFwiKSB0byBlc2NhcGUgaXQuKVwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9yID0gbmV3IFRva2VuRXJyb3IobXNnLCB0aGlzLl9jdXJyZW50VG9rZW5UeXBlLCBzcGFuKTtcbiAgICAgICAgdGhpcy5fY3VycmVudFRva2VuU3RhcnQgPSAoKG51bGwpKTtcbiAgICAgICAgdGhpcy5fY3VycmVudFRva2VuVHlwZSA9ICgobnVsbCkpO1xuICAgICAgICByZXR1cm4gbmV3IF9Db250cm9sRmxvd0Vycm9yKGVycm9yKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2FkdmFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbmRleCA+PSB0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bmV4cGVjdGVkQ2hhcmFjdGVyRXJyb3JNc2coJEVPRiksIHRoaXMuX2dldFNwYW4oKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3BlZWsgPT09ICRMRikge1xuICAgICAgICAgICAgdGhpcy5fbGluZSsrO1xuICAgICAgICAgICAgdGhpcy5fY29sdW1uID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9wZWVrICE9PSAkTEYgJiYgdGhpcy5fcGVlayAhPT0gJENSKSB7XG4gICAgICAgICAgICB0aGlzLl9jb2x1bW4rKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbmRleCsrO1xuICAgICAgICB0aGlzLl9wZWVrID0gdGhpcy5faW5kZXggPj0gdGhpcy5fbGVuZ3RoID8gJEVPRiA6IHRoaXMuX2lucHV0LmNoYXJDb2RlQXQodGhpcy5faW5kZXgpO1xuICAgICAgICB0aGlzLl9uZXh0UGVlayA9XG4gICAgICAgICAgICB0aGlzLl9pbmRleCArIDEgPj0gdGhpcy5fbGVuZ3RoID8gJEVPRiA6IHRoaXMuX2lucHV0LmNoYXJDb2RlQXQodGhpcy5faW5kZXggKyAxKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY2hhckNvZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9hdHRlbXB0Q2hhckNvZGUgPSBmdW5jdGlvbiAoY2hhckNvZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BlZWsgPT09IGNoYXJDb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNoYXJDb2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fYXR0ZW1wdENoYXJDb2RlQ2FzZUluc2Vuc2l0aXZlID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XG4gICAgICAgIGlmIChjb21wYXJlQ2hhckNvZGVDYXNlSW5zZW5zaXRpdmUodGhpcy5fcGVlaywgY2hhckNvZGUpKSB7XG4gICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNoYXJDb2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fcmVxdWlyZUNoYXJDb2RlID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxvY2F0aW9uID0gdGhpcy5fZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgaWYgKCF0aGlzLl9hdHRlbXB0Q2hhckNvZGUoY2hhckNvZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLl9jcmVhdGVFcnJvcihfdW5leHBlY3RlZENoYXJhY3RlckVycm9yTXNnKHRoaXMuX3BlZWspLCB0aGlzLl9nZXRTcGFuKGxvY2F0aW9uLCBsb2NhdGlvbikpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNoYXJzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fYXR0ZW1wdFN0ciA9IGZ1bmN0aW9uIChjaGFycykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsZW4gPSBjaGFycy5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLl9pbmRleCArIGxlbiA+IHRoaXMuX2xlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluaXRpYWxQb3NpdGlvbiA9IHRoaXMuX3NhdmVQb3NpdGlvbigpO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fYXR0ZW1wdENoYXJDb2RlKGNoYXJzLmNoYXJDb2RlQXQoaSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYXR0ZW1wdGluZyB0byBwYXJzZSB0aGUgc3RyaW5nIGZhaWxzLCB3ZSB3YW50IHRvIHJlc2V0IHRoZSBwYXJzZXJcbiAgICAgICAgICAgICAgICAvLyB0byB3aGVyZSBpdCB3YXMgYmVmb3JlIHRoZSBhdHRlbXB0XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzdG9yZVBvc2l0aW9uKGluaXRpYWxQb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjaGFyc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2F0dGVtcHRTdHJDYXNlSW5zZW5zaXRpdmUgPSBmdW5jdGlvbiAoY2hhcnMpIHtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2F0dGVtcHRDaGFyQ29kZUNhc2VJbnNlbnNpdGl2ZShjaGFycy5jaGFyQ29kZUF0KGkpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY2hhcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9yZXF1aXJlU3RyID0gZnVuY3Rpb24gKGNoYXJzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxvY2F0aW9uID0gdGhpcy5fZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgaWYgKCF0aGlzLl9hdHRlbXB0U3RyKGNoYXJzKSkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IoX3VuZXhwZWN0ZWRDaGFyYWN0ZXJFcnJvck1zZyh0aGlzLl9wZWVrKSwgdGhpcy5fZ2V0U3Bhbihsb2NhdGlvbikpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHByZWRpY2F0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4gPSBmdW5jdGlvbiAocHJlZGljYXRlKSB7XG4gICAgICAgIHdoaWxlICghcHJlZGljYXRlKHRoaXMuX3BlZWspKSB7XG4gICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJlZGljYXRlXG4gICAgICogQHBhcmFtIHs/fSBsZW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9yZXF1aXJlQ2hhckNvZGVVbnRpbEZuID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgbGVuKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0ID0gdGhpcy5fZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihwcmVkaWNhdGUpO1xuICAgICAgICBpZiAodGhpcy5faW5kZXggLSBzdGFydC5vZmZzZXQgPCBsZW4pIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bmV4cGVjdGVkQ2hhcmFjdGVyRXJyb3JNc2codGhpcy5fcGVlayksIHRoaXMuX2dldFNwYW4oc3RhcnQsIHN0YXJ0KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY2hhclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2F0dGVtcHRVbnRpbENoYXIgPSBmdW5jdGlvbiAoY2hhcikge1xuICAgICAgICB3aGlsZSAodGhpcy5fcGVlayAhPT0gY2hhcikge1xuICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRlY29kZUVudGl0aWVzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZENoYXIgPSBmdW5jdGlvbiAoZGVjb2RlRW50aXRpZXMpIHtcbiAgICAgICAgaWYgKGRlY29kZUVudGl0aWVzICYmIHRoaXMuX3BlZWsgPT09ICRBTVBFUlNBTkQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVFbnRpdHkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluZGV4ID0gdGhpcy5faW5kZXg7XG4gICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5wdXRbaW5kZXhdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9kZWNvZGVFbnRpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0ID0gdGhpcy5fZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICBpZiAodGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRIQVNIKSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNIZXggPSB0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJHgpIHx8IHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkWCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBudW1iZXJTdGFydCA9IHRoaXMuX2dldExvY2F0aW9uKCkub2Zmc2V0O1xuICAgICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc0RpZ2l0RW50aXR5RW5kKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wZWVrICE9ICRTRU1JQ09MT04pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLl9jcmVhdGVFcnJvcihfdW5leHBlY3RlZENoYXJhY3RlckVycm9yTXNnKHRoaXMuX3BlZWspLCB0aGlzLl9nZXRTcGFuKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RyTnVtID0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKG51bWJlclN0YXJ0LCB0aGlzLl9pbmRleCAtIDEpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGFyQ29kZSA9IHBhcnNlSW50KHN0ck51bSwgaXNIZXggPyAxNiA6IDEwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVudGl0eSA9IHRoaXMuX2lucHV0LnN1YnN0cmluZyhzdGFydC5vZmZzZXQgKyAxLCB0aGlzLl9pbmRleCAtIDEpO1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bmtub3duRW50aXR5RXJyb3JNc2coZW50aXR5KSwgdGhpcy5fZ2V0U3BhbihzdGFydCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnRQb3NpdGlvbiA9IHRoaXMuX3NhdmVQb3NpdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05hbWVkRW50aXR5RW5kKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wZWVrICE9ICRTRU1JQ09MT04pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXN0b3JlUG9zaXRpb24oc3RhcnRQb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcmJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWUgPSB0aGlzLl9pbnB1dC5zdWJzdHJpbmcoc3RhcnQub2Zmc2V0ICsgMSwgdGhpcy5faW5kZXggLSAxKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNoYXIgPSBOQU1FRF9FTlRJVElFU1tuYW1lXTtcbiAgICAgICAgICAgIGlmICghY2hhcikge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bmtub3duRW50aXR5RXJyb3JNc2cobmFtZSksIHRoaXMuX2dldFNwYW4oc3RhcnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaGFyO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRlY29kZUVudGl0aWVzXG4gICAgICogQHBhcmFtIHs/fSBmaXJzdENoYXJPZkVuZFxuICAgICAqIEBwYXJhbSB7P30gYXR0ZW1wdEVuZFJlc3RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lUmF3VGV4dCA9IGZ1bmN0aW9uIChkZWNvZGVFbnRpdGllcywgZmlyc3RDaGFyT2ZFbmQsIGF0dGVtcHRFbmRSZXN0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRhZ0Nsb3NlU3RhcnQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRleHRTdGFydCA9IHRoaXMuX2dldExvY2F0aW9uKCk7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oZGVjb2RlRW50aXRpZXMgPyBUb2tlblR5cGUkMS5FU0NBUEFCTEVfUkFXX1RFWFQgOiBUb2tlblR5cGUkMS5SQVdfVEVYVCwgdGV4dFN0YXJ0KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFydHMgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHRhZ0Nsb3NlU3RhcnQgPSB0aGlzLl9nZXRMb2NhdGlvbigpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZShmaXJzdENoYXJPZkVuZCkgJiYgYXR0ZW1wdEVuZFJlc3QoKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2luZGV4ID4gdGFnQ2xvc2VTdGFydC5vZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIGNoYXJhY3RlcnMgY29uc3VtZWQgYnkgdGhlIHByZXZpb3VzIGlmIHN0YXRlbWVudCB0byB0aGUgb3V0cHV0XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaCh0aGlzLl9pbnB1dC5zdWJzdHJpbmcodGFnQ2xvc2VTdGFydC5vZmZzZXQsIHRoaXMuX2luZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5fcGVlayAhPT0gZmlyc3RDaGFyT2ZFbmQpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHRoaXMuX3JlYWRDaGFyKGRlY29kZUVudGl0aWVzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZFRva2VuKFt0aGlzLl9wcm9jZXNzQ2FycmlhZ2VSZXR1cm5zKHBhcnRzLmpvaW4oJycpKV0sIHRhZ0Nsb3NlU3RhcnQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGFydFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVDb21tZW50ID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuQ09NTUVOVF9TVEFSVCwgc3RhcnQpO1xuICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGUoJE1JTlVTKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZXh0VG9rZW4gPSB0aGlzLl9jb25zdW1lUmF3VGV4dChmYWxzZSwgJE1JTlVTLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fYXR0ZW1wdFN0cignLT4nKTsgfSk7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuQ09NTUVOVF9FTkQsIHRleHRUb2tlbi5zb3VyY2VTcGFuLmVuZCk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFtdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RhcnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lQ2RhdGEgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5DREFUQV9TVEFSVCwgc3RhcnQpO1xuICAgICAgICB0aGlzLl9yZXF1aXJlU3RyKCdDREFUQVsnKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZXh0VG9rZW4gPSB0aGlzLl9jb25zdW1lUmF3VGV4dChmYWxzZSwgJFJCUkFDS0VULCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fYXR0ZW1wdFN0cignXT4nKTsgfSk7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuQ0RBVEFfRU5ELCB0ZXh0VG9rZW4uc291cmNlU3Bhbi5lbmQpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXJ0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZURvY1R5cGUgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5ET0NfVFlQRSwgc3RhcnQpO1xuICAgICAgICB0aGlzLl9hdHRlbXB0VW50aWxDaGFyKCRHVCk7XG4gICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW3RoaXMuX2lucHV0LnN1YnN0cmluZyhzdGFydC5vZmZzZXQgKyAyLCB0aGlzLl9pbmRleCAtIDEpXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lUHJlZml4QW5kTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZU9yUHJlZml4U3RhcnQgPSB0aGlzLl9pbmRleDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlZml4ID0gKChudWxsKSk7XG4gICAgICAgIHdoaWxlICh0aGlzLl9wZWVrICE9PSAkQ09MT04gJiYgIWlzUHJlZml4RW5kKHRoaXMuX3BlZWspKSB7XG4gICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZVN0YXJ0O1xuICAgICAgICBpZiAodGhpcy5fcGVlayA9PT0gJENPTE9OKSB7XG4gICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICBwcmVmaXggPSB0aGlzLl9pbnB1dC5zdWJzdHJpbmcobmFtZU9yUHJlZml4U3RhcnQsIHRoaXMuX2luZGV4IC0gMSk7XG4gICAgICAgICAgICBuYW1lU3RhcnQgPSB0aGlzLl9pbmRleDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5hbWVTdGFydCA9IG5hbWVPclByZWZpeFN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZVVudGlsRm4oaXNOYW1lRW5kLCB0aGlzLl9pbmRleCA9PT0gbmFtZVN0YXJ0ID8gMSA6IDApO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lID0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKG5hbWVTdGFydCwgdGhpcy5faW5kZXgpO1xuICAgICAgICByZXR1cm4gW3ByZWZpeCwgbmFtZV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXJ0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZVRhZ09wZW4gPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2F2ZWRQb3MgPSB0aGlzLl9zYXZlUG9zaXRpb24oKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGFnTmFtZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbG93ZXJjYXNlVGFnTmFtZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghaXNBc2NpaUxldHRlcih0aGlzLl9wZWVrKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bmV4cGVjdGVkQ2hhcmFjdGVyRXJyb3JNc2codGhpcy5fcGVlayksIHRoaXMuX2dldFNwYW4oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lU3RhcnQgPSB0aGlzLl9pbmRleDtcbiAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVUYWdPcGVuU3RhcnQoc3RhcnQpO1xuICAgICAgICAgICAgdGFnTmFtZSA9IHRoaXMuX2lucHV0LnN1YnN0cmluZyhuYW1lU3RhcnQsIHRoaXMuX2luZGV4KTtcbiAgICAgICAgICAgIGxvd2VyY2FzZVRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5fcGVlayAhPT0gJFNMQVNIICYmIHRoaXMuX3BlZWsgIT09ICRHVCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVBdHRyaWJ1dGVOYW1lKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJEVRKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVBdHRyaWJ1dGVWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jb25zdW1lVGFnT3BlbkVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIF9Db250cm9sRmxvd0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgc3RhcnQgdGFnIGlzIGludmFsaWQsIGFzc3VtZSB3ZSB3YW50IGEgXCI8XCJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXN0b3JlUG9zaXRpb24oc2F2ZWRQb3MpO1xuICAgICAgICAgICAgICAgIC8vIEJhY2sgdG8gYmFjayB0ZXh0IHRva2VucyBhcmUgbWVyZ2VkIGF0IHRoZSBlbmRcbiAgICAgICAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLlRFWFQsIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbJzwnXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250ZW50VG9rZW5UeXBlID0gdGhpcy5fZ2V0VGFnRGVmaW5pdGlvbih0YWdOYW1lKS5jb250ZW50VHlwZTtcbiAgICAgICAgaWYgKGNvbnRlbnRUb2tlblR5cGUgPT09IFRhZ0NvbnRlbnRUeXBlLlJBV19URVhUKSB7XG4gICAgICAgICAgICB0aGlzLl9jb25zdW1lUmF3VGV4dFdpdGhUYWdDbG9zZShsb3dlcmNhc2VUYWdOYW1lLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udGVudFRva2VuVHlwZSA9PT0gVGFnQ29udGVudFR5cGUuRVNDQVBBQkxFX1JBV19URVhUKSB7XG4gICAgICAgICAgICB0aGlzLl9jb25zdW1lUmF3VGV4dFdpdGhUYWdDbG9zZShsb3dlcmNhc2VUYWdOYW1lLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBsb3dlcmNhc2VUYWdOYW1lXG4gICAgICogQHBhcmFtIHs/fSBkZWNvZGVFbnRpdGllc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVSYXdUZXh0V2l0aFRhZ0Nsb3NlID0gZnVuY3Rpb24gKGxvd2VyY2FzZVRhZ05hbWUsIGRlY29kZUVudGl0aWVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRleHRUb2tlbiA9IHRoaXMuX2NvbnN1bWVSYXdUZXh0KGRlY29kZUVudGl0aWVzLCAkTFQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMuX2F0dGVtcHRDaGFyQ29kZSgkU0xBU0gpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIF90aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgICBpZiAoIV90aGlzLl9hdHRlbXB0U3RyQ2FzZUluc2Vuc2l0aXZlKGxvd2VyY2FzZVRhZ05hbWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIF90aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX2F0dGVtcHRDaGFyQ29kZSgkR1QpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5UQUdfQ0xPU0UsIHRleHRUb2tlbi5zb3VyY2VTcGFuLmVuZCk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFsvKiogQHR5cGUgez99ICovICgobnVsbCkpLCBsb3dlcmNhc2VUYWdOYW1lXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXJ0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZVRhZ09wZW5TdGFydCA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLlRBR19PUEVOX1NUQVJULCBzdGFydCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnRzID0gdGhpcy5fY29uc3VtZVByZWZpeEFuZE5hbWUoKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4ocGFydHMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZUF0dHJpYnV0ZU5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuQVRUUl9OQU1FKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlZml4QW5kTmFtZSA9IHRoaXMuX2NvbnN1bWVQcmVmaXhBbmROYW1lKCk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKHByZWZpeEFuZE5hbWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZUF0dHJpYnV0ZVZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkFUVFJfVkFMVUUpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuX3BlZWsgPT09ICRTUSB8fCB0aGlzLl9wZWVrID09PSAkRFEpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1b3RlQ2hhciA9IHRoaXMuX3BlZWs7XG4gICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJ0cyA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuX3BlZWsgIT09IHF1b3RlQ2hhcikge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5fcmVhZENoYXIodHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBwYXJ0cy5qb2luKCcnKTtcbiAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlU3RhcnQgPSB0aGlzLl9pbmRleDtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZVVudGlsRm4oaXNOYW1lRW5kLCAxKTtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKHZhbHVlU3RhcnQsIHRoaXMuX2luZGV4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lbmRUb2tlbihbdGhpcy5fcHJvY2Vzc0NhcnJpYWdlUmV0dXJucyh2YWx1ZSldKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVUYWdPcGVuRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b2tlblR5cGUgPSB0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJFNMQVNIKSA/IFRva2VuVHlwZSQxLlRBR19PUEVOX0VORF9WT0lEIDogVG9rZW5UeXBlJDEuVEFHX09QRU5fRU5EO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKHRva2VuVHlwZSk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkR1QpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXJ0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZVRhZ0Nsb3NlID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuVEFHX0NMT1NFLCBzdGFydCk7XG4gICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlZml4QW5kTmFtZSA9IHRoaXMuX2NvbnN1bWVQcmVmaXhBbmROYW1lKCk7XG4gICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlKCRHVCk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKHByZWZpeEFuZE5hbWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZUV4cGFuc2lvbkZvcm1TdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5FWFBBTlNJT05fRk9STV9TVEFSVCwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkTEJSQUNFKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgICB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2sucHVzaChUb2tlblR5cGUkMS5FWFBBTlNJT05fRk9STV9TVEFSVCk7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuUkFXX1RFWFQsIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb25kaXRpb24gPSB0aGlzLl9yZWFkVW50aWwoJENPTU1BKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW2NvbmRpdGlvbl0sIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGUoJENPTU1BKTtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLlJBV19URVhULCB0aGlzLl9nZXRMb2NhdGlvbigpKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHlwZSA9IHRoaXMuX3JlYWRVbnRpbCgkQ09NTUEpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbdHlwZV0sIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGUoJENPTU1BKTtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZUV4cGFuc2lvbkNhc2VTdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9WQUxVRSwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gdGhpcy5fcmVhZFVudGlsKCRMQlJBQ0UpLnRyaW0oKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW3ZhbHVlXSwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQsIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGUoJExCUkFDRSk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFtdLCB0aGlzLl9nZXRMb2NhdGlvbigpKTtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2sucHVzaChUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZUV4cGFuc2lvbkNhc2VFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0NBU0VfRVhQX0VORCwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkUkJSQUNFKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10sIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5wb3AoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVFeHBhbnNpb25Gb3JtRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkVYUEFOU0lPTl9GT1JNX0VORCwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkUkJSQUNFKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgICB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2sucG9wKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lVGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnQgPSB0aGlzLl9nZXRMb2NhdGlvbigpO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLlRFWFQsIHN0YXJ0KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFydHMgPSBbXTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2ludGVycG9sYXRpb25Db25maWcgJiYgdGhpcy5fYXR0ZW1wdFN0cih0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnLnN0YXJ0KSkge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZy5zdGFydCk7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5JbnRlcnBvbGF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2ludGVycG9sYXRpb25Db25maWcgJiYgdGhpcy5faW5JbnRlcnBvbGF0aW9uICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fYXR0ZW1wdFN0cih0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnLmVuZCkpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHRoaXMuX2ludGVycG9sYXRpb25Db25maWcuZW5kKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbkludGVycG9sYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5fcmVhZENoYXIodHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlICghdGhpcy5faXNUZXh0RW5kKCkpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbdGhpcy5fcHJvY2Vzc0NhcnJpYWdlUmV0dXJucyhwYXJ0cy5qb2luKCcnKSldKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2lzVGV4dEVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BlZWsgPT09ICRMVCB8fCB0aGlzLl9wZWVrID09PSAkRU9GKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdG9rZW5pemVJY3UgJiYgIXRoaXMuX2luSW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgICAgaWYgKGlzRXhwYW5zaW9uRm9ybVN0YXJ0KHRoaXMuX2lucHV0LCB0aGlzLl9pbmRleCwgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBvZiBhbiBleHBhbnNpb24gZm9ybVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3BlZWsgPT09ICRSQlJBQ0UgJiYgdGhpcy5faXNJbkV4cGFuc2lvbkNhc2UoKSkge1xuICAgICAgICAgICAgICAgIC8vIGVuZCBvZiBhbmQgZXhwYW5zaW9uIGNhc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9zYXZlUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5fcGVlaywgdGhpcy5faW5kZXgsIHRoaXMuX2NvbHVtbiwgdGhpcy5fbGluZSwgdGhpcy50b2tlbnMubGVuZ3RoXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY2hhclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX3JlYWRVbnRpbCA9IGZ1bmN0aW9uIChjaGFyKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0ID0gdGhpcy5faW5kZXg7XG4gICAgICAgIHRoaXMuX2F0dGVtcHRVbnRpbENoYXIoY2hhcik7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnB1dC5zdWJzdHJpbmcoc3RhcnQsIHRoaXMuX2luZGV4KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcG9zaXRpb25cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9yZXN0b3JlUG9zaXRpb24gPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5fcGVlayA9IHBvc2l0aW9uWzBdO1xuICAgICAgICB0aGlzLl9pbmRleCA9IHBvc2l0aW9uWzFdO1xuICAgICAgICB0aGlzLl9jb2x1bW4gPSBwb3NpdGlvblsyXTtcbiAgICAgICAgdGhpcy5fbGluZSA9IHBvc2l0aW9uWzNdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYlRva2VucyA9IHBvc2l0aW9uWzRdO1xuICAgICAgICBpZiAobmJUb2tlbnMgPCB0aGlzLnRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBhbnkgZXh0cmEgdG9rZW5zXG4gICAgICAgICAgICB0aGlzLnRva2VucyA9IHRoaXMudG9rZW5zLnNsaWNlKDAsIG5iVG9rZW5zKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5faXNJbkV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2subGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrW3RoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5sZW5ndGggLSAxXSA9PT1cbiAgICAgICAgICAgICAgICBUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9pc0luRXhwYW5zaW9uRm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2tbdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrLmxlbmd0aCAtIDFdID09PVxuICAgICAgICAgICAgICAgIFRva2VuVHlwZSQxLkVYUEFOU0lPTl9GT1JNX1NUQVJUO1xuICAgIH07XG4gICAgcmV0dXJuIF9Ub2tlbml6ZXI7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IGNvZGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzTm90V2hpdGVzcGFjZShjb2RlKSB7XG4gICAgcmV0dXJuICFpc1doaXRlc3BhY2UoY29kZSkgfHwgY29kZSA9PT0gJEVPRjtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBjb2RlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc05hbWVFbmQoY29kZSkge1xuICAgIHJldHVybiBpc1doaXRlc3BhY2UoY29kZSkgfHwgY29kZSA9PT0gJEdUIHx8IGNvZGUgPT09ICRTTEFTSCB8fFxuICAgICAgICBjb2RlID09PSAkU1EgfHwgY29kZSA9PT0gJERRIHx8IGNvZGUgPT09ICRFUTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBjb2RlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc1ByZWZpeEVuZChjb2RlKSB7XG4gICAgcmV0dXJuIChjb2RlIDwgJGEgfHwgJHogPCBjb2RlKSAmJiAoY29kZSA8ICRBIHx8ICRaIDwgY29kZSkgJiZcbiAgICAgICAgKGNvZGUgPCAkMCB8fCBjb2RlID4gJDkpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGNvZGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzRGlnaXRFbnRpdHlFbmQoY29kZSkge1xuICAgIHJldHVybiBjb2RlID09ICRTRU1JQ09MT04gfHwgY29kZSA9PSAkRU9GIHx8ICFpc0FzY2lpSGV4RGlnaXQoY29kZSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gY29kZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNOYW1lZEVudGl0eUVuZChjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPT0gJFNFTUlDT0xPTiB8fCBjb2RlID09ICRFT0YgfHwgIWlzQXNjaWlMZXR0ZXIoY29kZSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gaW5wdXRcbiAqIEBwYXJhbSB7P30gb2Zmc2V0XG4gKiBAcGFyYW0gez99IGludGVycG9sYXRpb25Db25maWdcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzRXhwYW5zaW9uRm9ybVN0YXJ0KGlucHV0LCBvZmZzZXQsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc0ludGVycG9sYXRpb25TdGFydCA9IGludGVycG9sYXRpb25Db25maWcgPyBpbnB1dC5pbmRleE9mKGludGVycG9sYXRpb25Db25maWcuc3RhcnQsIG9mZnNldCkgPT0gb2Zmc2V0IDogZmFsc2U7XG4gICAgcmV0dXJuIGlucHV0LmNoYXJDb2RlQXQob2Zmc2V0KSA9PSAkTEJSQUNFICYmICFpc0ludGVycG9sYXRpb25TdGFydDtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBwZWVrXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc0V4cGFuc2lvbkNhc2VTdGFydChwZWVrKSB7XG4gICAgcmV0dXJuIHBlZWsgPT09ICRFUSB8fCBpc0FzY2lpTGV0dGVyKHBlZWspIHx8IGlzRGlnaXQocGVlayk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gY29kZTFcbiAqIEBwYXJhbSB7P30gY29kZTJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVDaGFyQ29kZUNhc2VJbnNlbnNpdGl2ZShjb2RlMSwgY29kZTIpIHtcbiAgICByZXR1cm4gdG9VcHBlckNhc2VDaGFyQ29kZShjb2RlMSkgPT0gdG9VcHBlckNhc2VDaGFyQ29kZShjb2RlMik7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gY29kZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdG9VcHBlckNhc2VDaGFyQ29kZShjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPj0gJGEgJiYgY29kZSA8PSAkeiA/IGNvZGUgLSAkYSArICRBIDogY29kZTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBzcmNUb2tlbnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG1lcmdlVGV4dFRva2VucyhzcmNUb2tlbnMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkc3RUb2tlbnMgPSBbXTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsYXN0RHN0VG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHNyY1Rva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b2tlbiA9IHNyY1Rva2Vuc1tpXTtcbiAgICAgICAgaWYgKGxhc3REc3RUb2tlbiAmJiBsYXN0RHN0VG9rZW4udHlwZSA9PSBUb2tlblR5cGUkMS5URVhUICYmIHRva2VuLnR5cGUgPT0gVG9rZW5UeXBlJDEuVEVYVCkge1xuICAgICAgICAgICAgbGFzdERzdFRva2VuLnBhcnRzWzBdICs9IHRva2VuLnBhcnRzWzBdO1xuICAgICAgICAgICAgbGFzdERzdFRva2VuLnNvdXJjZVNwYW4uZW5kID0gdG9rZW4uc291cmNlU3Bhbi5lbmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsYXN0RHN0VG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgIGRzdFRva2Vucy5wdXNoKGxhc3REc3RUb2tlbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRzdFRva2Vucztcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBUcmVlRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFRyZWVFcnJvciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnROYW1lXG4gICAgICogQHBhcmFtIHs/fSBzcGFuXG4gICAgICogQHBhcmFtIHs/fSBtc2dcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUcmVlRXJyb3IoZWxlbWVudE5hbWUsIHNwYW4sIG1zZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuLCBtc2cpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmVsZW1lbnROYW1lID0gZWxlbWVudE5hbWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50TmFtZVxuICAgICAqIEBwYXJhbSB7P30gc3BhblxuICAgICAqIEBwYXJhbSB7P30gbXNnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmVlRXJyb3IuY3JlYXRlID0gZnVuY3Rpb24gKGVsZW1lbnROYW1lLCBzcGFuLCBtc2cpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlRXJyb3IoZWxlbWVudE5hbWUsIHNwYW4sIG1zZyk7XG4gICAgfTtcbiAgICByZXR1cm4gVHJlZUVycm9yO1xufShQYXJzZUVycm9yKSk7XG52YXIgUGFyc2VUcmVlUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJvb3ROb2Rlc1xuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGFyc2VUcmVlUmVzdWx0KHJvb3ROb2RlcywgZXJyb3JzKSB7XG4gICAgICAgIHRoaXMucm9vdE5vZGVzID0gcm9vdE5vZGVzO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB9XG4gICAgcmV0dXJuIFBhcnNlVHJlZVJlc3VsdDtcbn0oKSk7XG52YXIgUGFyc2VyJDEgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZ2V0VGFnRGVmaW5pdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBhcnNlciQxKGdldFRhZ0RlZmluaXRpb24pIHtcbiAgICAgICAgdGhpcy5nZXRUYWdEZWZpbml0aW9uID0gZ2V0VGFnRGVmaW5pdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VcbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEBwYXJhbSB7Pz19IHBhcnNlRXhwYW5zaW9uRm9ybXNcbiAgICAgKiBAcGFyYW0gez89fSBpbnRlcnBvbGF0aW9uQ29uZmlnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZXIkMS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCB1cmwsIHBhcnNlRXhwYW5zaW9uRm9ybXMsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgaWYgKHBhcnNlRXhwYW5zaW9uRm9ybXMgPT09IHZvaWQgMCkgeyBwYXJzZUV4cGFuc2lvbkZvcm1zID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKGludGVycG9sYXRpb25Db25maWcgPT09IHZvaWQgMCkgeyBpbnRlcnBvbGF0aW9uQ29uZmlnID0gREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRzsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b2tlbnNBbmRFcnJvcnMgPSB0b2tlbml6ZShzb3VyY2UsIHVybCwgdGhpcy5nZXRUYWdEZWZpbml0aW9uLCBwYXJzZUV4cGFuc2lvbkZvcm1zLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJlZUFuZEVycm9ycyA9IG5ldyBfVHJlZUJ1aWxkZXIodG9rZW5zQW5kRXJyb3JzLnRva2VucywgdGhpcy5nZXRUYWdEZWZpbml0aW9uKS5idWlsZCgpO1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlVHJlZVJlc3VsdCh0cmVlQW5kRXJyb3JzLnJvb3ROb2RlcywgKCh0b2tlbnNBbmRFcnJvcnMuZXJyb3JzKSkuY29uY2F0KHRyZWVBbmRFcnJvcnMuZXJyb3JzKSk7XG4gICAgfTtcbiAgICByZXR1cm4gUGFyc2VyJDE7XG59KCkpO1xudmFyIF9UcmVlQnVpbGRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0b2tlbnNcbiAgICAgKiBAcGFyYW0gez99IGdldFRhZ0RlZmluaXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfVHJlZUJ1aWxkZXIodG9rZW5zLCBnZXRUYWdEZWZpbml0aW9uKSB7XG4gICAgICAgIHRoaXMudG9rZW5zID0gdG9rZW5zO1xuICAgICAgICB0aGlzLmdldFRhZ0RlZmluaXRpb24gPSBnZXRUYWdEZWZpbml0aW9uO1xuICAgICAgICB0aGlzLl9pbmRleCA9IC0xO1xuICAgICAgICB0aGlzLl9yb290Tm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fZXJyb3JzID0gW107XG4gICAgICAgIHRoaXMuX2VsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuX3BlZWsudHlwZSAhPT0gVG9rZW5UeXBlJDEuRU9GKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5UQUdfT1BFTl9TVEFSVCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVTdGFydFRhZyh0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5UQUdfQ0xPU0UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lRW5kVGFnKHRoaXMuX2FkdmFuY2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLkNEQVRBX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xvc2VWb2lkRWxlbWVudCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVDZGF0YSh0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5DT01NRU5UX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xvc2VWb2lkRWxlbWVudCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVDb21tZW50KHRoaXMuX2FkdmFuY2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLlRFWFQgfHwgdGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5SQVdfVEVYVCB8fFxuICAgICAgICAgICAgICAgIHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuRVNDQVBBQkxFX1JBV19URVhUKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xvc2VWb2lkRWxlbWVudCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVUZXh0KHRoaXMuX2FkdmFuY2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLkVYUEFOU0lPTl9GT1JNX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUV4cGFuc2lvbih0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU2tpcCBhbGwgb3RoZXIgdG9rZW5zLi4uXG4gICAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VUcmVlUmVzdWx0KHRoaXMuX3Jvb3ROb2RlcywgdGhpcy5fZXJyb3JzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fYWR2YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJldiA9IHRoaXMuX3BlZWs7XG4gICAgICAgIGlmICh0aGlzLl9pbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIC8vIE5vdGU6IHRoZXJlIGlzIGFsd2F5cyBhbiBFT0YgdG9rZW4gYXQgdGhlIGVuZFxuICAgICAgICAgICAgdGhpcy5faW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wZWVrID0gdGhpcy50b2tlbnNbdGhpcy5faW5kZXhdO1xuICAgICAgICByZXR1cm4gcHJldjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fYWR2YW5jZUlmID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RhcnRUb2tlblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fY29uc3VtZUNkYXRhID0gZnVuY3Rpb24gKHN0YXJ0VG9rZW4pIHtcbiAgICAgICAgdGhpcy5fY29uc3VtZVRleHQodGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgdGhpcy5fYWR2YW5jZUlmKFRva2VuVHlwZSQxLkNEQVRBX0VORCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRva2VuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9jb25zdW1lQ29tbWVudCA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZXh0ID0gdGhpcy5fYWR2YW5jZUlmKFRva2VuVHlwZSQxLlJBV19URVhUKTtcbiAgICAgICAgdGhpcy5fYWR2YW5jZUlmKFRva2VuVHlwZSQxLkNPTU1FTlRfRU5EKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSB0ZXh0ICE9IG51bGwgPyB0ZXh0LnBhcnRzWzBdLnRyaW0oKSA6IG51bGw7XG4gICAgICAgIHRoaXMuX2FkZFRvUGFyZW50KG5ldyBDb21tZW50KHZhbHVlLCB0b2tlbi5zb3VyY2VTcGFuKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRva2VuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9jb25zdW1lRXhwYW5zaW9uID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN3aXRjaFZhbHVlID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0eXBlID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjYXNlcyA9IFtdO1xuICAgICAgICAvLyByZWFkID1cbiAgICAgICAgd2hpbGUgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0NBU0VfVkFMVUUpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cENhc2UgPSB0aGlzLl9wYXJzZUV4cGFuc2lvbkNhc2UoKTtcbiAgICAgICAgICAgIGlmICghZXhwQ2FzZSlcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIGVycm9yXG4gICAgICAgICAgICBjYXNlcy5wdXNoKGV4cENhc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlYWQgdGhlIGZpbmFsIH1cbiAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSAhPT0gVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0ZPUk1fRU5EKSB7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChUcmVlRXJyb3IuY3JlYXRlKG51bGwsIHRoaXMuX3BlZWsuc291cmNlU3BhbiwgXCJJbnZhbGlkIElDVSBtZXNzYWdlLiBNaXNzaW5nICd9Jy5cIikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvdXJjZVNwYW4gPSBuZXcgUGFyc2VTb3VyY2VTcGFuKHRva2VuLnNvdXJjZVNwYW4uc3RhcnQsIHRoaXMuX3BlZWsuc291cmNlU3Bhbi5lbmQpO1xuICAgICAgICB0aGlzLl9hZGRUb1BhcmVudChuZXcgRXhwYW5zaW9uKHN3aXRjaFZhbHVlLnBhcnRzWzBdLCB0eXBlLnBhcnRzWzBdLCBjYXNlcywgc291cmNlU3Bhbiwgc3dpdGNoVmFsdWUuc291cmNlU3BhbikpO1xuICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX3BhcnNlRXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgIC8vIHJlYWQge1xuICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlICE9PSBUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQpIHtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUobnVsbCwgdGhpcy5fcGVlay5zb3VyY2VTcGFuLCBcIkludmFsaWQgSUNVIG1lc3NhZ2UuIE1pc3NpbmcgJ3snLlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWFkIHVudGlsIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnQgPSB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cCA9IHRoaXMuX2NvbGxlY3RFeHBhbnNpb25FeHBUb2tlbnMoc3RhcnQpO1xuICAgICAgICBpZiAoIWV4cClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbmQgPSB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgIGV4cC5wdXNoKG5ldyBUb2tlbiQxKFRva2VuVHlwZSQxLkVPRiwgW10sIGVuZC5zb3VyY2VTcGFuKSk7XG4gICAgICAgIC8vIHBhcnNlIGV2ZXJ5dGhpbmcgaW4gYmV0d2VlbiB7IGFuZCB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnNlZEV4cCA9IG5ldyBfVHJlZUJ1aWxkZXIoZXhwLCB0aGlzLmdldFRhZ0RlZmluaXRpb24pLmJ1aWxkKCk7XG4gICAgICAgIGlmIChwYXJzZWRFeHAuZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9ycyA9IHRoaXMuX2Vycm9ycy5jb25jYXQoLyoqIEB0eXBlIHs/fSAqLyAocGFyc2VkRXhwLmVycm9ycykpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlU3BhbiA9IG5ldyBQYXJzZVNvdXJjZVNwYW4odmFsdWUuc291cmNlU3Bhbi5zdGFydCwgZW5kLnNvdXJjZVNwYW4uZW5kKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwU291cmNlU3BhbiA9IG5ldyBQYXJzZVNvdXJjZVNwYW4oc3RhcnQuc291cmNlU3Bhbi5zdGFydCwgZW5kLnNvdXJjZVNwYW4uZW5kKTtcbiAgICAgICAgcmV0dXJuIG5ldyBFeHBhbnNpb25DYXNlKHZhbHVlLnBhcnRzWzBdLCBwYXJzZWRFeHAucm9vdE5vZGVzLCBzb3VyY2VTcGFuLCB2YWx1ZS5zb3VyY2VTcGFuLCBleHBTb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RhcnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2NvbGxlY3RFeHBhbnNpb25FeHBUb2tlbnMgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cGFuc2lvbkZvcm1TdGFjayA9IFtUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlRdO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0ZPUk1fU1RBUlQgfHxcbiAgICAgICAgICAgICAgICB0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLkVYUEFOU0lPTl9DQVNFX0VYUF9TVEFSVCkge1xuICAgICAgICAgICAgICAgIGV4cGFuc2lvbkZvcm1TdGFjay5wdXNoKHRoaXMuX3BlZWsudHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9FWFBfRU5EKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RPblN0YWNrKGV4cGFuc2lvbkZvcm1TdGFjaywgVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJUKSkge1xuICAgICAgICAgICAgICAgICAgICBleHBhbnNpb25Gb3JtU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHBhbnNpb25Gb3JtU3RhY2subGVuZ3RoID09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2goVHJlZUVycm9yLmNyZWF0ZShudWxsLCBzdGFydC5zb3VyY2VTcGFuLCBcIkludmFsaWQgSUNVIG1lc3NhZ2UuIE1pc3NpbmcgJ30nLlwiKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLkVYUEFOU0lPTl9GT1JNX0VORCkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0T25TdGFjayhleHBhbnNpb25Gb3JtU3RhY2ssIFRva2VuVHlwZSQxLkVYUEFOU0lPTl9GT1JNX1NUQVJUKSkge1xuICAgICAgICAgICAgICAgICAgICBleHBhbnNpb25Gb3JtU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChUcmVlRXJyb3IuY3JlYXRlKG51bGwsIHN0YXJ0LnNvdXJjZVNwYW4sIFwiSW52YWxpZCBJQ1UgbWVzc2FnZS4gTWlzc2luZyAnfScuXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuRU9GKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2goVHJlZUVycm9yLmNyZWF0ZShudWxsLCBzdGFydC5zb3VyY2VTcGFuLCBcIkludmFsaWQgSUNVIG1lc3NhZ2UuIE1pc3NpbmcgJ30nLlwiKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHAucHVzaCh0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRva2VuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9jb25zdW1lVGV4dCA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZXh0ID0gdG9rZW4ucGFydHNbMF07XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDAgJiYgdGV4dFswXSA9PSAnXFxuJykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyZW50ID0gdGhpcy5fZ2V0UGFyZW50RWxlbWVudCgpO1xuICAgICAgICAgICAgaWYgKHBhcmVudCAhPSBudWxsICYmIHBhcmVudC5jaGlsZHJlbi5sZW5ndGggPT0gMCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0VGFnRGVmaW5pdGlvbihwYXJlbnQubmFtZSkuaWdub3JlRmlyc3RMZikge1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRUb1BhcmVudChuZXcgVGV4dCh0ZXh0LCB0b2tlbi5zb3VyY2VTcGFuKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fY2xvc2VWb2lkRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWwgPSB0aGlzLl9nZXRQYXJlbnRFbGVtZW50KCk7XG4gICAgICAgIGlmIChlbCAmJiB0aGlzLmdldFRhZ0RlZmluaXRpb24oZWwubmFtZSkuaXNWb2lkKSB7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50U3RhY2sucG9wKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RhcnRUYWdUb2tlblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fY29uc3VtZVN0YXJ0VGFnID0gZnVuY3Rpb24gKHN0YXJ0VGFnVG9rZW4pIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlZml4ID0gc3RhcnRUYWdUb2tlbi5wYXJ0c1swXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZSA9IHN0YXJ0VGFnVG9rZW4ucGFydHNbMV07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGF0dHJzID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLkFUVFJfTkFNRSkge1xuICAgICAgICAgICAgYXR0cnMucHVzaCh0aGlzLl9jb25zdW1lQXR0cih0aGlzLl9hZHZhbmNlKCkpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmdWxsTmFtZSA9IHRoaXMuX2dldEVsZW1lbnRGdWxsTmFtZShwcmVmaXgsIG5hbWUsIHRoaXMuX2dldFBhcmVudEVsZW1lbnQoKSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlbGZDbG9zaW5nID0gZmFsc2U7XG4gICAgICAgIC8vIE5vdGU6IFRoZXJlIGNvdWxkIGhhdmUgYmVlbiBhIHRva2VuaXplciBlcnJvclxuICAgICAgICAvLyBzbyB0aGF0IHdlIGRvbid0IGdldCBhIHRva2VuIGZvciB0aGUgZW5kIHRhZy4uLlxuICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5UQUdfT1BFTl9FTkRfVk9JRCkge1xuICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgc2VsZkNsb3NpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGFnRGVmID0gdGhpcy5nZXRUYWdEZWZpbml0aW9uKGZ1bGxOYW1lKTtcbiAgICAgICAgICAgIGlmICghKHRhZ0RlZi5jYW5TZWxmQ2xvc2UgfHwgZ2V0TnNQcmVmaXgoZnVsbE5hbWUpICE9PSBudWxsIHx8IHRhZ0RlZi5pc1ZvaWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2goVHJlZUVycm9yLmNyZWF0ZShmdWxsTmFtZSwgc3RhcnRUYWdUb2tlbi5zb3VyY2VTcGFuLCBcIk9ubHkgdm9pZCBhbmQgZm9yZWlnbiBlbGVtZW50cyBjYW4gYmUgc2VsZiBjbG9zZWQgXFxcIlwiICsgc3RhcnRUYWdUb2tlbi5wYXJ0c1sxXSArIFwiXFxcIlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5UQUdfT1BFTl9FTkQpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgIHNlbGZDbG9zaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW5kID0gdGhpcy5fcGVlay5zb3VyY2VTcGFuLnN0YXJ0O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzcGFuID0gbmV3IFBhcnNlU291cmNlU3BhbihzdGFydFRhZ1Rva2VuLnNvdXJjZVNwYW4uc3RhcnQsIGVuZCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsID0gbmV3IEVsZW1lbnQoZnVsbE5hbWUsIGF0dHJzLCBbXSwgc3Bhbiwgc3BhbiwgdW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5fcHVzaEVsZW1lbnQoZWwpO1xuICAgICAgICBpZiAoc2VsZkNsb3NpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX3BvcEVsZW1lbnQoZnVsbE5hbWUpO1xuICAgICAgICAgICAgZWwuZW5kU291cmNlU3BhbiA9IHNwYW47XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX3B1c2hFbGVtZW50ID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmVudEVsID0gdGhpcy5fZ2V0UGFyZW50RWxlbWVudCgpO1xuICAgICAgICBpZiAocGFyZW50RWwgJiYgdGhpcy5nZXRUYWdEZWZpbml0aW9uKHBhcmVudEVsLm5hbWUpLmlzQ2xvc2VkQnlDaGlsZChlbC5uYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFN0YWNrLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRhZ0RlZiA9IHRoaXMuZ2V0VGFnRGVmaW5pdGlvbihlbC5uYW1lKTtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5fZ2V0UGFyZW50RWxlbWVudFNraXBwaW5nQ29udGFpbmVycygpLCBwYXJlbnQgPSBfYS5wYXJlbnQsIGNvbnRhaW5lciA9IF9hLmNvbnRhaW5lcjtcbiAgICAgICAgaWYgKHBhcmVudCAmJiB0YWdEZWYucmVxdWlyZUV4dHJhUGFyZW50KHBhcmVudC5uYW1lKSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmV3UGFyZW50ID0gbmV3IEVsZW1lbnQodGFnRGVmLnBhcmVudFRvQWRkLCBbXSwgW10sIGVsLnNvdXJjZVNwYW4sIGVsLnN0YXJ0U291cmNlU3BhbiwgZWwuZW5kU291cmNlU3Bhbik7XG4gICAgICAgICAgICB0aGlzLl9pbnNlcnRCZWZvcmVDb250YWluZXIocGFyZW50LCBjb250YWluZXIsIG5ld1BhcmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYWRkVG9QYXJlbnQoZWwpO1xuICAgICAgICB0aGlzLl9lbGVtZW50U3RhY2sucHVzaChlbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVuZFRhZ1Rva2VuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9jb25zdW1lRW5kVGFnID0gZnVuY3Rpb24gKGVuZFRhZ1Rva2VuKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZ1bGxOYW1lID0gdGhpcy5fZ2V0RWxlbWVudEZ1bGxOYW1lKGVuZFRhZ1Rva2VuLnBhcnRzWzBdLCBlbmRUYWdUb2tlbi5wYXJ0c1sxXSwgdGhpcy5fZ2V0UGFyZW50RWxlbWVudCgpKTtcbiAgICAgICAgaWYgKHRoaXMuX2dldFBhcmVudEVsZW1lbnQoKSkge1xuICAgICAgICAgICAgKCh0aGlzLl9nZXRQYXJlbnRFbGVtZW50KCkpKS5lbmRTb3VyY2VTcGFuID0gZW5kVGFnVG9rZW4uc291cmNlU3BhbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5nZXRUYWdEZWZpbml0aW9uKGZ1bGxOYW1lKS5pc1ZvaWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUoZnVsbE5hbWUsIGVuZFRhZ1Rva2VuLnNvdXJjZVNwYW4sIFwiVm9pZCBlbGVtZW50cyBkbyBub3QgaGF2ZSBlbmQgdGFncyBcXFwiXCIgKyBlbmRUYWdUb2tlbi5wYXJ0c1sxXSArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX3BvcEVsZW1lbnQoZnVsbE5hbWUpKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJNc2cgPSBcIlVuZXhwZWN0ZWQgY2xvc2luZyB0YWcgXFxcIlwiICsgZnVsbE5hbWUgKyBcIlxcXCIuIEl0IG1heSBoYXBwZW4gd2hlbiB0aGUgdGFnIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkIGJ5IGFub3RoZXIgdGFnLiBGb3IgbW9yZSBpbmZvIHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjY2xvc2luZy1lbGVtZW50cy10aGF0LWhhdmUtaW1wbGllZC1lbmQtdGFnc1wiO1xuICAgICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2goVHJlZUVycm9yLmNyZWF0ZShmdWxsTmFtZSwgZW5kVGFnVG9rZW4uc291cmNlU3BhbiwgZXJyTXNnKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZnVsbE5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX3BvcEVsZW1lbnQgPSBmdW5jdGlvbiAoZnVsbE5hbWUpIHtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFja0luZGV4ID0gdGhpcy5fZWxlbWVudFN0YWNrLmxlbmd0aCAtIDE7IHN0YWNrSW5kZXggPj0gMDsgc3RhY2tJbmRleC0tKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbCA9IHRoaXMuX2VsZW1lbnRTdGFja1tzdGFja0luZGV4XTtcbiAgICAgICAgICAgIGlmIChlbC5uYW1lID09IGZ1bGxOYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZWxlbWVudFN0YWNrLnNwbGljZShzdGFja0luZGV4LCB0aGlzLl9lbGVtZW50U3RhY2subGVuZ3RoIC0gc3RhY2tJbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0VGFnRGVmaW5pdGlvbihlbC5uYW1lKS5jbG9zZWRCeVBhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGF0dHJOYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9jb25zdW1lQXR0ciA9IGZ1bmN0aW9uIChhdHRyTmFtZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmdWxsTmFtZSA9IG1lcmdlTnNBbmROYW1lKGF0dHJOYW1lLnBhcnRzWzBdLCBhdHRyTmFtZS5wYXJ0c1sxXSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVuZCA9IGF0dHJOYW1lLnNvdXJjZVNwYW4uZW5kO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9ICcnO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZVNwYW4gPSAoKHVuZGVmaW5lZCkpO1xuICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5BVFRSX1ZBTFVFKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZVRva2VuID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVRva2VuLnBhcnRzWzBdO1xuICAgICAgICAgICAgZW5kID0gdmFsdWVUb2tlbi5zb3VyY2VTcGFuLmVuZDtcbiAgICAgICAgICAgIHZhbHVlU3BhbiA9IHZhbHVlVG9rZW4uc291cmNlU3BhbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEF0dHJpYnV0ZSQxKGZ1bGxOYW1lLCB2YWx1ZSwgbmV3IFBhcnNlU291cmNlU3BhbihhdHRyTmFtZS5zb3VyY2VTcGFuLnN0YXJ0LCBlbmQpLCB2YWx1ZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9nZXRQYXJlbnRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudFN0YWNrLmxlbmd0aCA+IDAgPyB0aGlzLl9lbGVtZW50U3RhY2tbdGhpcy5fZWxlbWVudFN0YWNrLmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBhcmVudCBpbiB0aGUgRE9NIGFuZCB0aGUgY29udGFpbmVyLlxuICAgICAqXG4gICAgICogYDxuZy1jb250YWluZXI+YCBlbGVtZW50cyBhcmUgc2tpcHBlZCBhcyB0aGV5IGFyZSBub3QgcmVuZGVyZWQgYXMgRE9NIGVsZW1lbnQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9nZXRQYXJlbnRFbGVtZW50U2tpcHBpbmdDb250YWluZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250YWluZXIgPSBudWxsO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSB0aGlzLl9lbGVtZW50U3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmICghaXNOZ0NvbnRhaW5lcih0aGlzLl9lbGVtZW50U3RhY2tbaV0ubmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBwYXJlbnQ6IHRoaXMuX2VsZW1lbnRTdGFja1tpXSwgY29udGFpbmVyOiBjb250YWluZXIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHRoaXMuX2VsZW1lbnRTdGFja1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBwYXJlbnQ6IG51bGwsIGNvbnRhaW5lcjogY29udGFpbmVyIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2FkZFRvUGFyZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyZW50ID0gdGhpcy5fZ2V0UGFyZW50RWxlbWVudCgpO1xuICAgICAgICBpZiAocGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcm9vdE5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluc2VydCBhIG5vZGUgYmV0d2VlbiB0aGUgcGFyZW50IGFuZCB0aGUgY29udGFpbmVyLlxuICAgICAqIFdoZW4gbm8gY29udGFpbmVyIGlzIGdpdmVuLCB0aGUgbm9kZSBpcyBhcHBlbmRlZCBhcyBhIGNoaWxkIG9mIHRoZSBwYXJlbnQuXG4gICAgICogQWxzbyB1cGRhdGVzIHRoZSBlbGVtZW50IHN0YWNrIGFjY29yZGluZ2x5LlxuICAgICAqXG4gICAgICogXFxAaW50ZXJuYWxcbiAgICAgKiBAcGFyYW0gez99IHBhcmVudFxuICAgICAqIEBwYXJhbSB7P30gY29udGFpbmVyXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9pbnNlcnRCZWZvcmVDb250YWluZXIgPSBmdW5jdGlvbiAocGFyZW50LCBjb250YWluZXIsIG5vZGUpIHtcbiAgICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZFRvUGFyZW50KG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFN0YWNrLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjZSB0aGUgY29udGFpbmVyIHdpdGggdGhlIG5ldyBub2RlIGluIHRoZSBjaGlsZHJlblxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluZGV4ID0gcGFyZW50LmNoaWxkcmVuLmluZGV4T2YoY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW5baW5kZXhdID0gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jvb3ROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKGNvbnRhaW5lcik7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50U3RhY2suc3BsaWNlKHRoaXMuX2VsZW1lbnRTdGFjay5pbmRleE9mKGNvbnRhaW5lciksIDAsIG5vZGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHByZWZpeFxuICAgICAqIEBwYXJhbSB7P30gbG9jYWxOYW1lXG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRFbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9nZXRFbGVtZW50RnVsbE5hbWUgPSBmdW5jdGlvbiAocHJlZml4LCBsb2NhbE5hbWUsIHBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgaWYgKHByZWZpeCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwcmVmaXggPSAoKHRoaXMuZ2V0VGFnRGVmaW5pdGlvbihsb2NhbE5hbWUpLmltcGxpY2l0TmFtZXNwYWNlUHJlZml4KSk7XG4gICAgICAgICAgICBpZiAocHJlZml4ID09IG51bGwgJiYgcGFyZW50RWxlbWVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gZ2V0TnNQcmVmaXgocGFyZW50RWxlbWVudC5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVyZ2VOc0FuZE5hbWUocHJlZml4LCBsb2NhbE5hbWUpO1xuICAgIH07XG4gICAgcmV0dXJuIF9UcmVlQnVpbGRlcjtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gc3RhY2tcbiAqIEBwYXJhbSB7P30gZWxlbWVudFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gbGFzdE9uU3RhY2soc3RhY2ssIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gc3RhY2subGVuZ3RoID4gMCAmJiBzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gZWxlbWVudDtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBkaWdlc3QobWVzc2FnZSkge1xuICAgIHJldHVybiBtZXNzYWdlLmlkIHx8IHNoYTEoc2VyaWFsaXplTm9kZXMobWVzc2FnZS5ub2Rlcykuam9pbignJykgKyAoXCJbXCIgKyBtZXNzYWdlLm1lYW5pbmcgKyBcIl1cIikpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGRlY2ltYWxEaWdlc3QobWVzc2FnZSkge1xuICAgIGlmIChtZXNzYWdlLmlkKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlLmlkO1xuICAgIH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aXNpdG9yID0gbmV3IF9TZXJpYWxpemVySWdub3JlSWN1RXhwVmlzaXRvcigpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnRzID0gbWVzc2FnZS5ub2Rlcy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEudmlzaXQodmlzaXRvciwgbnVsbCk7IH0pO1xuICAgIHJldHVybiBjb21wdXRlTXNnSWQocGFydHMuam9pbignJyksIG1lc3NhZ2UubWVhbmluZyk7XG59XG4vKipcbiAqIFNlcmlhbGl6ZSB0aGUgaTE4biBhc3QgdG8gc29tZXRoaW5nIHhtbC1saWtlIGluIG9yZGVyIHRvIGdlbmVyYXRlIGFuIFVJRC5cbiAqXG4gKiBUaGUgdmlzaXRvciBpcyBhbHNvIHVzZWQgaW4gdGhlIGkxOG4gcGFyc2VyIHRlc3RzXG4gKlxuICogXFxAaW50ZXJuYWxcbiAqL1xudmFyIF9TZXJpYWxpemVyVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gX1NlcmlhbGl6ZXJWaXNpdG9yKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRleHRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9TZXJpYWxpemVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHsgcmV0dXJuIHRleHQudmFsdWU7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb250YWluZXJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9TZXJpYWxpemVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb250YWluZXIgPSBmdW5jdGlvbiAoY29udGFpbmVyLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBcIltcIiArIGNvbnRhaW5lci5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZC52aXNpdChfdGhpcyk7IH0pLmpvaW4oJywgJykgKyBcIl1cIjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWN1XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfU2VyaWFsaXplclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWN1ID0gZnVuY3Rpb24gKGljdSwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHJDYXNlcyA9IE9iamVjdC5rZXlzKGljdS5jYXNlcykubWFwKGZ1bmN0aW9uIChrKSB7IHJldHVybiBrICsgXCIge1wiICsgaWN1LmNhc2VzW2tdLnZpc2l0KF90aGlzKSArIFwifVwiOyB9KTtcbiAgICAgICAgcmV0dXJuIFwie1wiICsgaWN1LmV4cHJlc3Npb24gKyBcIiwgXCIgKyBpY3UudHlwZSArIFwiLCBcIiArIHN0ckNhc2VzLmpvaW4oJywgJykgKyBcIn1cIjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGhcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9TZXJpYWxpemVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUYWdQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gcGguaXNWb2lkID9cbiAgICAgICAgICAgIFwiPHBoIHRhZyBuYW1lPVxcXCJcIiArIHBoLnN0YXJ0TmFtZSArIFwiXFxcIi8+XCIgOlxuICAgICAgICAgICAgXCI8cGggdGFnIG5hbWU9XFxcIlwiICsgcGguc3RhcnROYW1lICsgXCJcXFwiPlwiICsgcGguY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gY2hpbGQudmlzaXQoX3RoaXMpOyB9KS5qb2luKCcsICcpICsgXCI8L3BoIG5hbWU9XFxcIlwiICsgcGguY2xvc2VOYW1lICsgXCJcXFwiPlwiO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1NlcmlhbGl6ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBwaC52YWx1ZSA/IFwiPHBoIG5hbWU9XFxcIlwiICsgcGgubmFtZSArIFwiXFxcIj5cIiArIHBoLnZhbHVlICsgXCI8L3BoPlwiIDogXCI8cGggbmFtZT1cXFwiXCIgKyBwaC5uYW1lICsgXCJcXFwiLz5cIjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGhcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfU2VyaWFsaXplclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWN1UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIFwiPHBoIGljdSBuYW1lPVxcXCJcIiArIHBoLm5hbWUgKyBcIlxcXCI+XCIgKyBwaC52YWx1ZS52aXNpdCh0aGlzKSArIFwiPC9waD5cIjtcbiAgICB9O1xuICAgIHJldHVybiBfU2VyaWFsaXplclZpc2l0b3I7XG59KCkpO1xudmFyIHNlcmlhbGl6ZXJWaXNpdG9yID0gbmV3IF9TZXJpYWxpemVyVmlzaXRvcigpO1xuLyoqXG4gKiBAcGFyYW0gez99IG5vZGVzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzZXJpYWxpemVOb2Rlcyhub2Rlcykge1xuICAgIHJldHVybiBub2Rlcy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEudmlzaXQoc2VyaWFsaXplclZpc2l0b3IsIG51bGwpOyB9KTtcbn1cbi8qKlxuICogU2VyaWFsaXplIHRoZSBpMThuIGFzdCB0byBzb21ldGhpbmcgeG1sLWxpa2UgaW4gb3JkZXIgdG8gZ2VuZXJhdGUgYW4gVUlELlxuICpcbiAqIElnbm9yZSB0aGUgSUNVIGV4cHJlc3Npb25zIHNvIHRoYXQgbWVzc2FnZSBJRHMgc3RheXMgaWRlbnRpY2FsIGlmIG9ubHkgdGhlIGV4cHJlc3Npb24gY2hhbmdlcy5cbiAqXG4gKiBcXEBpbnRlcm5hbFxuICovXG52YXIgX1NlcmlhbGl6ZXJJZ25vcmVJY3VFeHBWaXNpdG9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhfU2VyaWFsaXplcklnbm9yZUljdUV4cFZpc2l0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gX1NlcmlhbGl6ZXJJZ25vcmVJY3VFeHBWaXNpdG9yKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWN1XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfU2VyaWFsaXplcklnbm9yZUljdUV4cFZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWN1ID0gZnVuY3Rpb24gKGljdSwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHJDYXNlcyA9IE9iamVjdC5rZXlzKGljdS5jYXNlcykubWFwKGZ1bmN0aW9uIChrKSB7IHJldHVybiBrICsgXCIge1wiICsgaWN1LmNhc2VzW2tdLnZpc2l0KF90aGlzKSArIFwifVwiOyB9KTtcbiAgICAgICAgLy8gRG8gbm90IHRha2UgdGhlIGV4cHJlc3Npb24gaW50byBhY2NvdW50XG4gICAgICAgIHJldHVybiBcIntcIiArIGljdS50eXBlICsgXCIsIFwiICsgc3RyQ2FzZXMuam9pbignLCAnKSArIFwifVwiO1xuICAgIH07XG4gICAgcmV0dXJuIF9TZXJpYWxpemVySWdub3JlSWN1RXhwVmlzaXRvcjtcbn0oX1NlcmlhbGl6ZXJWaXNpdG9yKSk7XG4vKipcbiAqIENvbXB1dGUgdGhlIFNIQTEgb2YgdGhlIGdpdmVuIHN0cmluZ1xuICpcbiAqIHNlZSBodHRwOi8vY3NyYy5uaXN0Lmdvdi9wdWJsaWNhdGlvbnMvZmlwcy9maXBzMTgwLTQvZmlwcy0xODAtNC5wZGZcbiAqXG4gKiBXQVJOSU5HOiB0aGlzIGZ1bmN0aW9uIGhhcyBub3QgYmVlbiBkZXNpZ25lZCBub3QgdGVzdGVkIHdpdGggc2VjdXJpdHkgaW4gbWluZC5cbiAqICAgICAgICAgIERPIE5PVCBVU0UgSVQgSU4gQSBTRUNVUklUWSBTRU5TSVRJVkUgQ09OVEVYVC5cbiAqIEBwYXJhbSB7P30gc3RyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzaGExKHN0cikge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHV0ZjggPSB1dGY4RW5jb2RlKHN0cik7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gd29yZHMzMiA9IHN0cmluZ1RvV29yZHMzMih1dGY4LCBFbmRpYW4uQmlnKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsZW4gPSB1dGY4Lmxlbmd0aCAqIDg7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdyA9IG5ldyBBcnJheSg4MCk7XG4gICAgdmFyIF9hID0gWzB4Njc0NTIzMDEsIDB4ZWZjZGFiODksIDB4OThiYWRjZmUsIDB4MTAzMjU0NzYsIDB4YzNkMmUxZjBdLCBhID0gX2FbMF0sIGIgPSBfYVsxXSwgYyA9IF9hWzJdLCBkID0gX2FbM10sIGUgPSBfYVs0XTtcbiAgICB3b3JkczMyW2xlbiA+PiA1XSB8PSAweDgwIDw8ICgyNCAtIGxlbiAlIDMyKTtcbiAgICB3b3JkczMyWygobGVuICsgNjQgPj4gOSkgPDwgNCkgKyAxNV0gPSBsZW47XG4gICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHdvcmRzMzIubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgICAgIHZhciBfYiA9IFthLCBiLCBjLCBkLCBlXSwgaDAgPSBfYlswXSwgaDEgPSBfYlsxXSwgaDIgPSBfYlsyXSwgaDMgPSBfYlszXSwgaDQgPSBfYls0XTtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBqID0gMDsgaiA8IDgwOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChqIDwgMTYpIHtcbiAgICAgICAgICAgICAgICB3W2pdID0gd29yZHMzMltpICsgal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3W2pdID0gcm9sMzIod1tqIC0gM10gXiB3W2ogLSA4XSBeIHdbaiAtIDE0XSBeIHdbaiAtIDE2XSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2MgPSBmayhqLCBiLCBjLCBkKSwgZiA9IF9jWzBdLCBrID0gX2NbMV07XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wID0gW3JvbDMyKGEsIDUpLCBmLCBlLCBrLCB3W2pdXS5yZWR1Y2UoYWRkMzIpO1xuICAgICAgICAgICAgX2QgPSBbZCwgYywgcm9sMzIoYiwgMzApLCBhLCB0ZW1wXSwgZSA9IF9kWzBdLCBkID0gX2RbMV0sIGMgPSBfZFsyXSwgYiA9IF9kWzNdLCBhID0gX2RbNF07XG4gICAgICAgIH1cbiAgICAgICAgX2UgPSBbYWRkMzIoYSwgaDApLCBhZGQzMihiLCBoMSksIGFkZDMyKGMsIGgyKSwgYWRkMzIoZCwgaDMpLCBhZGQzMihlLCBoNCldLCBhID0gX2VbMF0sIGIgPSBfZVsxXSwgYyA9IF9lWzJdLCBkID0gX2VbM10sIGUgPSBfZVs0XTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVTdHJpbmdUb0hleFN0cmluZyh3b3JkczMyVG9CeXRlU3RyaW5nKFthLCBiLCBjLCBkLCBlXSkpO1xuICAgIHZhciBfZCwgX2U7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gaW5kZXhcbiAqIEBwYXJhbSB7P30gYlxuICogQHBhcmFtIHs/fSBjXG4gKiBAcGFyYW0gez99IGRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGZrKGluZGV4LCBiLCBjLCBkKSB7XG4gICAgaWYgKGluZGV4IDwgMjApIHtcbiAgICAgICAgcmV0dXJuIFsoYiAmIGMpIHwgKH5iICYgZCksIDB4NWE4Mjc5OTldO1xuICAgIH1cbiAgICBpZiAoaW5kZXggPCA0MCkge1xuICAgICAgICByZXR1cm4gW2IgXiBjIF4gZCwgMHg2ZWQ5ZWJhMV07XG4gICAgfVxuICAgIGlmIChpbmRleCA8IDYwKSB7XG4gICAgICAgIHJldHVybiBbKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpLCAweDhmMWJiY2RjXTtcbiAgICB9XG4gICAgcmV0dXJuIFtiIF4gYyBeIGQsIDB4Y2E2MmMxZDZdO1xufVxuLyoqXG4gKiBDb21wdXRlIHRoZSBmaW5nZXJwcmludCBvZiB0aGUgZ2l2ZW4gc3RyaW5nXG4gKlxuICogVGhlIG91dHB1dCBpcyA2NCBiaXQgbnVtYmVyIGVuY29kZWQgYXMgYSBkZWNpbWFsIHN0cmluZ1xuICpcbiAqIGJhc2VkIG9uOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWNvbXBpbGVyL2Jsb2IvbWFzdGVyL3NyYy9jb20vZ29vZ2xlL2phdmFzY3JpcHQvanNjb21wL0dvb2dsZUpzTWVzc2FnZUlkR2VuZXJhdG9yLmphdmFcbiAqIEBwYXJhbSB7P30gc3RyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBmaW5nZXJwcmludChzdHIpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1dGY4ID0gdXRmOEVuY29kZShzdHIpO1xuICAgIHZhciBfYSA9IFtoYXNoMzIodXRmOCwgMCksIGhhc2gzMih1dGY4LCAxMDIwNzIpXSwgaGkgPSBfYVswXSwgbG8gPSBfYVsxXTtcbiAgICBpZiAoaGkgPT0gMCAmJiAobG8gPT0gMCB8fCBsbyA9PSAxKSkge1xuICAgICAgICBoaSA9IGhpIF4gMHgxMzBmOWJlZjtcbiAgICAgICAgbG8gPSBsbyBeIC0weDZiNWY1NmQ4O1xuICAgIH1cbiAgICByZXR1cm4gW2hpLCBsb107XG59XG4vKipcbiAqIEBwYXJhbSB7P30gbXNnXG4gKiBAcGFyYW0gez99IG1lYW5pbmdcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVNc2dJZChtc2csIG1lYW5pbmcpIHtcbiAgICB2YXIgX2EgPSBmaW5nZXJwcmludChtc2cpLCBoaSA9IF9hWzBdLCBsbyA9IF9hWzFdO1xuICAgIGlmIChtZWFuaW5nKSB7XG4gICAgICAgIHZhciBfYiA9IGZpbmdlcnByaW50KG1lYW5pbmcpLCBoaW0gPSBfYlswXSwgbG9tID0gX2JbMV07XG4gICAgICAgIF9jID0gYWRkNjQocm9sNjQoW2hpLCBsb10sIDEpLCBbaGltLCBsb21dKSwgaGkgPSBfY1swXSwgbG8gPSBfY1sxXTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVTdHJpbmdUb0RlY1N0cmluZyh3b3JkczMyVG9CeXRlU3RyaW5nKFtoaSAmIDB4N2ZmZmZmZmYsIGxvXSkpO1xuICAgIHZhciBfYztcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBzdHJcbiAqIEBwYXJhbSB7P30gY1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaGFzaDMyKHN0ciwgYykge1xuICAgIHZhciBfYSA9IFsweDllMzc3OWI5LCAweDllMzc3OWI5XSwgYSA9IF9hWzBdLCBiID0gX2FbMV07XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsZW4gPSBzdHIubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgKyAxMiA8PSBsZW47IGkgKz0gMTIpIHtcbiAgICAgICAgYSA9IGFkZDMyKGEsIHdvcmRBdChzdHIsIGksIEVuZGlhbi5MaXR0bGUpKTtcbiAgICAgICAgYiA9IGFkZDMyKGIsIHdvcmRBdChzdHIsIGkgKyA0LCBFbmRpYW4uTGl0dGxlKSk7XG4gICAgICAgIGMgPSBhZGQzMihjLCB3b3JkQXQoc3RyLCBpICsgOCwgRW5kaWFuLkxpdHRsZSkpO1xuICAgICAgICBfYiA9IG1peChbYSwgYiwgY10pLCBhID0gX2JbMF0sIGIgPSBfYlsxXSwgYyA9IF9iWzJdO1xuICAgIH1cbiAgICBhID0gYWRkMzIoYSwgd29yZEF0KHN0ciwgaSwgRW5kaWFuLkxpdHRsZSkpO1xuICAgIGIgPSBhZGQzMihiLCB3b3JkQXQoc3RyLCBpICsgNCwgRW5kaWFuLkxpdHRsZSkpO1xuICAgIC8vIHRoZSBmaXJzdCBieXRlIG9mIGMgaXMgcmVzZXJ2ZWQgZm9yIHRoZSBsZW5ndGhcbiAgICBjID0gYWRkMzIoYywgbGVuKTtcbiAgICBjID0gYWRkMzIoYywgd29yZEF0KHN0ciwgaSArIDgsIEVuZGlhbi5MaXR0bGUpIDw8IDgpO1xuICAgIHJldHVybiBtaXgoW2EsIGIsIGNdKVsyXTtcbiAgICB2YXIgX2I7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gX18wXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBtaXgoX2EpIHtcbiAgICB2YXIgYSA9IF9hWzBdLCBiID0gX2FbMV0sIGMgPSBfYVsyXTtcbiAgICBhID0gc3ViMzIoYSwgYik7XG4gICAgYSA9IHN1YjMyKGEsIGMpO1xuICAgIGEgXj0gYyA+Pj4gMTM7XG4gICAgYiA9IHN1YjMyKGIsIGMpO1xuICAgIGIgPSBzdWIzMihiLCBhKTtcbiAgICBiIF49IGEgPDwgODtcbiAgICBjID0gc3ViMzIoYywgYSk7XG4gICAgYyA9IHN1YjMyKGMsIGIpO1xuICAgIGMgXj0gYiA+Pj4gMTM7XG4gICAgYSA9IHN1YjMyKGEsIGIpO1xuICAgIGEgPSBzdWIzMihhLCBjKTtcbiAgICBhIF49IGMgPj4+IDEyO1xuICAgIGIgPSBzdWIzMihiLCBjKTtcbiAgICBiID0gc3ViMzIoYiwgYSk7XG4gICAgYiBePSBhIDw8IDE2O1xuICAgIGMgPSBzdWIzMihjLCBhKTtcbiAgICBjID0gc3ViMzIoYywgYik7XG4gICAgYyBePSBiID4+PiA1O1xuICAgIGEgPSBzdWIzMihhLCBiKTtcbiAgICBhID0gc3ViMzIoYSwgYyk7XG4gICAgYSBePSBjID4+PiAzO1xuICAgIGIgPSBzdWIzMihiLCBjKTtcbiAgICBiID0gc3ViMzIoYiwgYSk7XG4gICAgYiBePSBhIDw8IDEwO1xuICAgIGMgPSBzdWIzMihjLCBhKTtcbiAgICBjID0gc3ViMzIoYywgYik7XG4gICAgYyBePSBiID4+PiAxNTtcbiAgICByZXR1cm4gW2EsIGIsIGNdO1xufVxudmFyIEVuZGlhbiA9IHt9O1xuRW5kaWFuLkxpdHRsZSA9IDA7XG5FbmRpYW4uQmlnID0gMTtcbkVuZGlhbltFbmRpYW4uTGl0dGxlXSA9IFwiTGl0dGxlXCI7XG5FbmRpYW5bRW5kaWFuLkJpZ10gPSBcIkJpZ1wiO1xuLyoqXG4gKiBAcGFyYW0gez99IGFcbiAqIEBwYXJhbSB7P30gYlxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gYWRkMzIoYSwgYikge1xuICAgIHJldHVybiBhZGQzMnRvNjQoYSwgYilbMV07XG59XG4vKipcbiAqIEBwYXJhbSB7P30gYVxuICogQHBhcmFtIHs/fSBiXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBhZGQzMnRvNjQoYSwgYikge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGxvdyA9IChhICYgMHhmZmZmKSArIChiICYgMHhmZmZmKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoaWdoID0gKGEgPj4+IDE2KSArIChiID4+PiAxNikgKyAobG93ID4+PiAxNik7XG4gICAgcmV0dXJuIFtoaWdoID4+PiAxNiwgKGhpZ2ggPDwgMTYpIHwgKGxvdyAmIDB4ZmZmZildO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IF9fMFxuICogQHBhcmFtIHs/fSBfXzFcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGFkZDY0KF9hLCBfYikge1xuICAgIHZhciBhaCA9IF9hWzBdLCBhbCA9IF9hWzFdO1xuICAgIHZhciBiaCA9IF9iWzBdLCBibCA9IF9iWzFdO1xuICAgIHZhciBfYyA9IGFkZDMydG82NChhbCwgYmwpLCBjYXJyeSA9IF9jWzBdLCBsID0gX2NbMV07XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaCA9IGFkZDMyKGFkZDMyKGFoLCBiaCksIGNhcnJ5KTtcbiAgICByZXR1cm4gW2gsIGxdO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGFcbiAqIEBwYXJhbSB7P30gYlxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc3ViMzIoYSwgYikge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGxvdyA9IChhICYgMHhmZmZmKSAtIChiICYgMHhmZmZmKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoaWdoID0gKGEgPj4gMTYpIC0gKGIgPj4gMTYpICsgKGxvdyA+PiAxNik7XG4gICAgcmV0dXJuIChoaWdoIDw8IDE2KSB8IChsb3cgJiAweGZmZmYpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGFcbiAqIEBwYXJhbSB7P30gY291bnRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHJvbDMyKGEsIGNvdW50KSB7XG4gICAgcmV0dXJuIChhIDw8IGNvdW50KSB8IChhID4+PiAoMzIgLSBjb3VudCkpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IF9fMFxuICogQHBhcmFtIHs/fSBjb3VudFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gcm9sNjQoX2EsIGNvdW50KSB7XG4gICAgdmFyIGhpID0gX2FbMF0sIGxvID0gX2FbMV07XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaCA9IChoaSA8PCBjb3VudCkgfCAobG8gPj4+ICgzMiAtIGNvdW50KSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbCA9IChsbyA8PCBjb3VudCkgfCAoaGkgPj4+ICgzMiAtIGNvdW50KSk7XG4gICAgcmV0dXJuIFtoLCBsXTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBzdHJcbiAqIEBwYXJhbSB7P30gZW5kaWFuXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzdHJpbmdUb1dvcmRzMzIoc3RyLCBlbmRpYW4pIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB3b3JkczMyID0gQXJyYXkoKHN0ci5sZW5ndGggKyAzKSA+Pj4gMik7XG4gICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHdvcmRzMzIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd29yZHMzMltpXSA9IHdvcmRBdChzdHIsIGkgKiA0LCBlbmRpYW4pO1xuICAgIH1cbiAgICByZXR1cm4gd29yZHMzMjtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBzdHJcbiAqIEBwYXJhbSB7P30gaW5kZXhcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGJ5dGVBdChzdHIsIGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4ID49IHN0ci5sZW5ndGggPyAwIDogc3RyLmNoYXJDb2RlQXQoaW5kZXgpICYgMHhmZjtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBzdHJcbiAqIEBwYXJhbSB7P30gaW5kZXhcbiAqIEBwYXJhbSB7P30gZW5kaWFuXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB3b3JkQXQoc3RyLCBpbmRleCwgZW5kaWFuKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gd29yZCA9IDA7XG4gICAgaWYgKGVuZGlhbiA9PT0gRW5kaWFuLkJpZykge1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICB3b3JkICs9IGJ5dGVBdChzdHIsIGluZGV4ICsgaSkgPDwgKDI0IC0gOCAqIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICB3b3JkICs9IGJ5dGVBdChzdHIsIGluZGV4ICsgaSkgPDwgOCAqIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHdvcmQ7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gd29yZHMzMlxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gd29yZHMzMlRvQnl0ZVN0cmluZyh3b3JkczMyKSB7XG4gICAgcmV0dXJuIHdvcmRzMzIucmVkdWNlKGZ1bmN0aW9uIChzdHIsIHdvcmQpIHsgcmV0dXJuIHN0ciArIHdvcmQzMlRvQnl0ZVN0cmluZyh3b3JkKTsgfSwgJycpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHdvcmRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHdvcmQzMlRvQnl0ZVN0cmluZyh3b3JkKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RyID0gJyc7XG4gICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgod29yZCA+Pj4gOCAqICgzIC0gaSkpICYgMHhmZik7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gc3RyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBieXRlU3RyaW5nVG9IZXhTdHJpbmcoc3RyKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaGV4ID0gJyc7XG4gICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiID0gYnl0ZUF0KHN0ciwgaSk7XG4gICAgICAgIGhleCArPSAoYiA+Pj4gNCkudG9TdHJpbmcoMTYpICsgKGIgJiAweDBmKS50b1N0cmluZygxNik7XG4gICAgfVxuICAgIHJldHVybiBoZXgudG9Mb3dlckNhc2UoKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBzdHJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGJ5dGVTdHJpbmdUb0RlY1N0cmluZyhzdHIpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZWNpbWFsID0gJyc7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9UaGVQb3dlciA9ICcxJztcbiAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSBzdHIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgZGVjaW1hbCA9IGFkZEJpZ0ludChkZWNpbWFsLCBudW1iZXJUaW1lc0JpZ0ludChieXRlQXQoc3RyLCBpKSwgdG9UaGVQb3dlcikpO1xuICAgICAgICB0b1RoZVBvd2VyID0gbnVtYmVyVGltZXNCaWdJbnQoMjU2LCB0b1RoZVBvd2VyKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY2ltYWwuc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSB4XG4gKiBAcGFyYW0gez99IHlcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGFkZEJpZ0ludCh4LCB5KSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3VtID0gJyc7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGVuID0gTWF0aC5tYXgoeC5sZW5ndGgsIHkubGVuZ3RoKTtcbiAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwLCAvKiogQHR5cGUgez99ICovIGNhcnJ5ID0gMDsgaSA8IGxlbiB8fCBjYXJyeTsgaSsrKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRtcFN1bSA9IGNhcnJ5ICsgKyh4W2ldIHx8IDApICsgKyh5W2ldIHx8IDApO1xuICAgICAgICBpZiAodG1wU3VtID49IDEwKSB7XG4gICAgICAgICAgICBjYXJyeSA9IDE7XG4gICAgICAgICAgICBzdW0gKz0gdG1wU3VtIC0gMTA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYXJyeSA9IDA7XG4gICAgICAgICAgICBzdW0gKz0gdG1wU3VtO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59XG4vKipcbiAqIEBwYXJhbSB7P30gbnVtXG4gKiBAcGFyYW0gez99IGJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG51bWJlclRpbWVzQmlnSW50KG51bSwgYikge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb2R1Y3QgPSAnJztcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiVG9UaGVQb3dlciA9IGI7XG4gICAgZm9yICg7IG51bSAhPT0gMDsgbnVtID0gbnVtID4+PiAxKSB7XG4gICAgICAgIGlmIChudW0gJiAxKVxuICAgICAgICAgICAgcHJvZHVjdCA9IGFkZEJpZ0ludChwcm9kdWN0LCBiVG9UaGVQb3dlcik7XG4gICAgICAgIGJUb1RoZVBvd2VyID0gYWRkQmlnSW50KGJUb1RoZVBvd2VyLCBiVG9UaGVQb3dlcik7XG4gICAgfVxuICAgIHJldHVybiBwcm9kdWN0O1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIE1lc3NhZ2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZXMgbWVzc2FnZSBBU1RcbiAgICAgKiBAcGFyYW0gez99IHBsYWNlaG9sZGVycyBtYXBzIHBsYWNlaG9sZGVyIG5hbWVzIHRvIHN0YXRpYyBjb250ZW50XG4gICAgICogQHBhcmFtIHs/fSBwbGFjZWhvbGRlclRvTWVzc2FnZSBtYXBzIHBsYWNlaG9sZGVyIG5hbWVzIHRvIG1lc3NhZ2VzICh1c2VkIGZvciBuZXN0ZWQgSUNVIG1lc3NhZ2VzKVxuICAgICAqIEBwYXJhbSB7P30gbWVhbmluZ1xuICAgICAqIEBwYXJhbSB7P30gZGVzY3JpcHRpb25cbiAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWVzc2FnZShub2RlcywgcGxhY2Vob2xkZXJzLCBwbGFjZWhvbGRlclRvTWVzc2FnZSwgbWVhbmluZywgZGVzY3JpcHRpb24sIGlkKSB7XG4gICAgICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlcnMgPSBwbGFjZWhvbGRlcnM7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXJUb01lc3NhZ2UgPSBwbGFjZWhvbGRlclRvTWVzc2FnZTtcbiAgICAgICAgdGhpcy5tZWFuaW5nID0gbWVhbmluZztcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlcyA9IFt7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVQYXRoOiBub2Rlc1swXS5zb3VyY2VTcGFuLnN0YXJ0LmZpbGUudXJsLFxuICAgICAgICAgICAgICAgICAgICBzdGFydExpbmU6IG5vZGVzWzBdLnNvdXJjZVNwYW4uc3RhcnQubGluZSArIDEsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0Q29sOiBub2Rlc1swXS5zb3VyY2VTcGFuLnN0YXJ0LmNvbCArIDEsXG4gICAgICAgICAgICAgICAgICAgIGVuZExpbmU6IG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdLnNvdXJjZVNwYW4uZW5kLmxpbmUgKyAxLFxuICAgICAgICAgICAgICAgICAgICBlbmRDb2w6IG5vZGVzWzBdLnNvdXJjZVNwYW4uc3RhcnQuY29sICsgMVxuICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VzID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE1lc3NhZ2U7XG59KCkpO1xudmFyIFRleHQkMSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRleHQkMSh2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRleHQkMS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFRleHQodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIFRleHQkMTtcbn0oKSk7XG52YXIgQ29udGFpbmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNoaWxkcmVuXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29udGFpbmVyKGNoaWxkcmVuLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0Q29udGFpbmVyKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBDb250YWluZXI7XG59KCkpO1xudmFyIEljdSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHBhcmFtIHs/fSBjYXNlc1xuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEljdShleHByZXNzaW9uLCB0eXBlLCBjYXNlcywgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmNhc2VzID0gY2FzZXM7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEljdS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdEljdSh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gSWN1O1xufSgpKTtcbnZhciBUYWdQbGFjZWhvbGRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0YWdcbiAgICAgKiBAcGFyYW0gez99IGF0dHJzXG4gICAgICogQHBhcmFtIHs/fSBzdGFydE5hbWVcbiAgICAgKiBAcGFyYW0gez99IGNsb3NlTmFtZVxuICAgICAqIEBwYXJhbSB7P30gY2hpbGRyZW5cbiAgICAgKiBAcGFyYW0gez99IGlzVm9pZFxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRhZ1BsYWNlaG9sZGVyKHRhZywgYXR0cnMsIHN0YXJ0TmFtZSwgY2xvc2VOYW1lLCBjaGlsZHJlbiwgaXNWb2lkLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMuc3RhcnROYW1lID0gc3RhcnROYW1lO1xuICAgICAgICB0aGlzLmNsb3NlTmFtZSA9IGNsb3NlTmFtZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLmlzVm9pZCA9IGlzVm9pZDtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGFnUGxhY2Vob2xkZXIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRUYWdQbGFjZWhvbGRlcih0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gVGFnUGxhY2Vob2xkZXI7XG59KCkpO1xudmFyIFBsYWNlaG9sZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGxhY2Vob2xkZXIodmFsdWUsIG5hbWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQbGFjZWhvbGRlci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFBsYWNlaG9sZGVyKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBQbGFjZWhvbGRlcjtcbn0oKSk7XG52YXIgSWN1UGxhY2Vob2xkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJY3VQbGFjZWhvbGRlcih2YWx1ZSwgbmFtZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEljdVBsYWNlaG9sZGVyLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0SWN1UGxhY2Vob2xkZXIodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIEljdVBsYWNlaG9sZGVyO1xufSgpKTtcbnZhciBDbG9uZVZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENsb25lVmlzaXRvcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZXh0XG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ2xvbmVWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkgeyByZXR1cm4gbmV3IFRleHQkMSh0ZXh0LnZhbHVlLCB0ZXh0LnNvdXJjZVNwYW4pOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29udGFpbmVyXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ2xvbmVWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXIsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hpbGRyZW4gPSBjb250YWluZXIuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLnZpc2l0KF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICAgIHJldHVybiBuZXcgQ29udGFpbmVyKGNoaWxkcmVuLCBjb250YWluZXIuc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGljdVxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENsb25lVmlzaXRvci5wcm90b3R5cGUudmlzaXRJY3UgPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNhc2VzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKGljdS5jYXNlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBjYXNlc1trZXldID0gaWN1LmNhc2VzW2tleV0udmlzaXQoX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbXNnID0gbmV3IEljdShpY3UuZXhwcmVzc2lvbiwgaWN1LnR5cGUsIGNhc2VzLCBpY3Uuc291cmNlU3Bhbik7XG4gICAgICAgIG1zZy5leHByZXNzaW9uUGxhY2Vob2xkZXIgPSBpY3UuZXhwcmVzc2lvblBsYWNlaG9sZGVyO1xuICAgICAgICByZXR1cm4gbXNnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENsb25lVmlzaXRvci5wcm90b3R5cGUudmlzaXRUYWdQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlsZHJlbiA9IHBoLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAobikgeyByZXR1cm4gbi52aXNpdChfdGhpcywgY29udGV4dCk7IH0pO1xuICAgICAgICByZXR1cm4gbmV3IFRhZ1BsYWNlaG9sZGVyKHBoLnRhZywgcGguYXR0cnMsIHBoLnN0YXJ0TmFtZSwgcGguY2xvc2VOYW1lLCBjaGlsZHJlbiwgcGguaXNWb2lkLCBwaC5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGhcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDbG9uZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQbGFjZWhvbGRlcihwaC52YWx1ZSwgcGgubmFtZSwgcGguc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBoXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ2xvbmVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdVBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgSWN1UGxhY2Vob2xkZXIocGgudmFsdWUsIHBoLm5hbWUsIHBoLnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgcmV0dXJuIENsb25lVmlzaXRvcjtcbn0oKSk7XG52YXIgUmVjdXJzZVZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlY3Vyc2VWaXNpdG9yKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRleHRcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHsgfTtcbiAgICA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb250YWluZXJcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb250YWluZXIgPSBmdW5jdGlvbiAoY29udGFpbmVyLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGNvbnRhaW5lci5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gY2hpbGQudmlzaXQoX3RoaXMpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWN1XG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWN1ID0gZnVuY3Rpb24gKGljdSwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBPYmplY3Qua2V5cyhpY3UuY2FzZXMpLmZvckVhY2goZnVuY3Rpb24gKGspIHsgaWN1LmNhc2VzW2tdLnZpc2l0KF90aGlzKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBoXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGFnUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcGguY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkLnZpc2l0KF90aGlzKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBoXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHsgfTtcbiAgICA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdVBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7IH07XG4gICAgO1xuICAgIHJldHVybiBSZWN1cnNlVmlzaXRvcjtcbn0oKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgVEFHX1RPX1BMQUNFSE9MREVSX05BTUVTID0ge1xuICAgICdBJzogJ0xJTksnLFxuICAgICdCJzogJ0JPTERfVEVYVCcsXG4gICAgJ0JSJzogJ0xJTkVfQlJFQUsnLFxuICAgICdFTSc6ICdFTVBIQVNJU0VEX1RFWFQnLFxuICAgICdIMSc6ICdIRUFESU5HX0xFVkVMMScsXG4gICAgJ0gyJzogJ0hFQURJTkdfTEVWRUwyJyxcbiAgICAnSDMnOiAnSEVBRElOR19MRVZFTDMnLFxuICAgICdINCc6ICdIRUFESU5HX0xFVkVMNCcsXG4gICAgJ0g1JzogJ0hFQURJTkdfTEVWRUw1JyxcbiAgICAnSDYnOiAnSEVBRElOR19MRVZFTDYnLFxuICAgICdIUic6ICdIT1JJWk9OVEFMX1JVTEUnLFxuICAgICdJJzogJ0lUQUxJQ19URVhUJyxcbiAgICAnTEknOiAnTElTVF9JVEVNJyxcbiAgICAnTElOSyc6ICdNRURJQV9MSU5LJyxcbiAgICAnT0wnOiAnT1JERVJFRF9MSVNUJyxcbiAgICAnUCc6ICdQQVJBR1JBUEgnLFxuICAgICdRJzogJ1FVT1RBVElPTicsXG4gICAgJ1MnOiAnU1RSSUtFVEhST1VHSF9URVhUJyxcbiAgICAnU01BTEwnOiAnU01BTExfVEVYVCcsXG4gICAgJ1NVQic6ICdTVUJTVFJJUFQnLFxuICAgICdTVVAnOiAnU1VQRVJTQ1JJUFQnLFxuICAgICdUQk9EWSc6ICdUQUJMRV9CT0RZJyxcbiAgICAnVEQnOiAnVEFCTEVfQ0VMTCcsXG4gICAgJ1RGT09UJzogJ1RBQkxFX0ZPT1RFUicsXG4gICAgJ1RIJzogJ1RBQkxFX0hFQURFUl9DRUxMJyxcbiAgICAnVEhFQUQnOiAnVEFCTEVfSEVBREVSJyxcbiAgICAnVFInOiAnVEFCTEVfUk9XJyxcbiAgICAnVFQnOiAnTU9OT1NQQUNFRF9URVhUJyxcbiAgICAnVSc6ICdVTkRFUkxJTkVEX1RFWFQnLFxuICAgICdVTCc6ICdVTk9SREVSRURfTElTVCcsXG59O1xuLyoqXG4gKiBDcmVhdGVzIHVuaXF1ZSBuYW1lcyBmb3IgcGxhY2Vob2xkZXIgd2l0aCBkaWZmZXJlbnQgY29udGVudC5cbiAqXG4gKiBSZXR1cm5zIHRoZSBzYW1lIHBsYWNlaG9sZGVyIG5hbWUgd2hlbiB0aGUgY29udGVudCBpcyBpZGVudGljYWwuXG4gKlxuICogXFxAaW50ZXJuYWxcbiAqL1xudmFyIFBsYWNlaG9sZGVyUmVnaXN0cnkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBsYWNlaG9sZGVyUmVnaXN0cnkoKSB7XG4gICAgICAgIHRoaXMuX3BsYWNlSG9sZGVyTmFtZUNvdW50cyA9IHt9O1xuICAgICAgICB0aGlzLl9zaWduYXR1cmVUb05hbWUgPSB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0YWdcbiAgICAgKiBAcGFyYW0gez99IGF0dHJzXG4gICAgICogQHBhcmFtIHs/fSBpc1ZvaWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBsYWNlaG9sZGVyUmVnaXN0cnkucHJvdG90eXBlLmdldFN0YXJ0VGFnUGxhY2Vob2xkZXJOYW1lID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGlzVm9pZCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzaWduYXR1cmUgPSB0aGlzLl9oYXNoVGFnKHRhZywgYXR0cnMsIGlzVm9pZCk7XG4gICAgICAgIGlmICh0aGlzLl9zaWduYXR1cmVUb05hbWVbc2lnbmF0dXJlXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVwcGVyVGFnID0gdGFnLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJhc2VOYW1lID0gVEFHX1RPX1BMQUNFSE9MREVSX05BTUVTW3VwcGVyVGFnXSB8fCBcIlRBR19cIiArIHVwcGVyVGFnO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lID0gdGhpcy5fZ2VuZXJhdGVVbmlxdWVOYW1lKGlzVm9pZCA/IGJhc2VOYW1lIDogXCJTVEFSVF9cIiArIGJhc2VOYW1lKTtcbiAgICAgICAgdGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV0gPSBuYW1lO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGFnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQbGFjZWhvbGRlclJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRDbG9zZVRhZ1BsYWNlaG9sZGVyTmFtZSA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2lnbmF0dXJlID0gdGhpcy5faGFzaENsb3NpbmdUYWcodGFnKTtcbiAgICAgICAgaWYgKHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXBwZXJUYWcgPSB0YWcudG9VcHBlckNhc2UoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmFzZU5hbWUgPSBUQUdfVE9fUExBQ0VIT0xERVJfTkFNRVNbdXBwZXJUYWddIHx8IFwiVEFHX1wiICsgdXBwZXJUYWc7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWUgPSB0aGlzLl9nZW5lcmF0ZVVuaXF1ZU5hbWUoXCJDTE9TRV9cIiArIGJhc2VOYW1lKTtcbiAgICAgICAgdGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV0gPSBuYW1lO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gY29udGVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGxhY2Vob2xkZXJSZWdpc3RyeS5wcm90b3R5cGUuZ2V0UGxhY2Vob2xkZXJOYW1lID0gZnVuY3Rpb24gKG5hbWUsIGNvbnRlbnQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXBwZXJOYW1lID0gbmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzaWduYXR1cmUgPSBcIlBIOiBcIiArIHVwcGVyTmFtZSArIFwiPVwiICsgY29udGVudDtcbiAgICAgICAgaWYgKHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdW5pcXVlTmFtZSA9IHRoaXMuX2dlbmVyYXRlVW5pcXVlTmFtZSh1cHBlck5hbWUpO1xuICAgICAgICB0aGlzLl9zaWduYXR1cmVUb05hbWVbc2lnbmF0dXJlXSA9IHVuaXF1ZU5hbWU7XG4gICAgICAgIHJldHVybiB1bmlxdWVOYW1lO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQbGFjZWhvbGRlclJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRVbmlxdWVQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZW5lcmF0ZVVuaXF1ZU5hbWUobmFtZS50b1VwcGVyQ2FzZSgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGFnXG4gICAgICogQHBhcmFtIHs/fSBhdHRyc1xuICAgICAqIEBwYXJhbSB7P30gaXNWb2lkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQbGFjZWhvbGRlclJlZ2lzdHJ5LnByb3RvdHlwZS5faGFzaFRhZyA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBpc1ZvaWQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnQgPSBcIjxcIiArIHRhZztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RyQXR0cnMgPSBPYmplY3Qua2V5cyhhdHRycykuc29ydCgpLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gXCIgXCIgKyBuYW1lICsgXCI9XCIgKyBhdHRyc1tuYW1lXTsgfSkuam9pbignJyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVuZCA9IGlzVm9pZCA/ICcvPicgOiBcIj48L1wiICsgdGFnICsgXCI+XCI7XG4gICAgICAgIHJldHVybiBzdGFydCArIHN0ckF0dHJzICsgZW5kO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0YWdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBsYWNlaG9sZGVyUmVnaXN0cnkucHJvdG90eXBlLl9oYXNoQ2xvc2luZ1RhZyA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHRoaXMuX2hhc2hUYWcoXCIvXCIgKyB0YWcsIHt9LCBmYWxzZSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBiYXNlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQbGFjZWhvbGRlclJlZ2lzdHJ5LnByb3RvdHlwZS5fZ2VuZXJhdGVVbmlxdWVOYW1lID0gZnVuY3Rpb24gKGJhc2UpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VlbiA9IHRoaXMuX3BsYWNlSG9sZGVyTmFtZUNvdW50cy5oYXNPd25Qcm9wZXJ0eShiYXNlKTtcbiAgICAgICAgaWYgKCFzZWVuKSB7XG4gICAgICAgICAgICB0aGlzLl9wbGFjZUhvbGRlck5hbWVDb3VudHNbYmFzZV0gPSAxO1xuICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaWQgPSB0aGlzLl9wbGFjZUhvbGRlck5hbWVDb3VudHNbYmFzZV07XG4gICAgICAgIHRoaXMuX3BsYWNlSG9sZGVyTmFtZUNvdW50c1tiYXNlXSA9IGlkICsgMTtcbiAgICAgICAgcmV0dXJuIGJhc2UgKyBcIl9cIiArIGlkO1xuICAgIH07XG4gICAgcmV0dXJuIFBsYWNlaG9sZGVyUmVnaXN0cnk7XG59KCkpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIF9leHBQYXJzZXIgPSBuZXcgUGFyc2VyKG5ldyBMZXhlcigpKTtcbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIGNvbnZlcnRpbmcgaHRtbCBub2RlcyB0byBhbiBpMThuIE1lc3NhZ2UgZ2l2ZW4gYW4gaW50ZXJwb2xhdGlvbkNvbmZpZ1xuICogQHBhcmFtIHs/fSBpbnRlcnBvbGF0aW9uQ29uZmlnXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjcmVhdGVJMThuTWVzc2FnZUZhY3RvcnkoaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0b3IgPSBuZXcgX0kxOG5WaXNpdG9yKF9leHBQYXJzZXIsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgIHJldHVybiBmdW5jdGlvbiAobm9kZXMsIG1lYW5pbmcsIGRlc2NyaXB0aW9uLCBpZCkgeyByZXR1cm4gdmlzaXRvci50b0kxOG5NZXNzYWdlKG5vZGVzLCBtZWFuaW5nLCBkZXNjcmlwdGlvbiwgaWQpOyB9O1xufVxudmFyIF9JMThuVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZXhwcmVzc2lvblBhcnNlclxuICAgICAqIEBwYXJhbSB7P30gX2ludGVycG9sYXRpb25Db25maWdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfSTE4blZpc2l0b3IoX2V4cHJlc3Npb25QYXJzZXIsIF9pbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIHRoaXMuX2V4cHJlc3Npb25QYXJzZXIgPSBfZXhwcmVzc2lvblBhcnNlcjtcbiAgICAgICAgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyA9IF9pbnRlcnBvbGF0aW9uQ29uZmlnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVzXG4gICAgICogQHBhcmFtIHs/fSBtZWFuaW5nXG4gICAgICogQHBhcmFtIHs/fSBkZXNjcmlwdGlvblxuICAgICAqIEBwYXJhbSB7P30gaWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9JMThuVmlzaXRvci5wcm90b3R5cGUudG9JMThuTWVzc2FnZSA9IGZ1bmN0aW9uIChub2RlcywgbWVhbmluZywgZGVzY3JpcHRpb24sIGlkKSB7XG4gICAgICAgIHRoaXMuX2lzSWN1ID0gbm9kZXMubGVuZ3RoID09IDEgJiYgbm9kZXNbMF0gaW5zdGFuY2VvZiBFeHBhbnNpb247XG4gICAgICAgIHRoaXMuX2ljdURlcHRoID0gMDtcbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXJSZWdpc3RyeSA9IG5ldyBQbGFjZWhvbGRlclJlZ2lzdHJ5KCk7XG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyVG9Db250ZW50ID0ge307XG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyVG9NZXNzYWdlID0ge307XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGkxOG5vZGVzID0gdmlzaXRBbGwodGhpcywgbm9kZXMsIHt9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBNZXNzYWdlKGkxOG5vZGVzLCB0aGlzLl9wbGFjZWhvbGRlclRvQ29udGVudCwgdGhpcy5fcGxhY2Vob2xkZXJUb01lc3NhZ2UsIG1lYW5pbmcsIGRlc2NyaXB0aW9uLCBpZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfSTE4blZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbCwgY29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlsZHJlbiA9IHZpc2l0QWxsKHRoaXMsIGVsLmNoaWxkcmVuKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXR0cnMgPSB7fTtcbiAgICAgICAgZWwuYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgLy8gRG8gbm90IHZpc2l0IHRoZSBhdHRyaWJ1dGVzLCB0cmFuc2xhdGFibGUgb25lcyBhcmUgdG9wLWxldmVsIEFTVHNcbiAgICAgICAgICAgIGF0dHJzW2F0dHIubmFtZV0gPSBhdHRyLnZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNWb2lkID0gZ2V0SHRtbFRhZ0RlZmluaXRpb24oZWwubmFtZSkuaXNWb2lkO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydFBoTmFtZSA9IHRoaXMuX3BsYWNlaG9sZGVyUmVnaXN0cnkuZ2V0U3RhcnRUYWdQbGFjZWhvbGRlck5hbWUoZWwubmFtZSwgYXR0cnMsIGlzVm9pZCk7XG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyVG9Db250ZW50W3N0YXJ0UGhOYW1lXSA9ICgoZWwuc291cmNlU3BhbikpLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsb3NlUGhOYW1lID0gJyc7XG4gICAgICAgIGlmICghaXNWb2lkKSB7XG4gICAgICAgICAgICBjbG9zZVBoTmFtZSA9IHRoaXMuX3BsYWNlaG9sZGVyUmVnaXN0cnkuZ2V0Q2xvc2VUYWdQbGFjZWhvbGRlck5hbWUoZWwubmFtZSk7XG4gICAgICAgICAgICB0aGlzLl9wbGFjZWhvbGRlclRvQ29udGVudFtjbG9zZVBoTmFtZV0gPSBcIjwvXCIgKyBlbC5uYW1lICsgXCI+XCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUYWdQbGFjZWhvbGRlcihlbC5uYW1lLCBhdHRycywgc3RhcnRQaE5hbWUsIGNsb3NlUGhOYW1lLCBjaGlsZHJlbiwgaXNWb2lkLCAvKiogQHR5cGUgez99ICovICgoZWwuc291cmNlU3BhbikpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXR0cmlidXRlXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfSTE4blZpc2l0b3IucHJvdG90eXBlLnZpc2l0QXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXRUZXh0V2l0aEludGVycG9sYXRpb24oYXR0cmlidXRlLnZhbHVlLCBhdHRyaWJ1dGUuc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRleHRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9JMThuVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0VGV4dFdpdGhJbnRlcnBvbGF0aW9uKHRleHQudmFsdWUsIC8qKiBAdHlwZSB7P30gKi8gKCh0ZXh0LnNvdXJjZVNwYW4pKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9JMThuVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpY3VcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9JMThuVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb24gPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2ljdURlcHRoKys7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGkxOG5JY3VDYXNlcyA9IHt9O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpMThuSWN1ID0gbmV3IEljdShpY3Uuc3dpdGNoVmFsdWUsIGljdS50eXBlLCBpMThuSWN1Q2FzZXMsIGljdS5zb3VyY2VTcGFuKTtcbiAgICAgICAgaWN1LmNhc2VzLmZvckVhY2goZnVuY3Rpb24gKGNhemUpIHtcbiAgICAgICAgICAgIGkxOG5JY3VDYXNlc1tjYXplLnZhbHVlXSA9IG5ldyBDb250YWluZXIoY2F6ZS5leHByZXNzaW9uLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcywge30pOyB9KSwgY2F6ZS5leHBTb3VyY2VTcGFuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2ljdURlcHRoLS07XG4gICAgICAgIGlmICh0aGlzLl9pc0ljdSB8fCB0aGlzLl9pY3VEZXB0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIFJldHVybnMgYW4gSUNVIG5vZGUgd2hlbjpcbiAgICAgICAgICAgIC8vIC0gdGhlIG1lc3NhZ2UgKHZzIGEgcGFydCBvZiB0aGUgbWVzc2FnZSkgaXMgYW4gSUNVIG1lc3NhZ2UsIG9yXG4gICAgICAgICAgICAvLyAtIHRoZSBJQ1UgbWVzc2FnZSBpcyBuZXN0ZWQuXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHBQaCA9IHRoaXMuX3BsYWNlaG9sZGVyUmVnaXN0cnkuZ2V0VW5pcXVlUGxhY2Vob2xkZXIoXCJWQVJfXCIgKyBpY3UudHlwZSk7XG4gICAgICAgICAgICBpMThuSWN1LmV4cHJlc3Npb25QbGFjZWhvbGRlciA9IGV4cFBoO1xuICAgICAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXJUb0NvbnRlbnRbZXhwUGhdID0gaWN1LnN3aXRjaFZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGkxOG5JY3U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRWxzZSByZXR1cm5zIGEgcGxhY2Vob2xkZXJcbiAgICAgICAgLy8gSUNVIHBsYWNlaG9sZGVycyBzaG91bGQgbm90IGJlIHJlcGxhY2VkIHdpdGggdGhlaXIgb3JpZ2luYWwgY29udGVudCBidXQgd2l0aCB0aGUgdGhlaXJcbiAgICAgICAgLy8gdHJhbnNsYXRpb25zLiBXZSBuZWVkIHRvIGNyZWF0ZSBhIG5ldyB2aXNpdG9yICh0aGV5IGFyZSBub3QgcmUtZW50cmFudCkgdG8gY29tcHV0ZSB0aGVcbiAgICAgICAgLy8gbWVzc2FnZSBpZC5cbiAgICAgICAgLy8gVE9ETyh2aWNiKTogYWRkIGEgaHRtbC5Ob2RlIC0+IGkxOG4uTWVzc2FnZSBjYWNoZSB0byBhdm9pZCBoYXZpbmcgdG8gcmUtY3JlYXRlIHRoZSBtc2dcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGhOYW1lID0gdGhpcy5fcGxhY2Vob2xkZXJSZWdpc3RyeS5nZXRQbGFjZWhvbGRlck5hbWUoJ0lDVScsIGljdS5zb3VyY2VTcGFuLnRvU3RyaW5nKCkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aXNpdG9yID0gbmV3IF9JMThuVmlzaXRvcih0aGlzLl9leHByZXNzaW9uUGFyc2VyLCB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXJUb01lc3NhZ2VbcGhOYW1lXSA9IHZpc2l0b3IudG9JMThuTWVzc2FnZShbaWN1XSwgJycsICcnLCAnJyk7XG4gICAgICAgIHJldHVybiBuZXcgSWN1UGxhY2Vob2xkZXIoaTE4bkljdSwgcGhOYW1lLCBpY3Uuc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGljdUNhc2VcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9JMThuVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGljdUNhc2UsIGNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnJlYWNoYWJsZSBjb2RlJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRleHRcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9JMThuVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0VGV4dFdpdGhJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKHRleHQsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3BsaXRJbnRlcnBvbGF0aW9uID0gdGhpcy5fZXhwcmVzc2lvblBhcnNlci5zcGxpdEludGVycG9sYXRpb24odGV4dCwgc291cmNlU3Bhbi5zdGFydC50b1N0cmluZygpLCB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgaWYgKCFzcGxpdEludGVycG9sYXRpb24pIHtcbiAgICAgICAgICAgIC8vIE5vIGV4cHJlc3Npb24sIHJldHVybiBhIHNpbmdsZSB0ZXh0XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHQkMSh0ZXh0LCBzb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gYSBncm91cCBvZiB0ZXh0ICsgZXhwcmVzc2lvbnNcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZXMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udGFpbmVyID0gbmV3IENvbnRhaW5lcihub2Rlcywgc291cmNlU3Bhbik7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuX2ludGVycG9sYXRpb25Db25maWcsIHNEZWxpbWl0ZXIgPSBfYS5zdGFydCwgZURlbGltaXRlciA9IF9hLmVuZDtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHNwbGl0SW50ZXJwb2xhdGlvbi5zdHJpbmdzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwcmVzc2lvbiA9IHNwbGl0SW50ZXJwb2xhdGlvbi5leHByZXNzaW9uc1tpXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJhc2VOYW1lID0gX2V4dHJhY3RQbGFjZWhvbGRlck5hbWUoZXhwcmVzc2lvbikgfHwgJ0lOVEVSUE9MQVRJT04nO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGhOYW1lID0gdGhpcy5fcGxhY2Vob2xkZXJSZWdpc3RyeS5nZXRQbGFjZWhvbGRlck5hbWUoYmFzZU5hbWUsIGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgaWYgKHNwbGl0SW50ZXJwb2xhdGlvbi5zdHJpbmdzW2ldLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gYWRkIGVtcHR5IHN0cmluZ3NcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5ldyBUZXh0JDEoc3BsaXRJbnRlcnBvbGF0aW9uLnN0cmluZ3NbaV0sIHNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGVzLnB1c2gobmV3IFBsYWNlaG9sZGVyKGV4cHJlc3Npb24sIHBoTmFtZSwgc291cmNlU3BhbikpO1xuICAgICAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXJUb0NvbnRlbnRbcGhOYW1lXSA9IHNEZWxpbWl0ZXIgKyBleHByZXNzaW9uICsgZURlbGltaXRlcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgbGFzdCBpbmRleCBjb250YWlucyBubyBleHByZXNzaW9uXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxhc3RTdHJpbmdJZHggPSBzcGxpdEludGVycG9sYXRpb24uc3RyaW5ncy5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoc3BsaXRJbnRlcnBvbGF0aW9uLnN0cmluZ3NbbGFzdFN0cmluZ0lkeF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKG5ldyBUZXh0JDEoc3BsaXRJbnRlcnBvbGF0aW9uLnN0cmluZ3NbbGFzdFN0cmluZ0lkeF0sIHNvdXJjZVNwYW4pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH07XG4gICAgcmV0dXJuIF9JMThuVmlzaXRvcjtcbn0oKSk7XG52YXIgX0NVU1RPTV9QSF9FWFAgPSAvXFwvXFwvW1xcc1xcU10qaTE4bltcXHNcXFNdKlxcKFtcXHNcXFNdKnBoW1xcc1xcU10qPVtcXHNcXFNdKihcInwnKShbXFxzXFxTXSo/KVxcMVtcXHNcXFNdKlxcKS9nO1xuLyoqXG4gKiBAcGFyYW0gez99IGlucHV0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfZXh0cmFjdFBsYWNlaG9sZGVyTmFtZShpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dC5zcGxpdChfQ1VTVE9NX1BIX0VYUClbMl07XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEFuIGkxOG4gZXJyb3IuXG4gKi9cbnZhciBJMThuRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEkxOG5FcnJvciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IG1zZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEkxOG5FcnJvcihzcGFuLCBtc2cpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHNwYW4sIG1zZykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEkxOG5FcnJvcjtcbn0oUGFyc2VFcnJvcikpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIF9JMThOX0FUVFIgPSAnaTE4bic7XG52YXIgX0kxOE5fQVRUUl9QUkVGSVggPSAnaTE4bi0nO1xudmFyIF9JMThOX0NPTU1FTlRfUFJFRklYX1JFR0VYUCA9IC9eaTE4bjo/LztcbnZhciBNRUFOSU5HX1NFUEFSQVRPUiA9ICd8JztcbnZhciBJRF9TRVBBUkFUT1IgPSAnQEAnO1xuLyoqXG4gKiBFeHRyYWN0IHRyYW5zbGF0YWJsZSBtZXNzYWdlcyBmcm9tIGFuIGh0bWwgQVNUXG4gKiBAcGFyYW0gez99IG5vZGVzXG4gKiBAcGFyYW0gez99IGludGVycG9sYXRpb25Db25maWdcbiAqIEBwYXJhbSB7P30gaW1wbGljaXRUYWdzXG4gKiBAcGFyYW0gez99IGltcGxpY2l0QXR0cnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RNZXNzYWdlcyhub2RlcywgaW50ZXJwb2xhdGlvbkNvbmZpZywgaW1wbGljaXRUYWdzLCBpbXBsaWNpdEF0dHJzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlzaXRvciA9IG5ldyBfVmlzaXRvcihpbXBsaWNpdFRhZ3MsIGltcGxpY2l0QXR0cnMpO1xuICAgIHJldHVybiB2aXNpdG9yLmV4dHJhY3Qobm9kZXMsIGludGVycG9sYXRpb25Db25maWcpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IG5vZGVzXG4gKiBAcGFyYW0gez99IHRyYW5zbGF0aW9uc1xuICogQHBhcmFtIHs/fSBpbnRlcnBvbGF0aW9uQ29uZmlnXG4gKiBAcGFyYW0gez99IGltcGxpY2l0VGFnc1xuICogQHBhcmFtIHs/fSBpbXBsaWNpdEF0dHJzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBtZXJnZVRyYW5zbGF0aW9ucyhub2RlcywgdHJhbnNsYXRpb25zLCBpbnRlcnBvbGF0aW9uQ29uZmlnLCBpbXBsaWNpdFRhZ3MsIGltcGxpY2l0QXR0cnMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aXNpdG9yID0gbmV3IF9WaXNpdG9yKGltcGxpY2l0VGFncywgaW1wbGljaXRBdHRycyk7XG4gICAgcmV0dXJuIHZpc2l0b3IubWVyZ2Uobm9kZXMsIHRyYW5zbGF0aW9ucywgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG59XG52YXIgRXh0cmFjdGlvblJlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlc1xuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICovXG4gICAgZnVuY3Rpb24gRXh0cmFjdGlvblJlc3VsdChtZXNzYWdlcywgZXJyb3JzKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSBtZXNzYWdlcztcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgfVxuICAgIHJldHVybiBFeHRyYWN0aW9uUmVzdWx0O1xufSgpKTtcbnZhciBfVmlzaXRvck1vZGUgPSB7fTtcbl9WaXNpdG9yTW9kZS5FeHRyYWN0ID0gMDtcbl9WaXNpdG9yTW9kZS5NZXJnZSA9IDE7XG5fVmlzaXRvck1vZGVbX1Zpc2l0b3JNb2RlLkV4dHJhY3RdID0gXCJFeHRyYWN0XCI7XG5fVmlzaXRvck1vZGVbX1Zpc2l0b3JNb2RlLk1lcmdlXSA9IFwiTWVyZ2VcIjtcbi8qKlxuICogVGhpcyBWaXNpdG9yIGlzIHVzZWQ6XG4gKiAxLiB0byBleHRyYWN0IGFsbCB0aGUgdHJhbnNsYXRhYmxlIHN0cmluZ3MgZnJvbSBhbiBodG1sIEFTVCAoc2VlIGBleHRyYWN0KClgKSxcbiAqIDIuIHRvIHJlcGxhY2UgdGhlIHRyYW5zbGF0YWJsZSBzdHJpbmdzIHdpdGggdGhlIGFjdHVhbCB0cmFuc2xhdGlvbnMgKHNlZSBgbWVyZ2UoKWApXG4gKlxuICogXFxAaW50ZXJuYWxcbiAqL1xudmFyIF9WaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9pbXBsaWNpdFRhZ3NcbiAgICAgKiBAcGFyYW0gez99IF9pbXBsaWNpdEF0dHJzXG4gICAgICovXG4gICAgZnVuY3Rpb24gX1Zpc2l0b3IoX2ltcGxpY2l0VGFncywgX2ltcGxpY2l0QXR0cnMpIHtcbiAgICAgICAgdGhpcy5faW1wbGljaXRUYWdzID0gX2ltcGxpY2l0VGFncztcbiAgICAgICAgdGhpcy5faW1wbGljaXRBdHRycyA9IF9pbXBsaWNpdEF0dHJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aGUgbWVzc2FnZXMgZnJvbSB0aGUgdHJlZVxuICAgICAqIEBwYXJhbSB7P30gbm9kZXNcbiAgICAgKiBAcGFyYW0gez99IGludGVycG9sYXRpb25Db25maWdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS5leHRyYWN0ID0gZnVuY3Rpb24gKG5vZGVzLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2luaXQoX1Zpc2l0b3JNb2RlLkV4dHJhY3QsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnZpc2l0KF90aGlzLCBudWxsKTsgfSk7XG4gICAgICAgIGlmICh0aGlzLl9pbkkxOG5CbG9jaykge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Iobm9kZXNbbm9kZXMubGVuZ3RoIC0gMV0sICdVbmNsb3NlZCBibG9jaycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRXh0cmFjdGlvblJlc3VsdCh0aGlzLl9tZXNzYWdlcywgdGhpcy5fZXJyb3JzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB0cmVlIHdoZXJlIGFsbCB0cmFuc2xhdGFibGUgbm9kZXMgYXJlIHRyYW5zbGF0ZWRcbiAgICAgKiBAcGFyYW0gez99IG5vZGVzXG4gICAgICogQHBhcmFtIHs/fSB0cmFuc2xhdGlvbnNcbiAgICAgKiBAcGFyYW0gez99IGludGVycG9sYXRpb25Db25maWdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChub2RlcywgdHJhbnNsYXRpb25zLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIHRoaXMuX2luaXQoX1Zpc2l0b3JNb2RlLk1lcmdlLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgdGhpcy5fdHJhbnNsYXRpb25zID0gdHJhbnNsYXRpb25zO1xuICAgICAgICAvLyBDb25zdHJ1Y3QgYSBzaW5nbGUgZmFrZSByb290IGVsZW1lbnRcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gd3JhcHBlciA9IG5ldyBFbGVtZW50KCd3cmFwcGVyJywgW10sIG5vZGVzLCAvKiogQHR5cGUgez99ICovICgodW5kZWZpbmVkKSksIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNsYXRlZE5vZGUgPSB3cmFwcGVyLnZpc2l0KHRoaXMsIG51bGwpO1xuICAgICAgICBpZiAodGhpcy5faW5JMThuQmxvY2spIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdLCAnVW5jbG9zZWQgYmxvY2snKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlVHJlZVJlc3VsdCh0cmFuc2xhdGVkTm9kZS5jaGlsZHJlbiwgdGhpcy5fZXJyb3JzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWN1Q2FzZVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChpY3VDYXNlLCBjb250ZXh0KSB7XG4gICAgICAgIC8vIFBhcnNlIGNhc2VzIGZvciB0cmFuc2xhdGFibGUgaHRtbCBhdHRyaWJ1dGVzXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cHJlc3Npb24gPSB2aXNpdEFsbCh0aGlzLCBpY3VDYXNlLmV4cHJlc3Npb24sIGNvbnRleHQpO1xuICAgICAgICBpZiAodGhpcy5fbW9kZSA9PT0gX1Zpc2l0b3JNb2RlLk1lcmdlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEV4cGFuc2lvbkNhc2UoaWN1Q2FzZS52YWx1ZSwgZXhwcmVzc2lvbiwgaWN1Q2FzZS5zb3VyY2VTcGFuLCBpY3VDYXNlLnZhbHVlU291cmNlU3BhbiwgaWN1Q2FzZS5leHBTb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpY3VcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fbWF5QmVBZGRCbG9ja0NoaWxkcmVuKGljdSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHdhc0luSWN1ID0gdGhpcy5faW5JY3U7XG4gICAgICAgIGlmICghdGhpcy5faW5JY3UpIHtcbiAgICAgICAgICAgIC8vIG5lc3RlZCBJQ1UgbWVzc2FnZXMgc2hvdWxkIG5vdCBiZSBleHRyYWN0ZWQgYnV0IHRvcC1sZXZlbCB0cmFuc2xhdGVkIGFzIGEgd2hvbGVcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZE1lc3NhZ2UoW2ljdV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faW5JY3UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNhc2VzID0gdmlzaXRBbGwodGhpcywgaWN1LmNhc2VzLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHRoaXMuX21vZGUgPT09IF9WaXNpdG9yTW9kZS5NZXJnZSkge1xuICAgICAgICAgICAgaWN1ID0gbmV3IEV4cGFuc2lvbihpY3Uuc3dpdGNoVmFsdWUsIGljdS50eXBlLCBjYXNlcywgaWN1LnNvdXJjZVNwYW4sIGljdS5zd2l0Y2hWYWx1ZVNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2luSWN1ID0gd2FzSW5JY3U7XG4gICAgICAgIHJldHVybiBpY3U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCwgY29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc09wZW5pbmcgPSBfaXNPcGVuaW5nQ29tbWVudChjb21tZW50KTtcbiAgICAgICAgaWYgKGlzT3BlbmluZyAmJiB0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoY29tbWVudCwgJ0NvdWxkIG5vdCBzdGFydCBhIGJsb2NrIGluc2lkZSBhIHRyYW5zbGF0YWJsZSBzZWN0aW9uJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNDbG9zaW5nID0gX2lzQ2xvc2luZ0NvbW1lbnQoY29tbWVudCk7XG4gICAgICAgIGlmIChpc0Nsb3NpbmcgJiYgIXRoaXMuX2luSTE4bkJsb2NrKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihjb21tZW50LCAnVHJ5aW5nIHRvIGNsb3NlIGFuIHVub3BlbmVkIGJsb2NrJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9pbkkxOG5Ob2RlICYmICF0aGlzLl9pbkljdSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pbkkxOG5CbG9jaykge1xuICAgICAgICAgICAgICAgIGlmIChpc09wZW5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5JMThuQmxvY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ibG9ja1N0YXJ0RGVwdGggPSB0aGlzLl9kZXB0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmxvY2tDaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ibG9ja01lYW5pbmdBbmREZXNjID0gKChjb21tZW50LnZhbHVlKSkucmVwbGFjZShfSTE4Tl9DT01NRU5UX1BSRUZJWF9SRUdFWFAsICcnKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29wZW5UcmFuc2xhdGFibGVTZWN0aW9uKGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc0Nsb3NpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2RlcHRoID09IHRoaXMuX2Jsb2NrU3RhcnREZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xvc2VUcmFuc2xhdGFibGVTZWN0aW9uKGNvbW1lbnQsIHRoaXMuX2Jsb2NrQ2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5JMThuQmxvY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lc3NhZ2UgPSAoKHRoaXMuX2FkZE1lc3NhZ2UodGhpcy5fYmxvY2tDaGlsZHJlbiwgdGhpcy5fYmxvY2tNZWFuaW5nQW5kRGVzYykpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1lcmdlIGF0dHJpYnV0ZXMgaW4gc2VjdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVzID0gdGhpcy5fdHJhbnNsYXRlTWVzc2FnZShjb21tZW50LCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdEFsbCh0aGlzLCBub2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihjb21tZW50LCAnSTE4TiBibG9ja3Mgc2hvdWxkIG5vdCBjcm9zcyBlbGVtZW50IGJvdW5kYXJpZXMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZXh0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzSW5UcmFuc2xhdGFibGVTZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXlCZUFkZEJsb2NrQ2hpbGRyZW4odGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX21heUJlQWRkQmxvY2tDaGlsZHJlbihlbCk7XG4gICAgICAgIHRoaXMuX2RlcHRoKys7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHdhc0luSTE4bk5vZGUgPSB0aGlzLl9pbkkxOG5Ob2RlO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB3YXNJbkltcGxpY2l0Tm9kZSA9IHRoaXMuX2luSW1wbGljaXROb2RlO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlsZE5vZGVzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zbGF0ZWRDaGlsZE5vZGVzID0gKCh1bmRlZmluZWQpKTtcbiAgICAgICAgLy8gRXh0cmFjdDpcbiAgICAgICAgLy8gLSB0b3AgbGV2ZWwgbm9kZXMgd2l0aCB0aGUgKGltcGxpY2l0KSBcImkxOG5cIiBhdHRyaWJ1dGUgaWYgbm90IGFscmVhZHkgaW4gYSBzZWN0aW9uXG4gICAgICAgIC8vIC0gSUNVIG1lc3NhZ2VzXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGkxOG5BdHRyID0gX2dldEkxOG5BdHRyKGVsKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaTE4bk1ldGEgPSBpMThuQXR0ciA/IGkxOG5BdHRyLnZhbHVlIDogJyc7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzSW1wbGljaXQgPSB0aGlzLl9pbXBsaWNpdFRhZ3Muc29tZShmdW5jdGlvbiAodGFnKSB7IHJldHVybiBlbC5uYW1lID09PSB0YWc7IH0pICYmICF0aGlzLl9pbkljdSAmJlxuICAgICAgICAgICAgIXRoaXMuX2lzSW5UcmFuc2xhdGFibGVTZWN0aW9uO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc1RvcExldmVsSW1wbGljaXQgPSAhd2FzSW5JbXBsaWNpdE5vZGUgJiYgaXNJbXBsaWNpdDtcbiAgICAgICAgdGhpcy5faW5JbXBsaWNpdE5vZGUgPSB3YXNJbkltcGxpY2l0Tm9kZSB8fCBpc0ltcGxpY2l0O1xuICAgICAgICBpZiAoIXRoaXMuX2lzSW5UcmFuc2xhdGFibGVTZWN0aW9uICYmICF0aGlzLl9pbkljdSkge1xuICAgICAgICAgICAgaWYgKGkxOG5BdHRyIHx8IGlzVG9wTGV2ZWxJbXBsaWNpdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luSTE4bk5vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lc3NhZ2UgPSAoKHRoaXMuX2FkZE1lc3NhZ2UoZWwuY2hpbGRyZW4sIGkxOG5NZXRhKSkpO1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZWRDaGlsZE5vZGVzID0gdGhpcy5fdHJhbnNsYXRlTWVzc2FnZShlbCwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fbW9kZSA9PSBfVmlzaXRvck1vZGUuRXh0cmFjdCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzVHJhbnNsYXRhYmxlID0gaTE4bkF0dHIgfHwgaXNUb3BMZXZlbEltcGxpY2l0O1xuICAgICAgICAgICAgICAgIGlmIChpc1RyYW5zbGF0YWJsZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3BlblRyYW5zbGF0YWJsZVNlY3Rpb24oZWwpO1xuICAgICAgICAgICAgICAgIHZpc2l0QWxsKHRoaXMsIGVsLmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNUcmFuc2xhdGFibGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlVHJhbnNsYXRhYmxlU2VjdGlvbihlbCwgZWwuY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGkxOG5BdHRyIHx8IGlzVG9wTGV2ZWxJbXBsaWNpdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGVsLCAnQ291bGQgbm90IG1hcmsgYW4gZWxlbWVudCBhcyB0cmFuc2xhdGFibGUgaW5zaWRlIGEgdHJhbnNsYXRhYmxlIHNlY3Rpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9tb2RlID09IF9WaXNpdG9yTW9kZS5FeHRyYWN0KSB7XG4gICAgICAgICAgICAgICAgLy8gRGVzY2VuZCBpbnRvIGNoaWxkIG5vZGVzIGZvciBleHRyYWN0aW9uXG4gICAgICAgICAgICAgICAgdmlzaXRBbGwodGhpcywgZWwuY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9tb2RlID09PSBfVmlzaXRvck1vZGUuTWVyZ2UpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0Tm9kZXMgPSB0cmFuc2xhdGVkQ2hpbGROb2RlcyB8fCBlbC5jaGlsZHJlbjtcbiAgICAgICAgICAgIHZpc2l0Tm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aXNpdGVkID0gY2hpbGQudmlzaXQoX3RoaXMsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGlmICh2aXNpdGVkICYmICFfdGhpcy5faXNJblRyYW5zbGF0YWJsZVNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG8gbm90IGFkZCB0aGUgY2hpbGRyZW4gZnJvbSB0cmFuc2xhdGFibGUgc2VjdGlvbnMgKD0gaTE4biBibG9ja3MgaGVyZSlcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhleSB3aWxsIGJlIGFkZGVkIGxhdGVyIGluIHRoaXMgbG9vcCB3aGVuIHRoZSBibG9jayBjbG9zZXMgKGkuZS4gb24gYDwhLS0gL2kxOG4gLS0+YClcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlcyA9IGNoaWxkTm9kZXMuY29uY2F0KHZpc2l0ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Zpc2l0QXR0cmlidXRlc09mKGVsKTtcbiAgICAgICAgdGhpcy5fZGVwdGgtLTtcbiAgICAgICAgdGhpcy5faW5JMThuTm9kZSA9IHdhc0luSTE4bk5vZGU7XG4gICAgICAgIHRoaXMuX2luSW1wbGljaXROb2RlID0gd2FzSW5JbXBsaWNpdE5vZGU7XG4gICAgICAgIGlmICh0aGlzLl9tb2RlID09PSBfVmlzaXRvck1vZGUuTWVyZ2UpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zbGF0ZWRBdHRycyA9IHRoaXMuX3RyYW5zbGF0ZUF0dHJpYnV0ZXMoZWwpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50KGVsLm5hbWUsIHRyYW5zbGF0ZWRBdHRycywgY2hpbGROb2RlcywgZWwuc291cmNlU3BhbiwgZWwuc3RhcnRTb3VyY2VTcGFuLCBlbC5lbmRTb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXR0cmlidXRlXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWFjaGFibGUgY29kZScpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtb2RlXG4gICAgICogQHBhcmFtIHs/fSBpbnRlcnBvbGF0aW9uQ29uZmlnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmlzaXRvci5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAobW9kZSwgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICB0aGlzLl9tb2RlID0gbW9kZTtcbiAgICAgICAgdGhpcy5faW5JMThuQmxvY2sgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faW5JMThuTm9kZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kZXB0aCA9IDA7XG4gICAgICAgIHRoaXMuX2luSWN1ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX21zZ0NvdW50QXRTZWN0aW9uU3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2Vycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLl9tZXNzYWdlcyA9IFtdO1xuICAgICAgICB0aGlzLl9pbkltcGxpY2l0Tm9kZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jcmVhdGVJMThuTWVzc2FnZSA9IGNyZWF0ZUkxOG5NZXNzYWdlRmFjdG9yeShpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRBdHRyaWJ1dGVzT2YgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwbGljaXRBdHRyTmFtZVRvVmFsdWUgPSB7fTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW1wbGljaXRBdHRyTmFtZXMgPSB0aGlzLl9pbXBsaWNpdEF0dHJzW2VsLm5hbWVdIHx8IFtdO1xuICAgICAgICBlbC5hdHRycy5maWx0ZXIoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuIGF0dHIubmFtZS5zdGFydHNXaXRoKF9JMThOX0FUVFJfUFJFRklYKTsgfSlcbiAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBleHBsaWNpdEF0dHJOYW1lVG9WYWx1ZVthdHRyLm5hbWUuc2xpY2UoX0kxOE5fQVRUUl9QUkVGSVgubGVuZ3RoKV0gPVxuICAgICAgICAgICAgYXR0ci52YWx1ZTsgfSk7XG4gICAgICAgIGVsLmF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICAgIGlmIChhdHRyLm5hbWUgaW4gZXhwbGljaXRBdHRyTmFtZVRvVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fYWRkTWVzc2FnZShbYXR0cl0sIGV4cGxpY2l0QXR0ck5hbWVUb1ZhbHVlW2F0dHIubmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW1wbGljaXRBdHRyTmFtZXMuc29tZShmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gYXR0ci5uYW1lID09PSBuYW1lOyB9KSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9hZGRNZXNzYWdlKFthdHRyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez89fSBtc2dNZXRhXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmlzaXRvci5wcm90b3R5cGUuX2FkZE1lc3NhZ2UgPSBmdW5jdGlvbiAoYXN0LCBtc2dNZXRhKSB7XG4gICAgICAgIGlmIChhc3QubGVuZ3RoID09IDAgfHxcbiAgICAgICAgICAgIGFzdC5sZW5ndGggPT0gMSAmJiBhc3RbMF0gaW5zdGFuY2VvZiBBdHRyaWJ1dGUkMSAmJiAhKChhc3RbMF0pKS52YWx1ZSkge1xuICAgICAgICAgICAgLy8gRG8gbm90IGNyZWF0ZSBlbXB0eSBtZXNzYWdlc1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gX3BhcnNlTWVzc2FnZU1ldGEobXNnTWV0YSksIG1lYW5pbmcgPSBfYS5tZWFuaW5nLCBkZXNjcmlwdGlvbiA9IF9hLmRlc2NyaXB0aW9uLCBpZCA9IF9hLmlkO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZXNzYWdlID0gdGhpcy5fY3JlYXRlSTE4bk1lc3NhZ2UoYXN0LCBtZWFuaW5nLCBkZXNjcmlwdGlvbiwgaWQpO1xuICAgICAgICB0aGlzLl9tZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS5fdHJhbnNsYXRlTWVzc2FnZSA9IGZ1bmN0aW9uIChlbCwgbWVzc2FnZSkge1xuICAgICAgICBpZiAobWVzc2FnZSAmJiB0aGlzLl9tb2RlID09PSBfVmlzaXRvck1vZGUuTWVyZ2UpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVzID0gdGhpcy5fdHJhbnNsYXRpb25zLmdldChtZXNzYWdlKTtcbiAgICAgICAgICAgIGlmIChub2Rlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGVsLCBcIlRyYW5zbGF0aW9uIHVuYXZhaWxhYmxlIGZvciBtZXNzYWdlIGlkPVxcXCJcIiArIHRoaXMuX3RyYW5zbGF0aW9ucy5kaWdlc3QobWVzc2FnZSkgKyBcIlxcXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLl90cmFuc2xhdGVBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGF0dHJpYnV0ZXMgPSBlbC5hdHRycztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaTE4blBhcnNlZE1lc3NhZ2VNZXRhID0ge307XG4gICAgICAgIGF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgaWYgKGF0dHIubmFtZS5zdGFydHNXaXRoKF9JMThOX0FUVFJfUFJFRklYKSkge1xuICAgICAgICAgICAgICAgIGkxOG5QYXJzZWRNZXNzYWdlTWV0YVthdHRyLm5hbWUuc2xpY2UoX0kxOE5fQVRUUl9QUkVGSVgubGVuZ3RoKV0gPVxuICAgICAgICAgICAgICAgICAgICBfcGFyc2VNZXNzYWdlTWV0YShhdHRyLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zbGF0ZWRBdHRyaWJ1dGVzID0gW107XG4gICAgICAgIGF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgaWYgKGF0dHIubmFtZSA9PT0gX0kxOE5fQVRUUiB8fCBhdHRyLm5hbWUuc3RhcnRzV2l0aChfSTE4Tl9BVFRSX1BSRUZJWCkpIHtcbiAgICAgICAgICAgICAgICAvLyBzdHJpcCBpMThuIHNwZWNpZmljIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXR0ci52YWx1ZSAmJiBhdHRyLnZhbHVlICE9ICcnICYmIGkxOG5QYXJzZWRNZXNzYWdlTWV0YS5oYXNPd25Qcm9wZXJ0eShhdHRyLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gaTE4blBhcnNlZE1lc3NhZ2VNZXRhW2F0dHIubmFtZV0sIG1lYW5pbmcgPSBfYS5tZWFuaW5nLCBkZXNjcmlwdGlvbiA9IF9hLmRlc2NyaXB0aW9uLCBpZCA9IF9hLmlkO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lc3NhZ2UgPSBfdGhpcy5fY3JlYXRlSTE4bk1lc3NhZ2UoW2F0dHJdLCBtZWFuaW5nLCBkZXNjcmlwdGlvbiwgaWQpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVzID0gX3RoaXMuX3RyYW5zbGF0aW9ucy5nZXQobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2Rlcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlZEF0dHJpYnV0ZXMucHVzaChuZXcgQXR0cmlidXRlJDEoYXR0ci5uYW1lLCAnJywgYXR0ci5zb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZXNbMF0gaW5zdGFuY2VvZiBUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9ICgobm9kZXNbMF0pKS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZWRBdHRyaWJ1dGVzLnB1c2gobmV3IEF0dHJpYnV0ZSQxKGF0dHIubmFtZSwgdmFsdWUsIGF0dHIuc291cmNlU3BhbikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKGVsLCBcIlVuZXhwZWN0ZWQgdHJhbnNsYXRpb24gZm9yIGF0dHJpYnV0ZSBcXFwiXCIgKyBhdHRyLm5hbWUgKyBcIlxcXCIgKGlkPVxcXCJcIiArIChpZCB8fCBfdGhpcy5fdHJhbnNsYXRpb25zLmRpZ2VzdChtZXNzYWdlKSkgKyBcIlxcXCIpXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoZWwsIFwiVHJhbnNsYXRpb24gdW5hdmFpbGFibGUgZm9yIGF0dHJpYnV0ZSBcXFwiXCIgKyBhdHRyLm5hbWUgKyBcIlxcXCIgKGlkPVxcXCJcIiArIChpZCB8fCBfdGhpcy5fdHJhbnNsYXRpb25zLmRpZ2VzdChtZXNzYWdlKSkgKyBcIlxcXCIpXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZWRBdHRyaWJ1dGVzLnB1c2goYXR0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJhbnNsYXRlZEF0dHJpYnV0ZXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIG5vZGUgYXMgYSBjaGlsZCBvZiB0aGUgYmxvY2sgd2hlbjpcbiAgICAgKiAtIHdlIGFyZSBpbiBhIGJsb2NrLFxuICAgICAqIC0gd2UgYXJlIG5vdCBpbnNpZGUgYSBJQ1UgbWVzc2FnZSAodGhvc2UgYXJlIGhhbmRsZWQgc2VwYXJhdGVseSksXG4gICAgICogLSB0aGUgbm9kZSBpcyBhIFwiZGlyZWN0IGNoaWxkXCIgb2YgdGhlIGJsb2NrXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmlzaXRvci5wcm90b3R5cGUuX21heUJlQWRkQmxvY2tDaGlsZHJlbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbkkxOG5CbG9jayAmJiAhdGhpcy5faW5JY3UgJiYgdGhpcy5fZGVwdGggPT0gdGhpcy5fYmxvY2tTdGFydERlcHRoKSB7XG4gICAgICAgICAgICB0aGlzLl9ibG9ja0NoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1hcmtzIHRoZSBzdGFydCBvZiBhIHNlY3Rpb24sIHNlZSBgX2Nsb3NlVHJhbnNsYXRhYmxlU2VjdGlvbmBcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS5fb3BlblRyYW5zbGF0YWJsZVNlY3Rpb24gPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAodGhpcy5faXNJblRyYW5zbGF0YWJsZVNlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKG5vZGUsICdVbmV4cGVjdGVkIHNlY3Rpb24gc3RhcnQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX21zZ0NvdW50QXRTZWN0aW9uU3RhcnQgPSB0aGlzLl9tZXNzYWdlcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfVmlzaXRvci5wcm90b3R5cGUsIFwiX2lzSW5UcmFuc2xhdGFibGVTZWN0aW9uXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgdHJhbnNsYXRhYmxlIHNlY3Rpb24gY291bGQgYmU6XG4gICAgICAgICAqIC0gdGhlIGNvbnRlbnQgb2YgdHJhbnNsYXRhYmxlIGVsZW1lbnQsXG4gICAgICAgICAqIC0gbm9kZXMgYmV0d2VlbiBgPCEtLSBpMThuIC0tPmAgYW5kIGA8IS0tIC9pMThuIC0tPmAgY29tbWVudHNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21zZ0NvdW50QXRTZWN0aW9uU3RhcnQgIT09IHZvaWQgMDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogVGVybWluYXRlcyBhIHNlY3Rpb24uXG4gICAgICpcbiAgICAgKiBJZiBhIHNlY3Rpb24gaGFzIG9ubHkgb25lIHNpZ25pZmljYW50IGNoaWxkcmVuIChjb21tZW50cyBub3Qgc2lnbmlmaWNhbnQpIHRoZW4gd2Ugc2hvdWxkIG5vdFxuICAgICAqIGtlZXAgdGhlIG1lc3NhZ2UgZnJvbSB0aGlzIGNoaWxkcmVuOlxuICAgICAqXG4gICAgICogYDxwIGkxOG49XCJtZWFuaW5nfGRlc2NyaXB0aW9uXCI+e0lDVSBtZXNzYWdlfTwvcD5gIHdvdWxkIHByb2R1Y2UgdHdvIG1lc3NhZ2VzOlxuICAgICAqIC0gb25lIGZvciB0aGUgPHA+IGNvbnRlbnQgd2l0aCBtZWFuaW5nIGFuZCBkZXNjcmlwdGlvbixcbiAgICAgKiAtIGFub3RoZXIgb25lIGZvciB0aGUgSUNVIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBJbiB0aGlzIGNhc2UgdGhlIGxhc3QgbWVzc2FnZSBpcyBkaXNjYXJkZWQgYXMgaXQgY29udGFpbnMgbGVzcyBpbmZvcm1hdGlvbiAodGhlIEFTVCBpc1xuICAgICAqIG90aGVyd2lzZSBpZGVudGljYWwpLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHdlIHNob3VsZCBzdGlsbCBrZWVwIG1lc3NhZ2VzIGV4dHJhY3RlZCBmcm9tIGF0dHJpYnV0ZXMgaW5zaWRlIHRoZSBzZWN0aW9uIChpZSBpbiB0aGVcbiAgICAgKiBJQ1UgbWVzc2FnZSBoZXJlKVxuICAgICAqIEBwYXJhbSB7P30gbm9kZVxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0Q2hpbGRyZW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS5fY2xvc2VUcmFuc2xhdGFibGVTZWN0aW9uID0gZnVuY3Rpb24gKG5vZGUsIGRpcmVjdENoaWxkcmVuKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNJblRyYW5zbGF0YWJsZVNlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKG5vZGUsICdVbmV4cGVjdGVkIHNlY3Rpb24gZW5kJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnRJbmRleCA9IHRoaXMuX21zZ0NvdW50QXRTZWN0aW9uU3RhcnQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNpZ25pZmljYW50Q2hpbGRyZW4gPSBkaXJlY3RDaGlsZHJlbi5yZWR1Y2UoZnVuY3Rpb24gKGNvdW50LCBub2RlKSB7IHJldHVybiBjb3VudCArIChub2RlIGluc3RhbmNlb2YgQ29tbWVudCA/IDAgOiAxKTsgfSwgMCk7XG4gICAgICAgIGlmIChzaWduaWZpY2FudENoaWxkcmVuID09IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IHRoaXMuX21lc3NhZ2VzLmxlbmd0aCAtIDE7IGkgPj0gKChzdGFydEluZGV4KSk7IGktLSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdCA9IHRoaXMuX21lc3NhZ2VzW2ldLm5vZGVzO1xuICAgICAgICAgICAgICAgIGlmICghKGFzdC5sZW5ndGggPT0gMSAmJiBhc3RbMF0gaW5zdGFuY2VvZiBUZXh0JDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lc3NhZ2VzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21zZ0NvdW50QXRTZWN0aW9uU3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcGFyYW0gez99IG1zZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLl9yZXBvcnRFcnJvciA9IGZ1bmN0aW9uIChub2RlLCBtc2cpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IEkxOG5FcnJvcigvKiogQHR5cGUgez99ICovICgobm9kZS5zb3VyY2VTcGFuKSksIG1zZykpO1xuICAgIH07XG4gICAgcmV0dXJuIF9WaXNpdG9yO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBuXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfaXNPcGVuaW5nQ29tbWVudChuKSB7XG4gICAgcmV0dXJuICEhKG4gaW5zdGFuY2VvZiBDb21tZW50ICYmIG4udmFsdWUgJiYgbi52YWx1ZS5zdGFydHNXaXRoKCdpMThuJykpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IG5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9pc0Nsb3NpbmdDb21tZW50KG4pIHtcbiAgICByZXR1cm4gISEobiBpbnN0YW5jZW9mIENvbW1lbnQgJiYgbi52YWx1ZSAmJiBuLnZhbHVlID09PSAnL2kxOG4nKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBwXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfZ2V0STE4bkF0dHIocCkge1xuICAgIHJldHVybiBwLmF0dHJzLmZpbmQoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuIGF0dHIubmFtZSA9PT0gX0kxOE5fQVRUUjsgfSkgfHwgbnVsbDtcbn1cbi8qKlxuICogQHBhcmFtIHs/PX0gaTE4blxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX3BhcnNlTWVzc2FnZU1ldGEoaTE4bikge1xuICAgIGlmICghaTE4bilcbiAgICAgICAgcmV0dXJuIHsgbWVhbmluZzogJycsIGRlc2NyaXB0aW9uOiAnJywgaWQ6ICcnIH07XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaWRJbmRleCA9IGkxOG4uaW5kZXhPZihJRF9TRVBBUkFUT1IpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlc2NJbmRleCA9IGkxOG4uaW5kZXhPZihNRUFOSU5HX1NFUEFSQVRPUik7XG4gICAgdmFyIF9hID0gKGlkSW5kZXggPiAtMSkgPyBbaTE4bi5zbGljZSgwLCBpZEluZGV4KSwgaTE4bi5zbGljZShpZEluZGV4ICsgMildIDogW2kxOG4sICcnXSwgbWVhbmluZ0FuZERlc2MgPSBfYVswXSwgaWQgPSBfYVsxXTtcbiAgICB2YXIgX2IgPSAoZGVzY0luZGV4ID4gLTEpID9cbiAgICAgICAgW21lYW5pbmdBbmREZXNjLnNsaWNlKDAsIGRlc2NJbmRleCksIG1lYW5pbmdBbmREZXNjLnNsaWNlKGRlc2NJbmRleCArIDEpXSA6XG4gICAgICAgIFsnJywgbWVhbmluZ0FuZERlc2NdLCBtZWFuaW5nID0gX2JbMF0sIGRlc2NyaXB0aW9uID0gX2JbMV07XG4gICAgcmV0dXJuIHsgbWVhbmluZzogbWVhbmluZywgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLCBpZDogaWQgfTtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBYbWxUYWdEZWZpbml0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBYbWxUYWdEZWZpbml0aW9uKCkge1xuICAgICAgICB0aGlzLmNsb3NlZEJ5UGFyZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29udGVudFR5cGUgPSBUYWdDb250ZW50VHlwZS5QQVJTQUJMRV9EQVRBO1xuICAgICAgICB0aGlzLmlzVm9pZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlnbm9yZUZpcnN0TGYgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYW5TZWxmQ2xvc2UgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGN1cnJlbnRQYXJlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtbFRhZ0RlZmluaXRpb24ucHJvdG90eXBlLnJlcXVpcmVFeHRyYVBhcmVudCA9IGZ1bmN0aW9uIChjdXJyZW50UGFyZW50KSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtbFRhZ0RlZmluaXRpb24ucHJvdG90eXBlLmlzQ2xvc2VkQnlDaGlsZCA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICByZXR1cm4gWG1sVGFnRGVmaW5pdGlvbjtcbn0oKSk7XG52YXIgX1RBR19ERUZJTklUSU9OID0gbmV3IFhtbFRhZ0RlZmluaXRpb24oKTtcbi8qKlxuICogQHBhcmFtIHs/fSB0YWdOYW1lXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBnZXRYbWxUYWdEZWZpbml0aW9uKHRhZ05hbWUpIHtcbiAgICByZXR1cm4gX1RBR19ERUZJTklUSU9OO1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIFhtbFBhcnNlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoWG1sUGFyc2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFhtbFBhcnNlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGdldFhtbFRhZ0RlZmluaXRpb24pIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc291cmNlXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcGFyYW0gez89fSBwYXJzZUV4cGFuc2lvbkZvcm1zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgdXJsLCBwYXJzZUV4cGFuc2lvbkZvcm1zKSB7XG4gICAgICAgIGlmIChwYXJzZUV4cGFuc2lvbkZvcm1zID09PSB2b2lkIDApIHsgcGFyc2VFeHBhbnNpb25Gb3JtcyA9IGZhbHNlOyB9XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnBhcnNlLmNhbGwodGhpcywgc291cmNlLCB1cmwsIHBhcnNlRXhwYW5zaW9uRm9ybXMpO1xuICAgIH07XG4gICAgcmV0dXJuIFhtbFBhcnNlcjtcbn0oUGFyc2VyJDEpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQGFic3RyYWN0XG4gKi9cbnZhciBTZXJpYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXJpYWxpemVyKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VzXG4gICAgICogQHBhcmFtIHs/fSBsb2NhbGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlcmlhbGl6ZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKG1lc3NhZ2VzLCBsb2NhbGUpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRlbnRcbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VyaWFsaXplci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChjb250ZW50LCB1cmwpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlcmlhbGl6ZXIucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZXJpYWxpemVyLnByb3RvdHlwZS5jcmVhdGVOYW1lTWFwcGVyID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgcmV0dXJuIFNlcmlhbGl6ZXI7XG59KCkpO1xuLyoqXG4gKiBBIHNpbXBsZSBtYXBwZXIgdGhhdCB0YWtlIGEgZnVuY3Rpb24gdG8gdHJhbnNmb3JtIGFuIGludGVybmFsIG5hbWUgdG8gYSBwdWJsaWMgbmFtZVxuICovXG52YXIgU2ltcGxlUGxhY2Vob2xkZXJNYXBwZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFNpbXBsZVBsYWNlaG9sZGVyTWFwcGVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7P30gbWFwTmFtZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNpbXBsZVBsYWNlaG9sZGVyTWFwcGVyKG1lc3NhZ2UsIG1hcE5hbWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubWFwTmFtZSA9IG1hcE5hbWU7XG4gICAgICAgIF90aGlzLmludGVybmFsVG9QdWJsaWMgPSB7fTtcbiAgICAgICAgX3RoaXMucHVibGljVG9OZXh0SWQgPSB7fTtcbiAgICAgICAgX3RoaXMucHVibGljVG9JbnRlcm5hbCA9IHt9O1xuICAgICAgICBtZXNzYWdlLm5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3RoaXMpOyB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGludGVybmFsTmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2ltcGxlUGxhY2Vob2xkZXJNYXBwZXIucHJvdG90eXBlLnRvUHVibGljTmFtZSA9IGZ1bmN0aW9uIChpbnRlcm5hbE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxUb1B1YmxpYy5oYXNPd25Qcm9wZXJ0eShpbnRlcm5hbE5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxUb1B1YmxpY1tpbnRlcm5hbE5hbWVdIDpcbiAgICAgICAgICAgIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHB1YmxpY05hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZVBsYWNlaG9sZGVyTWFwcGVyLnByb3RvdHlwZS50b0ludGVybmFsTmFtZSA9IGZ1bmN0aW9uIChwdWJsaWNOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1YmxpY1RvSW50ZXJuYWwuaGFzT3duUHJvcGVydHkocHVibGljTmFtZSkgPyB0aGlzLnB1YmxpY1RvSW50ZXJuYWxbcHVibGljTmFtZV0gOlxuICAgICAgICAgICAgbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGV4dFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZVBsYWNlaG9sZGVyTWFwcGVyLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBoXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2ltcGxlUGxhY2Vob2xkZXJNYXBwZXIucHJvdG90eXBlLnZpc2l0VGFnUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdFBsYWNlaG9sZGVyTmFtZShwaC5zdGFydE5hbWUpO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnZpc2l0VGFnUGxhY2Vob2xkZXIuY2FsbCh0aGlzLCBwaCwgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmlzaXRQbGFjZWhvbGRlck5hbWUocGguY2xvc2VOYW1lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGhcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVQbGFjZWhvbGRlck1hcHBlci5wcm90b3R5cGUudmlzaXRQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkgeyB0aGlzLnZpc2l0UGxhY2Vob2xkZXJOYW1lKHBoLm5hbWUpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGhcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVQbGFjZWhvbGRlck1hcHBlci5wcm90b3R5cGUudmlzaXRJY3VQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0UGxhY2Vob2xkZXJOYW1lKHBoLm5hbWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbnRlcm5hbE5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZVBsYWNlaG9sZGVyTWFwcGVyLnByb3RvdHlwZS52aXNpdFBsYWNlaG9sZGVyTmFtZSA9IGZ1bmN0aW9uIChpbnRlcm5hbE5hbWUpIHtcbiAgICAgICAgaWYgKCFpbnRlcm5hbE5hbWUgfHwgdGhpcy5pbnRlcm5hbFRvUHVibGljLmhhc093blByb3BlcnR5KGludGVybmFsTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwdWJsaWNOYW1lID0gdGhpcy5tYXBOYW1lKGludGVybmFsTmFtZSk7XG4gICAgICAgIGlmICh0aGlzLnB1YmxpY1RvSW50ZXJuYWwuaGFzT3duUHJvcGVydHkocHVibGljTmFtZSkpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBYTUIgd2hlbiBpdCBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5leHRJZCA9IHRoaXMucHVibGljVG9OZXh0SWRbcHVibGljTmFtZV07XG4gICAgICAgICAgICB0aGlzLnB1YmxpY1RvTmV4dElkW3B1YmxpY05hbWVdID0gbmV4dElkICsgMTtcbiAgICAgICAgICAgIHB1YmxpY05hbWUgPSBwdWJsaWNOYW1lICsgXCJfXCIgKyBuZXh0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnB1YmxpY1RvTmV4dElkW3B1YmxpY05hbWVdID0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludGVybmFsVG9QdWJsaWNbaW50ZXJuYWxOYW1lXSA9IHB1YmxpY05hbWU7XG4gICAgICAgIHRoaXMucHVibGljVG9JbnRlcm5hbFtwdWJsaWNOYW1lXSA9IGludGVybmFsTmFtZTtcbiAgICB9O1xuICAgIHJldHVybiBTaW1wbGVQbGFjZWhvbGRlck1hcHBlcjtcbn0oUmVjdXJzZVZpc2l0b3IpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBfVmlzaXRvciQxID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBfVmlzaXRvciQxKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRhZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0ckF0dHJzID0gdGhpcy5fc2VyaWFsaXplQXR0cmlidXRlcyh0YWcuYXR0cnMpO1xuICAgICAgICBpZiAodGFnLmNoaWxkcmVuLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gXCI8XCIgKyB0YWcubmFtZSArIHN0ckF0dHJzICsgXCIvPlwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0ckNoaWxkcmVuID0gdGFnLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcyk7IH0pO1xuICAgICAgICByZXR1cm4gXCI8XCIgKyB0YWcubmFtZSArIHN0ckF0dHJzICsgXCI+XCIgKyBzdHJDaGlsZHJlbi5qb2luKCcnKSArIFwiPC9cIiArIHRhZy5uYW1lICsgXCI+XCI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9WaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7IHJldHVybiB0ZXh0LnZhbHVlOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGVjbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IkMS5wcm90b3R5cGUudmlzaXREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChkZWNsKSB7XG4gICAgICAgIHJldHVybiBcIjw/eG1sXCIgKyB0aGlzLl9zZXJpYWxpemVBdHRyaWJ1dGVzKGRlY2wuYXR0cnMpICsgXCIgPz5cIjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXR0cnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9WaXNpdG9yJDEucHJvdG90eXBlLl9zZXJpYWxpemVBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGF0dHJzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0ckF0dHJzID0gT2JqZWN0LmtleXMoYXR0cnMpLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbmFtZSArIFwiPVxcXCJcIiArIGF0dHJzW25hbWVdICsgXCJcXFwiXCI7IH0pLmpvaW4oJyAnKTtcbiAgICAgICAgcmV0dXJuIHN0ckF0dHJzLmxlbmd0aCA+IDAgPyAnICcgKyBzdHJBdHRycyA6ICcnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkb2N0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmlzaXRvciQxLnByb3RvdHlwZS52aXNpdERvY3R5cGUgPSBmdW5jdGlvbiAoZG9jdHlwZSkge1xuICAgICAgICByZXR1cm4gXCI8IURPQ1RZUEUgXCIgKyBkb2N0eXBlLnJvb3RUYWcgKyBcIiBbXFxuXCIgKyBkb2N0eXBlLmR0ZCArIFwiXFxuXT5cIjtcbiAgICB9O1xuICAgIHJldHVybiBfVmlzaXRvciQxO1xufSgpKTtcbnZhciBfdmlzaXRvciA9IG5ldyBfVmlzaXRvciQxKCk7XG4vKipcbiAqIEBwYXJhbSB7P30gbm9kZXNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZShub2Rlcykge1xuICAgIHJldHVybiBub2Rlcy5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3Zpc2l0b3IpOyB9KS5qb2luKCcnKTtcbn1cbnZhciBEZWNsYXJhdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB1bmVzY2FwZWRBdHRyc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIERlY2xhcmF0aW9uKHVuZXNjYXBlZEF0dHJzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuYXR0cnMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXModW5lc2NhcGVkQXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIF90aGlzLmF0dHJzW2tdID0gX2VzY2FwZVhtbCh1bmVzY2FwZWRBdHRyc1trXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERlY2xhcmF0aW9uLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7IHJldHVybiB2aXNpdG9yLnZpc2l0RGVjbGFyYXRpb24odGhpcyk7IH07XG4gICAgcmV0dXJuIERlY2xhcmF0aW9uO1xufSgpKTtcbnZhciBEb2N0eXBlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJvb3RUYWdcbiAgICAgKiBAcGFyYW0gez99IGR0ZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERvY3R5cGUocm9vdFRhZywgZHRkKSB7XG4gICAgICAgIHRoaXMucm9vdFRhZyA9IHJvb3RUYWc7XG4gICAgICAgIHRoaXMuZHRkID0gZHRkO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb2N0eXBlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7IHJldHVybiB2aXNpdG9yLnZpc2l0RG9jdHlwZSh0aGlzKTsgfTtcbiAgICByZXR1cm4gRG9jdHlwZTtcbn0oKSk7XG52YXIgVGFnID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez89fSB1bmVzY2FwZWRBdHRyc1xuICAgICAqIEBwYXJhbSB7Pz19IGNoaWxkcmVuXG4gICAgICovXG4gICAgZnVuY3Rpb24gVGFnKG5hbWUsIHVuZXNjYXBlZEF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBpZiAodW5lc2NhcGVkQXR0cnMgPT09IHZvaWQgMCkgeyB1bmVzY2FwZWRBdHRycyA9IHt9OyB9XG4gICAgICAgIGlmIChjaGlsZHJlbiA9PT0gdm9pZCAwKSB7IGNoaWxkcmVuID0gW107IH1cbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLmF0dHJzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKHVuZXNjYXBlZEF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBfdGhpcy5hdHRyc1trXSA9IF9lc2NhcGVYbWwodW5lc2NhcGVkQXR0cnNba10pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUYWcucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRUYWcodGhpcyk7IH07XG4gICAgcmV0dXJuIFRhZztcbn0oKSk7XG52YXIgVGV4dCQyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHVuZXNjYXBlZFZhbHVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gVGV4dCQyKHVuZXNjYXBlZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBfZXNjYXBlWG1sKHVuZXNjYXBlZFZhbHVlKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGV4dCQyLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7IHJldHVybiB2aXNpdG9yLnZpc2l0VGV4dCh0aGlzKTsgfTtcbiAgICByZXR1cm4gVGV4dCQyO1xufSgpKTtcbnZhciBDUiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQ1IsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gd3NcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDUih3cykge1xuICAgICAgICBpZiAod3MgPT09IHZvaWQgMCkgeyB3cyA9IDA7IH1cbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIFwiXFxuXCIgKyBuZXcgQXJyYXkod3MgKyAxKS5qb2luKCcgJykpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBDUjtcbn0oVGV4dCQyKSk7XG52YXIgX0VTQ0FQRURfQ0hBUlMgPSBbXG4gICAgWy8mL2csICcmYW1wOyddLFxuICAgIFsvXCIvZywgJyZxdW90OyddLFxuICAgIFsvJy9nLCAnJmFwb3M7J10sXG4gICAgWy88L2csICcmbHQ7J10sXG4gICAgWy8+L2csICcmZ3Q7J10sXG5dO1xuLyoqXG4gKiBAcGFyYW0gez99IHRleHRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9lc2NhcGVYbWwodGV4dCkge1xuICAgIHJldHVybiBfRVNDQVBFRF9DSEFSUy5yZWR1Y2UoZnVuY3Rpb24gKHRleHQsIGVudHJ5KSB7IHJldHVybiB0ZXh0LnJlcGxhY2UoZW50cnlbMF0sIGVudHJ5WzFdKTsgfSwgdGV4dCk7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgX1ZFUlNJT04gPSAnMS4yJztcbnZhciBfWE1MTlMgPSAndXJuOm9hc2lzOm5hbWVzOnRjOnhsaWZmOmRvY3VtZW50OjEuMic7XG4vLyBUT0RPKHZpY2IpOiBtYWtlIHRoaXMgYSBwYXJhbSAocy9fLy0vKVxudmFyIF9ERUZBVUxUX1NPVVJDRV9MQU5HID0gJ2VuJztcbnZhciBfUExBQ0VIT0xERVJfVEFHID0gJ3gnO1xudmFyIF9GSUxFX1RBRyA9ICdmaWxlJztcbnZhciBfU09VUkNFX1RBRyA9ICdzb3VyY2UnO1xudmFyIF9UQVJHRVRfVEFHID0gJ3RhcmdldCc7XG52YXIgX1VOSVRfVEFHID0gJ3RyYW5zLXVuaXQnO1xudmFyIF9DT05URVhUX0dST1VQX1RBRyA9ICdjb250ZXh0LWdyb3VwJztcbnZhciBfQ09OVEVYVF9UQUcgPSAnY29udGV4dCc7XG52YXIgWGxpZmYgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFhsaWZmLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFhsaWZmKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZXNcbiAgICAgKiBAcGFyYW0gez99IGxvY2FsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWGxpZmYucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKG1lc3NhZ2VzLCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlzaXRvciA9IG5ldyBfV3JpdGVWaXNpdG9yKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zVW5pdHMgPSBbXTtcbiAgICAgICAgbWVzc2FnZXMuZm9yRWFjaChmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udGV4dFRhZ3MgPSBbXTtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250ZXh0R3JvdXBUYWcgPSBuZXcgVGFnKF9DT05URVhUX0dST1VQX1RBRywgeyBwdXJwb3NlOiAnbG9jYXRpb24nIH0pO1xuICAgICAgICAgICAgICAgIGNvbnRleHRHcm91cFRhZy5jaGlsZHJlbi5wdXNoKG5ldyBDUigxMCksIG5ldyBUYWcoX0NPTlRFWFRfVEFHLCB7ICdjb250ZXh0LXR5cGUnOiAnc291cmNlZmlsZScgfSwgW25ldyBUZXh0JDIoc291cmNlLmZpbGVQYXRoKV0pLCBuZXcgQ1IoMTApLCBuZXcgVGFnKF9DT05URVhUX1RBRywgeyAnY29udGV4dC10eXBlJzogJ2xpbmVudW1iZXInIH0sIFtuZXcgVGV4dCQyKFwiXCIgKyBzb3VyY2Uuc3RhcnRMaW5lKV0pLCBuZXcgQ1IoOCkpO1xuICAgICAgICAgICAgICAgIGNvbnRleHRUYWdzLnB1c2gobmV3IENSKDgpLCBjb250ZXh0R3JvdXBUYWcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc1VuaXQgPSBuZXcgVGFnKF9VTklUX1RBRywgeyBpZDogbWVzc2FnZS5pZCwgZGF0YXR5cGU6ICdodG1sJyB9KTtcbiAgICAgICAgICAgIChfYSA9IHRyYW5zVW5pdC5jaGlsZHJlbikucHVzaC5hcHBseShfYSwgW25ldyBDUig4KSwgbmV3IFRhZyhfU09VUkNFX1RBRywge30sIHZpc2l0b3Iuc2VyaWFsaXplKG1lc3NhZ2Uubm9kZXMpKV0uY29uY2F0KGNvbnRleHRUYWdzKSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIHRyYW5zVW5pdC5jaGlsZHJlbi5wdXNoKG5ldyBDUig4KSwgbmV3IFRhZygnbm90ZScsIHsgcHJpb3JpdHk6ICcxJywgZnJvbTogJ2Rlc2NyaXB0aW9uJyB9LCBbbmV3IFRleHQkMihtZXNzYWdlLmRlc2NyaXB0aW9uKV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1lYW5pbmcpIHtcbiAgICAgICAgICAgICAgICB0cmFuc1VuaXQuY2hpbGRyZW4ucHVzaChuZXcgQ1IoOCksIG5ldyBUYWcoJ25vdGUnLCB7IHByaW9yaXR5OiAnMScsIGZyb206ICdtZWFuaW5nJyB9LCBbbmV3IFRleHQkMihtZXNzYWdlLm1lYW5pbmcpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhbnNVbml0LmNoaWxkcmVuLnB1c2gobmV3IENSKDYpKTtcbiAgICAgICAgICAgIHRyYW5zVW5pdHMucHVzaChuZXcgQ1IoNiksIHRyYW5zVW5pdCk7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBib2R5ID0gbmV3IFRhZygnYm9keScsIHt9LCB0cmFuc1VuaXRzLmNvbmNhdChbbmV3IENSKDQpXSkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmaWxlID0gbmV3IFRhZygnZmlsZScsIHtcbiAgICAgICAgICAgICdzb3VyY2UtbGFuZ3VhZ2UnOiBsb2NhbGUgfHwgX0RFRkFVTFRfU09VUkNFX0xBTkcsXG4gICAgICAgICAgICBkYXRhdHlwZTogJ3BsYWludGV4dCcsXG4gICAgICAgICAgICBvcmlnaW5hbDogJ25nMi50ZW1wbGF0ZScsXG4gICAgICAgIH0sIFtuZXcgQ1IoNCksIGJvZHksIG5ldyBDUigyKV0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB4bGlmZiA9IG5ldyBUYWcoJ3hsaWZmJywgeyB2ZXJzaW9uOiBfVkVSU0lPTiwgeG1sbnM6IF9YTUxOUyB9LCBbbmV3IENSKDIpLCBmaWxlLCBuZXcgQ1IoKV0pO1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplKFtcbiAgICAgICAgICAgIG5ldyBEZWNsYXJhdGlvbih7IHZlcnNpb246ICcxLjAnLCBlbmNvZGluZzogJ1VURi04JyB9KSwgbmV3IENSKCksIHhsaWZmLCBuZXcgQ1IoKVxuICAgICAgICBdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29udGVudFxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbGlmZi5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChjb250ZW50LCB1cmwpIHtcbiAgICAgICAgLy8geGxpZmYgdG8geG1sIG5vZGVzXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHhsaWZmUGFyc2VyID0gbmV3IFhsaWZmUGFyc2VyKCk7XG4gICAgICAgIHZhciBfYSA9IHhsaWZmUGFyc2VyLnBhcnNlKGNvbnRlbnQsIHVybCksIGxvY2FsZSA9IF9hLmxvY2FsZSwgbXNnSWRUb0h0bWwgPSBfYS5tc2dJZFRvSHRtbCwgZXJyb3JzID0gX2EuZXJyb3JzO1xuICAgICAgICAvLyB4bWwgbm9kZXMgdG8gaTE4biBub2Rlc1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpMThuTm9kZXNCeU1zZ0lkID0ge307XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnZlcnRlciA9IG5ldyBYbWxUb0kxOG4oKTtcbiAgICAgICAgT2JqZWN0LmtleXMobXNnSWRUb0h0bWwpLmZvckVhY2goZnVuY3Rpb24gKG1zZ0lkKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBjb252ZXJ0ZXIuY29udmVydChtc2dJZFRvSHRtbFttc2dJZF0sIHVybCksIGkxOG5Ob2RlcyA9IF9hLmkxOG5Ob2RlcywgZSA9IF9hLmVycm9ycztcbiAgICAgICAgICAgIGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgZSk7XG4gICAgICAgICAgICBpMThuTm9kZXNCeU1zZ0lkW21zZ0lkXSA9IGkxOG5Ob2RlcztcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4bGlmZiBwYXJzZSBlcnJvcnM6XFxuXCIgKyBlcnJvcnMuam9pbignXFxuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGxvY2FsZTogLyoqIEB0eXBlIHs/fSAqLyAoKGxvY2FsZSkpLCBpMThuTm9kZXNCeU1zZ0lkOiBpMThuTm9kZXNCeU1zZ0lkIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhsaWZmLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAobWVzc2FnZSkgeyByZXR1cm4gZGlnZXN0KG1lc3NhZ2UpOyB9O1xuICAgIHJldHVybiBYbGlmZjtcbn0oU2VyaWFsaXplcikpO1xudmFyIF9Xcml0ZVZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIF9Xcml0ZVZpc2l0b3IoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGV4dFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Xcml0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7IHJldHVybiBbbmV3IFRleHQkMih0ZXh0LnZhbHVlKV07IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb250YWluZXJcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfV3JpdGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXIsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZXMgPSBbXTtcbiAgICAgICAgY29udGFpbmVyLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGVzLnB1c2guYXBwbHkobm9kZXMsIG5vZGUudmlzaXQoX3RoaXMpKTsgfSk7XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWN1XG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1dyaXRlVmlzaXRvci5wcm90b3R5cGUudmlzaXRJY3UgPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVzID0gW25ldyBUZXh0JDIoXCJ7XCIgKyBpY3UuZXhwcmVzc2lvblBsYWNlaG9sZGVyICsgXCIsIFwiICsgaWN1LnR5cGUgKyBcIiwgXCIpXTtcbiAgICAgICAgT2JqZWN0LmtleXMoaWN1LmNhc2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoLmFwcGx5KG5vZGVzLCBbbmV3IFRleHQkMihjICsgXCIge1wiKV0uY29uY2F0KGljdS5jYXNlc1tjXS52aXNpdChfdGhpcyksIFtuZXcgVGV4dCQyKFwifSBcIildKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBub2Rlcy5wdXNoKG5ldyBUZXh0JDIoXCJ9XCIpKTtcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Xcml0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGFnUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3R5cGUgPSBnZXRDdHlwZUZvclRhZyhwaC50YWcpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydFRhZ1BoID0gbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHLCB7IGlkOiBwaC5zdGFydE5hbWUsIGN0eXBlOiBjdHlwZSB9KTtcbiAgICAgICAgaWYgKHBoLmlzVm9pZCkge1xuICAgICAgICAgICAgLy8gdm9pZCB0YWdzIGhhdmUgbm8gY2hpbGRyZW4gbm9yIGNsb3NpbmcgdGFnc1xuICAgICAgICAgICAgcmV0dXJuIFtzdGFydFRhZ1BoXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbG9zZVRhZ1BoID0gbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHLCB7IGlkOiBwaC5jbG9zZU5hbWUsIGN0eXBlOiBjdHlwZSB9KTtcbiAgICAgICAgcmV0dXJuIFtzdGFydFRhZ1BoXS5jb25jYXQodGhpcy5zZXJpYWxpemUocGguY2hpbGRyZW4pLCBbY2xvc2VUYWdQaF0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Xcml0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUcsIHsgaWQ6IHBoLm5hbWUgfSldO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Xcml0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWN1UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUcsIHsgaWQ6IHBoLm5hbWUgfSldO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2Rlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1dyaXRlVmlzaXRvci5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKG5vZGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIG5vZGVzLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcyk7IH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBfV3JpdGVWaXNpdG9yO1xufSgpKTtcbnZhciBYbGlmZlBhcnNlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWGxpZmZQYXJzZXIoKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsZSA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30geGxpZmZcbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWGxpZmZQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHhsaWZmLCB1cmwpIHtcbiAgICAgICAgdGhpcy5fdW5pdE1sU3RyaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbXNnSWRUb0h0bWwgPSB7fTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8geG1sID0gbmV3IFhtbFBhcnNlcigpLnBhcnNlKHhsaWZmLCB1cmwsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fZXJyb3JzID0geG1sLmVycm9ycztcbiAgICAgICAgdmlzaXRBbGwodGhpcywgeG1sLnJvb3ROb2RlcywgbnVsbCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtc2dJZFRvSHRtbDogdGhpcy5fbXNnSWRUb0h0bWwsXG4gICAgICAgICAgICBlcnJvcnM6IHRoaXMuX2Vycm9ycyxcbiAgICAgICAgICAgIGxvY2FsZTogdGhpcy5fbG9jYWxlLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbGlmZlBhcnNlci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRleHQpIHtcbiAgICAgICAgc3dpdGNoIChlbGVtZW50Lm5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgX1VOSVRfVEFHOlxuICAgICAgICAgICAgICAgIHRoaXMuX3VuaXRNbFN0cmluZyA9ICgobnVsbCkpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlkQXR0ciA9IGVsZW1lbnQuYXR0cnMuZmluZChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lID09PSAnaWQnOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWlkQXR0cikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBcIjxcIiArIF9VTklUX1RBRyArIFwiPiBtaXNzZXMgdGhlIFxcXCJpZFxcXCIgYXR0cmlidXRlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaWQgPSBpZEF0dHIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tc2dJZFRvSHRtbC5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsZW1lbnQsIFwiRHVwbGljYXRlZCB0cmFuc2xhdGlvbnMgZm9yIG1zZyBcIiArIGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0QWxsKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4sIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl91bml0TWxTdHJpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbXNnSWRUb0h0bWxbaWRdID0gdGhpcy5fdW5pdE1sU3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgXCJNZXNzYWdlIFwiICsgaWQgKyBcIiBtaXNzZXMgYSB0cmFuc2xhdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgX1NPVVJDRV9UQUc6XG4gICAgICAgICAgICAgICAgLy8gaWdub3JlIHNvdXJjZSBtZXNzYWdlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIF9UQVJHRVRfVEFHOlxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlubmVyVGV4dFN0YXJ0ID0gKChlbGVtZW50LnN0YXJ0U291cmNlU3BhbikpLmVuZC5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5uZXJUZXh0RW5kID0gKChlbGVtZW50LmVuZFNvdXJjZVNwYW4pKS5zdGFydC5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udGVudCA9ICgoZWxlbWVudC5zdGFydFNvdXJjZVNwYW4pKS5zdGFydC5maWxlLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5uZXJUZXh0ID0gY29udGVudC5zbGljZShpbm5lclRleHRTdGFydCwgaW5uZXJUZXh0RW5kKTtcbiAgICAgICAgICAgICAgICB0aGlzLl91bml0TWxTdHJpbmcgPSBpbm5lclRleHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIF9GSUxFX1RBRzpcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsb2NhbGVBdHRyID0gZWxlbWVudC5hdHRycy5maW5kKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUgPT09ICd0YXJnZXQtbGFuZ3VhZ2UnOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlQXR0cikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBsb2NhbGVBdHRyLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2aXNpdEFsbCh0aGlzLCBlbGVtZW50LmNoaWxkcmVuLCBudWxsKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gVE9ETyh2aWNiKTogYXNzZXJ0IGZpbGUgc3RydWN0dXJlLCB4bGlmZiB2ZXJzaW9uXG4gICAgICAgICAgICAgICAgLy8gRm9yIG5vdyBvbmx5IHJlY3Vyc2Ugb24gdW5oYW5kbGVkIG5vZGVzXG4gICAgICAgICAgICAgICAgdmlzaXRBbGwodGhpcywgZWxlbWVudC5jaGlsZHJlbiwgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXR0cmlidXRlXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbGlmZlBhcnNlci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZXh0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbGlmZlBhcnNlci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhsaWZmUGFyc2VyLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwYW5zaW9uXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbGlmZlBhcnNlci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb24gPSBmdW5jdGlvbiAoZXhwYW5zaW9uLCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHBhbnNpb25DYXNlXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbGlmZlBhcnNlci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGV4cGFuc2lvbkNhc2UsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhsaWZmUGFyc2VyLnByb3RvdHlwZS5fYWRkRXJyb3IgPSBmdW5jdGlvbiAobm9kZSwgbWVzc2FnZSkge1xuICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChuZXcgSTE4bkVycm9yKC8qKiBAdHlwZSB7P30gKi8gKChub2RlLnNvdXJjZVNwYW4pKSwgbWVzc2FnZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFhsaWZmUGFyc2VyO1xufSgpKTtcbnZhciBYbWxUb0kxOG4gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFhtbFRvSTE4bigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtbFRvSTE4bi5wcm90b3R5cGUuY29udmVydCA9IGZ1bmN0aW9uIChtZXNzYWdlLCB1cmwpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8geG1sSWN1ID0gbmV3IFhtbFBhcnNlcigpLnBhcnNlKG1lc3NhZ2UsIHVybCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX2Vycm9ycyA9IHhtbEljdS5lcnJvcnM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGkxOG5Ob2RlcyA9IHRoaXMuX2Vycm9ycy5sZW5ndGggPiAwIHx8IHhtbEljdS5yb290Tm9kZXMubGVuZ3RoID09IDAgP1xuICAgICAgICAgICAgW10gOlxuICAgICAgICAgICAgdmlzaXRBbGwodGhpcywgeG1sSWN1LnJvb3ROb2Rlcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpMThuTm9kZXM6IGkxOG5Ob2RlcyxcbiAgICAgICAgICAgIGVycm9yczogdGhpcy5fZXJyb3JzLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZXh0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4ucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7IHJldHVybiBuZXcgVGV4dCQxKHRleHQudmFsdWUsIC8qKiBAdHlwZSB7P30gKi8gKCh0ZXh0LnNvdXJjZVNwYW4pKSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWG1sVG9JMThuLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWwsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGVsLm5hbWUgPT09IF9QTEFDRUhPTERFUl9UQUcpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWVBdHRyID0gZWwuYXR0cnMuZmluZChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lID09PSAnaWQnOyB9KTtcbiAgICAgICAgICAgIGlmIChuYW1lQXR0cikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUGxhY2Vob2xkZXIoJycsIG5hbWVBdHRyLnZhbHVlLCAvKiogQHR5cGUgez99ICovICgoZWwuc291cmNlU3BhbikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsLCBcIjxcIiArIF9QTEFDRUhPTERFUl9UQUcgKyBcIj4gbWlzc2VzIHRoZSBcXFwiaWRcXFwiIGF0dHJpYnV0ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsLCBcIlVuZXhwZWN0ZWQgdGFnXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpY3VcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtbFRvSTE4bi5wcm90b3R5cGUudmlzaXRFeHBhbnNpb24gPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNhc2VNYXAgPSB7fTtcbiAgICAgICAgdmlzaXRBbGwodGhpcywgaWN1LmNhc2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBjYXNlTWFwW2MudmFsdWVdID0gbmV3IENvbnRhaW5lcihjLm5vZGVzLCBpY3Uuc291cmNlU3Bhbik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IEljdShpY3Uuc3dpdGNoVmFsdWUsIGljdS50eXBlLCBjYXNlTWFwLCBpY3Uuc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGljdUNhc2VcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtbFRvSTE4bi5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGljdUNhc2UsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBpY3VDYXNlLnZhbHVlLFxuICAgICAgICAgICAgbm9kZXM6IHZpc2l0QWxsKHRoaXMsIGljdUNhc2UuZXhwcmVzc2lvbiksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtbFRvSTE4bi5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGF0dHJpYnV0ZVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWG1sVG9JMThuLnByb3RvdHlwZS52aXNpdEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtbFRvSTE4bi5wcm90b3R5cGUuX2FkZEVycm9yID0gZnVuY3Rpb24gKG5vZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IEkxOG5FcnJvcigvKiogQHR5cGUgez99ICovICgobm9kZS5zb3VyY2VTcGFuKSksIG1lc3NhZ2UpKTtcbiAgICB9O1xuICAgIHJldHVybiBYbWxUb0kxOG47XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IHRhZ1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZ2V0Q3R5cGVGb3JUYWcodGFnKSB7XG4gICAgc3dpdGNoICh0YWcudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICBjYXNlICdicic6XG4gICAgICAgICAgICByZXR1cm4gJ2xiJztcbiAgICAgICAgY2FzZSAnaW1nJzpcbiAgICAgICAgICAgIHJldHVybiAnaW1hZ2UnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFwieC1cIiArIHRhZztcbiAgICB9XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgX1ZFUlNJT04kMSA9ICcyLjAnO1xudmFyIF9YTUxOUyQxID0gJ3VybjpvYXNpczpuYW1lczp0Yzp4bGlmZjpkb2N1bWVudDoyLjAnO1xuLy8gVE9ETyh2aWNiKTogbWFrZSB0aGlzIGEgcGFyYW0gKHMvXy8tLylcbnZhciBfREVGQVVMVF9TT1VSQ0VfTEFORyQxID0gJ2VuJztcbnZhciBfUExBQ0VIT0xERVJfVEFHJDEgPSAncGgnO1xudmFyIF9QTEFDRUhPTERFUl9TUEFOTklOR19UQUcgPSAncGMnO1xudmFyIF9YTElGRl9UQUcgPSAneGxpZmYnO1xudmFyIF9TT1VSQ0VfVEFHJDEgPSAnc291cmNlJztcbnZhciBfVEFSR0VUX1RBRyQxID0gJ3RhcmdldCc7XG52YXIgX1VOSVRfVEFHJDEgPSAndW5pdCc7XG52YXIgWGxpZmYyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhYbGlmZjIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWGxpZmYyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZXNcbiAgICAgKiBAcGFyYW0gez99IGxvY2FsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWGxpZmYyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlcywgbG9jYWxlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0b3IgPSBuZXcgX1dyaXRlVmlzaXRvciQxKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVuaXRzID0gW107XG4gICAgICAgIG1lc3NhZ2VzLmZvckVhY2goZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVuaXQgPSBuZXcgVGFnKF9VTklUX1RBRyQxLCB7IGlkOiBtZXNzYWdlLmlkIH0pO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm90ZXMgPSBuZXcgVGFnKCdub3RlcycpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGVzY3JpcHRpb24gfHwgbWVzc2FnZS5tZWFuaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbm90ZXMuY2hpbGRyZW4ucHVzaChuZXcgQ1IoOCksIG5ldyBUYWcoJ25vdGUnLCB7IGNhdGVnb3J5OiAnZGVzY3JpcHRpb24nIH0sIFtuZXcgVGV4dCQyKG1lc3NhZ2UuZGVzY3JpcHRpb24pXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5tZWFuaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vdGVzLmNoaWxkcmVuLnB1c2gobmV3IENSKDgpLCBuZXcgVGFnKCdub3RlJywgeyBjYXRlZ29yeTogJ21lYW5pbmcnIH0sIFtuZXcgVGV4dCQyKG1lc3NhZ2UubWVhbmluZyldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVzc2FnZS5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIG5vdGVzLmNoaWxkcmVuLnB1c2gobmV3IENSKDgpLCBuZXcgVGFnKCdub3RlJywgeyBjYXRlZ29yeTogJ2xvY2F0aW9uJyB9LCBbXG4gICAgICAgICAgICAgICAgICAgIG5ldyBUZXh0JDIoc291cmNlLmZpbGVQYXRoICsgXCI6XCIgKyBzb3VyY2Uuc3RhcnRMaW5lICsgKHNvdXJjZS5lbmRMaW5lICE9PSBzb3VyY2Uuc3RhcnRMaW5lID8gJywnICsgc291cmNlLmVuZExpbmUgOiAnJykpXG4gICAgICAgICAgICAgICAgXSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBub3Rlcy5jaGlsZHJlbi5wdXNoKG5ldyBDUig2KSk7XG4gICAgICAgICAgICB1bml0LmNoaWxkcmVuLnB1c2gobmV3IENSKDYpLCBub3Rlcyk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZWdtZW50ID0gbmV3IFRhZygnc2VnbWVudCcpO1xuICAgICAgICAgICAgc2VnbWVudC5jaGlsZHJlbi5wdXNoKG5ldyBDUig4KSwgbmV3IFRhZyhfU09VUkNFX1RBRyQxLCB7fSwgdmlzaXRvci5zZXJpYWxpemUobWVzc2FnZS5ub2RlcykpLCBuZXcgQ1IoNikpO1xuICAgICAgICAgICAgdW5pdC5jaGlsZHJlbi5wdXNoKG5ldyBDUig2KSwgc2VnbWVudCwgbmV3IENSKDQpKTtcbiAgICAgICAgICAgIHVuaXRzLnB1c2gobmV3IENSKDQpLCB1bml0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZpbGUgPSBuZXcgVGFnKCdmaWxlJywgeyAnb3JpZ2luYWwnOiAnbmcudGVtcGxhdGUnLCBpZDogJ25naTE4bicgfSwgdW5pdHMuY29uY2F0KFtuZXcgQ1IoMildKSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHhsaWZmID0gbmV3IFRhZyhfWExJRkZfVEFHLCB7IHZlcnNpb246IF9WRVJTSU9OJDEsIHhtbG5zOiBfWE1MTlMkMSwgc3JjTGFuZzogbG9jYWxlIHx8IF9ERUZBVUxUX1NPVVJDRV9MQU5HJDEgfSwgW25ldyBDUigyKSwgZmlsZSwgbmV3IENSKCldKTtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShbXG4gICAgICAgICAgICBuZXcgRGVjbGFyYXRpb24oeyB2ZXJzaW9uOiAnMS4wJywgZW5jb2Rpbmc6ICdVVEYtOCcgfSksIG5ldyBDUigpLCB4bGlmZiwgbmV3IENSKClcbiAgICAgICAgXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbnRlbnRcbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWGxpZmYyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGNvbnRlbnQsIHVybCkge1xuICAgICAgICAvLyB4bGlmZiB0byB4bWwgbm9kZXNcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8geGxpZmYyUGFyc2VyID0gbmV3IFhsaWZmMlBhcnNlcigpO1xuICAgICAgICB2YXIgX2EgPSB4bGlmZjJQYXJzZXIucGFyc2UoY29udGVudCwgdXJsKSwgbG9jYWxlID0gX2EubG9jYWxlLCBtc2dJZFRvSHRtbCA9IF9hLm1zZ0lkVG9IdG1sLCBlcnJvcnMgPSBfYS5lcnJvcnM7XG4gICAgICAgIC8vIHhtbCBub2RlcyB0byBpMThuIG5vZGVzXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGkxOG5Ob2Rlc0J5TXNnSWQgPSB7fTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udmVydGVyID0gbmV3IFhtbFRvSTE4biQxKCk7XG4gICAgICAgIE9iamVjdC5rZXlzKG1zZ0lkVG9IdG1sKS5mb3JFYWNoKGZ1bmN0aW9uIChtc2dJZCkge1xuICAgICAgICAgICAgdmFyIF9hID0gY29udmVydGVyLmNvbnZlcnQobXNnSWRUb0h0bWxbbXNnSWRdLCB1cmwpLCBpMThuTm9kZXMgPSBfYS5pMThuTm9kZXMsIGUgPSBfYS5lcnJvcnM7XG4gICAgICAgICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIGUpO1xuICAgICAgICAgICAgaTE4bk5vZGVzQnlNc2dJZFttc2dJZF0gPSBpMThuTm9kZXM7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwieGxpZmYyIHBhcnNlIGVycm9yczpcXG5cIiArIGVycm9ycy5qb2luKCdcXG4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbG9jYWxlOiAvKiogQHR5cGUgez99ICovICgobG9jYWxlKSksIGkxOG5Ob2Rlc0J5TXNnSWQ6IGkxOG5Ob2Rlc0J5TXNnSWQgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWGxpZmYyLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAobWVzc2FnZSkgeyByZXR1cm4gZGVjaW1hbERpZ2VzdChtZXNzYWdlKTsgfTtcbiAgICByZXR1cm4gWGxpZmYyO1xufShTZXJpYWxpemVyKSk7XG52YXIgX1dyaXRlVmlzaXRvciQxID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBfV3JpdGVWaXNpdG9yJDEoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGV4dFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Xcml0ZVZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHsgcmV0dXJuIFtuZXcgVGV4dCQyKHRleHQudmFsdWUpXTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Xcml0ZVZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRDb250YWluZXIgPSBmdW5jdGlvbiAoY29udGFpbmVyLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVzID0gW107XG4gICAgICAgIGNvbnRhaW5lci5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2Rlcy5wdXNoLmFwcGx5KG5vZGVzLCBub2RlLnZpc2l0KF90aGlzKSk7IH0pO1xuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGljdVxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Xcml0ZVZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRJY3UgPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVzID0gW25ldyBUZXh0JDIoXCJ7XCIgKyBpY3UuZXhwcmVzc2lvblBsYWNlaG9sZGVyICsgXCIsIFwiICsgaWN1LnR5cGUgKyBcIiwgXCIpXTtcbiAgICAgICAgT2JqZWN0LmtleXMoaWN1LmNhc2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoLmFwcGx5KG5vZGVzLCBbbmV3IFRleHQkMihjICsgXCIge1wiKV0uY29uY2F0KGljdS5jYXNlc1tjXS52aXNpdChfdGhpcyksIFtuZXcgVGV4dCQyKFwifSBcIildKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBub2Rlcy5wdXNoKG5ldyBUZXh0JDIoXCJ9XCIpKTtcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Xcml0ZVZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRUYWdQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0eXBlID0gZ2V0VHlwZUZvclRhZyhwaC50YWcpO1xuICAgICAgICBpZiAocGguaXNWb2lkKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0YWdQaCA9IG5ldyBUYWcoX1BMQUNFSE9MREVSX1RBRyQxLCB7XG4gICAgICAgICAgICAgICAgaWQ6ICh0aGlzLl9uZXh0UGxhY2Vob2xkZXJJZCsrKS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGVxdWl2OiBwaC5zdGFydE5hbWUsXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICBkaXNwOiBcIjxcIiArIHBoLnRhZyArIFwiLz5cIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFt0YWdQaF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGFnUGMgPSBuZXcgVGFnKF9QTEFDRUhPTERFUl9TUEFOTklOR19UQUcsIHtcbiAgICAgICAgICAgIGlkOiAodGhpcy5fbmV4dFBsYWNlaG9sZGVySWQrKykudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGVxdWl2U3RhcnQ6IHBoLnN0YXJ0TmFtZSxcbiAgICAgICAgICAgIGVxdWl2RW5kOiBwaC5jbG9zZU5hbWUsXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgZGlzcFN0YXJ0OiBcIjxcIiArIHBoLnRhZyArIFwiPlwiLFxuICAgICAgICAgICAgZGlzcEVuZDogXCI8L1wiICsgcGgudGFnICsgXCI+XCIsXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlcyA9IFtdLmNvbmNhdC5hcHBseShbXSwgcGguY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnZpc2l0KF90aGlzKTsgfSkpO1xuICAgICAgICBpZiAobm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiB0YWdQYy5jaGlsZHJlbi5wdXNoKG5vZGUpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhZ1BjLmNoaWxkcmVuLnB1c2gobmV3IFRleHQkMignJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbdGFnUGNdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Xcml0ZVZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpZFN0ciA9ICh0aGlzLl9uZXh0UGxhY2Vob2xkZXJJZCsrKS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gW25ldyBUYWcoX1BMQUNFSE9MREVSX1RBRyQxLCB7XG4gICAgICAgICAgICAgICAgaWQ6IGlkU3RyLFxuICAgICAgICAgICAgICAgIGVxdWl2OiBwaC5uYW1lLFxuICAgICAgICAgICAgICAgIGRpc3A6IFwie3tcIiArIHBoLnZhbHVlICsgXCJ9fVwiLFxuICAgICAgICAgICAgfSldO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Xcml0ZVZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRJY3VQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjYXNlcyA9IE9iamVjdC5rZXlzKHBoLnZhbHVlLmNhc2VzKS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZSArICcgey4uLn0nOyB9KS5qb2luKCcgJyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlkU3RyID0gKHRoaXMuX25leHRQbGFjZWhvbGRlcklkKyspLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiBbbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHJDEsIHsgaWQ6IGlkU3RyLCBlcXVpdjogcGgubmFtZSwgZGlzcDogXCJ7XCIgKyBwaC52YWx1ZS5leHByZXNzaW9uICsgXCIsIFwiICsgcGgudmFsdWUudHlwZSArIFwiLCBcIiArIGNhc2VzICsgXCJ9XCIgfSldO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2Rlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1dyaXRlVmlzaXRvciQxLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAobm9kZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fbmV4dFBsYWNlaG9sZGVySWQgPSAwO1xuICAgICAgICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCBub2Rlcy5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3RoaXMpOyB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gX1dyaXRlVmlzaXRvciQxO1xufSgpKTtcbnZhciBYbGlmZjJQYXJzZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFhsaWZmMlBhcnNlcigpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxlID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB4bGlmZlxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbGlmZjJQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHhsaWZmLCB1cmwpIHtcbiAgICAgICAgdGhpcy5fdW5pdE1sU3RyaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbXNnSWRUb0h0bWwgPSB7fTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8geG1sID0gbmV3IFhtbFBhcnNlcigpLnBhcnNlKHhsaWZmLCB1cmwsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fZXJyb3JzID0geG1sLmVycm9ycztcbiAgICAgICAgdmlzaXRBbGwodGhpcywgeG1sLnJvb3ROb2RlcywgbnVsbCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtc2dJZFRvSHRtbDogdGhpcy5fbXNnSWRUb0h0bWwsXG4gICAgICAgICAgICBlcnJvcnM6IHRoaXMuX2Vycm9ycyxcbiAgICAgICAgICAgIGxvY2FsZTogdGhpcy5fbG9jYWxlLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbGlmZjJQYXJzZXIucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb250ZXh0KSB7XG4gICAgICAgIHN3aXRjaCAoZWxlbWVudC5uYW1lKSB7XG4gICAgICAgICAgICBjYXNlIF9VTklUX1RBRyQxOlxuICAgICAgICAgICAgICAgIHRoaXMuX3VuaXRNbFN0cmluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaWRBdHRyID0gZWxlbWVudC5hdHRycy5maW5kKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUgPT09ICdpZCc7IH0pO1xuICAgICAgICAgICAgICAgIGlmICghaWRBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsZW1lbnQsIFwiPFwiICsgX1VOSVRfVEFHJDEgKyBcIj4gbWlzc2VzIHRoZSBcXFwiaWRcXFwiIGF0dHJpYnV0ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlkID0gaWRBdHRyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbXNnSWRUb0h0bWwuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBcIkR1cGxpY2F0ZWQgdHJhbnNsYXRpb25zIGZvciBtc2cgXCIgKyBpZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpdEFsbCh0aGlzLCBlbGVtZW50LmNoaWxkcmVuLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5fdW5pdE1sU3RyaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21zZ0lkVG9IdG1sW2lkXSA9IHRoaXMuX3VuaXRNbFN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsZW1lbnQsIFwiTWVzc2FnZSBcIiArIGlkICsgXCIgbWlzc2VzIGEgdHJhbnNsYXRpb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIF9TT1VSQ0VfVEFHJDE6XG4gICAgICAgICAgICAgICAgLy8gaWdub3JlIHNvdXJjZSBtZXNzYWdlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIF9UQVJHRVRfVEFHJDE6XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5uZXJUZXh0U3RhcnQgPSAoKGVsZW1lbnQuc3RhcnRTb3VyY2VTcGFuKSkuZW5kLm9mZnNldDtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbm5lclRleHRFbmQgPSAoKGVsZW1lbnQuZW5kU291cmNlU3BhbikpLnN0YXJ0Lm9mZnNldDtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250ZW50ID0gKChlbGVtZW50LnN0YXJ0U291cmNlU3BhbikpLnN0YXJ0LmZpbGUuY29udGVudDtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbm5lclRleHQgPSBjb250ZW50LnNsaWNlKGlubmVyVGV4dFN0YXJ0LCBpbm5lclRleHRFbmQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VuaXRNbFN0cmluZyA9IGlubmVyVGV4dDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgX1hMSUZGX1RBRzpcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsb2NhbGVBdHRyID0gZWxlbWVudC5hdHRycy5maW5kKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUgPT09ICd0cmdMYW5nJzsgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZUF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxlID0gbG9jYWxlQXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmVyc2lvbkF0dHIgPSBlbGVtZW50LmF0dHJzLmZpbmQoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuIGF0dHIubmFtZSA9PT0gJ3ZlcnNpb24nOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAodmVyc2lvbkF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmVyc2lvbiA9IHZlcnNpb25BdHRyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmVyc2lvbiAhPT0gJzIuMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsZW1lbnQsIFwiVGhlIFhMSUZGIGZpbGUgdmVyc2lvbiBcIiArIHZlcnNpb24gKyBcIiBpcyBub3QgY29tcGF0aWJsZSB3aXRoIFhMSUZGIDIuMCBzZXJpYWxpemVyXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRBbGwodGhpcywgZWxlbWVudC5jaGlsZHJlbiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHZpc2l0QWxsKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4sIG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGF0dHJpYnV0ZVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWGxpZmYyUGFyc2VyLnByb3RvdHlwZS52aXNpdEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRleHRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhsaWZmMlBhcnNlci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhsaWZmMlBhcnNlci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cGFuc2lvblxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWGxpZmYyUGFyc2VyLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChleHBhbnNpb24sIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cGFuc2lvbkNhc2VcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhsaWZmMlBhcnNlci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGV4cGFuc2lvbkNhc2UsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhsaWZmMlBhcnNlci5wcm90b3R5cGUuX2FkZEVycm9yID0gZnVuY3Rpb24gKG5vZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IEkxOG5FcnJvcihub2RlLnNvdXJjZVNwYW4sIG1lc3NhZ2UpKTtcbiAgICB9O1xuICAgIHJldHVybiBYbGlmZjJQYXJzZXI7XG59KCkpO1xudmFyIFhtbFRvSTE4biQxID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBYbWxUb0kxOG4kMSgpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtbFRvSTE4biQxLnByb3RvdHlwZS5jb252ZXJ0ID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHVybCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB4bWxJY3UgPSBuZXcgWG1sUGFyc2VyKCkucGFyc2UobWVzc2FnZSwgdXJsLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fZXJyb3JzID0geG1sSWN1LmVycm9ycztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaTE4bk5vZGVzID0gdGhpcy5fZXJyb3JzLmxlbmd0aCA+IDAgfHwgeG1sSWN1LnJvb3ROb2Rlcy5sZW5ndGggPT0gMCA/XG4gICAgICAgICAgICBbXSA6IFtdLmNvbmNhdC5hcHBseShbXSwgdmlzaXRBbGwodGhpcywgeG1sSWN1LnJvb3ROb2RlcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaTE4bk5vZGVzOiBpMThuTm9kZXMsXG4gICAgICAgICAgICBlcnJvcnM6IHRoaXMuX2Vycm9ycyxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGV4dFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWG1sVG9JMThuJDEucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7IHJldHVybiBuZXcgVGV4dCQxKHRleHQudmFsdWUsIHRleHQuc291cmNlU3Bhbik7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWG1sVG9JMThuJDEucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBzd2l0Y2ggKGVsLm5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgX1BMQUNFSE9MREVSX1RBRyQxOlxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWVBdHRyID0gZWwuYXR0cnMuZmluZChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lID09PSAnZXF1aXYnOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZUF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtuZXcgUGxhY2Vob2xkZXIoJycsIG5hbWVBdHRyLnZhbHVlLCBlbC5zb3VyY2VTcGFuKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsLCBcIjxcIiArIF9QTEFDRUhPTERFUl9UQUckMSArIFwiPiBtaXNzZXMgdGhlIFxcXCJlcXVpdlxcXCIgYXR0cmlidXRlXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBfUExBQ0VIT0xERVJfU1BBTk5JTkdfVEFHOlxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0QXR0ciA9IGVsLmF0dHJzLmZpbmQoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuIGF0dHIubmFtZSA9PT0gJ2VxdWl2U3RhcnQnOyB9KTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbmRBdHRyID0gZWwuYXR0cnMuZmluZChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lID09PSAnZXF1aXZFbmQnOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXJ0QXR0cikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbCwgXCI8XCIgKyBfUExBQ0VIT0xERVJfVEFHJDEgKyBcIj4gbWlzc2VzIHRoZSBcXFwiZXF1aXZTdGFydFxcXCIgYXR0cmlidXRlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghZW5kQXR0cikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbCwgXCI8XCIgKyBfUExBQ0VIT0xERVJfVEFHJDEgKyBcIj4gbWlzc2VzIHRoZSBcXFwiZXF1aXZFbmRcXFwiIGF0dHJpYnV0ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0SWQgPSBzdGFydEF0dHIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVuZElkID0gZW5kQXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVzLmNvbmNhdC5hcHBseShub2RlcywgW25ldyBQbGFjZWhvbGRlcignJywgc3RhcnRJZCwgZWwuc291cmNlU3BhbildLmNvbmNhdChlbC5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3RoaXMsIG51bGwpOyB9KSwgW25ldyBQbGFjZWhvbGRlcignJywgZW5kSWQsIGVsLnNvdXJjZVNwYW4pXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWwsIFwiVW5leHBlY3RlZCB0YWdcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGljdVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWG1sVG9JMThuJDEucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGljdSwgY29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjYXNlTWFwID0ge307XG4gICAgICAgIHZpc2l0QWxsKHRoaXMsIGljdS5jYXNlcykuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgY2FzZU1hcFtjLnZhbHVlXSA9IG5ldyBDb250YWluZXIoYy5ub2RlcywgaWN1LnNvdXJjZVNwYW4pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBJY3UoaWN1LnN3aXRjaFZhbHVlLCBpY3UudHlwZSwgY2FzZU1hcCwgaWN1LnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpY3VDYXNlXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4kMS5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGljdUNhc2UsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBpY3VDYXNlLnZhbHVlLFxuICAgICAgICAgICAgbm9kZXM6IFtdLmNvbmNhdC5hcHBseShbXSwgdmlzaXRBbGwodGhpcywgaWN1Q2FzZS5leHByZXNzaW9uKSksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtbFRvSTE4biQxLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXR0cmlidXRlXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4kMS5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4kMS5wcm90b3R5cGUuX2FkZEVycm9yID0gZnVuY3Rpb24gKG5vZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IEkxOG5FcnJvcihub2RlLnNvdXJjZVNwYW4sIG1lc3NhZ2UpKTtcbiAgICB9O1xuICAgIHJldHVybiBYbWxUb0kxOG4kMTtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gdGFnXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBnZXRUeXBlRm9yVGFnKHRhZykge1xuICAgIHN3aXRjaCAodGFnLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgY2FzZSAnYnInOlxuICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgY2FzZSAnaSc6XG4gICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICAgICAgcmV0dXJuICdmbXQnO1xuICAgICAgICBjYXNlICdpbWcnOlxuICAgICAgICAgICAgcmV0dXJuICdpbWFnZSc7XG4gICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgcmV0dXJuICdsaW5rJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAnb3RoZXInO1xuICAgIH1cbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBfTUVTU0FHRVNfVEFHID0gJ21lc3NhZ2VidW5kbGUnO1xudmFyIF9NRVNTQUdFX1RBRyA9ICdtc2cnO1xudmFyIF9QTEFDRUhPTERFUl9UQUckMiA9ICdwaCc7XG52YXIgX0VYRU1QTEVfVEFHID0gJ2V4JztcbnZhciBfU09VUkNFX1RBRyQyID0gJ3NvdXJjZSc7XG52YXIgX0RPQ1RZUEUgPSBcIjwhRUxFTUVOVCBtZXNzYWdlYnVuZGxlIChtc2cpKj5cXG48IUFUVExJU1QgbWVzc2FnZWJ1bmRsZSBjbGFzcyBDREFUQSAjSU1QTElFRD5cXG5cXG48IUVMRU1FTlQgbXNnICgjUENEQVRBfHBofHNvdXJjZSkqPlxcbjwhQVRUTElTVCBtc2cgaWQgQ0RBVEEgI0lNUExJRUQ+XFxuPCFBVFRMSVNUIG1zZyBzZXEgQ0RBVEEgI0lNUExJRUQ+XFxuPCFBVFRMSVNUIG1zZyBuYW1lIENEQVRBICNJTVBMSUVEPlxcbjwhQVRUTElTVCBtc2cgZGVzYyBDREFUQSAjSU1QTElFRD5cXG48IUFUVExJU1QgbXNnIG1lYW5pbmcgQ0RBVEEgI0lNUExJRUQ+XFxuPCFBVFRMSVNUIG1zZyBvYnNvbGV0ZSAob2Jzb2xldGUpICNJTVBMSUVEPlxcbjwhQVRUTElTVCBtc2cgeG1sOnNwYWNlIChkZWZhdWx0fHByZXNlcnZlKSBcXFwiZGVmYXVsdFxcXCI+XFxuPCFBVFRMSVNUIG1zZyBpc19oaWRkZW4gQ0RBVEEgI0lNUExJRUQ+XFxuXFxuPCFFTEVNRU5UIHNvdXJjZSAoI1BDREFUQSk+XFxuXFxuPCFFTEVNRU5UIHBoICgjUENEQVRBfGV4KSo+XFxuPCFBVFRMSVNUIHBoIG5hbWUgQ0RBVEEgI1JFUVVJUkVEPlxcblxcbjwhRUxFTUVOVCBleCAoI1BDREFUQSk+XCI7XG52YXIgWG1iID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhYbWIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWG1iKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZXNcbiAgICAgKiBAcGFyYW0gez99IGxvY2FsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWG1iLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlcywgbG9jYWxlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4YW1wbGVWaXNpdG9yID0gbmV3IEV4YW1wbGVWaXNpdG9yKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0b3IgPSBuZXcgX1Zpc2l0b3IkMigpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByb290Tm9kZSA9IG5ldyBUYWcoX01FU1NBR0VTX1RBRyk7XG4gICAgICAgIG1lc3NhZ2VzLmZvckVhY2goZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGF0dHJzID0geyBpZDogbWVzc2FnZS5pZCB9O1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICBhdHRyc1snZGVzYyddID0gbWVzc2FnZS5kZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1lYW5pbmcpIHtcbiAgICAgICAgICAgICAgICBhdHRyc1snbWVhbmluZyddID0gbWVzc2FnZS5tZWFuaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlVGFncyA9IFtdO1xuICAgICAgICAgICAgbWVzc2FnZS5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZVRhZ3MucHVzaChuZXcgVGFnKF9TT1VSQ0VfVEFHJDIsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIG5ldyBUZXh0JDIoc291cmNlLmZpbGVQYXRoICsgXCI6XCIgKyBzb3VyY2Uuc3RhcnRMaW5lICsgKHNvdXJjZS5lbmRMaW5lICE9PSBzb3VyY2Uuc3RhcnRMaW5lID8gJywnICsgc291cmNlLmVuZExpbmUgOiAnJykpXG4gICAgICAgICAgICAgICAgXSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByb290Tm9kZS5jaGlsZHJlbi5wdXNoKG5ldyBDUigyKSwgbmV3IFRhZyhfTUVTU0FHRV9UQUcsIGF0dHJzLCBzb3VyY2VUYWdzLmNvbmNhdCh2aXNpdG9yLnNlcmlhbGl6ZShtZXNzYWdlLm5vZGVzKSkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJvb3ROb2RlLmNoaWxkcmVuLnB1c2gobmV3IENSKCkpO1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplKFtcbiAgICAgICAgICAgIG5ldyBEZWNsYXJhdGlvbih7IHZlcnNpb246ICcxLjAnLCBlbmNvZGluZzogJ1VURi04JyB9KSxcbiAgICAgICAgICAgIG5ldyBDUigpLFxuICAgICAgICAgICAgbmV3IERvY3R5cGUoX01FU1NBR0VTX1RBRywgX0RPQ1RZUEUpLFxuICAgICAgICAgICAgbmV3IENSKCksXG4gICAgICAgICAgICBleGFtcGxlVmlzaXRvci5hZGREZWZhdWx0RXhhbXBsZXMocm9vdE5vZGUpLFxuICAgICAgICAgICAgbmV3IENSKCksXG4gICAgICAgIF0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb250ZW50XG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtYi5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChjb250ZW50LCB1cmwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWIucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7IHJldHVybiBkaWdlc3QkMShtZXNzYWdlKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtYi5wcm90b3R5cGUuY3JlYXRlTmFtZU1hcHBlciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2ltcGxlUGxhY2Vob2xkZXJNYXBwZXIobWVzc2FnZSwgdG9QdWJsaWNOYW1lKTtcbiAgICB9O1xuICAgIHJldHVybiBYbWI7XG59KFNlcmlhbGl6ZXIpKTtcbnZhciBfVmlzaXRvciQyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBfVmlzaXRvciQyKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRleHRcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmlzaXRvciQyLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkgeyByZXR1cm4gW25ldyBUZXh0JDIodGV4dC52YWx1ZSldOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29udGFpbmVyXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmlzaXRvciQyLnByb3RvdHlwZS52aXNpdENvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXIsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZXMgPSBbXTtcbiAgICAgICAgY29udGFpbmVyLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGVzLnB1c2guYXBwbHkobm9kZXMsIG5vZGUudmlzaXQoX3RoaXMpKTsgfSk7XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWN1XG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IkMi5wcm90b3R5cGUudmlzaXRJY3UgPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVzID0gW25ldyBUZXh0JDIoXCJ7XCIgKyBpY3UuZXhwcmVzc2lvblBsYWNlaG9sZGVyICsgXCIsIFwiICsgaWN1LnR5cGUgKyBcIiwgXCIpXTtcbiAgICAgICAgT2JqZWN0LmtleXMoaWN1LmNhc2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoLmFwcGx5KG5vZGVzLCBbbmV3IFRleHQkMihjICsgXCIge1wiKV0uY29uY2F0KGljdS5jYXNlc1tjXS52aXNpdChfdGhpcyksIFtuZXcgVGV4dCQyKFwifSBcIildKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBub2Rlcy5wdXNoKG5ldyBUZXh0JDIoXCJ9XCIpKTtcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9WaXNpdG9yJDIucHJvdG90eXBlLnZpc2l0VGFnUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnRFeCA9IG5ldyBUYWcoX0VYRU1QTEVfVEFHLCB7fSwgW25ldyBUZXh0JDIoXCI8XCIgKyBwaC50YWcgKyBcIj5cIildKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnRUYWdQaCA9IG5ldyBUYWcoX1BMQUNFSE9MREVSX1RBRyQyLCB7IG5hbWU6IHBoLnN0YXJ0TmFtZSB9LCBbc3RhcnRFeF0pO1xuICAgICAgICBpZiAocGguaXNWb2lkKSB7XG4gICAgICAgICAgICAvLyB2b2lkIHRhZ3MgaGF2ZSBubyBjaGlsZHJlbiBub3IgY2xvc2luZyB0YWdzXG4gICAgICAgICAgICByZXR1cm4gW3N0YXJ0VGFnUGhdO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsb3NlRXggPSBuZXcgVGFnKF9FWEVNUExFX1RBRywge30sIFtuZXcgVGV4dCQyKFwiPC9cIiArIHBoLnRhZyArIFwiPlwiKV0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbG9zZVRhZ1BoID0gbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHJDIsIHsgbmFtZTogcGguY2xvc2VOYW1lIH0sIFtjbG9zZUV4XSk7XG4gICAgICAgIHJldHVybiBbc3RhcnRUYWdQaF0uY29uY2F0KHRoaXMuc2VyaWFsaXplKHBoLmNoaWxkcmVuKSwgW2Nsb3NlVGFnUGhdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGhcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmlzaXRvciQyLnByb3RvdHlwZS52aXNpdFBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBbbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHJDIsIHsgbmFtZTogcGgubmFtZSB9KV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBoXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IkMi5wcm90b3R5cGUudmlzaXRJY3VQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gW25ldyBUYWcoX1BMQUNFSE9MREVSX1RBRyQyLCB7IG5hbWU6IHBoLm5hbWUgfSldO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2Rlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IkMi5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKG5vZGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIG5vZGVzLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcyk7IH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBfVmlzaXRvciQyO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBkaWdlc3QkMShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIGRlY2ltYWxEaWdlc3QobWVzc2FnZSk7XG59XG52YXIgRXhhbXBsZVZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV4YW1wbGVWaXNpdG9yKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4YW1wbGVWaXNpdG9yLnByb3RvdHlwZS5hZGREZWZhdWx0RXhhbXBsZXMgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBub2RlLnZpc2l0KHRoaXMpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGFnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeGFtcGxlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0YWcubmFtZSA9PT0gX1BMQUNFSE9MREVSX1RBRyQyKSB7XG4gICAgICAgICAgICBpZiAoIXRhZy5jaGlsZHJlbiB8fCB0YWcuY2hpbGRyZW4ubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleFRleHQgPSBuZXcgVGV4dCQyKHRhZy5hdHRyc1snbmFtZSddIHx8ICcuLi4nKTtcbiAgICAgICAgICAgICAgICB0YWcuY2hpbGRyZW4gPSBbbmV3IFRhZyhfRVhFTVBMRV9UQUcsIHt9LCBbZXhUZXh0XSldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRhZy5jaGlsZHJlbikge1xuICAgICAgICAgICAgdGFnLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3RoaXMpOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeGFtcGxlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRlY2xcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4YW1wbGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmF0aW9uID0gZnVuY3Rpb24gKGRlY2wpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRvY3R5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4YW1wbGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdERvY3R5cGUgPSBmdW5jdGlvbiAoZG9jdHlwZSkgeyB9O1xuICAgIHJldHVybiBFeGFtcGxlVmlzaXRvcjtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gaW50ZXJuYWxOYW1lXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB0b1B1YmxpY05hbWUoaW50ZXJuYWxOYW1lKSB7XG4gICAgcmV0dXJuIGludGVybmFsTmFtZS50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoL1teQS1aMC05X10vZywgJ18nKTtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBfVFJBTlNMQVRJT05TX1RBRyA9ICd0cmFuc2xhdGlvbmJ1bmRsZSc7XG52YXIgX1RSQU5TTEFUSU9OX1RBRyA9ICd0cmFuc2xhdGlvbic7XG52YXIgX1BMQUNFSE9MREVSX1RBRyQzID0gJ3BoJztcbnZhciBYdGIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFh0YiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBYdGIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlc1xuICAgICAqIEBwYXJhbSB7P30gbG9jYWxlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYdGIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKG1lc3NhZ2VzLCBsb2NhbGUpIHsgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCcpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29udGVudFxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYdGIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoY29udGVudCwgdXJsKSB7XG4gICAgICAgIC8vIHh0YiB0byB4bWwgbm9kZXNcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8geHRiUGFyc2VyID0gbmV3IFh0YlBhcnNlcigpO1xuICAgICAgICB2YXIgX2EgPSB4dGJQYXJzZXIucGFyc2UoY29udGVudCwgdXJsKSwgbG9jYWxlID0gX2EubG9jYWxlLCBtc2dJZFRvSHRtbCA9IF9hLm1zZ0lkVG9IdG1sLCBlcnJvcnMgPSBfYS5lcnJvcnM7XG4gICAgICAgIC8vIHhtbCBub2RlcyB0byBpMThuIG5vZGVzXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGkxOG5Ob2Rlc0J5TXNnSWQgPSB7fTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udmVydGVyID0gbmV3IFhtbFRvSTE4biQyKCk7XG4gICAgICAgIC8vIEJlY2F1c2Ugd2Ugc2hvdWxkIGJlIGFibGUgdG8gbG9hZCB4dGIgZmlsZXMgdGhhdCByZWx5IG9uIGZlYXR1cmVzIG5vdCBzdXBwb3J0ZWQgYnkgYW5ndWxhcixcbiAgICAgICAgLy8gd2UgbmVlZCB0byBkZWxheSB0aGUgY29udmVyc2lvbiBvZiBodG1sIHRvIGkxOG4gbm9kZXMgc28gdGhhdCBub24gYW5ndWxhciBtZXNzYWdlcyBhcmUgbm90XG4gICAgICAgIC8vIGNvbnZlcnRlZFxuICAgICAgICBPYmplY3Qua2V5cyhtc2dJZFRvSHRtbCkuZm9yRWFjaChmdW5jdGlvbiAobXNnSWQpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlRm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gY29udmVydGVyLmNvbnZlcnQobXNnSWRUb0h0bWxbbXNnSWRdLCB1cmwpLCBpMThuTm9kZXMgPSBfYS5pMThuTm9kZXMsIGVycm9ycyA9IF9hLmVycm9ycztcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4dGIgcGFyc2UgZXJyb3JzOlxcblwiICsgZXJyb3JzLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkxOG5Ob2RlcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjcmVhdGVMYXp5UHJvcGVydHkoaTE4bk5vZGVzQnlNc2dJZCwgbXNnSWQsIHZhbHVlRm4pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInh0YiBwYXJzZSBlcnJvcnM6XFxuXCIgKyBlcnJvcnMuam9pbignXFxuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGxvY2FsZTogLyoqIEB0eXBlIHs/fSAqLyAoKGxvY2FsZSkpLCBpMThuTm9kZXNCeU1zZ0lkOiBpMThuTm9kZXNCeU1zZ0lkIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFh0Yi5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHsgcmV0dXJuIGRpZ2VzdCQxKG1lc3NhZ2UpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWHRiLnByb3RvdHlwZS5jcmVhdGVOYW1lTWFwcGVyID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTaW1wbGVQbGFjZWhvbGRlck1hcHBlcihtZXNzYWdlLCB0b1B1YmxpY05hbWUpO1xuICAgIH07XG4gICAgcmV0dXJuIFh0Yjtcbn0oU2VyaWFsaXplcikpO1xuLyoqXG4gKiBAcGFyYW0gez99IG1lc3NhZ2VzXG4gKiBAcGFyYW0gez99IGlkXG4gKiBAcGFyYW0gez99IHZhbHVlRm5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUxhenlQcm9wZXJ0eShtZXNzYWdlcywgaWQsIHZhbHVlRm4pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWVzc2FnZXMsIGlkLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IHZhbHVlRm4oKTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXNzYWdlcywgaWQsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfKSB7IHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IG92ZXJ3cml0ZSBhbiBYVEIgdHJhbnNsYXRpb24nKTsgfSxcbiAgICB9KTtcbn1cbnZhciBYdGJQYXJzZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFh0YlBhcnNlcigpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxlID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB4dGJcbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWHRiUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICh4dGIsIHVybCkge1xuICAgICAgICB0aGlzLl9idW5kbGVEZXB0aCA9IDA7XG4gICAgICAgIHRoaXMuX21zZ0lkVG9IdG1sID0ge307XG4gICAgICAgIC8vIFdlIGNhbiBub3QgcGFyc2UgdGhlIElDVSBtZXNzYWdlcyBhdCB0aGlzIHBvaW50IGFzIHNvbWUgbWVzc2FnZXMgbWlnaHQgbm90IG9yaWdpbmF0ZVxuICAgICAgICAvLyBmcm9tIEFuZ3VsYXIgdGhhdCBjb3VsZCBub3QgYmUgbGV4J2QuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHhtbCA9IG5ldyBYbWxQYXJzZXIoKS5wYXJzZSh4dGIsIHVybCwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9lcnJvcnMgPSB4bWwuZXJyb3JzO1xuICAgICAgICB2aXNpdEFsbCh0aGlzLCB4bWwucm9vdE5vZGVzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1zZ0lkVG9IdG1sOiB0aGlzLl9tc2dJZFRvSHRtbCxcbiAgICAgICAgICAgIGVycm9yczogdGhpcy5fZXJyb3JzLFxuICAgICAgICAgICAgbG9jYWxlOiB0aGlzLl9sb2NhbGUsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFh0YlBhcnNlci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRleHQpIHtcbiAgICAgICAgc3dpdGNoIChlbGVtZW50Lm5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgX1RSQU5TTEFUSU9OU19UQUc6XG4gICAgICAgICAgICAgICAgdGhpcy5fYnVuZGxlRGVwdGgrKztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYnVuZGxlRGVwdGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsZW1lbnQsIFwiPFwiICsgX1RSQU5TTEFUSU9OU19UQUcgKyBcIj4gZWxlbWVudHMgY2FuIG5vdCBiZSBuZXN0ZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxhbmdBdHRyID0gZWxlbWVudC5hdHRycy5maW5kKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUgPT09ICdsYW5nJzsgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGxhbmdBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvY2FsZSA9IGxhbmdBdHRyLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2aXNpdEFsbCh0aGlzLCBlbGVtZW50LmNoaWxkcmVuLCBudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9idW5kbGVEZXB0aC0tO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBfVFJBTlNMQVRJT05fVEFHOlxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlkQXR0ciA9IGVsZW1lbnQuYXR0cnMuZmluZChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lID09PSAnaWQnOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWlkQXR0cikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBcIjxcIiArIF9UUkFOU0xBVElPTl9UQUcgKyBcIj4gbWlzc2VzIHRoZSBcXFwiaWRcXFwiIGF0dHJpYnV0ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlkID0gaWRBdHRyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbXNnSWRUb0h0bWwuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBcIkR1cGxpY2F0ZWQgdHJhbnNsYXRpb25zIGZvciBtc2cgXCIgKyBpZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbm5lclRleHRTdGFydCA9ICgoZWxlbWVudC5zdGFydFNvdXJjZVNwYW4pKS5lbmQub2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5uZXJUZXh0RW5kID0gKChlbGVtZW50LmVuZFNvdXJjZVNwYW4pKS5zdGFydC5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250ZW50ID0gKChlbGVtZW50LnN0YXJ0U291cmNlU3BhbikpLnN0YXJ0LmZpbGUuY29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlubmVyVGV4dCA9IGNvbnRlbnQuc2xpY2UoLyoqIEB0eXBlIHs/fSAqLyAoKGlubmVyVGV4dFN0YXJ0KSksIC8qKiBAdHlwZSB7P30gKi8gKChpbm5lclRleHRFbmQpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tc2dJZFRvSHRtbFtpZF0gPSBpbm5lclRleHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsZW1lbnQsICdVbmV4cGVjdGVkIHRhZycpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGF0dHJpYnV0ZVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWHRiUGFyc2VyLnByb3RvdHlwZS52aXNpdEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRleHRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFh0YlBhcnNlci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFh0YlBhcnNlci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cGFuc2lvblxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWHRiUGFyc2VyLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChleHBhbnNpb24sIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cGFuc2lvbkNhc2VcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFh0YlBhcnNlci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGV4cGFuc2lvbkNhc2UsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFh0YlBhcnNlci5wcm90b3R5cGUuX2FkZEVycm9yID0gZnVuY3Rpb24gKG5vZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IEkxOG5FcnJvcigvKiogQHR5cGUgez99ICovICgobm9kZS5zb3VyY2VTcGFuKSksIG1lc3NhZ2UpKTtcbiAgICB9O1xuICAgIHJldHVybiBYdGJQYXJzZXI7XG59KCkpO1xudmFyIFhtbFRvSTE4biQyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBYbWxUb0kxOG4kMigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtbFRvSTE4biQyLnByb3RvdHlwZS5jb252ZXJ0ID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHVybCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB4bWxJY3UgPSBuZXcgWG1sUGFyc2VyKCkucGFyc2UobWVzc2FnZSwgdXJsLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fZXJyb3JzID0geG1sSWN1LmVycm9ycztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaTE4bk5vZGVzID0gdGhpcy5fZXJyb3JzLmxlbmd0aCA+IDAgfHwgeG1sSWN1LnJvb3ROb2Rlcy5sZW5ndGggPT0gMCA/XG4gICAgICAgICAgICBbXSA6XG4gICAgICAgICAgICB2aXNpdEFsbCh0aGlzLCB4bWxJY3Uucm9vdE5vZGVzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGkxOG5Ob2RlczogaTE4bk5vZGVzLFxuICAgICAgICAgICAgZXJyb3JzOiB0aGlzLl9lcnJvcnMsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRleHRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtbFRvSTE4biQyLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkgeyByZXR1cm4gbmV3IFRleHQkMSh0ZXh0LnZhbHVlLCAvKiogQHR5cGUgez99ICovICgodGV4dC5zb3VyY2VTcGFuKSkpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWN1XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4kMi5wcm90b3R5cGUudmlzaXRFeHBhbnNpb24gPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNhc2VNYXAgPSB7fTtcbiAgICAgICAgdmlzaXRBbGwodGhpcywgaWN1LmNhc2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBjYXNlTWFwW2MudmFsdWVdID0gbmV3IENvbnRhaW5lcihjLm5vZGVzLCBpY3Uuc291cmNlU3Bhbik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IEljdShpY3Uuc3dpdGNoVmFsdWUsIGljdS50eXBlLCBjYXNlTWFwLCBpY3Uuc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGljdUNhc2VcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtbFRvSTE4biQyLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoaWN1Q2FzZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IGljdUNhc2UudmFsdWUsXG4gICAgICAgICAgICBub2RlczogdmlzaXRBbGwodGhpcywgaWN1Q2FzZS5leHByZXNzaW9uKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtbFRvSTE4biQyLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWwsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGVsLm5hbWUgPT09IF9QTEFDRUhPTERFUl9UQUckMykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZUF0dHIgPSBlbC5hdHRycy5maW5kKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUgPT09ICduYW1lJzsgfSk7XG4gICAgICAgICAgICBpZiAobmFtZUF0dHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBsYWNlaG9sZGVyKCcnLCBuYW1lQXR0ci52YWx1ZSwgLyoqIEB0eXBlIHs/fSAqLyAoKGVsLnNvdXJjZVNwYW4pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbCwgXCI8XCIgKyBfUExBQ0VIT0xERVJfVEFHJDMgKyBcIj4gbWlzc2VzIHRoZSBcXFwibmFtZVxcXCIgYXR0cmlidXRlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWwsIFwiVW5leHBlY3RlZCB0YWdcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtbFRvSTE4biQyLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXR0cmlidXRlXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4kMi5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4kMi5wcm90b3R5cGUuX2FkZEVycm9yID0gZnVuY3Rpb24gKG5vZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IEkxOG5FcnJvcigvKiogQHR5cGUgez99ICovICgobm9kZS5zb3VyY2VTcGFuKSksIG1lc3NhZ2UpKTtcbiAgICB9O1xuICAgIHJldHVybiBYbWxUb0kxOG4kMjtcbn0oKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgSHRtbFBhcnNlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSHRtbFBhcnNlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIdG1sUGFyc2VyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgZ2V0SHRtbFRhZ0RlZmluaXRpb24pIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc291cmNlXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcGFyYW0gez89fSBwYXJzZUV4cGFuc2lvbkZvcm1zXG4gICAgICogQHBhcmFtIHs/PX0gaW50ZXJwb2xhdGlvbkNvbmZpZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHRtbFBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCB1cmwsIHBhcnNlRXhwYW5zaW9uRm9ybXMsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgaWYgKHBhcnNlRXhwYW5zaW9uRm9ybXMgPT09IHZvaWQgMCkgeyBwYXJzZUV4cGFuc2lvbkZvcm1zID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKGludGVycG9sYXRpb25Db25maWcgPT09IHZvaWQgMCkgeyBpbnRlcnBvbGF0aW9uQ29uZmlnID0gREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRzsgfVxuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5wYXJzZS5jYWxsKHRoaXMsIHNvdXJjZSwgdXJsLCBwYXJzZUV4cGFuc2lvbkZvcm1zLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICB9O1xuICAgIHJldHVybiBIdG1sUGFyc2VyO1xufShQYXJzZXIkMSkpO1xuSHRtbFBhcnNlci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcGlsZXJJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5IdG1sUGFyc2VyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEEgY29udGFpbmVyIGZvciB0cmFuc2xhdGVkIG1lc3NhZ2VzXG4gKi9cbnZhciBUcmFuc2xhdGlvbkJ1bmRsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gX2kxOG5Ob2Rlc0J5TXNnSWRcbiAgICAgKiBAcGFyYW0gez89fSBsb2NhbGVcbiAgICAgKiBAcGFyYW0gez89fSBkaWdlc3RcbiAgICAgKiBAcGFyYW0gez89fSBtYXBwZXJGYWN0b3J5XG4gICAgICogQHBhcmFtIHs/PX0gbWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3lcbiAgICAgKiBAcGFyYW0gez89fSBjb25zb2xlXG4gICAgICovXG4gICAgZnVuY3Rpb24gVHJhbnNsYXRpb25CdW5kbGUoX2kxOG5Ob2Rlc0J5TXNnSWQsIGxvY2FsZSwgZGlnZXN0LCBtYXBwZXJGYWN0b3J5LCBtaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSwgY29uc29sZSkge1xuICAgICAgICBpZiAoX2kxOG5Ob2Rlc0J5TXNnSWQgPT09IHZvaWQgMCkgeyBfaTE4bk5vZGVzQnlNc2dJZCA9IHt9OyB9XG4gICAgICAgIGlmIChtaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSA9PT0gdm9pZCAwKSB7IG1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5ID0gTWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kuV2FybmluZzsgfVxuICAgICAgICB0aGlzLl9pMThuTm9kZXNCeU1zZ0lkID0gX2kxOG5Ob2Rlc0J5TXNnSWQ7XG4gICAgICAgIHRoaXMuZGlnZXN0ID0gZGlnZXN0O1xuICAgICAgICB0aGlzLm1hcHBlckZhY3RvcnkgPSBtYXBwZXJGYWN0b3J5O1xuICAgICAgICB0aGlzLl9pMThuVG9IdG1sID0gbmV3IEkxOG5Ub0h0bWxWaXNpdG9yKF9pMThuTm9kZXNCeU1zZ0lkLCBsb2NhbGUsIGRpZ2VzdCwgbWFwcGVyRmFjdG9yeSwgbWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3ksIGNvbnNvbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbnRlbnRcbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEBwYXJhbSB7P30gc2VyaWFsaXplclxuICAgICAqIEBwYXJhbSB7P30gbWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3lcbiAgICAgKiBAcGFyYW0gez89fSBjb25zb2xlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2xhdGlvbkJ1bmRsZS5sb2FkID0gZnVuY3Rpb24gKGNvbnRlbnQsIHVybCwgc2VyaWFsaXplciwgbWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3ksIGNvbnNvbGUpIHtcbiAgICAgICAgdmFyIF9hID0gc2VyaWFsaXplci5sb2FkKGNvbnRlbnQsIHVybCksIGxvY2FsZSA9IF9hLmxvY2FsZSwgaTE4bk5vZGVzQnlNc2dJZCA9IF9hLmkxOG5Ob2Rlc0J5TXNnSWQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpZ2VzdEZuID0gZnVuY3Rpb24gKG0pIHsgcmV0dXJuIHNlcmlhbGl6ZXIuZGlnZXN0KG0pOyB9O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXBwZXJGYWN0b3J5ID0gZnVuY3Rpb24gKG0pIHsgcmV0dXJuICgoc2VyaWFsaXplci5jcmVhdGVOYW1lTWFwcGVyKG0pKSk7IH07XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNsYXRpb25CdW5kbGUoaTE4bk5vZGVzQnlNc2dJZCwgbG9jYWxlLCBkaWdlc3RGbiwgbWFwcGVyRmFjdG9yeSwgbWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3ksIGNvbnNvbGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcmNNc2dcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zbGF0aW9uQnVuZGxlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoc3JjTXNnKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGh0bWwgPSB0aGlzLl9pMThuVG9IdG1sLmNvbnZlcnQoc3JjTXNnKTtcbiAgICAgICAgaWYgKGh0bWwuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGh0bWwuZXJyb3JzLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaHRtbC5ub2RlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3JjTXNnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2xhdGlvbkJ1bmRsZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKHNyY01zZykgeyByZXR1cm4gdGhpcy5kaWdlc3Qoc3JjTXNnKSBpbiB0aGlzLl9pMThuTm9kZXNCeU1zZ0lkOyB9O1xuICAgIHJldHVybiBUcmFuc2xhdGlvbkJ1bmRsZTtcbn0oKSk7XG52YXIgSTE4blRvSHRtbFZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IF9pMThuTm9kZXNCeU1zZ0lkXG4gICAgICogQHBhcmFtIHs/PX0gX2xvY2FsZVxuICAgICAqIEBwYXJhbSB7Pz19IF9kaWdlc3RcbiAgICAgKiBAcGFyYW0gez89fSBfbWFwcGVyRmFjdG9yeVxuICAgICAqIEBwYXJhbSB7Pz19IF9taXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneVxuICAgICAqIEBwYXJhbSB7Pz19IF9jb25zb2xlXG4gICAgICovXG4gICAgZnVuY3Rpb24gSTE4blRvSHRtbFZpc2l0b3IoX2kxOG5Ob2Rlc0J5TXNnSWQsIF9sb2NhbGUsIF9kaWdlc3QsIF9tYXBwZXJGYWN0b3J5LCBfbWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3ksIF9jb25zb2xlKSB7XG4gICAgICAgIGlmIChfaTE4bk5vZGVzQnlNc2dJZCA9PT0gdm9pZCAwKSB7IF9pMThuTm9kZXNCeU1zZ0lkID0ge307IH1cbiAgICAgICAgdGhpcy5faTE4bk5vZGVzQnlNc2dJZCA9IF9pMThuTm9kZXNCeU1zZ0lkO1xuICAgICAgICB0aGlzLl9sb2NhbGUgPSBfbG9jYWxlO1xuICAgICAgICB0aGlzLl9kaWdlc3QgPSBfZGlnZXN0O1xuICAgICAgICB0aGlzLl9tYXBwZXJGYWN0b3J5ID0gX21hcHBlckZhY3Rvcnk7XG4gICAgICAgIHRoaXMuX21pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5ID0gX21pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5O1xuICAgICAgICB0aGlzLl9jb25zb2xlID0gX2NvbnNvbGU7XG4gICAgICAgIHRoaXMuX2NvbnRleHRTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLl9lcnJvcnMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcmNNc2dcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEkxOG5Ub0h0bWxWaXNpdG9yLnByb3RvdHlwZS5jb252ZXJ0ID0gZnVuY3Rpb24gKHNyY01zZykge1xuICAgICAgICB0aGlzLl9jb250ZXh0U3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fZXJyb3JzLmxlbmd0aCA9IDA7XG4gICAgICAgIC8vIGkxOG4gdG8gdGV4dFxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZXh0ID0gdGhpcy5fY29udmVydFRvVGV4dChzcmNNc2cpO1xuICAgICAgICAvLyB0ZXh0IHRvIGh0bWxcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXJsID0gc3JjTXNnLm5vZGVzWzBdLnNvdXJjZVNwYW4uc3RhcnQuZmlsZS51cmw7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGh0bWwgPSBuZXcgSHRtbFBhcnNlcigpLnBhcnNlKHRleHQsIHVybCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub2RlczogaHRtbC5yb290Tm9kZXMsXG4gICAgICAgICAgICBlcnJvcnM6IHRoaXMuX2Vycm9ycy5jb25jYXQoaHRtbC5lcnJvcnMpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZXh0XG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSTE4blRvSHRtbFZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7IHJldHVybiB0ZXh0LnZhbHVlOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29udGFpbmVyXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSTE4blRvSHRtbFZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29udGFpbmVyID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gY29udGFpbmVyLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAobikgeyByZXR1cm4gbi52aXNpdChfdGhpcyk7IH0pLmpvaW4oJycpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpY3VcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBJMThuVG9IdG1sVmlzaXRvci5wcm90b3R5cGUudmlzaXRJY3UgPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNhc2VzID0gT2JqZWN0LmtleXMoaWN1LmNhc2VzKS5tYXAoZnVuY3Rpb24gKGspIHsgcmV0dXJuIGsgKyBcIiB7XCIgKyBpY3UuY2FzZXNba10udmlzaXQoX3RoaXMpICsgXCJ9XCI7IH0pO1xuICAgICAgICAvLyBUT0RPKHZpY2IpOiBPbmNlIGFsbCBmb3JtYXQgc3dpdGNoIHRvIHVzaW5nIGV4cHJlc3Npb24gcGxhY2Vob2xkZXJzXG4gICAgICAgIC8vIHdlIHNob3VsZCB0aHJvdyB3aGVuIHRoZSBwbGFjZWhvbGRlciBpcyBub3QgaW4gdGhlIHNvdXJjZSBtZXNzYWdlXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cCA9IHRoaXMuX3NyY01zZy5wbGFjZWhvbGRlcnMuaGFzT3duUHJvcGVydHkoaWN1LmV4cHJlc3Npb24pID9cbiAgICAgICAgICAgIHRoaXMuX3NyY01zZy5wbGFjZWhvbGRlcnNbaWN1LmV4cHJlc3Npb25dIDpcbiAgICAgICAgICAgIGljdS5leHByZXNzaW9uO1xuICAgICAgICByZXR1cm4gXCJ7XCIgKyBleHAgKyBcIiwgXCIgKyBpY3UudHlwZSArIFwiLCBcIiArIGNhc2VzLmpvaW4oJyAnKSArIFwifVwiO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEkxOG5Ub0h0bWxWaXNpdG9yLnByb3RvdHlwZS52aXNpdFBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBoTmFtZSA9IHRoaXMuX21hcHBlcihwaC5uYW1lKTtcbiAgICAgICAgaWYgKHRoaXMuX3NyY01zZy5wbGFjZWhvbGRlcnMuaGFzT3duUHJvcGVydHkocGhOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NyY01zZy5wbGFjZWhvbGRlcnNbcGhOYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc3JjTXNnLnBsYWNlaG9sZGVyVG9NZXNzYWdlLmhhc093blByb3BlcnR5KHBoTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb252ZXJ0VG9UZXh0KHRoaXMuX3NyY01zZy5wbGFjZWhvbGRlclRvTWVzc2FnZVtwaE5hbWVdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hZGRFcnJvcihwaCwgXCJVbmtub3duIHBsYWNlaG9sZGVyIFxcXCJcIiArIHBoLm5hbWUgKyBcIlxcXCJcIik7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGhcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBJMThuVG9IdG1sVmlzaXRvci5wcm90b3R5cGUudmlzaXRUYWdQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0YWcgPSBcIlwiICsgcGgudGFnO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhdHRycyA9IE9iamVjdC5rZXlzKHBoLmF0dHJzKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG5hbWUgKyBcIj1cXFwiXCIgKyBwaC5hdHRyc1tuYW1lXSArIFwiXFxcIlwiOyB9KS5qb2luKCcgJyk7XG4gICAgICAgIGlmIChwaC5pc1ZvaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBcIjxcIiArIHRhZyArIFwiIFwiICsgYXR0cnMgKyBcIi8+XCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hpbGRyZW4gPSBwaC5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudmlzaXQoX3RoaXMpOyB9KS5qb2luKCcnKTtcbiAgICAgICAgcmV0dXJuIFwiPFwiICsgdGFnICsgXCIgXCIgKyBhdHRycyArIFwiPlwiICsgY2hpbGRyZW4gKyBcIjwvXCIgKyB0YWcgKyBcIj5cIjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGhcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBJMThuVG9IdG1sVmlzaXRvci5wcm90b3R5cGUudmlzaXRJY3VQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICAvLyBBbiBJQ1UgcGxhY2Vob2xkZXIgcmVmZXJlbmNlcyB0aGUgc291cmNlIG1lc3NhZ2UgdG8gYmUgc2VyaWFsaXplZFxuICAgICAgICByZXR1cm4gdGhpcy5fY29udmVydFRvVGV4dCh0aGlzLl9zcmNNc2cucGxhY2Vob2xkZXJUb01lc3NhZ2VbcGgubmFtZV0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIHNvdXJjZSBtZXNzYWdlIHRvIGEgdHJhbnNsYXRlZCB0ZXh0IHN0cmluZzpcbiAgICAgKiAtIHRleHQgbm9kZXMgYXJlIHJlcGxhY2VkIHdpdGggdGhlaXIgdHJhbnNsYXRpb24sXG4gICAgICogLSBwbGFjZWhvbGRlcnMgYXJlIHJlcGxhY2VkIHdpdGggdGhlaXIgY29udGVudCxcbiAgICAgKiAtIElDVSBub2RlcyBhcmUgY29udmVydGVkIHRvIElDVSBleHByZXNzaW9ucy5cbiAgICAgKiBAcGFyYW0gez99IHNyY01zZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSTE4blRvSHRtbFZpc2l0b3IucHJvdG90eXBlLl9jb252ZXJ0VG9UZXh0ID0gZnVuY3Rpb24gKHNyY01zZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpZCA9IHRoaXMuX2RpZ2VzdChzcmNNc2cpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXBwZXIgPSB0aGlzLl9tYXBwZXJGYWN0b3J5ID8gdGhpcy5fbWFwcGVyRmFjdG9yeShzcmNNc2cpIDogbnVsbDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZXM7XG4gICAgICAgIHRoaXMuX2NvbnRleHRTdGFjay5wdXNoKHsgbXNnOiB0aGlzLl9zcmNNc2csIG1hcHBlcjogdGhpcy5fbWFwcGVyIH0pO1xuICAgICAgICB0aGlzLl9zcmNNc2cgPSBzcmNNc2c7XG4gICAgICAgIGlmICh0aGlzLl9pMThuTm9kZXNCeU1zZ0lkLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgLy8gV2hlbiB0aGVyZSBpcyBhIHRyYW5zbGF0aW9uIHVzZSBpdHMgbm9kZXMgYXMgdGhlIHNvdXJjZVxuICAgICAgICAgICAgLy8gQW5kIGNyZWF0ZSBhIG1hcHBlciB0byBjb252ZXJ0IHNlcmlhbGl6ZWQgcGxhY2Vob2xkZXIgbmFtZXMgdG8gaW50ZXJuYWwgbmFtZXNcbiAgICAgICAgICAgIG5vZGVzID0gdGhpcy5faTE4bk5vZGVzQnlNc2dJZFtpZF07XG4gICAgICAgICAgICB0aGlzLl9tYXBwZXIgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbWFwcGVyID8gKChtYXBwZXIudG9JbnRlcm5hbE5hbWUobmFtZSkpKSA6IG5hbWU7IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXaGVuIG5vIHRyYW5zbGF0aW9uIGhhcyBiZWVuIGZvdW5kXG4gICAgICAgICAgICAvLyAtIHJlcG9ydCBhbiBlcnJvciAvIGEgd2FybmluZyAvIG5vdGhpbmcsXG4gICAgICAgICAgICAvLyAtIHVzZSB0aGUgbm9kZXMgZnJvbSB0aGUgb3JpZ2luYWwgbWVzc2FnZVxuICAgICAgICAgICAgLy8gLSBwbGFjZWhvbGRlcnMgYXJlIGFscmVhZHkgaW50ZXJuYWwgYW5kIG5lZWQgbm8gbWFwcGVyXG4gICAgICAgICAgICBpZiAodGhpcy5fbWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kgPT09IE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5LkVycm9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3R4ID0gdGhpcy5fbG9jYWxlID8gXCIgZm9yIGxvY2FsZSBcXFwiXCIgKyB0aGlzLl9sb2NhbGUgKyBcIlxcXCJcIiA6ICcnO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKHNyY01zZy5ub2Rlc1swXSwgXCJNaXNzaW5nIHRyYW5zbGF0aW9uIGZvciBtZXNzYWdlIFxcXCJcIiArIGlkICsgXCJcXFwiXCIgKyBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fY29uc29sZSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX21pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5ID09PSBNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneS5XYXJuaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3R4ID0gdGhpcy5fbG9jYWxlID8gXCIgZm9yIGxvY2FsZSBcXFwiXCIgKyB0aGlzLl9sb2NhbGUgKyBcIlxcXCJcIiA6ICcnO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnNvbGUud2FybihcIk1pc3NpbmcgdHJhbnNsYXRpb24gZm9yIG1lc3NhZ2UgXFxcIlwiICsgaWQgKyBcIlxcXCJcIiArIGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlcyA9IHNyY01zZy5ub2RlcztcbiAgICAgICAgICAgIHRoaXMuX21hcHBlciA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBuYW1lOyB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRleHQgPSBub2Rlcy5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3RoaXMpOyB9KS5qb2luKCcnKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udGV4dCA9ICgodGhpcy5fY29udGV4dFN0YWNrLnBvcCgpKSk7XG4gICAgICAgIHRoaXMuX3NyY01zZyA9IGNvbnRleHQubXNnO1xuICAgICAgICB0aGlzLl9tYXBwZXIgPSBjb250ZXh0Lm1hcHBlcjtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBtc2dcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEkxOG5Ub0h0bWxWaXNpdG9yLnByb3RvdHlwZS5fYWRkRXJyb3IgPSBmdW5jdGlvbiAoZWwsIG1zZykge1xuICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChuZXcgSTE4bkVycm9yKGVsLnNvdXJjZVNwYW4sIG1zZykpO1xuICAgIH07XG4gICAgcmV0dXJuIEkxOG5Ub0h0bWxWaXNpdG9yO1xufSgpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBJMThOSHRtbFBhcnNlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfaHRtbFBhcnNlclxuICAgICAqIEBwYXJhbSB7Pz19IHRyYW5zbGF0aW9uc1xuICAgICAqIEBwYXJhbSB7Pz19IHRyYW5zbGF0aW9uc0Zvcm1hdFxuICAgICAqIEBwYXJhbSB7Pz19IG1pc3NpbmdUcmFuc2xhdGlvblxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnNvbGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJMThOSHRtbFBhcnNlcihfaHRtbFBhcnNlciwgdHJhbnNsYXRpb25zLCB0cmFuc2xhdGlvbnNGb3JtYXQsIG1pc3NpbmdUcmFuc2xhdGlvbiwgY29uc29sZSkge1xuICAgICAgICBpZiAobWlzc2luZ1RyYW5zbGF0aW9uID09PSB2b2lkIDApIHsgbWlzc2luZ1RyYW5zbGF0aW9uID0gTWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kuV2FybmluZzsgfVxuICAgICAgICB0aGlzLl9odG1sUGFyc2VyID0gX2h0bWxQYXJzZXI7XG4gICAgICAgIGlmICh0cmFuc2xhdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBzZXJpYWxpemVyID0gY3JlYXRlU2VyaWFsaXplcih0cmFuc2xhdGlvbnNGb3JtYXQpO1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNsYXRpb25CdW5kbGUgPVxuICAgICAgICAgICAgICAgIFRyYW5zbGF0aW9uQnVuZGxlLmxvYWQodHJhbnNsYXRpb25zLCAnaTE4bicsIHNlcmlhbGl6ZXIsIG1pc3NpbmdUcmFuc2xhdGlvbiwgY29uc29sZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2xhdGlvbkJ1bmRsZSA9XG4gICAgICAgICAgICAgICAgbmV3IFRyYW5zbGF0aW9uQnVuZGxlKHt9LCBudWxsLCBkaWdlc3QsIHVuZGVmaW5lZCwgbWlzc2luZ1RyYW5zbGF0aW9uLCBjb25zb2xlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHBhcmFtIHs/PX0gcGFyc2VFeHBhbnNpb25Gb3Jtc1xuICAgICAqIEBwYXJhbSB7Pz19IGludGVycG9sYXRpb25Db25maWdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEkxOE5IdG1sUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHVybCwgcGFyc2VFeHBhbnNpb25Gb3JtcywgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICBpZiAocGFyc2VFeHBhbnNpb25Gb3JtcyA9PT0gdm9pZCAwKSB7IHBhcnNlRXhwYW5zaW9uRm9ybXMgPSBmYWxzZTsgfVxuICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbkNvbmZpZyA9PT0gdm9pZCAwKSB7IGludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnNlUmVzdWx0ID0gdGhpcy5faHRtbFBhcnNlci5wYXJzZShzb3VyY2UsIHVybCwgcGFyc2VFeHBhbnNpb25Gb3JtcywgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgIGlmIChwYXJzZVJlc3VsdC5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhcnNlVHJlZVJlc3VsdChwYXJzZVJlc3VsdC5yb290Tm9kZXMsIHBhcnNlUmVzdWx0LmVycm9ycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lcmdlVHJhbnNsYXRpb25zKHBhcnNlUmVzdWx0LnJvb3ROb2RlcywgdGhpcy5fdHJhbnNsYXRpb25CdW5kbGUsIGludGVycG9sYXRpb25Db25maWcsIFtdLCB7fSk7XG4gICAgfTtcbiAgICByZXR1cm4gSTE4Tkh0bWxQYXJzZXI7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez89fSBmb3JtYXRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVNlcmlhbGl6ZXIoZm9ybWF0KSB7XG4gICAgZm9ybWF0ID0gKGZvcm1hdCB8fCAneGxmJykudG9Mb3dlckNhc2UoKTtcbiAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgICBjYXNlICd4bWInOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBYbWIoKTtcbiAgICAgICAgY2FzZSAneHRiJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgWHRiKCk7XG4gICAgICAgIGNhc2UgJ3hsaWZmMic6XG4gICAgICAgIGNhc2UgJ3hsZjInOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBYbGlmZjIoKTtcbiAgICAgICAgY2FzZSAneGxpZmYnOlxuICAgICAgICBjYXNlICd4bGYnOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBYbGlmZigpO1xuICAgIH1cbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBDT1JFID0gJ0Bhbmd1bGFyL2NvcmUnO1xudmFyIElkZW50aWZpZXJzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJZGVudGlmaWVycygpIHtcbiAgICB9XG4gICAgcmV0dXJuIElkZW50aWZpZXJzO1xufSgpKTtcbklkZW50aWZpZXJzLkFOQUxZWkVfRk9SX0VOVFJZX0NPTVBPTkVOVFMgPSB7XG4gICAgbmFtZTogJ0FOQUxZWkVfRk9SX0VOVFJZX0NPTVBPTkVOVFMnLFxuICAgIG1vZHVsZU5hbWU6IENPUkUsXG4gICAgcnVudGltZTogQU5BTFlaRV9GT1JfRU5UUllfQ09NUE9ORU5UU1xufTtcbklkZW50aWZpZXJzLkVsZW1lbnRSZWYgPSB7IG5hbWU6ICdFbGVtZW50UmVmJywgbW9kdWxlTmFtZTogQ09SRSwgcnVudGltZTogRWxlbWVudFJlZiB9O1xuSWRlbnRpZmllcnMuTmdNb2R1bGVSZWYgPSB7IG5hbWU6ICdOZ01vZHVsZVJlZicsIG1vZHVsZU5hbWU6IENPUkUsIHJ1bnRpbWU6IE5nTW9kdWxlUmVmIH07XG5JZGVudGlmaWVycy5WaWV3Q29udGFpbmVyUmVmID0geyBuYW1lOiAnVmlld0NvbnRhaW5lclJlZicsIG1vZHVsZU5hbWU6IENPUkUsIHJ1bnRpbWU6IFZpZXdDb250YWluZXJSZWYgfTtcbklkZW50aWZpZXJzLkNoYW5nZURldGVjdG9yUmVmID0ge1xuICAgIG5hbWU6ICdDaGFuZ2VEZXRlY3RvclJlZicsXG4gICAgbW9kdWxlTmFtZTogQ09SRSxcbiAgICBydW50aW1lOiBDaGFuZ2VEZXRlY3RvclJlZlxufTtcbklkZW50aWZpZXJzLlF1ZXJ5TGlzdCA9IHsgbmFtZTogJ1F1ZXJ5TGlzdCcsIG1vZHVsZU5hbWU6IENPUkUsIHJ1bnRpbWU6IFF1ZXJ5TGlzdCB9O1xuSWRlbnRpZmllcnMuVGVtcGxhdGVSZWYgPSB7IG5hbWU6ICdUZW1wbGF0ZVJlZicsIG1vZHVsZU5hbWU6IENPUkUsIHJ1bnRpbWU6IFRlbXBsYXRlUmVmIH07XG5JZGVudGlmaWVycy5Db2RlZ2VuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyID0ge1xuICAgIG5hbWU6ICfJtUNvZGVnZW5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXInLFxuICAgIG1vZHVsZU5hbWU6IENPUkUsXG4gICAgcnVudGltZTogybVDb2RlZ2VuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyXG59O1xuSWRlbnRpZmllcnMuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyID0ge1xuICAgIG5hbWU6ICdDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXInLFxuICAgIG1vZHVsZU5hbWU6IENPUkUsXG4gICAgcnVudGltZTogQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyXG59O1xuSWRlbnRpZmllcnMuQ29tcG9uZW50RmFjdG9yeSA9IHsgbmFtZTogJ0NvbXBvbmVudEZhY3RvcnknLCBtb2R1bGVOYW1lOiBDT1JFLCBydW50aW1lOiBDb21wb25lbnRGYWN0b3J5IH07XG5JZGVudGlmaWVycy5Db21wb25lbnRSZWYgPSB7IG5hbWU6ICdDb21wb25lbnRSZWYnLCBtb2R1bGVOYW1lOiBDT1JFLCBydW50aW1lOiBDb21wb25lbnRSZWYgfTtcbklkZW50aWZpZXJzLk5nTW9kdWxlRmFjdG9yeSA9IHsgbmFtZTogJ05nTW9kdWxlRmFjdG9yeScsIG1vZHVsZU5hbWU6IENPUkUsIHJ1bnRpbWU6IE5nTW9kdWxlRmFjdG9yeSB9O1xuSWRlbnRpZmllcnMuY3JlYXRlTW9kdWxlRmFjdG9yeSA9IHtcbiAgICBuYW1lOiAnybVjbWYnLFxuICAgIG1vZHVsZU5hbWU6IENPUkUsXG4gICAgcnVudGltZTogybVjbWYsXG59O1xuSWRlbnRpZmllcnMubW9kdWxlRGVmID0ge1xuICAgIG5hbWU6ICfJtW1vZCcsXG4gICAgbW9kdWxlTmFtZTogQ09SRSxcbiAgICBydW50aW1lOiDJtW1vZCxcbn07XG5JZGVudGlmaWVycy5tb2R1bGVQcm92aWRlckRlZiA9IHtcbiAgICBuYW1lOiAnybVtcGQnLFxuICAgIG1vZHVsZU5hbWU6IENPUkUsXG4gICAgcnVudGltZTogybVtcGQsXG59O1xuSWRlbnRpZmllcnMuUmVnaXN0ZXJNb2R1bGVGYWN0b3J5Rm4gPSB7XG4gICAgbmFtZTogJ8m1cmVnaXN0ZXJNb2R1bGVGYWN0b3J5JyxcbiAgICBtb2R1bGVOYW1lOiBDT1JFLFxuICAgIHJ1bnRpbWU6IMm1cmVnaXN0ZXJNb2R1bGVGYWN0b3J5LFxufTtcbklkZW50aWZpZXJzLkluamVjdG9yID0geyBuYW1lOiAnSW5qZWN0b3InLCBtb2R1bGVOYW1lOiBDT1JFLCBydW50aW1lOiBJbmplY3RvciB9O1xuSWRlbnRpZmllcnMuVmlld0VuY2Fwc3VsYXRpb24gPSB7XG4gICAgbmFtZTogJ1ZpZXdFbmNhcHN1bGF0aW9uJyxcbiAgICBtb2R1bGVOYW1lOiBDT1JFLFxuICAgIHJ1bnRpbWU6IFZpZXdFbmNhcHN1bGF0aW9uXG59O1xuSWRlbnRpZmllcnMuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgPSB7XG4gICAgbmFtZTogJ0NoYW5nZURldGVjdGlvblN0cmF0ZWd5JyxcbiAgICBtb2R1bGVOYW1lOiBDT1JFLFxuICAgIHJ1bnRpbWU6IENoYW5nZURldGVjdGlvblN0cmF0ZWd5XG59O1xuSWRlbnRpZmllcnMuU2VjdXJpdHlDb250ZXh0ID0ge1xuICAgIG5hbWU6ICdTZWN1cml0eUNvbnRleHQnLFxuICAgIG1vZHVsZU5hbWU6IENPUkUsXG4gICAgcnVudGltZTogU2VjdXJpdHlDb250ZXh0LFxufTtcbklkZW50aWZpZXJzLkxPQ0FMRV9JRCA9IHsgbmFtZTogJ0xPQ0FMRV9JRCcsIG1vZHVsZU5hbWU6IENPUkUsIHJ1bnRpbWU6IExPQ0FMRV9JRCB9O1xuSWRlbnRpZmllcnMuVFJBTlNMQVRJT05TX0ZPUk1BVCA9IHtcbiAgICBuYW1lOiAnVFJBTlNMQVRJT05TX0ZPUk1BVCcsXG4gICAgbW9kdWxlTmFtZTogQ09SRSxcbiAgICBydW50aW1lOiBUUkFOU0xBVElPTlNfRk9STUFUXG59O1xuSWRlbnRpZmllcnMuaW5saW5lSW50ZXJwb2xhdGUgPSB7XG4gICAgbmFtZTogJ8m1aW5saW5lSW50ZXJwb2xhdGUnLFxuICAgIG1vZHVsZU5hbWU6IENPUkUsXG4gICAgcnVudGltZTogybVpbmxpbmVJbnRlcnBvbGF0ZVxufTtcbklkZW50aWZpZXJzLmludGVycG9sYXRlID0geyBuYW1lOiAnybVpbnRlcnBvbGF0ZScsIG1vZHVsZU5hbWU6IENPUkUsIHJ1bnRpbWU6IMm1aW50ZXJwb2xhdGUgfTtcbklkZW50aWZpZXJzLkVNUFRZX0FSUkFZID0geyBuYW1lOiAnybVFTVBUWV9BUlJBWScsIG1vZHVsZU5hbWU6IENPUkUsIHJ1bnRpbWU6IMm1RU1QVFlfQVJSQVkgfTtcbklkZW50aWZpZXJzLkVNUFRZX01BUCA9IHsgbmFtZTogJ8m1RU1QVFlfTUFQJywgbW9kdWxlTmFtZTogQ09SRSwgcnVudGltZTogybVFTVBUWV9NQVAgfTtcbklkZW50aWZpZXJzLlJlbmRlcmVyID0geyBuYW1lOiAnUmVuZGVyZXInLCBtb2R1bGVOYW1lOiBDT1JFLCBydW50aW1lOiBSZW5kZXJlciB9O1xuSWRlbnRpZmllcnMudmlld0RlZiA9IHsgbmFtZTogJ8m1dmlkJywgbW9kdWxlTmFtZTogQ09SRSwgcnVudGltZTogybV2aWQgfTtcbklkZW50aWZpZXJzLmVsZW1lbnREZWYgPSB7IG5hbWU6ICfJtWVsZCcsIG1vZHVsZU5hbWU6IENPUkUsIHJ1bnRpbWU6IMm1ZWxkIH07XG5JZGVudGlmaWVycy5hbmNob3JEZWYgPSB7IG5hbWU6ICfJtWFuZCcsIG1vZHVsZU5hbWU6IENPUkUsIHJ1bnRpbWU6IMm1YW5kIH07XG5JZGVudGlmaWVycy50ZXh0RGVmID0geyBuYW1lOiAnybV0ZWQnLCBtb2R1bGVOYW1lOiBDT1JFLCBydW50aW1lOiDJtXRlZCB9O1xuSWRlbnRpZmllcnMuZGlyZWN0aXZlRGVmID0geyBuYW1lOiAnybVkaWQnLCBtb2R1bGVOYW1lOiBDT1JFLCBydW50aW1lOiDJtWRpZCB9O1xuSWRlbnRpZmllcnMucHJvdmlkZXJEZWYgPSB7IG5hbWU6ICfJtXByZCcsIG1vZHVsZU5hbWU6IENPUkUsIHJ1bnRpbWU6IMm1cHJkIH07XG5JZGVudGlmaWVycy5xdWVyeURlZiA9IHsgbmFtZTogJ8m1cXVkJywgbW9kdWxlTmFtZTogQ09SRSwgcnVudGltZTogybVxdWQgfTtcbklkZW50aWZpZXJzLnB1cmVBcnJheURlZiA9IHsgbmFtZTogJ8m1cGFkJywgbW9kdWxlTmFtZTogQ09SRSwgcnVudGltZTogybVwYWQgfTtcbklkZW50aWZpZXJzLnB1cmVPYmplY3REZWYgPSB7IG5hbWU6ICfJtXBvZCcsIG1vZHVsZU5hbWU6IENPUkUsIHJ1bnRpbWU6IMm1cG9kIH07XG5JZGVudGlmaWVycy5wdXJlUGlwZURlZiA9IHsgbmFtZTogJ8m1cHBkJywgbW9kdWxlTmFtZTogQ09SRSwgcnVudGltZTogybVwcGQgfTtcbklkZW50aWZpZXJzLnBpcGVEZWYgPSB7IG5hbWU6ICfJtXBpZCcsIG1vZHVsZU5hbWU6IENPUkUsIHJ1bnRpbWU6IMm1cGlkIH07XG5JZGVudGlmaWVycy5ub2RlVmFsdWUgPSB7IG5hbWU6ICfJtW5vdicsIG1vZHVsZU5hbWU6IENPUkUsIHJ1bnRpbWU6IMm1bm92IH07XG5JZGVudGlmaWVycy5uZ0NvbnRlbnREZWYgPSB7IG5hbWU6ICfJtW5jZCcsIG1vZHVsZU5hbWU6IENPUkUsIHJ1bnRpbWU6IMm1bmNkIH07XG5JZGVudGlmaWVycy51bndyYXBWYWx1ZSA9IHsgbmFtZTogJ8m1dW52JywgbW9kdWxlTmFtZTogQ09SRSwgcnVudGltZTogybV1bnYgfTtcbklkZW50aWZpZXJzLmNyZWF0ZVJlbmRlcmVyVHlwZTIgPSB7IG5hbWU6ICfJtWNydCcsIG1vZHVsZU5hbWU6IENPUkUsIHJ1bnRpbWU6IMm1Y3J0IH07XG5JZGVudGlmaWVycy5SZW5kZXJlclR5cGUyID0ge1xuICAgIG5hbWU6ICdSZW5kZXJlclR5cGUyJyxcbiAgICBtb2R1bGVOYW1lOiBDT1JFLFxuICAgIC8vIHR5cGUgb25seVxuICAgIHJ1bnRpbWU6IG51bGxcbn07XG5JZGVudGlmaWVycy5WaWV3RGVmaW5pdGlvbiA9IHtcbiAgICBuYW1lOiAnybVWaWV3RGVmaW5pdGlvbicsXG4gICAgbW9kdWxlTmFtZTogQ09SRSxcbiAgICAvLyB0eXBlIG9ubHlcbiAgICBydW50aW1lOiBudWxsXG59O1xuSWRlbnRpZmllcnMuY3JlYXRlQ29tcG9uZW50RmFjdG9yeSA9IHsgbmFtZTogJ8m1Y2NmJywgbW9kdWxlTmFtZTogQ09SRSwgcnVudGltZTogybVjY2YgfTtcbi8qKlxuICogQHBhcmFtIHs/fSByZWZlcmVuY2VcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRva2VuRm9yUmVmZXJlbmNlKHJlZmVyZW5jZSkge1xuICAgIHJldHVybiB7IGlkZW50aWZpZXI6IHsgcmVmZXJlbmNlOiByZWZlcmVuY2UgfSB9O1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHJlZmxlY3RvclxuICogQHBhcmFtIHs/fSByZWZlcmVuY2VcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRva2VuRm9yRXh0ZXJuYWxSZWZlcmVuY2UocmVmbGVjdG9yLCByZWZlcmVuY2UpIHtcbiAgICByZXR1cm4gY3JlYXRlVG9rZW5Gb3JSZWZlcmVuY2UocmVmbGVjdG9yLnJlc29sdmVFeHRlcm5hbFJlZmVyZW5jZShyZWZlcmVuY2UpKTtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8vIGh0dHA6Ly9jbGRyLnVuaWNvZGUub3JnL2luZGV4L2NsZHItc3BlYy9wbHVyYWwtcnVsZXNcbnZhciBQTFVSQUxfQ0FTRVMgPSBbJ3plcm8nLCAnb25lJywgJ3R3bycsICdmZXcnLCAnbWFueScsICdvdGhlciddO1xuLyoqXG4gKiBFeHBhbmRzIHNwZWNpYWwgZm9ybXMgaW50byBlbGVtZW50cy5cbiAqXG4gKiBGb3IgZXhhbXBsZSxcbiAqXG4gKiBgYGBcbiAqIHsgbWVzc2FnZXMubGVuZ3RoLCBwbHVyYWwsXG4gKiAgID0wIHt6ZXJvfVxuICogICA9MSB7b25lfVxuICogICBvdGhlciB7bW9yZSB0aGFuIG9uZX1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIHdpbGwgYmUgZXhwYW5kZWQgaW50b1xuICpcbiAqIGBgYFxuICogPG5nLWNvbnRhaW5lciBbbmdQbHVyYWxdPVwibWVzc2FnZXMubGVuZ3RoXCI+XG4gKiAgIDxuZy10ZW1wbGF0ZSBuZ1BsdXJhbENhc2U9XCI9MFwiPnplcm88L25nLXRlbXBsYXRlPlxuICogICA8bmctdGVtcGxhdGUgbmdQbHVyYWxDYXNlPVwiPTFcIj5vbmU8L25nLXRlbXBsYXRlPlxuICogICA8bmctdGVtcGxhdGUgbmdQbHVyYWxDYXNlPVwib3RoZXJcIj5tb3JlIHRoYW4gb25lPC9uZy10ZW1wbGF0ZT5cbiAqIDwvbmctY29udGFpbmVyPlxuICogYGBgXG4gKiBAcGFyYW0gez99IG5vZGVzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBleHBhbmROb2Rlcyhub2Rlcykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cGFuZGVyID0gbmV3IF9FeHBhbmRlcigpO1xuICAgIHJldHVybiBuZXcgRXhwYW5zaW9uUmVzdWx0KHZpc2l0QWxsKGV4cGFuZGVyLCBub2RlcyksIGV4cGFuZGVyLmlzRXhwYW5kZWQsIGV4cGFuZGVyLmVycm9ycyk7XG59XG52YXIgRXhwYW5zaW9uUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVzXG4gICAgICogQHBhcmFtIHs/fSBleHBhbmRlZFxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICovXG4gICAgZnVuY3Rpb24gRXhwYW5zaW9uUmVzdWx0KG5vZGVzLCBleHBhbmRlZCwgZXJyb3JzKSB7XG4gICAgICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgICAgICAgdGhpcy5leHBhbmRlZCA9IGV4cGFuZGVkO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB9XG4gICAgcmV0dXJuIEV4cGFuc2lvblJlc3VsdDtcbn0oKSk7XG52YXIgRXhwYW5zaW9uRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEV4cGFuc2lvbkVycm9yLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3BhblxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JNc2dcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFeHBhbnNpb25FcnJvcihzcGFuLCBlcnJvck1zZykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgc3BhbiwgZXJyb3JNc2cpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBFeHBhbnNpb25FcnJvcjtcbn0oUGFyc2VFcnJvcikpO1xuLyoqXG4gKiBFeHBhbmQgZXhwYW5zaW9uIGZvcm1zIChwbHVyYWwsIHNlbGVjdCkgdG8gZGlyZWN0aXZlc1xuICpcbiAqIFxcQGludGVybmFsXG4gKi9cbnZhciBfRXhwYW5kZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIF9FeHBhbmRlcigpIHtcbiAgICAgICAgdGhpcy5pc0V4cGFuZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0V4cGFuZGVyLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnQoZWxlbWVudC5uYW1lLCBlbGVtZW50LmF0dHJzLCB2aXNpdEFsbCh0aGlzLCBlbGVtZW50LmNoaWxkcmVuKSwgZWxlbWVudC5zb3VyY2VTcGFuLCBlbGVtZW50LnN0YXJ0U291cmNlU3BhbiwgZWxlbWVudC5lbmRTb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXR0cmlidXRlXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfRXhwYW5kZXIucHJvdG90eXBlLnZpc2l0QXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSwgY29udGV4dCkgeyByZXR1cm4gYXR0cmlidXRlOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGV4dFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0V4cGFuZGVyLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkgeyByZXR1cm4gdGV4dDsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9FeHBhbmRlci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHsgcmV0dXJuIGNvbW1lbnQ7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpY3VcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9FeHBhbmRlci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb24gPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaXNFeHBhbmRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBpY3UudHlwZSA9PSAncGx1cmFsJyA/IF9leHBhbmRQbHVyYWxGb3JtKGljdSwgdGhpcy5lcnJvcnMpIDpcbiAgICAgICAgICAgIF9leHBhbmREZWZhdWx0Rm9ybShpY3UsIHRoaXMuZXJyb3JzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWN1Q2FzZVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0V4cGFuZGVyLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoaWN1Q2FzZSwgY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBub3QgYmUgcmVhY2hlZCcpO1xuICAgIH07XG4gICAgcmV0dXJuIF9FeHBhbmRlcjtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gYXN0XG4gKiBAcGFyYW0gez99IGVycm9yc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2V4cGFuZFBsdXJhbEZvcm0oYXN0LCBlcnJvcnMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlsZHJlbiA9IGFzdC5jYXNlcy5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKFBMVVJBTF9DQVNFUy5pbmRleE9mKGMudmFsdWUpID09IC0xICYmICFjLnZhbHVlLm1hdGNoKC9ePVxcZCskLykpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBFeHBhbnNpb25FcnJvcihjLnZhbHVlU291cmNlU3BhbiwgXCJQbHVyYWwgY2FzZXMgc2hvdWxkIGJlIFxcXCI9PG51bWJlcj5cXFwiIG9yIG9uZSBvZiBcIiArIFBMVVJBTF9DQVNFUy5qb2luKFwiLCBcIikpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHBhbnNpb25SZXN1bHQgPSBleHBhbmROb2RlcyhjLmV4cHJlc3Npb24pO1xuICAgICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIGV4cGFuc2lvblJlc3VsdC5lcnJvcnMpO1xuICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnQoXCJuZy10ZW1wbGF0ZVwiLCBbbmV3IEF0dHJpYnV0ZSQxKCduZ1BsdXJhbENhc2UnLCBcIlwiICsgYy52YWx1ZSwgYy52YWx1ZVNvdXJjZVNwYW4pXSwgZXhwYW5zaW9uUmVzdWx0Lm5vZGVzLCBjLnNvdXJjZVNwYW4sIGMuc291cmNlU3BhbiwgYy5zb3VyY2VTcGFuKTtcbiAgICB9KTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzd2l0Y2hBdHRyID0gbmV3IEF0dHJpYnV0ZSQxKCdbbmdQbHVyYWxdJywgYXN0LnN3aXRjaFZhbHVlLCBhc3Quc3dpdGNoVmFsdWVTb3VyY2VTcGFuKTtcbiAgICByZXR1cm4gbmV3IEVsZW1lbnQoJ25nLWNvbnRhaW5lcicsIFtzd2l0Y2hBdHRyXSwgY2hpbGRyZW4sIGFzdC5zb3VyY2VTcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0LnNvdXJjZVNwYW4pO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGFzdFxuICogQHBhcmFtIHs/fSBlcnJvcnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9leHBhbmREZWZhdWx0Rm9ybShhc3QsIGVycm9ycykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGNoaWxkcmVuID0gYXN0LmNhc2VzLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHBhbnNpb25SZXN1bHQgPSBleHBhbmROb2RlcyhjLmV4cHJlc3Npb24pO1xuICAgICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIGV4cGFuc2lvblJlc3VsdC5lcnJvcnMpO1xuICAgICAgICBpZiAoYy52YWx1ZSA9PT0gJ290aGVyJykge1xuICAgICAgICAgICAgLy8gb3RoZXIgaXMgdGhlIGRlZmF1bHQgY2FzZSB3aGVuIG5vIHZhbHVlcyBtYXRjaFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50KFwibmctdGVtcGxhdGVcIiwgW25ldyBBdHRyaWJ1dGUkMSgnbmdTd2l0Y2hEZWZhdWx0JywgJycsIGMudmFsdWVTb3VyY2VTcGFuKV0sIGV4cGFuc2lvblJlc3VsdC5ub2RlcywgYy5zb3VyY2VTcGFuLCBjLnNvdXJjZVNwYW4sIGMuc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50KFwibmctdGVtcGxhdGVcIiwgW25ldyBBdHRyaWJ1dGUkMSgnbmdTd2l0Y2hDYXNlJywgXCJcIiArIGMudmFsdWUsIGMudmFsdWVTb3VyY2VTcGFuKV0sIGV4cGFuc2lvblJlc3VsdC5ub2RlcywgYy5zb3VyY2VTcGFuLCBjLnNvdXJjZVNwYW4sIGMuc291cmNlU3Bhbik7XG4gICAgfSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3dpdGNoQXR0ciA9IG5ldyBBdHRyaWJ1dGUkMSgnW25nU3dpdGNoXScsIGFzdC5zd2l0Y2hWYWx1ZSwgYXN0LnN3aXRjaFZhbHVlU291cmNlU3Bhbik7XG4gICAgcmV0dXJuIG5ldyBFbGVtZW50KCduZy1jb250YWluZXInLCBbc3dpdGNoQXR0cl0sIGNoaWxkcmVuLCBhc3Quc291cmNlU3BhbiwgYXN0LnNvdXJjZVNwYW4sIGFzdC5zb3VyY2VTcGFuKTtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBQcm92aWRlckVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhQcm92aWRlckVycm9yLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7P30gc3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFByb3ZpZGVyRXJyb3IobWVzc2FnZSwgc3Bhbikge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgc3BhbiwgbWVzc2FnZSkgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFByb3ZpZGVyRXJyb3I7XG59KFBhcnNlRXJyb3IpKTtcbnZhciBQcm92aWRlclZpZXdDb250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlZmxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gY29tcG9uZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gUHJvdmlkZXJWaWV3Q29udGV4dChyZWZsZWN0b3IsIGNvbXBvbmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnJlZmxlY3RvciA9IHJlZmxlY3RvcjtcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICAgIHRoaXMudmlld1F1ZXJpZXMgPSBfZ2V0Vmlld1F1ZXJpZXMoY29tcG9uZW50KTtcbiAgICAgICAgdGhpcy52aWV3UHJvdmlkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICBjb21wb25lbnQudmlld1Byb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgaWYgKF90aGlzLnZpZXdQcm92aWRlcnMuZ2V0KHRva2VuUmVmZXJlbmNlKHByb3ZpZGVyLnRva2VuKSkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnZpZXdQcm92aWRlcnMuc2V0KHRva2VuUmVmZXJlbmNlKHByb3ZpZGVyLnRva2VuKSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gUHJvdmlkZXJWaWV3Q29udGV4dDtcbn0oKSk7XG52YXIgUHJvdmlkZXJFbGVtZW50Q29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aWV3Q29udGV4dFxuICAgICAqIEBwYXJhbSB7P30gX3BhcmVudFxuICAgICAqIEBwYXJhbSB7P30gX2lzVmlld1Jvb3RcbiAgICAgKiBAcGFyYW0gez99IF9kaXJlY3RpdmVBc3RzXG4gICAgICogQHBhcmFtIHs/fSBhdHRyc1xuICAgICAqIEBwYXJhbSB7P30gcmVmc1xuICAgICAqIEBwYXJhbSB7P30gaXNUZW1wbGF0ZVxuICAgICAqIEBwYXJhbSB7P30gY29udGVudFF1ZXJ5U3RhcnRJZFxuICAgICAqIEBwYXJhbSB7P30gX3NvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQcm92aWRlckVsZW1lbnRDb250ZXh0KHZpZXdDb250ZXh0LCBfcGFyZW50LCBfaXNWaWV3Um9vdCwgX2RpcmVjdGl2ZUFzdHMsIGF0dHJzLCByZWZzLCBpc1RlbXBsYXRlLCBjb250ZW50UXVlcnlTdGFydElkLCBfc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnZpZXdDb250ZXh0ID0gdmlld0NvbnRleHQ7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgICAgIHRoaXMuX2lzVmlld1Jvb3QgPSBfaXNWaWV3Um9vdDtcbiAgICAgICAgdGhpcy5fZGlyZWN0aXZlQXN0cyA9IF9kaXJlY3RpdmVBc3RzO1xuICAgICAgICB0aGlzLl9zb3VyY2VTcGFuID0gX3NvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybWVkUHJvdmlkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9zZWVuUHJvdmlkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9oYXNWaWV3Q29udGFpbmVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3F1ZXJpZWRUb2tlbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2F0dHJzID0ge307XG4gICAgICAgIGF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGF0dHJBc3QpIHsgcmV0dXJuIF90aGlzLl9hdHRyc1thdHRyQXN0Lm5hbWVdID0gYXR0ckFzdC52YWx1ZTsgfSk7XG4gICAgICAgIHZhciBkaXJlY3RpdmVzTWV0YSA9IF9kaXJlY3RpdmVBc3RzLm1hcChmdW5jdGlvbiAoZGlyZWN0aXZlQXN0KSB7IHJldHVybiBkaXJlY3RpdmVBc3QuZGlyZWN0aXZlOyB9KTtcbiAgICAgICAgdGhpcy5fYWxsUHJvdmlkZXJzID1cbiAgICAgICAgICAgIF9yZXNvbHZlUHJvdmlkZXJzRnJvbURpcmVjdGl2ZXMoZGlyZWN0aXZlc01ldGEsIF9zb3VyY2VTcGFuLCB2aWV3Q29udGV4dC5lcnJvcnMpO1xuICAgICAgICB0aGlzLl9jb250ZW50UXVlcmllcyA9IF9nZXRDb250ZW50UXVlcmllcyhjb250ZW50UXVlcnlTdGFydElkLCBkaXJlY3RpdmVzTWV0YSk7XG4gICAgICAgIEFycmF5LmZyb20odGhpcy5fYWxsUHJvdmlkZXJzLnZhbHVlcygpKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgX3RoaXMuX2FkZFF1ZXJ5UmVhZHNUbyhwcm92aWRlci50b2tlbiwgcHJvdmlkZXIudG9rZW4sIF90aGlzLl9xdWVyaWVkVG9rZW5zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc1RlbXBsYXRlKSB7XG4gICAgICAgICAgICB2YXIgdGVtcGxhdGVSZWZJZCA9IGNyZWF0ZVRva2VuRm9yRXh0ZXJuYWxSZWZlcmVuY2UodGhpcy52aWV3Q29udGV4dC5yZWZsZWN0b3IsIElkZW50aWZpZXJzLlRlbXBsYXRlUmVmKTtcbiAgICAgICAgICAgIHRoaXMuX2FkZFF1ZXJ5UmVhZHNUbyh0ZW1wbGF0ZVJlZklkLCB0ZW1wbGF0ZVJlZklkLCB0aGlzLl9xdWVyaWVkVG9rZW5zKTtcbiAgICAgICAgfVxuICAgICAgICByZWZzLmZvckVhY2goZnVuY3Rpb24gKHJlZkFzdCkge1xuICAgICAgICAgICAgdmFyIGRlZmF1bHRRdWVyeVZhbHVlID0gcmVmQXN0LnZhbHVlIHx8XG4gICAgICAgICAgICAgICAgY3JlYXRlVG9rZW5Gb3JFeHRlcm5hbFJlZmVyZW5jZShfdGhpcy52aWV3Q29udGV4dC5yZWZsZWN0b3IsIElkZW50aWZpZXJzLkVsZW1lbnRSZWYpO1xuICAgICAgICAgICAgX3RoaXMuX2FkZFF1ZXJ5UmVhZHNUbyh7IHZhbHVlOiByZWZBc3QubmFtZSB9LCBkZWZhdWx0UXVlcnlWYWx1ZSwgX3RoaXMuX3F1ZXJpZWRUb2tlbnMpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuX3F1ZXJpZWRUb2tlbnMuZ2V0KHRoaXMudmlld0NvbnRleHQucmVmbGVjdG9yLnJlc29sdmVFeHRlcm5hbFJlZmVyZW5jZShJZGVudGlmaWVycy5WaWV3Q29udGFpbmVyUmVmKSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhc1ZpZXdDb250YWluZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgcHJvdmlkZXJzIHRoYXQgd2Uga25vdyBhcmUgZWFnZXIgZmlyc3RcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLl9hbGxQcm92aWRlcnMudmFsdWVzKCkpLmZvckVhY2goZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICB2YXIgZWFnZXIgPSBwcm92aWRlci5lYWdlciB8fCBfdGhpcy5fcXVlcmllZFRva2Vucy5nZXQodG9rZW5SZWZlcmVuY2UocHJvdmlkZXIudG9rZW4pKTtcbiAgICAgICAgICAgIGlmIChlYWdlcikge1xuICAgICAgICAgICAgICAgIF90aGlzLl9nZXRPckNyZWF0ZUxvY2FsUHJvdmlkZXIocHJvdmlkZXIucHJvdmlkZXJUeXBlLCBwcm92aWRlci50b2tlbiwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFByb3ZpZGVyRWxlbWVudENvbnRleHQucHJvdG90eXBlLmFmdGVyRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gY29sbGVjdCBsYXp5IHByb3ZpZGVyc1xuICAgICAgICBBcnJheS5mcm9tKHRoaXMuX2FsbFByb3ZpZGVycy52YWx1ZXMoKSkuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgIF90aGlzLl9nZXRPckNyZWF0ZUxvY2FsUHJvdmlkZXIocHJvdmlkZXIucHJvdmlkZXJUeXBlLCBwcm92aWRlci50b2tlbiwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcm92aWRlckVsZW1lbnRDb250ZXh0LnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1Qcm92aWRlcnNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gTm90ZTogTWFwcyBrZWVwIHRoZWlyIGluc2VydGlvbiBvcmRlci5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxhenlQcm92aWRlcnMgPSBbXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVhZ2VyUHJvdmlkZXJzID0gW107XG4gICAgICAgICAgICB0aGlzLl90cmFuc2Zvcm1lZFByb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgICAgIGlmIChwcm92aWRlci5lYWdlcikge1xuICAgICAgICAgICAgICAgICAgICBlYWdlclByb3ZpZGVycy5wdXNoKHByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxhenlQcm92aWRlcnMucHVzaChwcm92aWRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbGF6eVByb3ZpZGVycy5jb25jYXQoZWFnZXJQcm92aWRlcnMpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJvdmlkZXJFbGVtZW50Q29udGV4dC5wcm90b3R5cGUsIFwidHJhbnNmb3JtZWREaXJlY3RpdmVBc3RzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvcnRlZFByb3ZpZGVyVHlwZXMgPSB0aGlzLnRyYW5zZm9ybVByb3ZpZGVycy5tYXAoZnVuY3Rpb24gKHByb3ZpZGVyKSB7IHJldHVybiBwcm92aWRlci50b2tlbi5pZGVudGlmaWVyOyB9KTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvcnRlZERpcmVjdGl2ZXMgPSB0aGlzLl9kaXJlY3RpdmVBc3RzLnNsaWNlKCk7XG4gICAgICAgICAgICBzb3J0ZWREaXJlY3RpdmVzLnNvcnQoZnVuY3Rpb24gKGRpcjEsIGRpcjIpIHsgcmV0dXJuIHNvcnRlZFByb3ZpZGVyVHlwZXMuaW5kZXhPZihkaXIxLmRpcmVjdGl2ZS50eXBlKSAtXG4gICAgICAgICAgICAgICAgc29ydGVkUHJvdmlkZXJUeXBlcy5pbmRleE9mKGRpcjIuZGlyZWN0aXZlLnR5cGUpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBzb3J0ZWREaXJlY3RpdmVzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJvdmlkZXJFbGVtZW50Q29udGV4dC5wcm90b3R5cGUsIFwidHJhbnNmb3JtZWRIYXNWaWV3Q29udGFpbmVyXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2hhc1ZpZXdDb250YWluZXI7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcm92aWRlckVsZW1lbnRDb250ZXh0LnByb3RvdHlwZSwgXCJxdWVyeU1hdGNoZXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWxsTWF0Y2hlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fcXVlcmllZFRva2Vucy5mb3JFYWNoKGZ1bmN0aW9uIChtYXRjaGVzKSB7IGFsbE1hdGNoZXMucHVzaC5hcHBseShhbGxNYXRjaGVzLCBtYXRjaGVzKTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gYWxsTWF0Y2hlcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0b2tlblxuICAgICAqIEBwYXJhbSB7P30gZGVmYXVsdFZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBxdWVyeVJlYWRUb2tlbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFByb3ZpZGVyRWxlbWVudENvbnRleHQucHJvdG90eXBlLl9hZGRRdWVyeVJlYWRzVG8gPSBmdW5jdGlvbiAodG9rZW4sIGRlZmF1bHRWYWx1ZSwgcXVlcnlSZWFkVG9rZW5zKSB7XG4gICAgICAgIHRoaXMuX2dldFF1ZXJpZXNGb3IodG9rZW4pLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdWVyeVZhbHVlID0gcXVlcnkubWV0YS5yZWFkIHx8IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRva2VuUmVmID0gdG9rZW5SZWZlcmVuY2UocXVlcnlWYWx1ZSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdWVyeU1hdGNoZXMgPSBxdWVyeVJlYWRUb2tlbnMuZ2V0KHRva2VuUmVmKTtcbiAgICAgICAgICAgIGlmICghcXVlcnlNYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlNYXRjaGVzID0gW107XG4gICAgICAgICAgICAgICAgcXVlcnlSZWFkVG9rZW5zLnNldCh0b2tlblJlZiwgcXVlcnlNYXRjaGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHF1ZXJ5TWF0Y2hlcy5wdXNoKHsgcXVlcnlJZDogcXVlcnkucXVlcnlJZCwgdmFsdWU6IHF1ZXJ5VmFsdWUgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0b2tlblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUHJvdmlkZXJFbGVtZW50Q29udGV4dC5wcm90b3R5cGUuX2dldFF1ZXJpZXNGb3IgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGN1cnJlbnRFbCA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpc3RhbmNlID0gMDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVlcmllcztcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRFbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcXVlcmllcyA9IGN1cnJlbnRFbC5fY29udGVudFF1ZXJpZXMuZ2V0KHRva2VuUmVmZXJlbmNlKHRva2VuKSk7XG4gICAgICAgICAgICBpZiAocXVlcmllcykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgcXVlcmllcy5maWx0ZXIoZnVuY3Rpb24gKHF1ZXJ5KSB7IHJldHVybiBxdWVyeS5tZXRhLmRlc2NlbmRhbnRzIHx8IGRpc3RhbmNlIDw9IDE7IH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50RWwuX2RpcmVjdGl2ZUFzdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50RWwgPSBjdXJyZW50RWwuX3BhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBxdWVyaWVzID0gdGhpcy52aWV3Q29udGV4dC52aWV3UXVlcmllcy5nZXQodG9rZW5SZWZlcmVuY2UodG9rZW4pKTtcbiAgICAgICAgaWYgKHF1ZXJpZXMpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgcXVlcmllcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVxdWVzdGluZ1Byb3ZpZGVyVHlwZVxuICAgICAqIEBwYXJhbSB7P30gdG9rZW5cbiAgICAgKiBAcGFyYW0gez99IGVhZ2VyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQcm92aWRlckVsZW1lbnRDb250ZXh0LnByb3RvdHlwZS5fZ2V0T3JDcmVhdGVMb2NhbFByb3ZpZGVyID0gZnVuY3Rpb24gKHJlcXVlc3RpbmdQcm92aWRlclR5cGUsIHRva2VuLCBlYWdlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXNvbHZlZFByb3ZpZGVyID0gdGhpcy5fYWxsUHJvdmlkZXJzLmdldCh0b2tlblJlZmVyZW5jZSh0b2tlbikpO1xuICAgICAgICBpZiAoIXJlc29sdmVkUHJvdmlkZXIgfHwgKChyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlID09PSBQcm92aWRlckFzdFR5cGUuRGlyZWN0aXZlIHx8XG4gICAgICAgICAgICByZXF1ZXN0aW5nUHJvdmlkZXJUeXBlID09PSBQcm92aWRlckFzdFR5cGUuUHVibGljU2VydmljZSkgJiZcbiAgICAgICAgICAgIHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJUeXBlID09PSBQcm92aWRlckFzdFR5cGUuUHJpdmF0ZVNlcnZpY2UpIHx8XG4gICAgICAgICAgICAoKHJlcXVlc3RpbmdQcm92aWRlclR5cGUgPT09IFByb3ZpZGVyQXN0VHlwZS5Qcml2YXRlU2VydmljZSB8fFxuICAgICAgICAgICAgICAgIHJlcXVlc3RpbmdQcm92aWRlclR5cGUgPT09IFByb3ZpZGVyQXN0VHlwZS5QdWJsaWNTZXJ2aWNlKSAmJlxuICAgICAgICAgICAgICAgIHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJUeXBlID09PSBQcm92aWRlckFzdFR5cGUuQnVpbHRpbikpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zZm9ybWVkUHJvdmlkZXJBc3QgPSB0aGlzLl90cmFuc2Zvcm1lZFByb3ZpZGVycy5nZXQodG9rZW5SZWZlcmVuY2UodG9rZW4pKTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybWVkUHJvdmlkZXJBc3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zZWVuUHJvdmlkZXJzLmdldCh0b2tlblJlZmVyZW5jZSh0b2tlbikpICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudmlld0NvbnRleHQuZXJyb3JzLnB1c2gobmV3IFByb3ZpZGVyRXJyb3IoXCJDYW5ub3QgaW5zdGFudGlhdGUgY3ljbGljIGRlcGVuZGVuY3khIFwiICsgdG9rZW5OYW1lKHRva2VuKSwgdGhpcy5fc291cmNlU3BhbikpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2VlblByb3ZpZGVycy5zZXQodG9rZW5SZWZlcmVuY2UodG9rZW4pLCB0cnVlKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNmb3JtZWRQcm92aWRlcnMgPSByZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVycy5tYXAoZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc2Zvcm1lZFVzZVZhbHVlID0gcHJvdmlkZXIudXNlVmFsdWU7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc2Zvcm1lZFVzZUV4aXN0aW5nID0gKChwcm92aWRlci51c2VFeGlzdGluZykpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNmb3JtZWREZXBzID0gKCh1bmRlZmluZWQpKTtcbiAgICAgICAgICAgIGlmIChwcm92aWRlci51c2VFeGlzdGluZyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhpc3RpbmdEaURlcCA9ICgoX3RoaXMuX2dldERlcGVuZGVuY3kocmVzb2x2ZWRQcm92aWRlci5wcm92aWRlclR5cGUsIHsgdG9rZW46IHByb3ZpZGVyLnVzZUV4aXN0aW5nIH0sIGVhZ2VyKSkpO1xuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0RpRGVwLnRva2VuICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRVc2VFeGlzdGluZyA9IGV4aXN0aW5nRGlEZXAudG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFVzZUV4aXN0aW5nID0gKChudWxsKSk7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkVXNlVmFsdWUgPSBleGlzdGluZ0RpRGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyLnVzZUZhY3RvcnkpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXBzID0gcHJvdmlkZXIuZGVwcyB8fCBwcm92aWRlci51c2VGYWN0b3J5LmRpRGVwcztcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZERlcHMgPVxuICAgICAgICAgICAgICAgICAgICBkZXBzLm1hcChmdW5jdGlvbiAoZGVwKSB7IHJldHVybiAoKF90aGlzLl9nZXREZXBlbmRlbmN5KHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJUeXBlLCBkZXAsIGVhZ2VyKSkpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyLnVzZUNsYXNzKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVwcyA9IHByb3ZpZGVyLmRlcHMgfHwgcHJvdmlkZXIudXNlQ2xhc3MuZGlEZXBzO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkRGVwcyA9XG4gICAgICAgICAgICAgICAgICAgIGRlcHMubWFwKGZ1bmN0aW9uIChkZXApIHsgcmV0dXJuICgoX3RoaXMuX2dldERlcGVuZGVuY3kocmVzb2x2ZWRQcm92aWRlci5wcm92aWRlclR5cGUsIGRlcCwgZWFnZXIpKSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF90cmFuc2Zvcm1Qcm92aWRlcihwcm92aWRlciwge1xuICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiB0cmFuc2Zvcm1lZFVzZUV4aXN0aW5nLFxuICAgICAgICAgICAgICAgIHVzZVZhbHVlOiB0cmFuc2Zvcm1lZFVzZVZhbHVlLFxuICAgICAgICAgICAgICAgIGRlcHM6IHRyYW5zZm9ybWVkRGVwc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0ID1cbiAgICAgICAgICAgIF90cmFuc2Zvcm1Qcm92aWRlckFzdChyZXNvbHZlZFByb3ZpZGVyLCB7IGVhZ2VyOiBlYWdlciwgcHJvdmlkZXJzOiB0cmFuc2Zvcm1lZFByb3ZpZGVycyB9KTtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtZWRQcm92aWRlcnMuc2V0KHRva2VuUmVmZXJlbmNlKHRva2VuKSwgdHJhbnNmb3JtZWRQcm92aWRlckFzdCk7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByZXF1ZXN0aW5nUHJvdmlkZXJUeXBlXG4gICAgICogQHBhcmFtIHs/fSBkZXBcbiAgICAgKiBAcGFyYW0gez89fSBlYWdlclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUHJvdmlkZXJFbGVtZW50Q29udGV4dC5wcm90b3R5cGUuX2dldExvY2FsRGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlLCBkZXAsIGVhZ2VyKSB7XG4gICAgICAgIGlmIChlYWdlciA9PT0gdm9pZCAwKSB7IGVhZ2VyID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKGRlcC5pc0F0dHJpYnV0ZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXR0clZhbHVlID0gdGhpcy5fYXR0cnNbKChkZXAudG9rZW4pKS52YWx1ZV07XG4gICAgICAgICAgICByZXR1cm4geyBpc1ZhbHVlOiB0cnVlLCB2YWx1ZTogYXR0clZhbHVlID09IG51bGwgPyBudWxsIDogYXR0clZhbHVlIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlcC50b2tlbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBhY2Nlc3MgYnVpbHRpbnRzXG4gICAgICAgICAgICBpZiAoKHJlcXVlc3RpbmdQcm92aWRlclR5cGUgPT09IFByb3ZpZGVyQXN0VHlwZS5EaXJlY3RpdmUgfHxcbiAgICAgICAgICAgICAgICByZXF1ZXN0aW5nUHJvdmlkZXJUeXBlID09PSBQcm92aWRlckFzdFR5cGUuQ29tcG9uZW50KSkge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlblJlZmVyZW5jZShkZXAudG9rZW4pID09PVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdDb250ZXh0LnJlZmxlY3Rvci5yZXNvbHZlRXh0ZXJuYWxSZWZlcmVuY2UoSWRlbnRpZmllcnMuUmVuZGVyZXIpIHx8XG4gICAgICAgICAgICAgICAgICAgIHRva2VuUmVmZXJlbmNlKGRlcC50b2tlbikgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdDb250ZXh0LnJlZmxlY3Rvci5yZXNvbHZlRXh0ZXJuYWxSZWZlcmVuY2UoSWRlbnRpZmllcnMuRWxlbWVudFJlZikgfHxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5SZWZlcmVuY2UoZGVwLnRva2VuKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlld0NvbnRleHQucmVmbGVjdG9yLnJlc29sdmVFeHRlcm5hbFJlZmVyZW5jZShJZGVudGlmaWVycy5DaGFuZ2VEZXRlY3RvclJlZikgfHxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5SZWZlcmVuY2UoZGVwLnRva2VuKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlld0NvbnRleHQucmVmbGVjdG9yLnJlc29sdmVFeHRlcm5hbFJlZmVyZW5jZShJZGVudGlmaWVycy5UZW1wbGF0ZVJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuUmVmZXJlbmNlKGRlcC50b2tlbikgPT09XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld0NvbnRleHQucmVmbGVjdG9yLnJlc29sdmVFeHRlcm5hbFJlZmVyZW5jZShJZGVudGlmaWVycy5WaWV3Q29udGFpbmVyUmVmKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYXNWaWV3Q29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhY2Nlc3MgdGhlIGluamVjdG9yXG4gICAgICAgICAgICBpZiAodG9rZW5SZWZlcmVuY2UoZGVwLnRva2VuKSA9PT1cbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdDb250ZXh0LnJlZmxlY3Rvci5yZXNvbHZlRXh0ZXJuYWxSZWZlcmVuY2UoSWRlbnRpZmllcnMuSW5qZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFjY2VzcyBwcm92aWRlcnNcbiAgICAgICAgICAgIGlmICh0aGlzLl9nZXRPckNyZWF0ZUxvY2FsUHJvdmlkZXIocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSwgZGVwLnRva2VuLCBlYWdlcikgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlcXVlc3RpbmdQcm92aWRlclR5cGVcbiAgICAgKiBAcGFyYW0gez99IGRlcFxuICAgICAqIEBwYXJhbSB7Pz19IGVhZ2VyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQcm92aWRlckVsZW1lbnRDb250ZXh0LnByb3RvdHlwZS5fZ2V0RGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlLCBkZXAsIGVhZ2VyKSB7XG4gICAgICAgIGlmIChlYWdlciA9PT0gdm9pZCAwKSB7IGVhZ2VyID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3VyckVsZW1lbnQgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdXJyRWFnZXIgPSBlYWdlcjtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFkZXAuaXNTa2lwU2VsZikge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fZ2V0TG9jYWxEZXBlbmRlbmN5KHJlcXVlc3RpbmdQcm92aWRlclR5cGUsIGRlcCwgZWFnZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXAuaXNTZWxmKSB7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCAmJiBkZXAuaXNPcHRpb25hbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHsgaXNWYWx1ZTogdHJ1ZSwgdmFsdWU6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIHBhcmVudCBlbGVtZW50c1xuICAgICAgICAgICAgd2hpbGUgKCFyZXN1bHQgJiYgY3VyckVsZW1lbnQuX3BhcmVudCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZXZFbGVtZW50ID0gY3VyckVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgY3VyckVsZW1lbnQgPSBjdXJyRWxlbWVudC5fcGFyZW50O1xuICAgICAgICAgICAgICAgIGlmIChwcmV2RWxlbWVudC5faXNWaWV3Um9vdCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyRWFnZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY3VyckVsZW1lbnQuX2dldExvY2FsRGVwZW5kZW5jeShQcm92aWRlckFzdFR5cGUuUHVibGljU2VydmljZSwgZGVwLCBjdXJyRWFnZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2hlY2sgQEhvc3QgcmVzdHJpY3Rpb25cbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkZXAuaXNIb3N0IHx8IHRoaXMudmlld0NvbnRleHQuY29tcG9uZW50LmlzSG9zdCB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdDb250ZXh0LmNvbXBvbmVudC50eXBlLnJlZmVyZW5jZSA9PT0gdG9rZW5SZWZlcmVuY2UoLyoqIEB0eXBlIHs/fSAqLyAoKGRlcC50b2tlbikpKSB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdDb250ZXh0LnZpZXdQcm92aWRlcnMuZ2V0KHRva2VuUmVmZXJlbmNlKC8qKiBAdHlwZSB7P30gKi8gKChkZXAudG9rZW4pKSkpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZGVwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZGVwLmlzT3B0aW9uYWwgPyByZXN1bHQgPSB7IGlzVmFsdWU6IHRydWUsIHZhbHVlOiBudWxsIH0gOiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy52aWV3Q29udGV4dC5lcnJvcnMucHVzaChuZXcgUHJvdmlkZXJFcnJvcihcIk5vIHByb3ZpZGVyIGZvciBcIiArIHRva2VuTmFtZSgvKiogQHR5cGUgez99ICovICgoZGVwLnRva2VuKSkpLCB0aGlzLl9zb3VyY2VTcGFuKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBQcm92aWRlckVsZW1lbnRDb250ZXh0O1xufSgpKTtcbnZhciBOZ01vZHVsZVByb3ZpZGVyQW5hbHl6ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVmbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBuZ01vZHVsZVxuICAgICAqIEBwYXJhbSB7P30gZXh0cmFQcm92aWRlcnNcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBOZ01vZHVsZVByb3ZpZGVyQW5hbHl6ZXIocmVmbGVjdG9yLCBuZ01vZHVsZSwgZXh0cmFQcm92aWRlcnMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5yZWZsZWN0b3IgPSByZWZsZWN0b3I7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybWVkUHJvdmlkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9zZWVuUHJvdmlkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9lcnJvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5fYWxsUHJvdmlkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICBuZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLm1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobmdNb2R1bGVUeXBlKSB7XG4gICAgICAgICAgICB2YXIgbmdNb2R1bGVQcm92aWRlciA9IHsgdG9rZW46IHsgaWRlbnRpZmllcjogbmdNb2R1bGVUeXBlIH0sIHVzZUNsYXNzOiBuZ01vZHVsZVR5cGUgfTtcbiAgICAgICAgICAgIF9yZXNvbHZlUHJvdmlkZXJzKFtuZ01vZHVsZVByb3ZpZGVyXSwgUHJvdmlkZXJBc3RUeXBlLlB1YmxpY1NlcnZpY2UsIHRydWUsIHNvdXJjZVNwYW4sIF90aGlzLl9lcnJvcnMsIF90aGlzLl9hbGxQcm92aWRlcnMpO1xuICAgICAgICB9KTtcbiAgICAgICAgX3Jlc29sdmVQcm92aWRlcnMobmdNb2R1bGUudHJhbnNpdGl2ZU1vZHVsZS5wcm92aWRlcnMubWFwKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gZW50cnkucHJvdmlkZXI7IH0pLmNvbmNhdChleHRyYVByb3ZpZGVycyksIFByb3ZpZGVyQXN0VHlwZS5QdWJsaWNTZXJ2aWNlLCBmYWxzZSwgc291cmNlU3BhbiwgdGhpcy5fZXJyb3JzLCB0aGlzLl9hbGxQcm92aWRlcnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5nTW9kdWxlUHJvdmlkZXJBbmFseXplci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIEFycmF5LmZyb20odGhpcy5fYWxsUHJvdmlkZXJzLnZhbHVlcygpKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgX3RoaXMuX2dldE9yQ3JlYXRlTG9jYWxQcm92aWRlcihwcm92aWRlci50b2tlbiwgcHJvdmlkZXIuZWFnZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuX2Vycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvclN0cmluZyA9IHRoaXMuX2Vycm9ycy5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3ZpZGVyIHBhcnNlIGVycm9yczpcXG5cIiArIGVycm9yU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlOiBNYXBzIGtlZXAgdGhlaXIgaW5zZXJ0aW9uIG9yZGVyLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsYXp5UHJvdmlkZXJzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVhZ2VyUHJvdmlkZXJzID0gW107XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybWVkUHJvdmlkZXJzLmZvckVhY2goZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICBpZiAocHJvdmlkZXIuZWFnZXIpIHtcbiAgICAgICAgICAgICAgICBlYWdlclByb3ZpZGVycy5wdXNoKHByb3ZpZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxhenlQcm92aWRlcnMucHVzaChwcm92aWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbGF6eVByb3ZpZGVycy5jb25jYXQoZWFnZXJQcm92aWRlcnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0b2tlblxuICAgICAqIEBwYXJhbSB7P30gZWFnZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5nTW9kdWxlUHJvdmlkZXJBbmFseXplci5wcm90b3R5cGUuX2dldE9yQ3JlYXRlTG9jYWxQcm92aWRlciA9IGZ1bmN0aW9uICh0b2tlbiwgZWFnZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzb2x2ZWRQcm92aWRlciA9IHRoaXMuX2FsbFByb3ZpZGVycy5nZXQodG9rZW5SZWZlcmVuY2UodG9rZW4pKTtcbiAgICAgICAgaWYgKCFyZXNvbHZlZFByb3ZpZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0ID0gdGhpcy5fdHJhbnNmb3JtZWRQcm92aWRlcnMuZ2V0KHRva2VuUmVmZXJlbmNlKHRva2VuKSk7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRQcm92aWRlckFzdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc2VlblByb3ZpZGVycy5nZXQodG9rZW5SZWZlcmVuY2UodG9rZW4pKSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChuZXcgUHJvdmlkZXJFcnJvcihcIkNhbm5vdCBpbnN0YW50aWF0ZSBjeWNsaWMgZGVwZW5kZW5jeSEgXCIgKyB0b2tlbk5hbWUodG9rZW4pLCByZXNvbHZlZFByb3ZpZGVyLnNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NlZW5Qcm92aWRlcnMuc2V0KHRva2VuUmVmZXJlbmNlKHRva2VuKSwgdHJ1ZSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zZm9ybWVkUHJvdmlkZXJzID0gcmVzb2x2ZWRQcm92aWRlci5wcm92aWRlcnMubWFwKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNmb3JtZWRVc2VWYWx1ZSA9IHByb3ZpZGVyLnVzZVZhbHVlO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNmb3JtZWRVc2VFeGlzdGluZyA9ICgocHJvdmlkZXIudXNlRXhpc3RpbmcpKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zZm9ybWVkRGVwcyA9ICgodW5kZWZpbmVkKSk7XG4gICAgICAgICAgICBpZiAocHJvdmlkZXIudXNlRXhpc3RpbmcgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4aXN0aW5nRGlEZXAgPSBfdGhpcy5fZ2V0RGVwZW5kZW5jeSh7IHRva2VuOiBwcm92aWRlci51c2VFeGlzdGluZyB9LCBlYWdlciwgcmVzb2x2ZWRQcm92aWRlci5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdEaURlcC50b2tlbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkVXNlRXhpc3RpbmcgPSBleGlzdGluZ0RpRGVwLnRva2VuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRVc2VFeGlzdGluZyA9ICgobnVsbCkpO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFVzZVZhbHVlID0gZXhpc3RpbmdEaURlcC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm92aWRlci51c2VGYWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVwcyA9IHByb3ZpZGVyLmRlcHMgfHwgcHJvdmlkZXIudXNlRmFjdG9yeS5kaURlcHM7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtZWREZXBzID1cbiAgICAgICAgICAgICAgICAgICAgZGVwcy5tYXAoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gX3RoaXMuX2dldERlcGVuZGVuY3koZGVwLCBlYWdlciwgcmVzb2x2ZWRQcm92aWRlci5zb3VyY2VTcGFuKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm92aWRlci51c2VDbGFzcykge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlcHMgPSBwcm92aWRlci5kZXBzIHx8IHByb3ZpZGVyLnVzZUNsYXNzLmRpRGVwcztcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZERlcHMgPVxuICAgICAgICAgICAgICAgICAgICBkZXBzLm1hcChmdW5jdGlvbiAoZGVwKSB7IHJldHVybiBfdGhpcy5fZ2V0RGVwZW5kZW5jeShkZXAsIGVhZ2VyLCByZXNvbHZlZFByb3ZpZGVyLnNvdXJjZVNwYW4pOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfdHJhbnNmb3JtUHJvdmlkZXIocHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogdHJhbnNmb3JtZWRVc2VFeGlzdGluZyxcbiAgICAgICAgICAgICAgICB1c2VWYWx1ZTogdHJhbnNmb3JtZWRVc2VWYWx1ZSxcbiAgICAgICAgICAgICAgICBkZXBzOiB0cmFuc2Zvcm1lZERlcHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdHJhbnNmb3JtZWRQcm92aWRlckFzdCA9XG4gICAgICAgICAgICBfdHJhbnNmb3JtUHJvdmlkZXJBc3QocmVzb2x2ZWRQcm92aWRlciwgeyBlYWdlcjogZWFnZXIsIHByb3ZpZGVyczogdHJhbnNmb3JtZWRQcm92aWRlcnMgfSk7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybWVkUHJvdmlkZXJzLnNldCh0b2tlblJlZmVyZW5jZSh0b2tlbiksIHRyYW5zZm9ybWVkUHJvdmlkZXJBc3QpO1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRQcm92aWRlckFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGVwXG4gICAgICogQHBhcmFtIHs/PX0gZWFnZXJcbiAgICAgKiBAcGFyYW0gez89fSByZXF1ZXN0b3JTb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOZ01vZHVsZVByb3ZpZGVyQW5hbHl6ZXIucHJvdG90eXBlLl9nZXREZXBlbmRlbmN5ID0gZnVuY3Rpb24gKGRlcCwgZWFnZXIsIHJlcXVlc3RvclNvdXJjZVNwYW4pIHtcbiAgICAgICAgaWYgKGVhZ2VyID09PSB2b2lkIDApIHsgZWFnZXIgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmb3VuZExvY2FsID0gZmFsc2U7XG4gICAgICAgIGlmICghZGVwLmlzU2tpcFNlbGYgJiYgZGVwLnRva2VuICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGFjY2VzcyB0aGUgaW5qZWN0b3JcbiAgICAgICAgICAgIGlmICh0b2tlblJlZmVyZW5jZShkZXAudG9rZW4pID09PVxuICAgICAgICAgICAgICAgIHRoaXMucmVmbGVjdG9yLnJlc29sdmVFeHRlcm5hbFJlZmVyZW5jZShJZGVudGlmaWVycy5JbmplY3RvcikgfHxcbiAgICAgICAgICAgICAgICB0b2tlblJlZmVyZW5jZShkZXAudG9rZW4pID09PVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZmxlY3Rvci5yZXNvbHZlRXh0ZXJuYWxSZWZlcmVuY2UoSWRlbnRpZmllcnMuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyKSkge1xuICAgICAgICAgICAgICAgIGZvdW5kTG9jYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIGFjY2VzcyBwcm92aWRlcnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2dldE9yQ3JlYXRlTG9jYWxQcm92aWRlcihkZXAudG9rZW4sIGVhZ2VyKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm91bmRMb2NhbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gZGVwO1xuICAgICAgICBpZiAoZGVwLmlzU2VsZiAmJiAhZm91bmRMb2NhbCkge1xuICAgICAgICAgICAgaWYgKGRlcC5pc09wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0geyBpc1ZhbHVlOiB0cnVlLCB2YWx1ZTogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IFByb3ZpZGVyRXJyb3IoXCJObyBwcm92aWRlciBmb3IgXCIgKyB0b2tlbk5hbWUoLyoqIEB0eXBlIHs/fSAqLyAoKGRlcC50b2tlbikpKSwgcmVxdWVzdG9yU291cmNlU3BhbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gTmdNb2R1bGVQcm92aWRlckFuYWx5emVyO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBwcm92aWRlclxuICogQHBhcmFtIHs/fSBfXzFcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF90cmFuc2Zvcm1Qcm92aWRlcihwcm92aWRlciwgX2EpIHtcbiAgICB2YXIgdXNlRXhpc3RpbmcgPSBfYS51c2VFeGlzdGluZywgdXNlVmFsdWUgPSBfYS51c2VWYWx1ZSwgZGVwcyA9IF9hLmRlcHM7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9rZW46IHByb3ZpZGVyLnRva2VuLFxuICAgICAgICB1c2VDbGFzczogcHJvdmlkZXIudXNlQ2xhc3MsXG4gICAgICAgIHVzZUV4aXN0aW5nOiB1c2VFeGlzdGluZyxcbiAgICAgICAgdXNlRmFjdG9yeTogcHJvdmlkZXIudXNlRmFjdG9yeSxcbiAgICAgICAgdXNlVmFsdWU6IHVzZVZhbHVlLFxuICAgICAgICBkZXBzOiBkZXBzLFxuICAgICAgICBtdWx0aTogcHJvdmlkZXIubXVsdGlcbiAgICB9O1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHByb3ZpZGVyXG4gKiBAcGFyYW0gez99IF9fMVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX3RyYW5zZm9ybVByb3ZpZGVyQXN0KHByb3ZpZGVyLCBfYSkge1xuICAgIHZhciBlYWdlciA9IF9hLmVhZ2VyLCBwcm92aWRlcnMgPSBfYS5wcm92aWRlcnM7XG4gICAgcmV0dXJuIG5ldyBQcm92aWRlckFzdChwcm92aWRlci50b2tlbiwgcHJvdmlkZXIubXVsdGlQcm92aWRlciwgcHJvdmlkZXIuZWFnZXIgfHwgZWFnZXIsIHByb3ZpZGVycywgcHJvdmlkZXIucHJvdmlkZXJUeXBlLCBwcm92aWRlci5saWZlY3ljbGVIb29rcywgcHJvdmlkZXIuc291cmNlU3Bhbik7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZGlyZWN0aXZlc1xuICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gKiBAcGFyYW0gez99IHRhcmdldEVycm9yc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX3Jlc29sdmVQcm92aWRlcnNGcm9tRGlyZWN0aXZlcyhkaXJlY3RpdmVzLCBzb3VyY2VTcGFuLCB0YXJnZXRFcnJvcnMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm92aWRlcnNCeVRva2VuID0gbmV3IE1hcCgpO1xuICAgIGRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpclByb3ZpZGVyID0geyB0b2tlbjogeyBpZGVudGlmaWVyOiBkaXJlY3RpdmUudHlwZSB9LCB1c2VDbGFzczogZGlyZWN0aXZlLnR5cGUgfTtcbiAgICAgICAgX3Jlc29sdmVQcm92aWRlcnMoW2RpclByb3ZpZGVyXSwgZGlyZWN0aXZlLmlzQ29tcG9uZW50ID8gUHJvdmlkZXJBc3RUeXBlLkNvbXBvbmVudCA6IFByb3ZpZGVyQXN0VHlwZS5EaXJlY3RpdmUsIHRydWUsIHNvdXJjZVNwYW4sIHRhcmdldEVycm9ycywgcHJvdmlkZXJzQnlUb2tlbik7XG4gICAgfSk7XG4gICAgLy8gTm90ZTogZGlyZWN0aXZlcyBuZWVkIHRvIGJlIGFibGUgdG8gb3ZlcndyaXRlIHByb3ZpZGVycyBvZiBhIGNvbXBvbmVudCFcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXJlY3RpdmVzV2l0aENvbXBvbmVudEZpcnN0ID0gZGlyZWN0aXZlcy5maWx0ZXIoZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gZGlyLmlzQ29tcG9uZW50OyB9KS5jb25jYXQoZGlyZWN0aXZlcy5maWx0ZXIoZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gIWRpci5pc0NvbXBvbmVudDsgfSkpO1xuICAgIGRpcmVjdGl2ZXNXaXRoQ29tcG9uZW50Rmlyc3QuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XG4gICAgICAgIF9yZXNvbHZlUHJvdmlkZXJzKGRpcmVjdGl2ZS5wcm92aWRlcnMsIFByb3ZpZGVyQXN0VHlwZS5QdWJsaWNTZXJ2aWNlLCBmYWxzZSwgc291cmNlU3BhbiwgdGFyZ2V0RXJyb3JzLCBwcm92aWRlcnNCeVRva2VuKTtcbiAgICAgICAgX3Jlc29sdmVQcm92aWRlcnMoZGlyZWN0aXZlLnZpZXdQcm92aWRlcnMsIFByb3ZpZGVyQXN0VHlwZS5Qcml2YXRlU2VydmljZSwgZmFsc2UsIHNvdXJjZVNwYW4sIHRhcmdldEVycm9ycywgcHJvdmlkZXJzQnlUb2tlbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb3ZpZGVyc0J5VG9rZW47XG59XG4vKipcbiAqIEBwYXJhbSB7P30gcHJvdmlkZXJzXG4gKiBAcGFyYW0gez99IHByb3ZpZGVyVHlwZVxuICogQHBhcmFtIHs/fSBlYWdlclxuICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gKiBAcGFyYW0gez99IHRhcmdldEVycm9yc1xuICogQHBhcmFtIHs/fSB0YXJnZXRQcm92aWRlcnNCeVRva2VuXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfcmVzb2x2ZVByb3ZpZGVycyhwcm92aWRlcnMsIHByb3ZpZGVyVHlwZSwgZWFnZXIsIHNvdXJjZVNwYW4sIHRhcmdldEVycm9ycywgdGFyZ2V0UHJvdmlkZXJzQnlUb2tlbikge1xuICAgIHByb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXNvbHZlZFByb3ZpZGVyID0gdGFyZ2V0UHJvdmlkZXJzQnlUb2tlbi5nZXQodG9rZW5SZWZlcmVuY2UocHJvdmlkZXIudG9rZW4pKTtcbiAgICAgICAgaWYgKHJlc29sdmVkUHJvdmlkZXIgIT0gbnVsbCAmJiAhIXJlc29sdmVkUHJvdmlkZXIubXVsdGlQcm92aWRlciAhPT0gISFwcm92aWRlci5tdWx0aSkge1xuICAgICAgICAgICAgdGFyZ2V0RXJyb3JzLnB1c2gobmV3IFByb3ZpZGVyRXJyb3IoXCJNaXhpbmcgbXVsdGkgYW5kIG5vbiBtdWx0aSBwcm92aWRlciBpcyBub3QgcG9zc2libGUgZm9yIHRva2VuIFwiICsgdG9rZW5OYW1lKHJlc29sdmVkUHJvdmlkZXIudG9rZW4pLCBzb3VyY2VTcGFuKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXNvbHZlZFByb3ZpZGVyKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsaWZlY3ljbGVIb29rcyA9IHByb3ZpZGVyLnRva2VuLmlkZW50aWZpZXIgJiZcbiAgICAgICAgICAgICAgICAoKHByb3ZpZGVyLnRva2VuLmlkZW50aWZpZXIpKS5saWZlY3ljbGVIb29rcyA/XG4gICAgICAgICAgICAgICAgKChwcm92aWRlci50b2tlbi5pZGVudGlmaWVyKSkubGlmZWN5Y2xlSG9va3MgOlxuICAgICAgICAgICAgICAgIFtdO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNVc2VWYWx1ZSA9ICEocHJvdmlkZXIudXNlQ2xhc3MgfHwgcHJvdmlkZXIudXNlRXhpc3RpbmcgfHwgcHJvdmlkZXIudXNlRmFjdG9yeSk7XG4gICAgICAgICAgICByZXNvbHZlZFByb3ZpZGVyID0gbmV3IFByb3ZpZGVyQXN0KHByb3ZpZGVyLnRva2VuLCAhIXByb3ZpZGVyLm11bHRpLCBlYWdlciB8fCBpc1VzZVZhbHVlLCBbcHJvdmlkZXJdLCBwcm92aWRlclR5cGUsIGxpZmVjeWNsZUhvb2tzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHRhcmdldFByb3ZpZGVyc0J5VG9rZW4uc2V0KHRva2VuUmVmZXJlbmNlKHByb3ZpZGVyLnRva2VuKSwgcmVzb2x2ZWRQcm92aWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXByb3ZpZGVyLm11bHRpKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRQcm92aWRlci5wcm92aWRlcnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJzLnB1c2gocHJvdmlkZXIpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gY29tcG9uZW50XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfZ2V0Vmlld1F1ZXJpZXMoY29tcG9uZW50KSB7XG4gICAgLy8gTm90ZTogcXVlcmllcyBzdGFydCB3aXRoIGlkIDEgc28gd2UgY2FuIHVzZSB0aGUgbnVtYmVyIGluIGEgQmxvb20gZmlsdGVyIVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpZXdRdWVyeUlkID0gMTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aWV3UXVlcmllcyA9IG5ldyBNYXAoKTtcbiAgICBpZiAoY29tcG9uZW50LnZpZXdRdWVyaWVzKSB7XG4gICAgICAgIGNvbXBvbmVudC52aWV3UXVlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyeSkgeyByZXR1cm4gX2FkZFF1ZXJ5VG9Ub2tlbk1hcCh2aWV3UXVlcmllcywgeyBtZXRhOiBxdWVyeSwgcXVlcnlJZDogdmlld1F1ZXJ5SWQrKyB9KTsgfSk7XG4gICAgfVxuICAgIHJldHVybiB2aWV3UXVlcmllcztcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBjb250ZW50UXVlcnlTdGFydElkXG4gKiBAcGFyYW0gez99IGRpcmVjdGl2ZXNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9nZXRDb250ZW50UXVlcmllcyhjb250ZW50UXVlcnlTdGFydElkLCBkaXJlY3RpdmVzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udGVudFF1ZXJ5SWQgPSBjb250ZW50UXVlcnlTdGFydElkO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRlbnRRdWVyaWVzID0gbmV3IE1hcCgpO1xuICAgIGRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlLCBkaXJlY3RpdmVJbmRleCkge1xuICAgICAgICBpZiAoZGlyZWN0aXZlLnF1ZXJpZXMpIHtcbiAgICAgICAgICAgIGRpcmVjdGl2ZS5xdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5KSB7IHJldHVybiBfYWRkUXVlcnlUb1Rva2VuTWFwKGNvbnRlbnRRdWVyaWVzLCB7IG1ldGE6IHF1ZXJ5LCBxdWVyeUlkOiBjb250ZW50UXVlcnlJZCsrIH0pOyB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjb250ZW50UXVlcmllcztcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBtYXBcbiAqIEBwYXJhbSB7P30gcXVlcnlcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9hZGRRdWVyeVRvVG9rZW5NYXAobWFwLCBxdWVyeSkge1xuICAgIHF1ZXJ5Lm1ldGEuc2VsZWN0b3JzLmZvckVhY2goZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVudHJ5ID0gbWFwLmdldCh0b2tlblJlZmVyZW5jZSh0b2tlbikpO1xuICAgICAgICBpZiAoIWVudHJ5KSB7XG4gICAgICAgICAgICBlbnRyeSA9IFtdO1xuICAgICAgICAgICAgbWFwLnNldCh0b2tlblJlZmVyZW5jZSh0b2tlbiksIGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICBlbnRyeS5wdXNoKHF1ZXJ5KTtcbiAgICB9KTtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQGFic3RyYWN0XG4gKi9cbnZhciBFbGVtZW50U2NoZW1hUmVnaXN0cnkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVsZW1lbnRTY2hlbWFSZWdpc3RyeSgpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSB0YWdOYW1lXG4gICAgICogQHBhcmFtIHs/fSBwcm9wTmFtZVxuICAgICAqIEBwYXJhbSB7P30gc2NoZW1hTWV0YXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUuaGFzUHJvcGVydHkgPSBmdW5jdGlvbiAodGFnTmFtZSwgcHJvcE5hbWUsIHNjaGVtYU1ldGFzKSB7IH07XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSB0YWdOYW1lXG4gICAgICogQHBhcmFtIHs/fSBzY2hlbWFNZXRhc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5oYXNFbGVtZW50ID0gZnVuY3Rpb24gKHRhZ05hbWUsIHNjaGVtYU1ldGFzKSB7IH07XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50TmFtZVxuICAgICAqIEBwYXJhbSB7P30gcHJvcE5hbWVcbiAgICAgKiBAcGFyYW0gez99IGlzQXR0cmlidXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLnNlY3VyaXR5Q29udGV4dCA9IGZ1bmN0aW9uIChlbGVtZW50TmFtZSwgcHJvcE5hbWUsIGlzQXR0cmlidXRlKSB7IH07XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLmFsbEtub3duRWxlbWVudE5hbWVzID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gcHJvcE5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUuZ2V0TWFwcGVkUHJvcE5hbWUgPSBmdW5jdGlvbiAocHJvcE5hbWUpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUuZ2V0RGVmYXVsdENvbXBvbmVudEVsZW1lbnROYW1lID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS52YWxpZGF0ZVByb3BlcnR5ID0gZnVuY3Rpb24gKG5hbWUpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUudmFsaWRhdGVBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobmFtZSkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gcHJvcE5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUubm9ybWFsaXplQW5pbWF0aW9uU3R5bGVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wTmFtZSkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gY2FtZWxDYXNlUHJvcFxuICAgICAqIEBwYXJhbSB7P30gdXNlclByb3ZpZGVkUHJvcFxuICAgICAqIEBwYXJhbSB7P30gdmFsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLm5vcm1hbGl6ZUFuaW1hdGlvblN0eWxlVmFsdWUgPSBmdW5jdGlvbiAoY2FtZWxDYXNlUHJvcCwgdXNlclByb3ZpZGVkUHJvcCwgdmFsKSB7IH07XG4gICAgcmV0dXJuIEVsZW1lbnRTY2hlbWFSZWdpc3RyeTtcbn0oKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgU3R5bGVXaXRoSW1wb3J0cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZVxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVVcmxzXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3R5bGVXaXRoSW1wb3J0cyhzdHlsZSQkMSwgc3R5bGVVcmxzKSB7XG4gICAgICAgIHRoaXMuc3R5bGUgPSBzdHlsZSQkMTtcbiAgICAgICAgdGhpcy5zdHlsZVVybHMgPSBzdHlsZVVybHM7XG4gICAgfVxuICAgIHJldHVybiBTdHlsZVdpdGhJbXBvcnRzO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSB1cmxcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzU3R5bGVVcmxSZXNvbHZhYmxlKHVybCkge1xuICAgIGlmICh1cmwgPT0gbnVsbCB8fCB1cmwubGVuZ3RoID09PSAwIHx8IHVybFswXSA9PSAnLycpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzY2hlbWVNYXRjaCA9IHVybC5tYXRjaChVUkxfV0lUSF9TQ0hFTUFfUkVHRVhQKTtcbiAgICByZXR1cm4gc2NoZW1lTWF0Y2ggPT09IG51bGwgfHwgc2NoZW1lTWF0Y2hbMV0gPT0gJ3BhY2thZ2UnIHx8IHNjaGVtZU1hdGNoWzFdID09ICdhc3NldCc7XG59XG4vKipcbiAqIFJld3JpdGVzIHN0eWxlc2hlZXRzIGJ5IHJlc29sdmluZyBhbmQgcmVtb3ZpbmcgdGhlIFxcQGltcG9ydCB1cmxzIHRoYXRcbiAqIGFyZSBlaXRoZXIgcmVsYXRpdmUgb3IgZG9uJ3QgaGF2ZSBhIGBwYWNrYWdlOmAgc2NoZW1lXG4gKiBAcGFyYW0gez99IHJlc29sdmVyXG4gKiBAcGFyYW0gez99IGJhc2VVcmxcbiAqIEBwYXJhbSB7P30gY3NzVGV4dFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFN0eWxlVXJscyhyZXNvbHZlciwgYmFzZVVybCwgY3NzVGV4dCkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGZvdW5kVXJscyA9IFtdO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG1vZGlmaWVkQ3NzVGV4dCA9IGNzc1RleHQucmVwbGFjZShDU1NfQ09NTUVOVF9SRUdFWFAsICcnKS5yZXBsYWNlKENTU19JTVBPUlRfUkVHRVhQLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBtW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXJsID0gbVsxXSB8fCBtWzJdO1xuICAgICAgICBpZiAoIWlzU3R5bGVVcmxSZXNvbHZhYmxlKHVybCkpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdCBhdHRlbXB0IHRvIHJlc29sdmUgbm9uLXBhY2thZ2UgYWJzb2x1dGUgVVJMcyB3aXRoIFVSSSBzY2hlbWVcbiAgICAgICAgICAgIHJldHVybiBtWzBdO1xuICAgICAgICB9XG4gICAgICAgIGZvdW5kVXJscy5wdXNoKHJlc29sdmVyLnJlc29sdmUoYmFzZVVybCwgdXJsKSk7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFN0eWxlV2l0aEltcG9ydHMobW9kaWZpZWRDc3NUZXh0LCBmb3VuZFVybHMpO1xufVxudmFyIENTU19JTVBPUlRfUkVHRVhQID0gL0BpbXBvcnRcXHMrKD86dXJsXFwoKT9cXHMqKD86KD86WydcIl0oW14nXCJdKikpfChbXjtcXClcXHNdKikpW147XSo7Py9nO1xudmFyIENTU19DT01NRU5UX1JFR0VYUCA9IC9cXC9cXCouKz9cXCpcXC8vZztcbnZhciBVUkxfV0lUSF9TQ0hFTUFfUkVHRVhQID0gL14oW146Lz8jXSspOi87XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgUFJPUEVSVFlfUEFSVFNfU0VQQVJBVE9SID0gJy4nO1xudmFyIEFUVFJJQlVURV9QUkVGSVggPSAnYXR0cic7XG52YXIgQ0xBU1NfUFJFRklYID0gJ2NsYXNzJztcbnZhciBTVFlMRV9QUkVGSVggPSAnc3R5bGUnO1xudmFyIEFOSU1BVEVfUFJPUF9QUkVGSVggPSAnYW5pbWF0ZS0nO1xudmFyIEJvdW5kUHJvcGVydHlUeXBlID0ge307XG5Cb3VuZFByb3BlcnR5VHlwZS5ERUZBVUxUID0gMDtcbkJvdW5kUHJvcGVydHlUeXBlLkxJVEVSQUxfQVRUUiA9IDE7XG5Cb3VuZFByb3BlcnR5VHlwZS5BTklNQVRJT04gPSAyO1xuQm91bmRQcm9wZXJ0eVR5cGVbQm91bmRQcm9wZXJ0eVR5cGUuREVGQVVMVF0gPSBcIkRFRkFVTFRcIjtcbkJvdW5kUHJvcGVydHlUeXBlW0JvdW5kUHJvcGVydHlUeXBlLkxJVEVSQUxfQVRUUl0gPSBcIkxJVEVSQUxfQVRUUlwiO1xuQm91bmRQcm9wZXJ0eVR5cGVbQm91bmRQcm9wZXJ0eVR5cGUuQU5JTUFUSU9OXSA9IFwiQU5JTUFUSU9OXCI7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBwYXJzZWQgcHJvcGVydHkuXG4gKi9cbnZhciBCb3VuZFByb3BlcnR5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCb3VuZFByb3BlcnR5KG5hbWUsIGV4cHJlc3Npb24sIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJvdW5kUHJvcGVydHkucHJvdG90eXBlLCBcImlzTGl0ZXJhbFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT09IEJvdW5kUHJvcGVydHlUeXBlLkxJVEVSQUxfQVRUUjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJvdW5kUHJvcGVydHkucHJvdG90eXBlLCBcImlzQW5pbWF0aW9uXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PT0gQm91bmRQcm9wZXJ0eVR5cGUuQU5JTUFUSU9OOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gQm91bmRQcm9wZXJ0eTtcbn0oKSk7XG4vKipcbiAqIFBhcnNlcyBiaW5kaW5ncyBpbiB0ZW1wbGF0ZXMgYW5kIGluIHRoZSBkaXJlY3RpdmUgaG9zdCBhcmVhLlxuICovXG52YXIgQmluZGluZ1BhcnNlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZXhwclBhcnNlclxuICAgICAqIEBwYXJhbSB7P30gX2ludGVycG9sYXRpb25Db25maWdcbiAgICAgKiBAcGFyYW0gez99IF9zY2hlbWFSZWdpc3RyeVxuICAgICAqIEBwYXJhbSB7P30gcGlwZXNcbiAgICAgKiBAcGFyYW0gez99IF90YXJnZXRFcnJvcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCaW5kaW5nUGFyc2VyKF9leHByUGFyc2VyLCBfaW50ZXJwb2xhdGlvbkNvbmZpZywgX3NjaGVtYVJlZ2lzdHJ5LCBwaXBlcywgX3RhcmdldEVycm9ycykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9leHByUGFyc2VyID0gX2V4cHJQYXJzZXI7XG4gICAgICAgIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcgPSBfaW50ZXJwb2xhdGlvbkNvbmZpZztcbiAgICAgICAgdGhpcy5fc2NoZW1hUmVnaXN0cnkgPSBfc2NoZW1hUmVnaXN0cnk7XG4gICAgICAgIHRoaXMuX3RhcmdldEVycm9ycyA9IF90YXJnZXRFcnJvcnM7XG4gICAgICAgIHRoaXMucGlwZXNCeU5hbWUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3VzZWRQaXBlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgcGlwZXMuZm9yRWFjaChmdW5jdGlvbiAocGlwZSkgeyByZXR1cm4gX3RoaXMucGlwZXNCeU5hbWUuc2V0KHBpcGUubmFtZSwgcGlwZSk7IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLmdldFVzZWRQaXBlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEFycmF5LmZyb20odGhpcy5fdXNlZFBpcGVzLnZhbHVlcygpKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRpck1ldGFcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRTZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuY3JlYXRlRGlyZWN0aXZlSG9zdFByb3BlcnR5QXN0cyA9IGZ1bmN0aW9uIChkaXJNZXRhLCBlbGVtZW50U2VsZWN0b3IsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGRpck1ldGEuaG9zdFByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJvdW5kUHJvcHNfMSA9IFtdO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZGlyTWV0YS5ob3N0UHJvcGVydGllcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHByZXNzaW9uID0gZGlyTWV0YS5ob3N0UHJvcGVydGllc1twcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBleHByZXNzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wYXJzZVByb3BlcnR5QmluZGluZyhwcm9wTmFtZSwgZXhwcmVzc2lvbiwgdHJ1ZSwgc291cmNlU3BhbiwgW10sIGJvdW5kUHJvcHNfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoXCJWYWx1ZSBvZiB0aGUgaG9zdCBwcm9wZXJ0eSBiaW5kaW5nIFxcXCJcIiArIHByb3BOYW1lICsgXCJcXFwiIG5lZWRzIHRvIGJlIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhbiBleHByZXNzaW9uIGJ1dCBnb3QgXFxcIlwiICsgZXhwcmVzc2lvbiArIFwiXFxcIiAoXCIgKyB0eXBlb2YgZXhwcmVzc2lvbiArIFwiKVwiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBib3VuZFByb3BzXzEubWFwKGZ1bmN0aW9uIChwcm9wKSB7IHJldHVybiBfdGhpcy5jcmVhdGVFbGVtZW50UHJvcGVydHlBc3QoZWxlbWVudFNlbGVjdG9yLCBwcm9wKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRpck1ldGFcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLmNyZWF0ZURpcmVjdGl2ZUhvc3RFdmVudEFzdHMgPSBmdW5jdGlvbiAoZGlyTWV0YSwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZGlyTWV0YS5ob3N0TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0YXJnZXRFdmVudEFzdHNfMSA9IFtdO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZGlyTWV0YS5ob3N0TGlzdGVuZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cHJlc3Npb24gPSBkaXJNZXRhLmhvc3RMaXN0ZW5lcnNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwcmVzc2lvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucGFyc2VFdmVudChwcm9wTmFtZSwgZXhwcmVzc2lvbiwgc291cmNlU3BhbiwgW10sIHRhcmdldEV2ZW50QXN0c18xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihcIlZhbHVlIG9mIHRoZSBob3N0IGxpc3RlbmVyIFxcXCJcIiArIHByb3BOYW1lICsgXCJcXFwiIG5lZWRzIHRvIGJlIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhbiBleHByZXNzaW9uIGJ1dCBnb3QgXFxcIlwiICsgZXhwcmVzc2lvbiArIFwiXFxcIiAoXCIgKyB0eXBlb2YgZXhwcmVzc2lvbiArIFwiKVwiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRFdmVudEFzdHNfMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLnBhcnNlSW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzb3VyY2VJbmZvID0gc291cmNlU3Bhbi5zdGFydC50b1N0cmluZygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0ID0gKCh0aGlzLl9leHByUGFyc2VyLnBhcnNlSW50ZXJwb2xhdGlvbih2YWx1ZSwgc291cmNlSW5mbywgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZykpKTtcbiAgICAgICAgICAgIGlmIChhc3QpXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXhwcmVzc2lvblBhcnNlckVycm9ycyhhc3QuZXJyb3JzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUGlwZXMoYXN0LCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiXCIgKyBlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHByUGFyc2VyLndyYXBMaXRlcmFsUHJpbWl0aXZlKCdFUlJPUicsIHNvdXJjZUluZm8pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHByZWZpeFRva2VuXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0TWF0Y2hhYmxlQXR0cnNcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFByb3BzXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRWYXJzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5wYXJzZUlubGluZVRlbXBsYXRlQmluZGluZyA9IGZ1bmN0aW9uIChwcmVmaXhUb2tlbiwgdmFsdWUsIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcywgdGFyZ2V0VmFycykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiaW5kaW5ncyA9IHRoaXMuX3BhcnNlVGVtcGxhdGVCaW5kaW5ncyhwcmVmaXhUb2tlbiwgdmFsdWUsIHNvdXJjZVNwYW4pO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgYmluZGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJpbmRpbmcgPSBiaW5kaW5nc1tpXTtcbiAgICAgICAgICAgIGlmIChiaW5kaW5nLmtleUlzVmFyKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0VmFycy5wdXNoKG5ldyBWYXJpYWJsZUFzdChiaW5kaW5nLmtleSwgYmluZGluZy5uYW1lLCBzb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiaW5kaW5nLmV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZVByb3BlcnR5QXN0KGJpbmRpbmcua2V5LCBiaW5kaW5nLmV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRNYXRjaGFibGVBdHRycy5wdXNoKFtiaW5kaW5nLmtleSwgJyddKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlTGl0ZXJhbEF0dHIoYmluZGluZy5rZXksIG51bGwsIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJlZml4VG9rZW5cbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VUZW1wbGF0ZUJpbmRpbmdzID0gZnVuY3Rpb24gKHByZWZpeFRva2VuLCB2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzb3VyY2VJbmZvID0gc291cmNlU3Bhbi5zdGFydC50b1N0cmluZygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmluZGluZ3NSZXN1bHQgPSB0aGlzLl9leHByUGFyc2VyLnBhcnNlVGVtcGxhdGVCaW5kaW5ncyhwcmVmaXhUb2tlbiwgdmFsdWUsIHNvdXJjZUluZm8pO1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXhwcmVzc2lvblBhcnNlckVycm9ycyhiaW5kaW5nc1Jlc3VsdC5lcnJvcnMsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgYmluZGluZ3NSZXN1bHQudGVtcGxhdGVCaW5kaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChiaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJpbmRpbmcuZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY2hlY2tQaXBlcyhiaW5kaW5nLmV4cHJlc3Npb24sIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYmluZGluZ3NSZXN1bHQud2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAod2FybmluZykgeyBfdGhpcy5fcmVwb3J0RXJyb3Iod2FybmluZywgc291cmNlU3BhbiwgUGFyc2VFcnJvckxldmVsLldBUk5JTkcpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBiaW5kaW5nc1Jlc3VsdC50ZW1wbGF0ZUJpbmRpbmdzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlwiICsgZSwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcGFyYW0gez99IHRhcmdldE1hdGNoYWJsZUF0dHJzXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRQcm9wc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUucGFyc2VMaXRlcmFsQXR0ciA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKSB7XG4gICAgICAgIGlmIChfaXNBbmltYXRpb25MYWJlbChuYW1lKSkge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJBc3NpZ25pbmcgYW5pbWF0aW9uIHRyaWdnZXJzIHZpYSBAcHJvcD1cXFwiZXhwXFxcIiBhdHRyaWJ1dGVzIHdpdGggYW4gZXhwcmVzc2lvbiBpcyBpbnZhbGlkLlwiICtcbiAgICAgICAgICAgICAgICAgICAgXCIgVXNlIHByb3BlcnR5IGJpbmRpbmdzIChlLmcuIFtAcHJvcF09XFxcImV4cFxcXCIpIG9yIHVzZSBhbiBhdHRyaWJ1dGUgd2l0aG91dCBhIHZhbHVlIChlLmcuIEBwcm9wKSBpbnN0ZWFkLlwiLCBzb3VyY2VTcGFuLCBQYXJzZUVycm9yTGV2ZWwuRVJST1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcGFyc2VBbmltYXRpb24obmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXRQcm9wcy5wdXNoKG5ldyBCb3VuZFByb3BlcnR5KG5hbWUsIHRoaXMuX2V4cHJQYXJzZXIud3JhcExpdGVyYWxQcmltaXRpdmUodmFsdWUsICcnKSwgQm91bmRQcm9wZXJ0eVR5cGUuTElURVJBTF9BVFRSLCBzb3VyY2VTcGFuKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7P30gaXNIb3N0XG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRNYXRjaGFibGVBdHRyc1xuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0UHJvcHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLnBhcnNlUHJvcGVydHlCaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUsIGV4cHJlc3Npb24sIGlzSG9zdCwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzQW5pbWF0aW9uUHJvcCA9IGZhbHNlO1xuICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKEFOSU1BVEVfUFJPUF9QUkVGSVgpKSB7XG4gICAgICAgICAgICBpc0FuaW1hdGlvblByb3AgPSB0cnVlO1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKEFOSU1BVEVfUFJPUF9QUkVGSVgubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChfaXNBbmltYXRpb25MYWJlbChuYW1lKSkge1xuICAgICAgICAgICAgaXNBbmltYXRpb25Qcm9wID0gdHJ1ZTtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBbmltYXRpb25Qcm9wKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZUFuaW1hdGlvbihuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VQcm9wZXJ0eUFzdChuYW1lLCB0aGlzLl9wYXJzZUJpbmRpbmcoZXhwcmVzc2lvbiwgaXNIb3N0LCBzb3VyY2VTcGFuKSwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0TWF0Y2hhYmxlQXR0cnNcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFByb3BzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5wYXJzZVByb3BlcnR5SW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cHIgPSB0aGlzLnBhcnNlSW50ZXJwb2xhdGlvbih2YWx1ZSwgc291cmNlU3Bhbik7XG4gICAgICAgIGlmIChleHByKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZVByb3BlcnR5QXN0KG5hbWUsIGV4cHIsIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0TWF0Y2hhYmxlQXR0cnNcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFByb3BzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VQcm9wZXJ0eUFzdCA9IGZ1bmN0aW9uIChuYW1lLCBhc3QsIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcykge1xuICAgICAgICB0YXJnZXRNYXRjaGFibGVBdHRycy5wdXNoKFtuYW1lLCAvKiogQHR5cGUgez99ICovICgoYXN0LnNvdXJjZSkpXSk7XG4gICAgICAgIHRhcmdldFByb3BzLnB1c2gobmV3IEJvdW5kUHJvcGVydHkobmFtZSwgYXN0LCBCb3VuZFByb3BlcnR5VHlwZS5ERUZBVUxULCBzb3VyY2VTcGFuKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcGFyYW0gez99IHRhcmdldE1hdGNoYWJsZUF0dHJzXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRQcm9wc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuX3BhcnNlQW5pbWF0aW9uID0gZnVuY3Rpb24gKG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcykge1xuICAgICAgICAvLyBUaGlzIHdpbGwgb2NjdXIgd2hlbiBhIEB0cmlnZ2VyIGlzIG5vdCBwYWlyZWQgd2l0aCBhbiBleHByZXNzaW9uLlxuICAgICAgICAvLyBGb3IgYW5pbWF0aW9ucyBpdCBpcyB2YWxpZCB0byBub3QgaGF2ZSBhbiBleHByZXNzaW9uIHNpbmNlICovdm9pZFxuICAgICAgICAvLyBzdGF0ZXMgd2lsbCBiZSBhcHBsaWVkIGJ5IGFuZ3VsYXIgd2hlbiB0aGUgZWxlbWVudCBpcyBhdHRhY2hlZC9kZXRhY2hlZFxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3QgPSB0aGlzLl9wYXJzZUJpbmRpbmcoZXhwcmVzc2lvbiB8fCAnbnVsbCcsIGZhbHNlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMucHVzaChbbmFtZSwgLyoqIEB0eXBlIHs/fSAqLyAoKGFzdC5zb3VyY2UpKV0pO1xuICAgICAgICB0YXJnZXRQcm9wcy5wdXNoKG5ldyBCb3VuZFByb3BlcnR5KG5hbWUsIGFzdCwgQm91bmRQcm9wZXJ0eVR5cGUuQU5JTUFUSU9OLCBzb3VyY2VTcGFuKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBpc0hvc3RCaW5kaW5nXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VCaW5kaW5nID0gZnVuY3Rpb24gKHZhbHVlLCBpc0hvc3RCaW5kaW5nLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvdXJjZUluZm8gPSBzb3VyY2VTcGFuLnN0YXJ0LnRvU3RyaW5nKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3QgPSBpc0hvc3RCaW5kaW5nID9cbiAgICAgICAgICAgICAgICB0aGlzLl9leHByUGFyc2VyLnBhcnNlU2ltcGxlQmluZGluZyh2YWx1ZSwgc291cmNlSW5mbywgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZykgOlxuICAgICAgICAgICAgICAgIHRoaXMuX2V4cHJQYXJzZXIucGFyc2VCaW5kaW5nKHZhbHVlLCBzb3VyY2VJbmZvLCB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICAgIGlmIChhc3QpXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXhwcmVzc2lvblBhcnNlckVycm9ycyhhc3QuZXJyb3JzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUGlwZXMoYXN0LCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiXCIgKyBlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHByUGFyc2VyLndyYXBMaXRlcmFsUHJpbWl0aXZlKCdFUlJPUicsIHNvdXJjZUluZm8pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRTZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gYm91bmRQcm9wXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50UHJvcGVydHlBc3QgPSBmdW5jdGlvbiAoZWxlbWVudFNlbGVjdG9yLCBib3VuZFByb3ApIHtcbiAgICAgICAgaWYgKGJvdW5kUHJvcC5pc0FuaW1hdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdChib3VuZFByb3AubmFtZSwgUHJvcGVydHlCaW5kaW5nVHlwZS5BbmltYXRpb24sIFNlY3VyaXR5Q29udGV4dC5OT05FLCBib3VuZFByb3AuZXhwcmVzc2lvbiwgbnVsbCwgYm91bmRQcm9wLnNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVuaXQgPSBudWxsO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiaW5kaW5nVHlwZSA9ICgodW5kZWZpbmVkKSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJvdW5kUHJvcGVydHlOYW1lID0gbnVsbDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFydHMgPSBib3VuZFByb3AubmFtZS5zcGxpdChQUk9QRVJUWV9QQVJUU19TRVBBUkFUT1IpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZWN1cml0eUNvbnRleHRzID0gKCh1bmRlZmluZWQpKTtcbiAgICAgICAgLy8gQ2hlY2sgY2hlY2sgZm9yIHNwZWNpYWwgY2FzZXMgKHByZWZpeCBzdHlsZSwgYXR0ciwgY2xhc3MpXG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBpZiAocGFydHNbMF0gPT0gQVRUUklCVVRFX1BSRUZJWCkge1xuICAgICAgICAgICAgICAgIGJvdW5kUHJvcGVydHlOYW1lID0gcGFydHNbMV07XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGVQcm9wZXJ0eU9yQXR0cmlidXRlTmFtZShib3VuZFByb3BlcnR5TmFtZSwgYm91bmRQcm9wLnNvdXJjZVNwYW4sIHRydWUpO1xuICAgICAgICAgICAgICAgIHNlY3VyaXR5Q29udGV4dHMgPSBjYWxjUG9zc2libGVTZWN1cml0eUNvbnRleHRzKHRoaXMuX3NjaGVtYVJlZ2lzdHJ5LCBlbGVtZW50U2VsZWN0b3IsIGJvdW5kUHJvcGVydHlOYW1lLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuc1NlcGFyYXRvcklkeCA9IGJvdW5kUHJvcGVydHlOYW1lLmluZGV4T2YoJzonKTtcbiAgICAgICAgICAgICAgICBpZiAobnNTZXBhcmF0b3JJZHggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBucyA9IGJvdW5kUHJvcGVydHlOYW1lLnN1YnN0cmluZygwLCBuc1NlcGFyYXRvcklkeCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWUgPSBib3VuZFByb3BlcnR5TmFtZS5zdWJzdHJpbmcobnNTZXBhcmF0b3JJZHggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgYm91bmRQcm9wZXJ0eU5hbWUgPSBtZXJnZU5zQW5kTmFtZShucywgbmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJpbmRpbmdUeXBlID0gUHJvcGVydHlCaW5kaW5nVHlwZS5BdHRyaWJ1dGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJ0c1swXSA9PSBDTEFTU19QUkVGSVgpIHtcbiAgICAgICAgICAgICAgICBib3VuZFByb3BlcnR5TmFtZSA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgICAgIGJpbmRpbmdUeXBlID0gUHJvcGVydHlCaW5kaW5nVHlwZS5DbGFzcztcbiAgICAgICAgICAgICAgICBzZWN1cml0eUNvbnRleHRzID0gW1NlY3VyaXR5Q29udGV4dC5OT05FXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcnRzWzBdID09IFNUWUxFX1BSRUZJWCkge1xuICAgICAgICAgICAgICAgIHVuaXQgPSBwYXJ0cy5sZW5ndGggPiAyID8gcGFydHNbMl0gOiBudWxsO1xuICAgICAgICAgICAgICAgIGJvdW5kUHJvcGVydHlOYW1lID0gcGFydHNbMV07XG4gICAgICAgICAgICAgICAgYmluZGluZ1R5cGUgPSBQcm9wZXJ0eUJpbmRpbmdUeXBlLlN0eWxlO1xuICAgICAgICAgICAgICAgIHNlY3VyaXR5Q29udGV4dHMgPSBbU2VjdXJpdHlDb250ZXh0LlNUWUxFXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBub3QgYSBzcGVjaWFsIGNhc2UsIHVzZSB0aGUgZnVsbCBwcm9wZXJ0eSBuYW1lXG4gICAgICAgIGlmIChib3VuZFByb3BlcnR5TmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgYm91bmRQcm9wZXJ0eU5hbWUgPSB0aGlzLl9zY2hlbWFSZWdpc3RyeS5nZXRNYXBwZWRQcm9wTmFtZShib3VuZFByb3AubmFtZSk7XG4gICAgICAgICAgICBzZWN1cml0eUNvbnRleHRzID0gY2FsY1Bvc3NpYmxlU2VjdXJpdHlDb250ZXh0cyh0aGlzLl9zY2hlbWFSZWdpc3RyeSwgZWxlbWVudFNlbGVjdG9yLCBib3VuZFByb3BlcnR5TmFtZSwgZmFsc2UpO1xuICAgICAgICAgICAgYmluZGluZ1R5cGUgPSBQcm9wZXJ0eUJpbmRpbmdUeXBlLlByb3BlcnR5O1xuICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGVQcm9wZXJ0eU9yQXR0cmlidXRlTmFtZShib3VuZFByb3BlcnR5TmFtZSwgYm91bmRQcm9wLnNvdXJjZVNwYW4sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJvdW5kRWxlbWVudFByb3BlcnR5QXN0KGJvdW5kUHJvcGVydHlOYW1lLCBiaW5kaW5nVHlwZSwgc2VjdXJpdHlDb250ZXh0c1swXSwgYm91bmRQcm9wLmV4cHJlc3Npb24sIHVuaXQsIGJvdW5kUHJvcC5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0TWF0Y2hhYmxlQXR0cnNcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldEV2ZW50c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUucGFyc2VFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKSB7XG4gICAgICAgIGlmIChfaXNBbmltYXRpb25MYWJlbChuYW1lKSkge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEpO1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VBbmltYXRpb25FdmVudChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCB0YXJnZXRFdmVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VFdmVudChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRFdmVudHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLl9wYXJzZUFuaW1hdGlvbkV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIHRhcmdldEV2ZW50cykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXRjaGVzID0gc3BsaXRBdFBlcmlvZChuYW1lLCBbbmFtZSwgJyddKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXZlbnROYW1lID0gbWF0Y2hlc1swXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGhhc2UgPSBtYXRjaGVzWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChwaGFzZSkge1xuICAgICAgICAgICAgc3dpdGNoIChwaGFzZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgICAgICAgICAgICBjYXNlICdkb25lJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0ID0gdGhpcy5fcGFyc2VBY3Rpb24oZXhwcmVzc2lvbiwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEV2ZW50cy5wdXNoKG5ldyBCb3VuZEV2ZW50QXN0KGV2ZW50TmFtZSwgbnVsbCwgcGhhc2UsIGFzdCwgc291cmNlU3BhbikpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlRoZSBwcm92aWRlZCBhbmltYXRpb24gb3V0cHV0IHBoYXNlIHZhbHVlIFxcXCJcIiArIHBoYXNlICsgXCJcXFwiIGZvciBcXFwiQFwiICsgZXZlbnROYW1lICsgXCJcXFwiIGlzIG5vdCBzdXBwb3J0ZWQgKHVzZSBzdGFydCBvciBkb25lKVwiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlRoZSBhbmltYXRpb24gdHJpZ2dlciBvdXRwdXQgZXZlbnQgKEBcIiArIGV2ZW50TmFtZSArIFwiKSBpcyBtaXNzaW5nIGl0cyBwaGFzZSB2YWx1ZSBuYW1lIChzdGFydCBvciBkb25lIGFyZSBjdXJyZW50bHkgc3VwcG9ydGVkKVwiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRNYXRjaGFibGVBdHRyc1xuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0RXZlbnRzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKSB7XG4gICAgICAgIC8vIGxvbmcgZm9ybWF0OiAndGFyZ2V0OiBldmVudE5hbWUnXG4gICAgICAgIHZhciBfYSA9IHNwbGl0QXRDb2xvbihuYW1lLCBbLyoqIEB0eXBlIHs/fSAqLyAoKG51bGwpKSwgbmFtZV0pLCB0YXJnZXQgPSBfYVswXSwgZXZlbnROYW1lID0gX2FbMV07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdCA9IHRoaXMuX3BhcnNlQWN0aW9uKGV4cHJlc3Npb24sIHNvdXJjZVNwYW4pO1xuICAgICAgICB0YXJnZXRNYXRjaGFibGVBdHRycy5wdXNoKFsvKiogQHR5cGUgez99ICovICgobmFtZSkpLCAvKiogQHR5cGUgez99ICovICgoYXN0LnNvdXJjZSkpXSk7XG4gICAgICAgIHRhcmdldEV2ZW50cy5wdXNoKG5ldyBCb3VuZEV2ZW50QXN0KGV2ZW50TmFtZSwgdGFyZ2V0LCBudWxsLCBhc3QsIHNvdXJjZVNwYW4pKTtcbiAgICAgICAgLy8gRG9uJ3QgZGV0ZWN0IGRpcmVjdGl2ZXMgZm9yIGV2ZW50IG5hbWVzIGZvciBub3csXG4gICAgICAgIC8vIHNvIGRvbid0IGFkZCB0aGUgZXZlbnQgbmFtZSB0byB0aGUgbWF0Y2hhYmxlQXR0cnNcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLl9wYXJzZUFjdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzb3VyY2VJbmZvID0gc291cmNlU3Bhbi5zdGFydC50b1N0cmluZygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0ID0gdGhpcy5fZXhwclBhcnNlci5wYXJzZUFjdGlvbih2YWx1ZSwgc291cmNlSW5mbywgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgICAgICBpZiAoYXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXhwcmVzc2lvblBhcnNlckVycm9ycyhhc3QuZXJyb3JzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYXN0IHx8IGFzdC5hc3QgaW5zdGFuY2VvZiBFbXB0eUV4cHIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIkVtcHR5IGV4cHJlc3Npb25zIGFyZSBub3QgYWxsb3dlZFwiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXhwclBhcnNlci53cmFwTGl0ZXJhbFByaW1pdGl2ZSgnRVJST1InLCBzb3VyY2VJbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUGlwZXMoYXN0LCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiXCIgKyBlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHByUGFyc2VyLndyYXBMaXRlcmFsUHJpbWl0aXZlKCdFUlJPUicsIHNvdXJjZUluZm8pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcGFyYW0gez89fSBsZXZlbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuX3JlcG9ydEVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHNvdXJjZVNwYW4sIGxldmVsKSB7XG4gICAgICAgIGlmIChsZXZlbCA9PT0gdm9pZCAwKSB7IGxldmVsID0gUGFyc2VFcnJvckxldmVsLkVSUk9SOyB9XG4gICAgICAgIHRoaXMuX3RhcmdldEVycm9ycy5wdXNoKG5ldyBQYXJzZUVycm9yKHNvdXJjZVNwYW4sIG1lc3NhZ2UsIGxldmVsKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuX3JlcG9ydEV4cHJlc3Npb25QYXJzZXJFcnJvcnMgPSBmdW5jdGlvbiAoZXJyb3JzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgZXJyb3JzXzEgPSBlcnJvcnM7IF9pIDwgZXJyb3JzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBlcnJvcnNfMVtfaV07XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihlcnJvci5tZXNzYWdlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLl9jaGVja1BpcGVzID0gZnVuY3Rpb24gKGFzdCwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoYXN0KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb2xsZWN0b3IgPSBuZXcgUGlwZUNvbGxlY3RvcigpO1xuICAgICAgICAgICAgYXN0LnZpc2l0KGNvbGxlY3Rvcik7XG4gICAgICAgICAgICBjb2xsZWN0b3IucGlwZXMuZm9yRWFjaChmdW5jdGlvbiAoYXN0LCBwaXBlTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBpcGVNZXRhID0gX3RoaXMucGlwZXNCeU5hbWUuZ2V0KHBpcGVOYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBpcGVNZXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihcIlRoZSBwaXBlICdcIiArIHBpcGVOYW1lICsgXCInIGNvdWxkIG5vdCBiZSBmb3VuZFwiLCBuZXcgUGFyc2VTb3VyY2VTcGFuKHNvdXJjZVNwYW4uc3RhcnQubW92ZUJ5KGFzdC5zcGFuLnN0YXJ0KSwgc291cmNlU3Bhbi5zdGFydC5tb3ZlQnkoYXN0LnNwYW4uZW5kKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3VzZWRQaXBlcy5zZXQocGlwZU5hbWUsIHBpcGVNZXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcm9wTmFtZSB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgLyBhdHRyaWJ1dGVcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcGFyYW0gez99IGlzQXR0ciB0cnVlIHdoZW4gYmluZGluZyB0byBhbiBhdHRyaWJ1dGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLl92YWxpZGF0ZVByb3BlcnR5T3JBdHRyaWJ1dGVOYW1lID0gZnVuY3Rpb24gKHByb3BOYW1lLCBzb3VyY2VTcGFuLCBpc0F0dHIpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVwb3J0ID0gaXNBdHRyID8gdGhpcy5fc2NoZW1hUmVnaXN0cnkudmFsaWRhdGVBdHRyaWJ1dGUocHJvcE5hbWUpIDpcbiAgICAgICAgICAgIHRoaXMuX3NjaGVtYVJlZ2lzdHJ5LnZhbGlkYXRlUHJvcGVydHkocHJvcE5hbWUpO1xuICAgICAgICBpZiAocmVwb3J0LmVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcigvKiogQHR5cGUgez99ICovICgocmVwb3J0Lm1zZykpLCBzb3VyY2VTcGFuLCBQYXJzZUVycm9yTGV2ZWwuRVJST1IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQmluZGluZ1BhcnNlcjtcbn0oKSk7XG52YXIgUGlwZUNvbGxlY3RvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoUGlwZUNvbGxlY3RvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQaXBlQ29sbGVjdG9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5waXBlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGlwZUNvbGxlY3Rvci5wcm90b3R5cGUudmlzaXRQaXBlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnBpcGVzLnNldChhc3QubmFtZSwgYXN0KTtcbiAgICAgICAgYXN0LmV4cC52aXNpdCh0aGlzKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbChhc3QuYXJncywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIFBpcGVDb2xsZWN0b3I7XG59KFJlY3Vyc2l2ZUFzdFZpc2l0b3IpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBuYW1lXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfaXNBbmltYXRpb25MYWJlbChuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWVbMF0gPT0gJ0AnO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHJlZ2lzdHJ5XG4gKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gKiBAcGFyYW0gez99IHByb3BOYW1lXG4gKiBAcGFyYW0gez99IGlzQXR0cmlidXRlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjYWxjUG9zc2libGVTZWN1cml0eUNvbnRleHRzKHJlZ2lzdHJ5LCBzZWxlY3RvciwgcHJvcE5hbWUsIGlzQXR0cmlidXRlKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3R4cyA9IFtdO1xuICAgIENzc1NlbGVjdG9yLnBhcnNlKHNlbGVjdG9yKS5mb3JFYWNoKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50TmFtZXMgPSBzZWxlY3Rvci5lbGVtZW50ID8gW3NlbGVjdG9yLmVsZW1lbnRdIDogcmVnaXN0cnkuYWxsS25vd25FbGVtZW50TmFtZXMoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm90RWxlbWVudE5hbWVzID0gbmV3IFNldChzZWxlY3Rvci5ub3RTZWxlY3RvcnMuZmlsdGVyKGZ1bmN0aW9uIChzZWxlY3RvcikgeyByZXR1cm4gc2VsZWN0b3IuaXNFbGVtZW50U2VsZWN0b3IoKTsgfSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHNlbGVjdG9yKSB7IHJldHVybiBzZWxlY3Rvci5lbGVtZW50OyB9KSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBvc3NpYmxlRWxlbWVudE5hbWVzID0gZWxlbWVudE5hbWVzLmZpbHRlcihmdW5jdGlvbiAoZWxlbWVudE5hbWUpIHsgcmV0dXJuICFub3RFbGVtZW50TmFtZXMuaGFzKGVsZW1lbnROYW1lKTsgfSk7XG4gICAgICAgIGN0eHMucHVzaC5hcHBseShjdHhzLCBwb3NzaWJsZUVsZW1lbnROYW1lcy5tYXAoZnVuY3Rpb24gKGVsZW1lbnROYW1lKSB7IHJldHVybiByZWdpc3RyeS5zZWN1cml0eUNvbnRleHQoZWxlbWVudE5hbWUsIHByb3BOYW1lLCBpc0F0dHJpYnV0ZSk7IH0pKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY3R4cy5sZW5ndGggPT09IDAgPyBbU2VjdXJpdHlDb250ZXh0Lk5PTkVdIDogQXJyYXkuZnJvbShuZXcgU2V0KGN0eHMpKS5zb3J0KCk7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgTkdfQ09OVEVOVF9TRUxFQ1RfQVRUUiA9ICdzZWxlY3QnO1xudmFyIExJTktfRUxFTUVOVCA9ICdsaW5rJztcbnZhciBMSU5LX1NUWUxFX1JFTF9BVFRSID0gJ3JlbCc7XG52YXIgTElOS19TVFlMRV9IUkVGX0FUVFIgPSAnaHJlZic7XG52YXIgTElOS19TVFlMRV9SRUxfVkFMVUUgPSAnc3R5bGVzaGVldCc7XG52YXIgU1RZTEVfRUxFTUVOVCA9ICdzdHlsZSc7XG52YXIgU0NSSVBUX0VMRU1FTlQgPSAnc2NyaXB0JztcbnZhciBOR19OT05fQklOREFCTEVfQVRUUiA9ICduZ05vbkJpbmRhYmxlJztcbnZhciBOR19QUk9KRUNUX0FTID0gJ25nUHJvamVjdEFzJztcbi8qKlxuICogQHBhcmFtIHs/fSBhc3RcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHByZXBhcnNlRWxlbWVudChhc3QpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZWxlY3RBdHRyID0gKChudWxsKSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaHJlZkF0dHIgPSAoKG51bGwpKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWxBdHRyID0gKChudWxsKSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9uQmluZGFibGUgPSBmYWxzZTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9qZWN0QXMgPSAoKG51bGwpKTtcbiAgICBhc3QuYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsY0F0dHJOYW1lID0gYXR0ci5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChsY0F0dHJOYW1lID09IE5HX0NPTlRFTlRfU0VMRUNUX0FUVFIpIHtcbiAgICAgICAgICAgIHNlbGVjdEF0dHIgPSBhdHRyLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxjQXR0ck5hbWUgPT0gTElOS19TVFlMRV9IUkVGX0FUVFIpIHtcbiAgICAgICAgICAgIGhyZWZBdHRyID0gYXR0ci52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsY0F0dHJOYW1lID09IExJTktfU1RZTEVfUkVMX0FUVFIpIHtcbiAgICAgICAgICAgIHJlbEF0dHIgPSBhdHRyLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGF0dHIubmFtZSA9PSBOR19OT05fQklOREFCTEVfQVRUUikge1xuICAgICAgICAgICAgbm9uQmluZGFibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGF0dHIubmFtZSA9PSBOR19QUk9KRUNUX0FTKSB7XG4gICAgICAgICAgICBpZiAoYXR0ci52YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcHJvamVjdEFzID0gYXR0ci52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHNlbGVjdEF0dHIgPSBub3JtYWxpemVOZ0NvbnRlbnRTZWxlY3Qoc2VsZWN0QXR0cik7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZU5hbWUgPSBhc3QubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHR5cGUgPSBQcmVwYXJzZWRFbGVtZW50VHlwZS5PVEhFUjtcbiAgICBpZiAoaXNOZ0NvbnRlbnQobm9kZU5hbWUpKSB7XG4gICAgICAgIHR5cGUgPSBQcmVwYXJzZWRFbGVtZW50VHlwZS5OR19DT05URU5UO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlTmFtZSA9PSBTVFlMRV9FTEVNRU5UKSB7XG4gICAgICAgIHR5cGUgPSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZU5hbWUgPT0gU0NSSVBUX0VMRU1FTlQpIHtcbiAgICAgICAgdHlwZSA9IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNDUklQVDtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZU5hbWUgPT0gTElOS19FTEVNRU5UICYmIHJlbEF0dHIgPT0gTElOS19TVFlMRV9SRUxfVkFMVUUpIHtcbiAgICAgICAgdHlwZSA9IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFU0hFRVQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJlcGFyc2VkRWxlbWVudCh0eXBlLCBzZWxlY3RBdHRyLCBocmVmQXR0ciwgbm9uQmluZGFibGUsIHByb2plY3RBcyk7XG59XG52YXIgUHJlcGFyc2VkRWxlbWVudFR5cGUgPSB7fTtcblByZXBhcnNlZEVsZW1lbnRUeXBlLk5HX0NPTlRFTlQgPSAwO1xuUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEUgPSAxO1xuUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEVTSEVFVCA9IDI7XG5QcmVwYXJzZWRFbGVtZW50VHlwZS5TQ1JJUFQgPSAzO1xuUHJlcGFyc2VkRWxlbWVudFR5cGUuT1RIRVIgPSA0O1xuUHJlcGFyc2VkRWxlbWVudFR5cGVbUHJlcGFyc2VkRWxlbWVudFR5cGUuTkdfQ09OVEVOVF0gPSBcIk5HX0NPTlRFTlRcIjtcblByZXBhcnNlZEVsZW1lbnRUeXBlW1ByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFXSA9IFwiU1RZTEVcIjtcblByZXBhcnNlZEVsZW1lbnRUeXBlW1ByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFU0hFRVRdID0gXCJTVFlMRVNIRUVUXCI7XG5QcmVwYXJzZWRFbGVtZW50VHlwZVtQcmVwYXJzZWRFbGVtZW50VHlwZS5TQ1JJUFRdID0gXCJTQ1JJUFRcIjtcblByZXBhcnNlZEVsZW1lbnRUeXBlW1ByZXBhcnNlZEVsZW1lbnRUeXBlLk9USEVSXSA9IFwiT1RIRVJcIjtcbnZhciBQcmVwYXJzZWRFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdEF0dHJcbiAgICAgKiBAcGFyYW0gez99IGhyZWZBdHRyXG4gICAgICogQHBhcmFtIHs/fSBub25CaW5kYWJsZVxuICAgICAqIEBwYXJhbSB7P30gcHJvamVjdEFzXG4gICAgICovXG4gICAgZnVuY3Rpb24gUHJlcGFyc2VkRWxlbWVudCh0eXBlLCBzZWxlY3RBdHRyLCBocmVmQXR0ciwgbm9uQmluZGFibGUsIHByb2plY3RBcykge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnNlbGVjdEF0dHIgPSBzZWxlY3RBdHRyO1xuICAgICAgICB0aGlzLmhyZWZBdHRyID0gaHJlZkF0dHI7XG4gICAgICAgIHRoaXMubm9uQmluZGFibGUgPSBub25CaW5kYWJsZTtcbiAgICAgICAgdGhpcy5wcm9qZWN0QXMgPSBwcm9qZWN0QXM7XG4gICAgfVxuICAgIHJldHVybiBQcmVwYXJzZWRFbGVtZW50O1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBzZWxlY3RBdHRyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVOZ0NvbnRlbnRTZWxlY3Qoc2VsZWN0QXR0cikge1xuICAgIGlmIChzZWxlY3RBdHRyID09PSBudWxsIHx8IHNlbGVjdEF0dHIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnKic7XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RBdHRyO1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEJJTkRfTkFNRV9SRUdFWFAgPSAvXig/Oig/Oig/OihiaW5kLSl8KGxldC0pfChyZWYtfCMpfChvbi0pfChiaW5kb24tKXwoQCkpKC4rKSl8XFxbXFwoKFteXFwpXSspXFwpXFxdfFxcWyhbXlxcXV0rKVxcXXxcXCgoW15cXCldKylcXCkpJC87XG4vLyBHcm91cCAxID0gXCJiaW5kLVwiXG52YXIgS1dfQklORF9JRFggPSAxO1xuLy8gR3JvdXAgMiA9IFwibGV0LVwiXG52YXIgS1dfTEVUX0lEWCA9IDI7XG4vLyBHcm91cCAzID0gXCJyZWYtLyNcIlxudmFyIEtXX1JFRl9JRFggPSAzO1xuLy8gR3JvdXAgNCA9IFwib24tXCJcbnZhciBLV19PTl9JRFggPSA0O1xuLy8gR3JvdXAgNSA9IFwiYmluZG9uLVwiXG52YXIgS1dfQklORE9OX0lEWCA9IDU7XG4vLyBHcm91cCA2ID0gXCJAXCJcbnZhciBLV19BVF9JRFggPSA2O1xuLy8gR3JvdXAgNyA9IHRoZSBpZGVudGlmaWVyIGFmdGVyIFwiYmluZC1cIiwgXCJsZXQtXCIsIFwicmVmLS8jXCIsIFwib24tXCIsIFwiYmluZG9uLVwiIG9yIFwiQFwiXG52YXIgSURFTlRfS1dfSURYID0gNztcbi8vIEdyb3VwIDggPSBpZGVudGlmaWVyIGluc2lkZSBbKCldXG52YXIgSURFTlRfQkFOQU5BX0JPWF9JRFggPSA4O1xuLy8gR3JvdXAgOSA9IGlkZW50aWZpZXIgaW5zaWRlIFtdXG52YXIgSURFTlRfUFJPUEVSVFlfSURYID0gOTtcbi8vIEdyb3VwIDEwID0gaWRlbnRpZmllciBpbnNpZGUgKClcbnZhciBJREVOVF9FVkVOVF9JRFggPSAxMDtcbi8vIGRlcHJlY2F0ZWQgaW4gNC54XG52YXIgVEVNUExBVEVfRUxFTUVOVCA9ICd0ZW1wbGF0ZSc7XG4vLyBkZXByZWNhdGVkIGluIDQueFxudmFyIFRFTVBMQVRFX0FUVFIgPSAndGVtcGxhdGUnO1xudmFyIFRFTVBMQVRFX0FUVFJfUFJFRklYID0gJyonO1xudmFyIENMQVNTX0FUVFIgPSAnY2xhc3MnO1xudmFyIFRFWFRfQ1NTX1NFTEVDVE9SID0gQ3NzU2VsZWN0b3IucGFyc2UoJyonKVswXTtcbnZhciBURU1QTEFURV9FTEVNRU5UX0RFUFJFQ0FUSU9OX1dBUk5JTkcgPSAnVGhlIDx0ZW1wbGF0ZT4gZWxlbWVudCBpcyBkZXByZWNhdGVkLiBVc2UgPG5nLXRlbXBsYXRlPiBpbnN0ZWFkJztcbnZhciBURU1QTEFURV9BVFRSX0RFUFJFQ0FUSU9OX1dBUk5JTkcgPSAnVGhlIHRlbXBsYXRlIGF0dHJpYnV0ZSBpcyBkZXByZWNhdGVkLiBVc2UgYW4gbmctdGVtcGxhdGUgZWxlbWVudCBpbnN0ZWFkLic7XG52YXIgd2FybmluZ0NvdW50cyA9IHt9O1xuLyoqXG4gKiBAcGFyYW0gez99IHdhcm5pbmdzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB3YXJuT25seU9uY2Uod2FybmluZ3MpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGlmICh3YXJuaW5ncy5pbmRleE9mKGVycm9yLm1zZykgIT09IC0xKSB7XG4gICAgICAgICAgICB3YXJuaW5nQ291bnRzW2Vycm9yLm1zZ10gPSAod2FybmluZ0NvdW50c1tlcnJvci5tc2ddIHx8IDApICsgMTtcbiAgICAgICAgICAgIHJldHVybiB3YXJuaW5nQ291bnRzW2Vycm9yLm1zZ10gPD0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG4gKiBQcm92aWRlcyBhbiBhcnJheSBvZiB7XFxAbGluayBUZW1wbGF0ZUFzdFZpc2l0b3J9cyB3aGljaCB3aWxsIGJlIHVzZWQgdG8gdHJhbnNmb3JtXG4gKiBwYXJzZWQgdGVtcGxhdGVzIGJlZm9yZSBjb21waWxhdGlvbiBpcyBpbnZva2VkLCBhbGxvd2luZyBjdXN0b20gZXhwcmVzc2lvbiBzeW50YXhcbiAqIGFuZCBvdGhlciBhZHZhbmNlZCB0cmFuc2Zvcm1hdGlvbnMuXG4gKlxuICogVGhpcyBpcyBjdXJyZW50bHkgYW4gaW50ZXJuYWwtb25seSBmZWF0dXJlIGFuZCBub3QgbWVhbnQgZm9yIGdlbmVyYWwgdXNlLlxuICovXG52YXIgVEVNUExBVEVfVFJBTlNGT1JNUyA9IG5ldyBJbmplY3Rpb25Ub2tlbignVGVtcGxhdGVUcmFuc2Zvcm1zJyk7XG52YXIgVGVtcGxhdGVQYXJzZUVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhUZW1wbGF0ZVBhcnNlRXJyb3IsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHs/fSBzcGFuXG4gICAgICogQHBhcmFtIHs/fSBsZXZlbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRlbXBsYXRlUGFyc2VFcnJvcihtZXNzYWdlLCBzcGFuLCBsZXZlbCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgc3BhbiwgbWVzc2FnZSwgbGV2ZWwpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBUZW1wbGF0ZVBhcnNlRXJyb3I7XG59KFBhcnNlRXJyb3IpKTtcbnZhciBUZW1wbGF0ZVBhcnNlUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSB0ZW1wbGF0ZUFzdFxuICAgICAqIEBwYXJhbSB7Pz19IHVzZWRQaXBlc1xuICAgICAqIEBwYXJhbSB7Pz19IGVycm9yc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRlbXBsYXRlUGFyc2VSZXN1bHQodGVtcGxhdGVBc3QsIHVzZWRQaXBlcywgZXJyb3JzKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVBc3QgPSB0ZW1wbGF0ZUFzdDtcbiAgICAgICAgdGhpcy51c2VkUGlwZXMgPSB1c2VkUGlwZXM7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIH1cbiAgICByZXR1cm4gVGVtcGxhdGVQYXJzZVJlc3VsdDtcbn0oKSk7XG52YXIgVGVtcGxhdGVQYXJzZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2NvbmZpZ1xuICAgICAqIEBwYXJhbSB7P30gX3JlZmxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gX2V4cHJQYXJzZXJcbiAgICAgKiBAcGFyYW0gez99IF9zY2hlbWFSZWdpc3RyeVxuICAgICAqIEBwYXJhbSB7P30gX2h0bWxQYXJzZXJcbiAgICAgKiBAcGFyYW0gez99IF9jb25zb2xlXG4gICAgICogQHBhcmFtIHs/fSB0cmFuc2Zvcm1zXG4gICAgICovXG4gICAgZnVuY3Rpb24gVGVtcGxhdGVQYXJzZXIoX2NvbmZpZywgX3JlZmxlY3RvciwgX2V4cHJQYXJzZXIsIF9zY2hlbWFSZWdpc3RyeSwgX2h0bWxQYXJzZXIsIF9jb25zb2xlLCB0cmFuc2Zvcm1zKSB7XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IF9jb25maWc7XG4gICAgICAgIHRoaXMuX3JlZmxlY3RvciA9IF9yZWZsZWN0b3I7XG4gICAgICAgIHRoaXMuX2V4cHJQYXJzZXIgPSBfZXhwclBhcnNlcjtcbiAgICAgICAgdGhpcy5fc2NoZW1hUmVnaXN0cnkgPSBfc2NoZW1hUmVnaXN0cnk7XG4gICAgICAgIHRoaXMuX2h0bWxQYXJzZXIgPSBfaHRtbFBhcnNlcjtcbiAgICAgICAgdGhpcy5fY29uc29sZSA9IF9jb25zb2xlO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybXMgPSB0cmFuc2Zvcm1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7P30gdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZXNcbiAgICAgKiBAcGFyYW0gez99IHBpcGVzXG4gICAgICogQHBhcmFtIHs/fSBzY2hlbWFzXG4gICAgICogQHBhcmFtIHs/fSB0ZW1wbGF0ZVVybFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgdGVtcGxhdGUsIGRpcmVjdGl2ZXMsIHBpcGVzLCBzY2hlbWFzLCB0ZW1wbGF0ZVVybCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSB0aGlzLnRyeVBhcnNlKGNvbXBvbmVudCwgdGVtcGxhdGUsIGRpcmVjdGl2ZXMsIHBpcGVzLCBzY2hlbWFzLCB0ZW1wbGF0ZVVybCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHdhcm5pbmdzID0gKChyZXN1bHQuZXJyb3JzKSkuZmlsdGVyKGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gZXJyb3IubGV2ZWwgPT09IFBhcnNlRXJyb3JMZXZlbC5XQVJOSU5HOyB9KVxuICAgICAgICAgICAgLmZpbHRlcih3YXJuT25seU9uY2UoW1RFTVBMQVRFX0FUVFJfREVQUkVDQVRJT05fV0FSTklORywgVEVNUExBVEVfRUxFTUVOVF9ERVBSRUNBVElPTl9XQVJOSU5HXSkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvcnMgPSAoKHJlc3VsdC5lcnJvcnMpKS5maWx0ZXIoZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBlcnJvci5sZXZlbCA9PT0gUGFyc2VFcnJvckxldmVsLkVSUk9SOyB9KTtcbiAgICAgICAgaWYgKHdhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnNvbGUud2FybihcIlRlbXBsYXRlIHBhcnNlIHdhcm5pbmdzOlxcblwiICsgd2FybmluZ3Muam9pbignXFxuJykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3JTdHJpbmcgPSBlcnJvcnMuam9pbignXFxuJyk7XG4gICAgICAgICAgICB0aHJvdyBzeW50YXhFcnJvcihcIlRlbXBsYXRlIHBhcnNlIGVycm9yczpcXG5cIiArIGVycm9yU3RyaW5nLCBlcnJvcnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHRlbXBsYXRlOiAvKiogQHR5cGUgez99ICovICgocmVzdWx0LnRlbXBsYXRlQXN0KSksIHBpcGVzOiAvKiogQHR5cGUgez99ICovICgocmVzdWx0LnVzZWRQaXBlcykpIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7P30gdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZXNcbiAgICAgKiBAcGFyYW0gez99IHBpcGVzXG4gICAgICogQHBhcmFtIHs/fSBzY2hlbWFzXG4gICAgICogQHBhcmFtIHs/fSB0ZW1wbGF0ZVVybFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZXIucHJvdG90eXBlLnRyeVBhcnNlID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgdGVtcGxhdGUsIGRpcmVjdGl2ZXMsIHBpcGVzLCBzY2hlbWFzLCB0ZW1wbGF0ZVVybCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cnlQYXJzZUh0bWwodGhpcy5leHBhbmRIdG1sKC8qKiBAdHlwZSB7P30gKi8gKCh0aGlzLl9odG1sUGFyc2VyKSkucGFyc2UodGVtcGxhdGUsIHRlbXBsYXRlVXJsLCB0cnVlLCB0aGlzLmdldEludGVycG9sYXRpb25Db25maWcoY29tcG9uZW50KSkpLCBjb21wb25lbnQsIGRpcmVjdGl2ZXMsIHBpcGVzLCBzY2hlbWFzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaHRtbEFzdFdpdGhFcnJvcnNcbiAgICAgKiBAcGFyYW0gez99IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlc1xuICAgICAqIEBwYXJhbSB7P30gcGlwZXNcbiAgICAgKiBAcGFyYW0gez99IHNjaGVtYXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VyLnByb3RvdHlwZS50cnlQYXJzZUh0bWwgPSBmdW5jdGlvbiAoaHRtbEFzdFdpdGhFcnJvcnMsIGNvbXBvbmVudCwgZGlyZWN0aXZlcywgcGlwZXMsIHNjaGVtYXMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvcnMgPSBodG1sQXN0V2l0aEVycm9ycy5lcnJvcnM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVzZWRQaXBlcyA9IFtdO1xuICAgICAgICBpZiAoaHRtbEFzdFdpdGhFcnJvcnMucm9vdE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVuaXFEaXJlY3RpdmVzID0gcmVtb3ZlU3VtbWFyeUR1cGxpY2F0ZXMoZGlyZWN0aXZlcyk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1bmlxUGlwZXMgPSByZW1vdmVTdW1tYXJ5RHVwbGljYXRlcyhwaXBlcyk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm92aWRlclZpZXdDb250ZXh0ID0gbmV3IFByb3ZpZGVyVmlld0NvbnRleHQodGhpcy5fcmVmbGVjdG9yLCBjb21wb25lbnQpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW50ZXJwb2xhdGlvbkNvbmZpZyA9ICgodW5kZWZpbmVkKSk7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50LnRlbXBsYXRlICYmIGNvbXBvbmVudC50ZW1wbGF0ZS5pbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGNvbXBvbmVudC50ZW1wbGF0ZS5pbnRlcnBvbGF0aW9uWzBdLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IGNvbXBvbmVudC50ZW1wbGF0ZS5pbnRlcnBvbGF0aW9uWzFdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJpbmRpbmdQYXJzZXIgPSBuZXcgQmluZGluZ1BhcnNlcih0aGlzLl9leHByUGFyc2VyLCAvKiogQHR5cGUgez99ICovICgoaW50ZXJwb2xhdGlvbkNvbmZpZykpLCB0aGlzLl9zY2hlbWFSZWdpc3RyeSwgdW5pcVBpcGVzLCBlcnJvcnMpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyc2VWaXNpdG9yID0gbmV3IFRlbXBsYXRlUGFyc2VWaXNpdG9yKHRoaXMuX3JlZmxlY3RvciwgdGhpcy5fY29uZmlnLCBwcm92aWRlclZpZXdDb250ZXh0LCB1bmlxRGlyZWN0aXZlcywgYmluZGluZ1BhcnNlciwgdGhpcy5fc2NoZW1hUmVnaXN0cnksIHNjaGVtYXMsIGVycm9ycyk7XG4gICAgICAgICAgICByZXN1bHQgPSB2aXNpdEFsbChwYXJzZVZpc2l0b3IsIGh0bWxBc3RXaXRoRXJyb3JzLnJvb3ROb2RlcywgRU1QVFlfRUxFTUVOVF9DT05URVhUKTtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgcHJvdmlkZXJWaWV3Q29udGV4dC5lcnJvcnMpO1xuICAgICAgICAgICAgdXNlZFBpcGVzLnB1c2guYXBwbHkodXNlZFBpcGVzLCBiaW5kaW5nUGFyc2VyLmdldFVzZWRQaXBlcygpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Fzc2VydE5vUmVmZXJlbmNlRHVwbGljYXRpb25PblRlbXBsYXRlKHJlc3VsdCwgZXJyb3JzKTtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRlbXBsYXRlUGFyc2VSZXN1bHQocmVzdWx0LCB1c2VkUGlwZXMsIGVycm9ycyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudHJhbnNmb3Jtcykge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1zLmZvckVhY2goZnVuY3Rpb24gKHRyYW5zZm9ybSkgeyByZXN1bHQgPSB0ZW1wbGF0ZVZpc2l0QWxsKHRyYW5zZm9ybSwgcmVzdWx0KTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUZW1wbGF0ZVBhcnNlUmVzdWx0KHJlc3VsdCwgdXNlZFBpcGVzLCBlcnJvcnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBodG1sQXN0V2l0aEVycm9yc1xuICAgICAqIEBwYXJhbSB7Pz19IGZvcmNlZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZXIucHJvdG90eXBlLmV4cGFuZEh0bWwgPSBmdW5jdGlvbiAoaHRtbEFzdFdpdGhFcnJvcnMsIGZvcmNlZCkge1xuICAgICAgICBpZiAoZm9yY2VkID09PSB2b2lkIDApIHsgZm9yY2VkID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3JzID0gaHRtbEFzdFdpdGhFcnJvcnMuZXJyb3JzO1xuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCA9PSAwIHx8IGZvcmNlZCkge1xuICAgICAgICAgICAgLy8gVHJhbnNmb3JtIElDVSBtZXNzYWdlcyB0byBhbmd1bGFyIGRpcmVjdGl2ZXNcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cGFuZGVkSHRtbEFzdCA9IGV4cGFuZE5vZGVzKGh0bWxBc3RXaXRoRXJyb3JzLnJvb3ROb2Rlcyk7XG4gICAgICAgICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIGV4cGFuZGVkSHRtbEFzdC5lcnJvcnMpO1xuICAgICAgICAgICAgaHRtbEFzdFdpdGhFcnJvcnMgPSBuZXcgUGFyc2VUcmVlUmVzdWx0KGV4cGFuZGVkSHRtbEFzdC5ub2RlcywgZXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaHRtbEFzdFdpdGhFcnJvcnM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbXBvbmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZXIucHJvdG90eXBlLmdldEludGVycG9sYXRpb25Db25maWcgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIGlmIChjb21wb25lbnQudGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnBvbGF0aW9uQ29uZmlnLmZyb21BcnJheShjb21wb25lbnQudGVtcGxhdGUuaW50ZXJwb2xhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFxcQGludGVybmFsXG4gICAgICogQHBhcmFtIHs/fSByZXN1bHRcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZXIucHJvdG90eXBlLl9hc3NlcnROb1JlZmVyZW5jZUR1cGxpY2F0aW9uT25UZW1wbGF0ZSA9IGZ1bmN0aW9uIChyZXN1bHQsIGVycm9ycykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleGlzdGluZ1JlZmVyZW5jZXMgPSBbXTtcbiAgICAgICAgcmVzdWx0LmZpbHRlcihmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gISEoKGVsZW1lbnQpKS5yZWZlcmVuY2VzOyB9KVxuICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHsgcmV0dXJuICgoZWxlbWVudCkpLnJlZmVyZW5jZXMuZm9yRWFjaChmdW5jdGlvbiAocmVmZXJlbmNlKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lID0gcmVmZXJlbmNlLm5hbWU7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdSZWZlcmVuY2VzLmluZGV4T2YobmFtZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgZXhpc3RpbmdSZWZlcmVuY2VzLnB1c2gobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvciA9IG5ldyBUZW1wbGF0ZVBhcnNlRXJyb3IoXCJSZWZlcmVuY2UgXFxcIiNcIiArIG5hbWUgKyBcIlxcXCIgaXMgZGVmaW5lZCBzZXZlcmFsIHRpbWVzXCIsIHJlZmVyZW5jZS5zb3VyY2VTcGFuLCBQYXJzZUVycm9yTGV2ZWwuRVJST1IpO1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFRlbXBsYXRlUGFyc2VyO1xufSgpKTtcblRlbXBsYXRlUGFyc2VyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21waWxlckluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cblRlbXBsYXRlUGFyc2VyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogQ29tcGlsZXJDb25maWcsIH0sXG4gICAgeyB0eXBlOiBDb21waWxlUmVmbGVjdG9yLCB9LFxuICAgIHsgdHlwZTogUGFyc2VyLCB9LFxuICAgIHsgdHlwZTogRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LCB9LFxuICAgIHsgdHlwZTogSTE4Tkh0bWxQYXJzZXIsIH0sXG4gICAgeyB0eXBlOiDJtUNvbnNvbGUsIH0sXG4gICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSwgeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtURU1QTEFURV9UUkFOU0ZPUk1TLF0gfSxdIH0sXG5dOyB9O1xudmFyIFRlbXBsYXRlUGFyc2VWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlZmxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gY29uZmlnXG4gICAgICogQHBhcmFtIHs/fSBwcm92aWRlclZpZXdDb250ZXh0XG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3RpdmVzXG4gICAgICogQHBhcmFtIHs/fSBfYmluZGluZ1BhcnNlclxuICAgICAqIEBwYXJhbSB7P30gX3NjaGVtYVJlZ2lzdHJ5XG4gICAgICogQHBhcmFtIHs/fSBfc2NoZW1hc1xuICAgICAqIEBwYXJhbSB7P30gX3RhcmdldEVycm9yc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRlbXBsYXRlUGFyc2VWaXNpdG9yKHJlZmxlY3RvciwgY29uZmlnLCBwcm92aWRlclZpZXdDb250ZXh0LCBkaXJlY3RpdmVzLCBfYmluZGluZ1BhcnNlciwgX3NjaGVtYVJlZ2lzdHJ5LCBfc2NoZW1hcywgX3RhcmdldEVycm9ycykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnJlZmxlY3RvciA9IHJlZmxlY3RvcjtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMucHJvdmlkZXJWaWV3Q29udGV4dCA9IHByb3ZpZGVyVmlld0NvbnRleHQ7XG4gICAgICAgIHRoaXMuX2JpbmRpbmdQYXJzZXIgPSBfYmluZGluZ1BhcnNlcjtcbiAgICAgICAgdGhpcy5fc2NoZW1hUmVnaXN0cnkgPSBfc2NoZW1hUmVnaXN0cnk7XG4gICAgICAgIHRoaXMuX3NjaGVtYXMgPSBfc2NoZW1hcztcbiAgICAgICAgdGhpcy5fdGFyZ2V0RXJyb3JzID0gX3RhcmdldEVycm9ycztcbiAgICAgICAgdGhpcy5zZWxlY3Rvck1hdGNoZXIgPSBuZXcgU2VsZWN0b3JNYXRjaGVyKCk7XG4gICAgICAgIHRoaXMuZGlyZWN0aXZlc0luZGV4ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm5nQ29udGVudENvdW50ID0gMDtcbiAgICAgICAgLy8gTm90ZTogcXVlcmllcyBzdGFydCB3aXRoIGlkIDEgc28gd2UgY2FuIHVzZSB0aGUgbnVtYmVyIGluIGEgQmxvb20gZmlsdGVyIVxuICAgICAgICB0aGlzLmNvbnRlbnRRdWVyeVN0YXJ0SWQgPSBwcm92aWRlclZpZXdDb250ZXh0LmNvbXBvbmVudC52aWV3UXVlcmllcy5sZW5ndGggKyAxO1xuICAgICAgICBkaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGl2ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IENzc1NlbGVjdG9yLnBhcnNlKGRpcmVjdGl2ZS5zZWxlY3Rvcik7XG4gICAgICAgICAgICBfdGhpcy5zZWxlY3Rvck1hdGNoZXIuYWRkU2VsZWN0YWJsZXMoc2VsZWN0b3IsIGRpcmVjdGl2ZSk7XG4gICAgICAgICAgICBfdGhpcy5kaXJlY3RpdmVzSW5kZXguc2V0KGRpcmVjdGl2ZSwgaW5kZXgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHBhbnNpb25cbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChleHBhbnNpb24sIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHBhbnNpb25DYXNlXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGV4cGFuc2lvbkNhc2UsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZXh0XG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgcGFyZW50KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nQ29udGVudEluZGV4ID0gKChwYXJlbnQuZmluZE5nQ29udGVudEluZGV4KFRFWFRfQ1NTX1NFTEVDVE9SKSkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHByID0gdGhpcy5fYmluZGluZ1BhcnNlci5wYXJzZUludGVycG9sYXRpb24odGV4dC52YWx1ZSwgLyoqIEB0eXBlIHs/fSAqLyAoKHRleHQuc291cmNlU3BhbikpKTtcbiAgICAgICAgcmV0dXJuIGV4cHIgPyBuZXcgQm91bmRUZXh0QXN0KGV4cHIsIG5nQ29udGVudEluZGV4LCAvKiogQHR5cGUgez99ICovICgodGV4dC5zb3VyY2VTcGFuKSkpIDpcbiAgICAgICAgICAgIG5ldyBUZXh0QXN0KHRleHQudmFsdWUsIG5nQ29udGVudEluZGV4LCAvKiogQHR5cGUgez99ICovICgodGV4dC5zb3VyY2VTcGFuKSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhdHRyaWJ1dGVcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdHRyQXN0KGF0dHJpYnV0ZS5uYW1lLCBhdHRyaWJ1dGUudmFsdWUsIGF0dHJpYnV0ZS5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29tbWVudFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29tbWVudCA9IGZ1bmN0aW9uIChjb21tZW50LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIHBhcmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdWVyeVN0YXJ0SW5kZXggPSB0aGlzLmNvbnRlbnRRdWVyeVN0YXJ0SWQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVOYW1lID0gZWxlbWVudC5uYW1lO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmVwYXJzZWRFbGVtZW50ID0gcHJlcGFyc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICBpZiAocHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TQ1JJUFQgfHxcbiAgICAgICAgICAgIHByZXBhcnNlZEVsZW1lbnQudHlwZSA9PT0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEUpIHtcbiAgICAgICAgICAgIC8vIFNraXBwaW5nIDxzY3JpcHQ+IGZvciBzZWN1cml0eSByZWFzb25zXG4gICAgICAgICAgICAvLyBTa2lwcGluZyA8c3R5bGU+IGFzIHdlIGFscmVhZHkgcHJvY2Vzc2VkIHRoZW1cbiAgICAgICAgICAgIC8vIGluIHRoZSBTdHlsZUNvbXBpbGVyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRVNIRUVUICYmXG4gICAgICAgICAgICBpc1N0eWxlVXJsUmVzb2x2YWJsZShwcmVwYXJzZWRFbGVtZW50LmhyZWZBdHRyKSkge1xuICAgICAgICAgICAgLy8gU2tpcHBpbmcgc3R5bGVzaGVldHMgd2l0aCBlaXRoZXIgcmVsYXRpdmUgdXJscyBvciBwYWNrYWdlIHNjaGVtZSBhcyB3ZSBhbHJlYWR5IHByb2Nlc3NlZFxuICAgICAgICAgICAgLy8gdGhlbSBpbiB0aGUgU3R5bGVDb21waWxlclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWF0Y2hhYmxlQXR0cnMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudE9yRGlyZWN0aXZlUHJvcHMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudE9yRGlyZWN0aXZlUmVmcyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50VmFycyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBldmVudHMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVtcGxhdGVFbGVtZW50T3JEaXJlY3RpdmVQcm9wcyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wbGF0ZU1hdGNoYWJsZUF0dHJzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlbXBsYXRlRWxlbWVudFZhcnMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaGFzSW5saW5lVGVtcGxhdGVzID0gZmFsc2U7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGF0dHJzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzVGVtcGxhdGVFbGVtZW50ID0gaXNUZW1wbGF0ZShlbGVtZW50LCB0aGlzLmNvbmZpZy5lbmFibGVMZWdhY3lUZW1wbGF0ZSwgZnVuY3Rpb24gKG0sIHNwYW4pIHsgcmV0dXJuIF90aGlzLl9yZXBvcnRFcnJvcihtLCBzcGFuLCBQYXJzZUVycm9yTGV2ZWwuV0FSTklORyk7IH0pO1xuICAgICAgICBlbGVtZW50LmF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhhc0JpbmRpbmcgPSBfdGhpcy5fcGFyc2VBdHRyKGlzVGVtcGxhdGVFbGVtZW50LCBhdHRyLCBtYXRjaGFibGVBdHRycywgZWxlbWVudE9yRGlyZWN0aXZlUHJvcHMsIGV2ZW50cywgZWxlbWVudE9yRGlyZWN0aXZlUmVmcywgZWxlbWVudFZhcnMpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVtcGxhdGVCaW5kaW5nc1NvdXJjZTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZWZpeFRva2VuO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9ybWFsaXplZE5hbWUgPSBfdGhpcy5fbm9ybWFsaXplQXR0cmlidXRlTmFtZShhdHRyLm5hbWUpO1xuICAgICAgICAgICAgaWYgKF90aGlzLmNvbmZpZy5lbmFibGVMZWdhY3lUZW1wbGF0ZSAmJiBub3JtYWxpemVkTmFtZSA9PSBURU1QTEFURV9BVFRSKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKFRFTVBMQVRFX0FUVFJfREVQUkVDQVRJT05fV0FSTklORywgYXR0ci5zb3VyY2VTcGFuLCBQYXJzZUVycm9yTGV2ZWwuV0FSTklORyk7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGVCaW5kaW5nc1NvdXJjZSA9IGF0dHIudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChub3JtYWxpemVkTmFtZS5zdGFydHNXaXRoKFRFTVBMQVRFX0FUVFJfUFJFRklYKSkge1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlQmluZGluZ3NTb3VyY2UgPSBhdHRyLnZhbHVlO1xuICAgICAgICAgICAgICAgIHByZWZpeFRva2VuID0gbm9ybWFsaXplZE5hbWUuc3Vic3RyaW5nKFRFTVBMQVRFX0FUVFJfUFJFRklYLmxlbmd0aCkgKyAnOic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoYXNUZW1wbGF0ZUJpbmRpbmcgPSB0ZW1wbGF0ZUJpbmRpbmdzU291cmNlICE9IG51bGw7XG4gICAgICAgICAgICBpZiAoaGFzVGVtcGxhdGVCaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0lubGluZVRlbXBsYXRlcykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoXCJDYW4ndCBoYXZlIG11bHRpcGxlIHRlbXBsYXRlIGJpbmRpbmdzIG9uIG9uZSBlbGVtZW50LiBVc2Ugb25seSBvbmUgYXR0cmlidXRlIG5hbWVkICd0ZW1wbGF0ZScgb3IgcHJlZml4ZWQgd2l0aCAqXCIsIGF0dHIuc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhhc0lubGluZVRlbXBsYXRlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2JpbmRpbmdQYXJzZXIucGFyc2VJbmxpbmVUZW1wbGF0ZUJpbmRpbmcoLyoqIEB0eXBlIHs/fSAqLyAoKHByZWZpeFRva2VuKSksIC8qKiBAdHlwZSB7P30gKi8gKCh0ZW1wbGF0ZUJpbmRpbmdzU291cmNlKSksIGF0dHIuc291cmNlU3BhbiwgdGVtcGxhdGVNYXRjaGFibGVBdHRycywgdGVtcGxhdGVFbGVtZW50T3JEaXJlY3RpdmVQcm9wcywgdGVtcGxhdGVFbGVtZW50VmFycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWhhc0JpbmRpbmcgJiYgIWhhc1RlbXBsYXRlQmluZGluZykge1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IGluY2x1ZGUgdGhlIGJpbmRpbmdzIGFzIGF0dHJpYnV0ZXMgYXMgd2VsbCBpbiB0aGUgQVNUXG4gICAgICAgICAgICAgICAgYXR0cnMucHVzaChfdGhpcy52aXNpdEF0dHJpYnV0ZShhdHRyLCBudWxsKSk7XG4gICAgICAgICAgICAgICAgbWF0Y2hhYmxlQXR0cnMucHVzaChbYXR0ci5uYW1lLCBhdHRyLnZhbHVlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50Q3NzU2VsZWN0b3IgPSBjcmVhdGVFbGVtZW50Q3NzU2VsZWN0b3Iobm9kZU5hbWUsIG1hdGNoYWJsZUF0dHJzKTtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5fcGFyc2VEaXJlY3RpdmVzKHRoaXMuc2VsZWN0b3JNYXRjaGVyLCBlbGVtZW50Q3NzU2VsZWN0b3IpLCBkaXJlY3RpdmVNZXRhcyA9IF9hLmRpcmVjdGl2ZXMsIG1hdGNoRWxlbWVudCA9IF9hLm1hdGNoRWxlbWVudDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVmZXJlbmNlcyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBib3VuZERpcmVjdGl2ZVByb3BOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlyZWN0aXZlQXN0cyA9IHRoaXMuX2NyZWF0ZURpcmVjdGl2ZUFzdHMoaXNUZW1wbGF0ZUVsZW1lbnQsIGVsZW1lbnQubmFtZSwgZGlyZWN0aXZlTWV0YXMsIGVsZW1lbnRPckRpcmVjdGl2ZVByb3BzLCBlbGVtZW50T3JEaXJlY3RpdmVSZWZzLCAvKiogQHR5cGUgez99ICovICgoZWxlbWVudC5zb3VyY2VTcGFuKSksIHJlZmVyZW5jZXMsIGJvdW5kRGlyZWN0aXZlUHJvcE5hbWVzKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudFByb3BzID0gdGhpcy5fY3JlYXRlRWxlbWVudFByb3BlcnR5QXN0cyhlbGVtZW50Lm5hbWUsIGVsZW1lbnRPckRpcmVjdGl2ZVByb3BzLCBib3VuZERpcmVjdGl2ZVByb3BOYW1lcyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzVmlld1Jvb3QgPSBwYXJlbnQuaXNUZW1wbGF0ZUVsZW1lbnQgfHwgaGFzSW5saW5lVGVtcGxhdGVzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm92aWRlckNvbnRleHQgPSBuZXcgUHJvdmlkZXJFbGVtZW50Q29udGV4dCh0aGlzLnByb3ZpZGVyVmlld0NvbnRleHQsIC8qKiBAdHlwZSB7P30gKi8gKChwYXJlbnQucHJvdmlkZXJDb250ZXh0KSksIGlzVmlld1Jvb3QsIGRpcmVjdGl2ZUFzdHMsIGF0dHJzLCByZWZlcmVuY2VzLCBpc1RlbXBsYXRlRWxlbWVudCwgcXVlcnlTdGFydEluZGV4LCAvKiogQHR5cGUgez99ICovICgoZWxlbWVudC5zb3VyY2VTcGFuKSkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlsZHJlbiA9IHZpc2l0QWxsKHByZXBhcnNlZEVsZW1lbnQubm9uQmluZGFibGUgPyBOT05fQklOREFCTEVfVklTSVRPUiA6IHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4sIEVsZW1lbnRDb250ZXh0LmNyZWF0ZShpc1RlbXBsYXRlRWxlbWVudCwgZGlyZWN0aXZlQXN0cywgaXNUZW1wbGF0ZUVsZW1lbnQgPyAoKHBhcmVudC5wcm92aWRlckNvbnRleHQpKSA6IHByb3ZpZGVyQ29udGV4dCkpO1xuICAgICAgICBwcm92aWRlckNvbnRleHQuYWZ0ZXJFbGVtZW50KCk7XG4gICAgICAgIC8vIE92ZXJyaWRlIHRoZSBhY3R1YWwgc2VsZWN0b3Igd2hlbiB0aGUgYG5nUHJvamVjdEFzYCBhdHRyaWJ1dGUgaXMgcHJvdmlkZWRcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvamVjdGlvblNlbGVjdG9yID0gcHJlcGFyc2VkRWxlbWVudC5wcm9qZWN0QXMgIT0gbnVsbCA/XG4gICAgICAgICAgICBDc3NTZWxlY3Rvci5wYXJzZShwcmVwYXJzZWRFbGVtZW50LnByb2plY3RBcylbMF0gOlxuICAgICAgICAgICAgZWxlbWVudENzc1NlbGVjdG9yO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZ0NvbnRlbnRJbmRleCA9ICgocGFyZW50LmZpbmROZ0NvbnRlbnRJbmRleChwcm9qZWN0aW9uU2VsZWN0b3IpKSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnNlZEVsZW1lbnQ7XG4gICAgICAgIGlmIChwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IFByZXBhcnNlZEVsZW1lbnRUeXBlLk5HX0NPTlRFTlQpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50LmNoaWxkcmVuICYmICFlbGVtZW50LmNoaWxkcmVuLmV2ZXJ5KF9pc0VtcHR5VGV4dE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCI8bmctY29udGVudD4gZWxlbWVudCBjYW5ub3QgaGF2ZSBjb250ZW50LlwiLCAvKiogQHR5cGUgez99ICovICgoZWxlbWVudC5zb3VyY2VTcGFuKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VkRWxlbWVudCA9IG5ldyBOZ0NvbnRlbnRBc3QodGhpcy5uZ0NvbnRlbnRDb3VudCsrLCBoYXNJbmxpbmVUZW1wbGF0ZXMgPyAoKG51bGwpKSA6IG5nQ29udGVudEluZGV4LCAvKiogQHR5cGUgez99ICovICgoZWxlbWVudC5zb3VyY2VTcGFuKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzVGVtcGxhdGVFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9hc3NlcnRBbGxFdmVudHNQdWJsaXNoZWRCeURpcmVjdGl2ZXMoZGlyZWN0aXZlQXN0cywgZXZlbnRzKTtcbiAgICAgICAgICAgIHRoaXMuX2Fzc2VydE5vQ29tcG9uZW50c05vckVsZW1lbnRCaW5kaW5nc09uVGVtcGxhdGUoZGlyZWN0aXZlQXN0cywgZWxlbWVudFByb3BzLCAvKiogQHR5cGUgez99ICovICgoZWxlbWVudC5zb3VyY2VTcGFuKSkpO1xuICAgICAgICAgICAgcGFyc2VkRWxlbWVudCA9IG5ldyBFbWJlZGRlZFRlbXBsYXRlQXN0KGF0dHJzLCBldmVudHMsIHJlZmVyZW5jZXMsIGVsZW1lbnRWYXJzLCBwcm92aWRlckNvbnRleHQudHJhbnNmb3JtZWREaXJlY3RpdmVBc3RzLCBwcm92aWRlckNvbnRleHQudHJhbnNmb3JtUHJvdmlkZXJzLCBwcm92aWRlckNvbnRleHQudHJhbnNmb3JtZWRIYXNWaWV3Q29udGFpbmVyLCBwcm92aWRlckNvbnRleHQucXVlcnlNYXRjaGVzLCBjaGlsZHJlbiwgaGFzSW5saW5lVGVtcGxhdGVzID8gKChudWxsKSkgOiBuZ0NvbnRlbnRJbmRleCwgLyoqIEB0eXBlIHs/fSAqLyAoKGVsZW1lbnQuc291cmNlU3BhbikpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2Fzc2VydEVsZW1lbnRFeGlzdHMobWF0Y2hFbGVtZW50LCBlbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuX2Fzc2VydE9ubHlPbmVDb21wb25lbnQoZGlyZWN0aXZlQXN0cywgLyoqIEB0eXBlIHs/fSAqLyAoKGVsZW1lbnQuc291cmNlU3BhbikpKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nQ29udGVudEluZGV4XzEgPSBoYXNJbmxpbmVUZW1wbGF0ZXMgPyBudWxsIDogcGFyZW50LmZpbmROZ0NvbnRlbnRJbmRleChwcm9qZWN0aW9uU2VsZWN0b3IpO1xuICAgICAgICAgICAgcGFyc2VkRWxlbWVudCA9IG5ldyBFbGVtZW50QXN0KG5vZGVOYW1lLCBhdHRycywgZWxlbWVudFByb3BzLCBldmVudHMsIHJlZmVyZW5jZXMsIHByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1lZERpcmVjdGl2ZUFzdHMsIHByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1Qcm92aWRlcnMsIHByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1lZEhhc1ZpZXdDb250YWluZXIsIHByb3ZpZGVyQ29udGV4dC5xdWVyeU1hdGNoZXMsIGNoaWxkcmVuLCBoYXNJbmxpbmVUZW1wbGF0ZXMgPyBudWxsIDogbmdDb250ZW50SW5kZXhfMSwgZWxlbWVudC5zb3VyY2VTcGFuLCBlbGVtZW50LmVuZFNvdXJjZVNwYW4gfHwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0lubGluZVRlbXBsYXRlcykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVtcGxhdGVRdWVyeVN0YXJ0SW5kZXggPSB0aGlzLmNvbnRlbnRRdWVyeVN0YXJ0SWQ7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wbGF0ZVNlbGVjdG9yID0gY3JlYXRlRWxlbWVudENzc1NlbGVjdG9yKFRFTVBMQVRFX0VMRU1FTlQsIHRlbXBsYXRlTWF0Y2hhYmxlQXR0cnMpO1xuICAgICAgICAgICAgdmFyIHRlbXBsYXRlRGlyZWN0aXZlTWV0YXMgPSB0aGlzLl9wYXJzZURpcmVjdGl2ZXModGhpcy5zZWxlY3Rvck1hdGNoZXIsIHRlbXBsYXRlU2VsZWN0b3IpLmRpcmVjdGl2ZXM7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wbGF0ZUJvdW5kRGlyZWN0aXZlUHJvcE5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVtcGxhdGVEaXJlY3RpdmVBc3RzID0gdGhpcy5fY3JlYXRlRGlyZWN0aXZlQXN0cyh0cnVlLCBlbGVtZW50Lm5hbWUsIHRlbXBsYXRlRGlyZWN0aXZlTWV0YXMsIHRlbXBsYXRlRWxlbWVudE9yRGlyZWN0aXZlUHJvcHMsIFtdLCAvKiogQHR5cGUgez99ICovICgoZWxlbWVudC5zb3VyY2VTcGFuKSksIFtdLCB0ZW1wbGF0ZUJvdW5kRGlyZWN0aXZlUHJvcE5hbWVzKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlbXBsYXRlRWxlbWVudFByb3BzID0gdGhpcy5fY3JlYXRlRWxlbWVudFByb3BlcnR5QXN0cyhlbGVtZW50Lm5hbWUsIHRlbXBsYXRlRWxlbWVudE9yRGlyZWN0aXZlUHJvcHMsIHRlbXBsYXRlQm91bmREaXJlY3RpdmVQcm9wTmFtZXMpO1xuICAgICAgICAgICAgdGhpcy5fYXNzZXJ0Tm9Db21wb25lbnRzTm9yRWxlbWVudEJpbmRpbmdzT25UZW1wbGF0ZSh0ZW1wbGF0ZURpcmVjdGl2ZUFzdHMsIHRlbXBsYXRlRWxlbWVudFByb3BzLCAvKiogQHR5cGUgez99ICovICgoZWxlbWVudC5zb3VyY2VTcGFuKSkpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVtcGxhdGVQcm92aWRlckNvbnRleHQgPSBuZXcgUHJvdmlkZXJFbGVtZW50Q29udGV4dCh0aGlzLnByb3ZpZGVyVmlld0NvbnRleHQsIC8qKiBAdHlwZSB7P30gKi8gKChwYXJlbnQucHJvdmlkZXJDb250ZXh0KSksIHBhcmVudC5pc1RlbXBsYXRlRWxlbWVudCwgdGVtcGxhdGVEaXJlY3RpdmVBc3RzLCBbXSwgW10sIHRydWUsIHRlbXBsYXRlUXVlcnlTdGFydEluZGV4LCAvKiogQHR5cGUgez99ICovICgoZWxlbWVudC5zb3VyY2VTcGFuKSkpO1xuICAgICAgICAgICAgdGVtcGxhdGVQcm92aWRlckNvbnRleHQuYWZ0ZXJFbGVtZW50KCk7XG4gICAgICAgICAgICBwYXJzZWRFbGVtZW50ID0gbmV3IEVtYmVkZGVkVGVtcGxhdGVBc3QoW10sIFtdLCBbXSwgdGVtcGxhdGVFbGVtZW50VmFycywgdGVtcGxhdGVQcm92aWRlckNvbnRleHQudHJhbnNmb3JtZWREaXJlY3RpdmVBc3RzLCB0ZW1wbGF0ZVByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1Qcm92aWRlcnMsIHRlbXBsYXRlUHJvdmlkZXJDb250ZXh0LnRyYW5zZm9ybWVkSGFzVmlld0NvbnRhaW5lciwgdGVtcGxhdGVQcm92aWRlckNvbnRleHQucXVlcnlNYXRjaGVzLCBbcGFyc2VkRWxlbWVudF0sIG5nQ29udGVudEluZGV4LCAvKiogQHR5cGUgez99ICovICgoZWxlbWVudC5zb3VyY2VTcGFuKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZWRFbGVtZW50O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpc1RlbXBsYXRlRWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gYXR0clxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0TWF0Y2hhYmxlQXR0cnNcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFByb3BzXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRFdmVudHNcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFJlZnNcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFZhcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fcGFyc2VBdHRyID0gZnVuY3Rpb24gKGlzVGVtcGxhdGVFbGVtZW50LCBhdHRyLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMsIHRhcmdldEV2ZW50cywgdGFyZ2V0UmVmcywgdGFyZ2V0VmFycykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lID0gdGhpcy5fbm9ybWFsaXplQXR0cmlidXRlTmFtZShhdHRyLm5hbWUpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IGF0dHIudmFsdWU7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNyY1NwYW4gPSBhdHRyLnNvdXJjZVNwYW47XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJpbmRQYXJ0cyA9IG5hbWUubWF0Y2goQklORF9OQU1FX1JFR0VYUCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhhc0JpbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKGJpbmRQYXJ0cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaGFzQmluZGluZyA9IHRydWU7XG4gICAgICAgICAgICBpZiAoYmluZFBhcnRzW0tXX0JJTkRfSURYXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmluZGluZ1BhcnNlci5wYXJzZVByb3BlcnR5QmluZGluZyhiaW5kUGFydHNbSURFTlRfS1dfSURYXSwgdmFsdWUsIGZhbHNlLCBzcmNTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0tXX0xFVF9JRFhdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzVGVtcGxhdGVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlkZW50aWZpZXIgPSBiaW5kUGFydHNbSURFTlRfS1dfSURYXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VWYXJpYWJsZShpZGVudGlmaWVyLCB2YWx1ZSwgc3JjU3BhbiwgdGFyZ2V0VmFycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlxcXCJsZXQtXFxcIiBpcyBvbmx5IHN1cHBvcnRlZCBvbiB0ZW1wbGF0ZSBlbGVtZW50cy5cIiwgc3JjU3Bhbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0tXX1JFRl9JRFhdKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaWRlbnRpZmllciA9IGJpbmRQYXJ0c1tJREVOVF9LV19JRFhdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlUmVmZXJlbmNlKGlkZW50aWZpZXIsIHZhbHVlLCBzcmNTcGFuLCB0YXJnZXRSZWZzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRQYXJ0c1tLV19PTl9JRFhdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmluZGluZ1BhcnNlci5wYXJzZUV2ZW50KGJpbmRQYXJ0c1tJREVOVF9LV19JRFhdLCB2YWx1ZSwgc3JjU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiaW5kUGFydHNbS1dfQklORE9OX0lEWF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iaW5kaW5nUGFyc2VyLnBhcnNlUHJvcGVydHlCaW5kaW5nKGJpbmRQYXJ0c1tJREVOVF9LV19JRFhdLCB2YWx1ZSwgZmFsc2UsIHNyY1NwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VBc3NpZ25tZW50RXZlbnQoYmluZFBhcnRzW0lERU5UX0tXX0lEWF0sIHZhbHVlLCBzcmNTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRQYXJ0c1tLV19BVF9JRFhdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmluZGluZ1BhcnNlci5wYXJzZUxpdGVyYWxBdHRyKG5hbWUsIHZhbHVlLCBzcmNTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0lERU5UX0JBTkFOQV9CT1hfSURYXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdQYXJzZXIucGFyc2VQcm9wZXJ0eUJpbmRpbmcoYmluZFBhcnRzW0lERU5UX0JBTkFOQV9CT1hfSURYXSwgdmFsdWUsIGZhbHNlLCBzcmNTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlQXNzaWdubWVudEV2ZW50KGJpbmRQYXJ0c1tJREVOVF9CQU5BTkFfQk9YX0lEWF0sIHZhbHVlLCBzcmNTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRQYXJ0c1tJREVOVF9QUk9QRVJUWV9JRFhdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmluZGluZ1BhcnNlci5wYXJzZVByb3BlcnR5QmluZGluZyhiaW5kUGFydHNbSURFTlRfUFJPUEVSVFlfSURYXSwgdmFsdWUsIGZhbHNlLCBzcmNTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0lERU5UX0VWRU5UX0lEWF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iaW5kaW5nUGFyc2VyLnBhcnNlRXZlbnQoYmluZFBhcnRzW0lERU5UX0VWRU5UX0lEWF0sIHZhbHVlLCBzcmNTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhhc0JpbmRpbmcgPSB0aGlzLl9iaW5kaW5nUGFyc2VyLnBhcnNlUHJvcGVydHlJbnRlcnBvbGF0aW9uKG5hbWUsIHZhbHVlLCBzcmNTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaGFzQmluZGluZykge1xuICAgICAgICAgICAgdGhpcy5fYmluZGluZ1BhcnNlci5wYXJzZUxpdGVyYWxBdHRyKG5hbWUsIHZhbHVlLCBzcmNTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYXNCaW5kaW5nO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhdHRyTmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9ub3JtYWxpemVBdHRyaWJ1dGVOYW1lID0gZnVuY3Rpb24gKGF0dHJOYW1lKSB7XG4gICAgICAgIHJldHVybiAvXmRhdGEtL2kudGVzdChhdHRyTmFtZSkgPyBhdHRyTmFtZS5zdWJzdHJpbmcoNSkgOiBhdHRyTmFtZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWRlbnRpZmllclxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFZhcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fcGFyc2VWYXJpYWJsZSA9IGZ1bmN0aW9uIChpZGVudGlmaWVyLCB2YWx1ZSwgc291cmNlU3BhbiwgdGFyZ2V0VmFycykge1xuICAgICAgICBpZiAoaWRlbnRpZmllci5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJcXFwiLVxcXCIgaXMgbm90IGFsbG93ZWQgaW4gdmFyaWFibGUgbmFtZXNcIiwgc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0VmFycy5wdXNoKG5ldyBWYXJpYWJsZUFzdChpZGVudGlmaWVyLCB2YWx1ZSwgc291cmNlU3BhbikpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpZGVudGlmaWVyXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0UmVmc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZVJlZmVyZW5jZSA9IGZ1bmN0aW9uIChpZGVudGlmaWVyLCB2YWx1ZSwgc291cmNlU3BhbiwgdGFyZ2V0UmVmcykge1xuICAgICAgICBpZiAoaWRlbnRpZmllci5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJcXFwiLVxcXCIgaXMgbm90IGFsbG93ZWQgaW4gcmVmZXJlbmNlIG5hbWVzXCIsIHNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldFJlZnMucHVzaChuZXcgRWxlbWVudE9yRGlyZWN0aXZlUmVmKGlkZW50aWZpZXIsIHZhbHVlLCBzb3VyY2VTcGFuKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcGFyYW0gez99IHRhcmdldE1hdGNoYWJsZUF0dHJzXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRFdmVudHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fcGFyc2VBc3NpZ25tZW50RXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgZXhwcmVzc2lvbiwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cykge1xuICAgICAgICB0aGlzLl9iaW5kaW5nUGFyc2VyLnBhcnNlRXZlbnQobmFtZSArIFwiQ2hhbmdlXCIsIGV4cHJlc3Npb24gKyBcIj0kZXZlbnRcIiwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yTWF0Y2hlclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudENzc1NlbGVjdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlRGlyZWN0aXZlcyA9IGZ1bmN0aW9uIChzZWxlY3Rvck1hdGNoZXIsIGVsZW1lbnRDc3NTZWxlY3Rvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBOZWVkIHRvIHNvcnQgdGhlIGRpcmVjdGl2ZXMgc28gdGhhdCB3ZSBnZXQgY29uc2lzdGVudCByZXN1bHRzIHRocm91Z2hvdXQsXG4gICAgICAgIC8vIGFzIHNlbGVjdG9yTWF0Y2hlciB1c2VzIE1hcHMgaW5zaWRlLlxuICAgICAgICAvLyBBbHNvIGRlZHVwbGljYXRlIGRpcmVjdGl2ZXMgYXMgdGhleSBtaWdodCBtYXRjaCBtb3JlIHRoYW4gb25lIHRpbWUhXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpcmVjdGl2ZXMgPSBuZXcgQXJyYXkodGhpcy5kaXJlY3RpdmVzSW5kZXguc2l6ZSk7XG4gICAgICAgIC8vIFdoZXRoZXIgYW55IGRpcmVjdGl2ZSBzZWxlY3RvciBtYXRjaGVzIG9uIHRoZSBlbGVtZW50IG5hbWVcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWF0Y2hFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgIHNlbGVjdG9yTWF0Y2hlci5tYXRjaChlbGVtZW50Q3NzU2VsZWN0b3IsIGZ1bmN0aW9uIChzZWxlY3RvciwgZGlyZWN0aXZlKSB7XG4gICAgICAgICAgICBkaXJlY3RpdmVzWygoX3RoaXMuZGlyZWN0aXZlc0luZGV4LmdldChkaXJlY3RpdmUpKSldID0gZGlyZWN0aXZlO1xuICAgICAgICAgICAgbWF0Y2hFbGVtZW50ID0gbWF0Y2hFbGVtZW50IHx8IHNlbGVjdG9yLmhhc0VsZW1lbnRTZWxlY3RvcigpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMuZmlsdGVyKGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuICEhZGlyOyB9KSxcbiAgICAgICAgICAgIG1hdGNoRWxlbWVudDogbWF0Y2hFbGVtZW50LFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpc1RlbXBsYXRlRWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudE5hbWVcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZXNcbiAgICAgKiBAcGFyYW0gez99IHByb3BzXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50T3JEaXJlY3RpdmVSZWZzXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50U291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0UmVmZXJlbmNlc1xuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0Qm91bmREaXJlY3RpdmVQcm9wTmFtZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fY3JlYXRlRGlyZWN0aXZlQXN0cyA9IGZ1bmN0aW9uIChpc1RlbXBsYXRlRWxlbWVudCwgZWxlbWVudE5hbWUsIGRpcmVjdGl2ZXMsIHByb3BzLCBlbGVtZW50T3JEaXJlY3RpdmVSZWZzLCBlbGVtZW50U291cmNlU3BhbiwgdGFyZ2V0UmVmZXJlbmNlcywgdGFyZ2V0Qm91bmREaXJlY3RpdmVQcm9wTmFtZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWF0Y2hlZFJlZmVyZW5jZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBvbmVudCA9ICgobnVsbCkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXJlY3RpdmVBc3RzID0gZGlyZWN0aXZlcy5tYXAoZnVuY3Rpb24gKGRpcmVjdGl2ZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlU3BhbiA9IG5ldyBQYXJzZVNvdXJjZVNwYW4oZWxlbWVudFNvdXJjZVNwYW4uc3RhcnQsIGVsZW1lbnRTb3VyY2VTcGFuLmVuZCwgXCJEaXJlY3RpdmUgXCIgKyBpZGVudGlmaWVyTmFtZShkaXJlY3RpdmUudHlwZSkpO1xuICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZS5pc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudCA9IGRpcmVjdGl2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpcmVjdGl2ZVByb3BlcnRpZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhvc3RQcm9wZXJ0aWVzID0gKChfdGhpcy5fYmluZGluZ1BhcnNlci5jcmVhdGVEaXJlY3RpdmVIb3N0UHJvcGVydHlBc3RzKGRpcmVjdGl2ZSwgZWxlbWVudE5hbWUsIHNvdXJjZVNwYW4pKSk7XG4gICAgICAgICAgICAvLyBOb3RlOiBXZSBuZWVkIHRvIGNoZWNrIHRoZSBob3N0IHByb3BlcnRpZXMgaGVyZSBhcyB3ZWxsLFxuICAgICAgICAgICAgLy8gYXMgd2UgZG9uJ3Qga25vdyB0aGUgZWxlbWVudCBuYW1lIGluIHRoZSBEaXJlY3RpdmVXcmFwcGVyQ29tcGlsZXIgeWV0LlxuICAgICAgICAgICAgaG9zdFByb3BlcnRpZXMgPSBfdGhpcy5fY2hlY2tQcm9wZXJ0aWVzSW5TY2hlbWEoZWxlbWVudE5hbWUsIGhvc3RQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhvc3RFdmVudHMgPSAoKF90aGlzLl9iaW5kaW5nUGFyc2VyLmNyZWF0ZURpcmVjdGl2ZUhvc3RFdmVudEFzdHMoZGlyZWN0aXZlLCBzb3VyY2VTcGFuKSkpO1xuICAgICAgICAgICAgX3RoaXMuX2NyZWF0ZURpcmVjdGl2ZVByb3BlcnR5QXN0cyhkaXJlY3RpdmUuaW5wdXRzLCBwcm9wcywgZGlyZWN0aXZlUHJvcGVydGllcywgdGFyZ2V0Qm91bmREaXJlY3RpdmVQcm9wTmFtZXMpO1xuICAgICAgICAgICAgZWxlbWVudE9yRGlyZWN0aXZlUmVmcy5mb3JFYWNoKGZ1bmN0aW9uIChlbE9yRGlyUmVmKSB7XG4gICAgICAgICAgICAgICAgaWYgKChlbE9yRGlyUmVmLnZhbHVlLmxlbmd0aCA9PT0gMCAmJiBkaXJlY3RpdmUuaXNDb21wb25lbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIChkaXJlY3RpdmUuZXhwb3J0QXMgPT0gZWxPckRpclJlZi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0UmVmZXJlbmNlcy5wdXNoKG5ldyBSZWZlcmVuY2VBc3QoZWxPckRpclJlZi5uYW1lLCBjcmVhdGVUb2tlbkZvclJlZmVyZW5jZShkaXJlY3RpdmUudHlwZS5yZWZlcmVuY2UpLCBlbE9yRGlyUmVmLnNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFJlZmVyZW5jZXMuYWRkKGVsT3JEaXJSZWYubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250ZW50UXVlcnlTdGFydElkID0gX3RoaXMuY29udGVudFF1ZXJ5U3RhcnRJZDtcbiAgICAgICAgICAgIF90aGlzLmNvbnRlbnRRdWVyeVN0YXJ0SWQgKz0gZGlyZWN0aXZlLnF1ZXJpZXMubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEaXJlY3RpdmVBc3QoZGlyZWN0aXZlLCBkaXJlY3RpdmVQcm9wZXJ0aWVzLCBob3N0UHJvcGVydGllcywgaG9zdEV2ZW50cywgY29udGVudFF1ZXJ5U3RhcnRJZCwgc291cmNlU3Bhbik7XG4gICAgICAgIH0pO1xuICAgICAgICBlbGVtZW50T3JEaXJlY3RpdmVSZWZzLmZvckVhY2goZnVuY3Rpb24gKGVsT3JEaXJSZWYpIHtcbiAgICAgICAgICAgIGlmIChlbE9yRGlyUmVmLnZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZWRSZWZlcmVuY2VzLmhhcyhlbE9yRGlyUmVmLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihcIlRoZXJlIGlzIG5vIGRpcmVjdGl2ZSB3aXRoIFxcXCJleHBvcnRBc1xcXCIgc2V0IHRvIFxcXCJcIiArIGVsT3JEaXJSZWYudmFsdWUgKyBcIlxcXCJcIiwgZWxPckRpclJlZi5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVmVG9rZW4gPSAoKG51bGwpKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNUZW1wbGF0ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmVG9rZW4gPSBjcmVhdGVUb2tlbkZvckV4dGVybmFsUmVmZXJlbmNlKF90aGlzLnJlZmxlY3RvciwgSWRlbnRpZmllcnMuVGVtcGxhdGVSZWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YXJnZXRSZWZlcmVuY2VzLnB1c2gobmV3IFJlZmVyZW5jZUFzdChlbE9yRGlyUmVmLm5hbWUsIHJlZlRva2VuLCBlbE9yRGlyUmVmLnNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkaXJlY3RpdmVBc3RzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3RpdmVQcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHs/fSBib3VuZFByb3BzXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRCb3VuZERpcmVjdGl2ZVByb3BzXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRCb3VuZERpcmVjdGl2ZVByb3BOYW1lc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9jcmVhdGVEaXJlY3RpdmVQcm9wZXJ0eUFzdHMgPSBmdW5jdGlvbiAoZGlyZWN0aXZlUHJvcGVydGllcywgYm91bmRQcm9wcywgdGFyZ2V0Qm91bmREaXJlY3RpdmVQcm9wcywgdGFyZ2V0Qm91bmREaXJlY3RpdmVQcm9wTmFtZXMpIHtcbiAgICAgICAgaWYgKGRpcmVjdGl2ZVByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJvdW5kUHJvcHNCeU5hbWVfMSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGJvdW5kUHJvcHMuZm9yRWFjaChmdW5jdGlvbiAoYm91bmRQcm9wKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJldlZhbHVlID0gYm91bmRQcm9wc0J5TmFtZV8xLmdldChib3VuZFByb3AubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2VmFsdWUgfHwgcHJldlZhbHVlLmlzTGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBnaXZlIFthXT1cImJcIiBhIGhpZ2hlciBwcmVjZWRlbmNlIHRoYW4gYT1cImJcIiBvbiB0aGUgc2FtZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kUHJvcHNCeU5hbWVfMS5zZXQoYm91bmRQcm9wLm5hbWUsIGJvdW5kUHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhkaXJlY3RpdmVQcm9wZXJ0aWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChkaXJQcm9wKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxQcm9wID0gZGlyZWN0aXZlUHJvcGVydGllc1tkaXJQcm9wXTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBib3VuZFByb3AgPSBib3VuZFByb3BzQnlOYW1lXzEuZ2V0KGVsUHJvcCk7XG4gICAgICAgICAgICAgICAgLy8gQmluZGluZ3MgYXJlIG9wdGlvbmFsLCBzbyB0aGlzIGJpbmRpbmcgb25seSBuZWVkcyB0byBiZSBzZXQgdXAgaWYgYW4gZXhwcmVzc2lvbiBpcyBnaXZlbi5cbiAgICAgICAgICAgICAgICBpZiAoYm91bmRQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEJvdW5kRGlyZWN0aXZlUHJvcE5hbWVzLmFkZChib3VuZFByb3AubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNFbXB0eUV4cHJlc3Npb24oYm91bmRQcm9wLmV4cHJlc3Npb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRCb3VuZERpcmVjdGl2ZVByb3BzLnB1c2gobmV3IEJvdW5kRGlyZWN0aXZlUHJvcGVydHlBc3QoZGlyUHJvcCwgYm91bmRQcm9wLm5hbWUsIGJvdW5kUHJvcC5leHByZXNzaW9uLCBib3VuZFByb3Auc291cmNlU3BhbikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudE5hbWVcbiAgICAgKiBAcGFyYW0gez99IHByb3BzXG4gICAgICogQHBhcmFtIHs/fSBib3VuZERpcmVjdGl2ZVByb3BOYW1lc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9jcmVhdGVFbGVtZW50UHJvcGVydHlBc3RzID0gZnVuY3Rpb24gKGVsZW1lbnROYW1lLCBwcm9wcywgYm91bmREaXJlY3RpdmVQcm9wTmFtZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYm91bmRFbGVtZW50UHJvcHMgPSBbXTtcbiAgICAgICAgcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgaWYgKCFwcm9wLmlzTGl0ZXJhbCAmJiAhYm91bmREaXJlY3RpdmVQcm9wTmFtZXMuaGFzKHByb3AubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBib3VuZEVsZW1lbnRQcm9wcy5wdXNoKF90aGlzLl9iaW5kaW5nUGFyc2VyLmNyZWF0ZUVsZW1lbnRQcm9wZXJ0eUFzdChlbGVtZW50TmFtZSwgcHJvcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrUHJvcGVydGllc0luU2NoZW1hKGVsZW1lbnROYW1lLCBib3VuZEVsZW1lbnRQcm9wcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fZmluZENvbXBvbmVudERpcmVjdGl2ZXMgPSBmdW5jdGlvbiAoZGlyZWN0aXZlcykge1xuICAgICAgICByZXR1cm4gZGlyZWN0aXZlcy5maWx0ZXIoZnVuY3Rpb24gKGRpcmVjdGl2ZSkgeyByZXR1cm4gZGlyZWN0aXZlLmRpcmVjdGl2ZS5pc0NvbXBvbmVudDsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fZmluZENvbXBvbmVudERpcmVjdGl2ZU5hbWVzID0gZnVuY3Rpb24gKGRpcmVjdGl2ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRDb21wb25lbnREaXJlY3RpdmVzKGRpcmVjdGl2ZXMpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHsgcmV0dXJuICgoaWRlbnRpZmllck5hbWUoZGlyZWN0aXZlLmRpcmVjdGl2ZS50eXBlKSkpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlc1xuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9hc3NlcnRPbmx5T25lQ29tcG9uZW50ID0gZnVuY3Rpb24gKGRpcmVjdGl2ZXMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcG9uZW50VHlwZU5hbWVzID0gdGhpcy5fZmluZENvbXBvbmVudERpcmVjdGl2ZU5hbWVzKGRpcmVjdGl2ZXMpO1xuICAgICAgICBpZiAoY29tcG9uZW50VHlwZU5hbWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiTW9yZSB0aGFuIG9uZSBjb21wb25lbnQgbWF0Y2hlZCBvbiB0aGlzIGVsZW1lbnQuXFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiTWFrZSBzdXJlIHRoYXQgb25seSBvbmUgY29tcG9uZW50J3Mgc2VsZWN0b3IgY2FuIG1hdGNoIGEgZ2l2ZW4gZWxlbWVudC5cXG5cIiArXG4gICAgICAgICAgICAgICAgKFwiQ29uZmxpY3RpbmcgY29tcG9uZW50czogXCIgKyBjb21wb25lbnRUeXBlTmFtZXMuam9pbignLCcpKSwgc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1ha2Ugc3VyZSB0aGF0IG5vbi1hbmd1bGFyIHRhZ3MgY29uZm9ybSB0byB0aGUgc2NoZW1hcy5cbiAgICAgKlxuICAgICAqIE5vdGU6IEFuIGVsZW1lbnQgaXMgY29uc2lkZXJlZCBhbiBhbmd1bGFyIHRhZyB3aGVuIGF0IGxlYXN0IG9uZSBkaXJlY3RpdmUgc2VsZWN0b3IgbWF0Y2hlcyB0aGVcbiAgICAgKiB0YWcgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gbWF0Y2hFbGVtZW50IFdoZXRoZXIgYW55IGRpcmVjdGl2ZSBoYXMgbWF0Y2hlZCBvbiB0aGUgdGFnIG5hbWVcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnQgdGhlIGh0bWwgZWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9hc3NlcnRFbGVtZW50RXhpc3RzID0gZnVuY3Rpb24gKG1hdGNoRWxlbWVudCwgZWxlbWVudCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbE5hbWUgPSBlbGVtZW50Lm5hbWUucmVwbGFjZSgvXjp4aHRtbDovLCAnJyk7XG4gICAgICAgIGlmICghbWF0Y2hFbGVtZW50ICYmICF0aGlzLl9zY2hlbWFSZWdpc3RyeS5oYXNFbGVtZW50KGVsTmFtZSwgdGhpcy5fc2NoZW1hcykpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9yTXNnID0gXCInXCIgKyBlbE5hbWUgKyBcIicgaXMgbm90IGEga25vd24gZWxlbWVudDpcXG5cIjtcbiAgICAgICAgICAgIGVycm9yTXNnICs9XG4gICAgICAgICAgICAgICAgXCIxLiBJZiAnXCIgKyBlbE5hbWUgKyBcIicgaXMgYW4gQW5ndWxhciBjb21wb25lbnQsIHRoZW4gdmVyaWZ5IHRoYXQgaXQgaXMgcGFydCBvZiB0aGlzIG1vZHVsZS5cXG5cIjtcbiAgICAgICAgICAgIGlmIChlbE5hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBlcnJvck1zZyArPVxuICAgICAgICAgICAgICAgICAgICBcIjIuIElmICdcIiArIGVsTmFtZSArIFwiJyBpcyBhIFdlYiBDb21wb25lbnQgdGhlbiBhZGQgJ0NVU1RPTV9FTEVNRU5UU19TQ0hFTUEnIHRvIHRoZSAnQE5nTW9kdWxlLnNjaGVtYXMnIG9mIHRoaXMgY29tcG9uZW50IHRvIHN1cHByZXNzIHRoaXMgbWVzc2FnZS5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yTXNnICs9XG4gICAgICAgICAgICAgICAgICAgIFwiMi4gVG8gYWxsb3cgYW55IGVsZW1lbnQgYWRkICdOT19FUlJPUlNfU0NIRU1BJyB0byB0aGUgJ0BOZ01vZHVsZS5zY2hlbWFzJyBvZiB0aGlzIGNvbXBvbmVudC5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGVycm9yTXNnLCAvKiogQHR5cGUgez99ICovICgoZWxlbWVudC5zb3VyY2VTcGFuKSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZXNcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRQcm9wc1xuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9hc3NlcnROb0NvbXBvbmVudHNOb3JFbGVtZW50QmluZGluZ3NPblRlbXBsYXRlID0gZnVuY3Rpb24gKGRpcmVjdGl2ZXMsIGVsZW1lbnRQcm9wcywgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wb25lbnRUeXBlTmFtZXMgPSB0aGlzLl9maW5kQ29tcG9uZW50RGlyZWN0aXZlTmFtZXMoZGlyZWN0aXZlcyk7XG4gICAgICAgIGlmIChjb21wb25lbnRUeXBlTmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJDb21wb25lbnRzIG9uIGFuIGVtYmVkZGVkIHRlbXBsYXRlOiBcIiArIGNvbXBvbmVudFR5cGVOYW1lcy5qb2luKCcsJyksIHNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnRQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoXCJQcm9wZXJ0eSBiaW5kaW5nIFwiICsgcHJvcC5uYW1lICsgXCIgbm90IHVzZWQgYnkgYW55IGRpcmVjdGl2ZSBvbiBhbiBlbWJlZGRlZCB0ZW1wbGF0ZS4gTWFrZSBzdXJlIHRoYXQgdGhlIHByb3BlcnR5IG5hbWUgaXMgc3BlbGxlZCBjb3JyZWN0bHkgYW5kIGFsbCBkaXJlY3RpdmVzIGFyZSBsaXN0ZWQgaW4gdGhlIFxcXCJATmdNb2R1bGUuZGVjbGFyYXRpb25zXFxcIi5cIiwgc291cmNlU3Bhbik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3RpdmVzXG4gICAgICogQHBhcmFtIHs/fSBldmVudHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fYXNzZXJ0QWxsRXZlbnRzUHVibGlzaGVkQnlEaXJlY3RpdmVzID0gZnVuY3Rpb24gKGRpcmVjdGl2ZXMsIGV2ZW50cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbGxEaXJlY3RpdmVFdmVudHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhkaXJlY3RpdmUuZGlyZWN0aXZlLm91dHB1dHMpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBldmVudE5hbWUgPSBkaXJlY3RpdmUuZGlyZWN0aXZlLm91dHB1dHNba107XG4gICAgICAgICAgICAgICAgYWxsRGlyZWN0aXZlRXZlbnRzLmFkZChldmVudE5hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC50YXJnZXQgIT0gbnVsbCB8fCAhYWxsRGlyZWN0aXZlRXZlbnRzLmhhcyhldmVudC5uYW1lKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihcIkV2ZW50IGJpbmRpbmcgXCIgKyBldmVudC5mdWxsTmFtZSArIFwiIG5vdCBlbWl0dGVkIGJ5IGFueSBkaXJlY3RpdmUgb24gYW4gZW1iZWRkZWQgdGVtcGxhdGUuIE1ha2Ugc3VyZSB0aGF0IHRoZSBldmVudCBuYW1lIGlzIHNwZWxsZWQgY29ycmVjdGx5IGFuZCBhbGwgZGlyZWN0aXZlcyBhcmUgbGlzdGVkIGluIHRoZSBcXFwiQE5nTW9kdWxlLmRlY2xhcmF0aW9uc1xcXCIuXCIsIGV2ZW50LnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudE5hbWVcbiAgICAgKiBAcGFyYW0gez99IGJvdW5kUHJvcHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fY2hlY2tQcm9wZXJ0aWVzSW5TY2hlbWEgPSBmdW5jdGlvbiAoZWxlbWVudE5hbWUsIGJvdW5kUHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gTm90ZTogV2UgY2FuJ3QgZmlsdGVyIG91dCBlbXB0eSBleHByZXNzaW9ucyBiZWZvcmUgdGhpcyBtZXRob2QsXG4gICAgICAgIC8vIGFzIHdlIHN0aWxsIHdhbnQgdG8gdmFsaWRhdGUgdGhlbSFcbiAgICAgICAgcmV0dXJuIGJvdW5kUHJvcHMuZmlsdGVyKGZ1bmN0aW9uIChib3VuZFByb3ApIHtcbiAgICAgICAgICAgIGlmIChib3VuZFByb3AudHlwZSA9PT0gUHJvcGVydHlCaW5kaW5nVHlwZS5Qcm9wZXJ0eSAmJlxuICAgICAgICAgICAgICAgICFfdGhpcy5fc2NoZW1hUmVnaXN0cnkuaGFzUHJvcGVydHkoZWxlbWVudE5hbWUsIGJvdW5kUHJvcC5uYW1lLCBfdGhpcy5fc2NoZW1hcykpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvck1zZyA9IFwiQ2FuJ3QgYmluZCB0byAnXCIgKyBib3VuZFByb3AubmFtZSArIFwiJyBzaW5jZSBpdCBpc24ndCBhIGtub3duIHByb3BlcnR5IG9mICdcIiArIGVsZW1lbnROYW1lICsgXCInLlwiO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50TmFtZS5zdGFydHNXaXRoKCduZy0nKSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvck1zZyArPVxuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG4xLiBJZiAnXCIgKyBib3VuZFByb3AubmFtZSArIFwiJyBpcyBhbiBBbmd1bGFyIGRpcmVjdGl2ZSwgdGhlbiBhZGQgJ0NvbW1vbk1vZHVsZScgdG8gdGhlICdATmdNb2R1bGUuaW1wb3J0cycgb2YgdGhpcyBjb21wb25lbnQuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuMi4gVG8gYWxsb3cgYW55IHByb3BlcnR5IGFkZCAnTk9fRVJST1JTX1NDSEVNQScgdG8gdGhlICdATmdNb2R1bGUuc2NoZW1hcycgb2YgdGhpcyBjb21wb25lbnQuXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVsZW1lbnROYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTXNnICs9XG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcbjEuIElmICdcIiArIGVsZW1lbnROYW1lICsgXCInIGlzIGFuIEFuZ3VsYXIgY29tcG9uZW50IGFuZCBpdCBoYXMgJ1wiICsgYm91bmRQcm9wLm5hbWUgKyBcIicgaW5wdXQsIHRoZW4gdmVyaWZ5IHRoYXQgaXQgaXMgcGFydCBvZiB0aGlzIG1vZHVsZS5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiXFxuMi4gSWYgJ1wiICsgZWxlbWVudE5hbWUgKyBcIicgaXMgYSBXZWIgQ29tcG9uZW50IHRoZW4gYWRkICdDVVNUT01fRUxFTUVOVFNfU0NIRU1BJyB0byB0aGUgJ0BOZ01vZHVsZS5zY2hlbWFzJyBvZiB0aGlzIGNvbXBvbmVudCB0byBzdXBwcmVzcyB0aGlzIG1lc3NhZ2UuXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcbjMuIFRvIGFsbG93IGFueSBwcm9wZXJ0eSBhZGQgJ05PX0VSUk9SU19TQ0hFTUEnIHRvIHRoZSAnQE5nTW9kdWxlLnNjaGVtYXMnIG9mIHRoaXMgY29tcG9uZW50LlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoZXJyb3JNc2csIGJvdW5kUHJvcC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAhaXNFbXB0eUV4cHJlc3Npb24oYm91bmRQcm9wLnZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcGFyYW0gez89fSBsZXZlbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9yZXBvcnRFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBzb3VyY2VTcGFuLCBsZXZlbCkge1xuICAgICAgICBpZiAobGV2ZWwgPT09IHZvaWQgMCkgeyBsZXZlbCA9IFBhcnNlRXJyb3JMZXZlbC5FUlJPUjsgfVxuICAgICAgICB0aGlzLl90YXJnZXRFcnJvcnMucHVzaChuZXcgUGFyc2VFcnJvcihzb3VyY2VTcGFuLCBtZXNzYWdlLCBsZXZlbCkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRlbXBsYXRlUGFyc2VWaXNpdG9yO1xufSgpKTtcbnZhciBOb25CaW5kYWJsZVZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vbkJpbmRhYmxlVmlzaXRvcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IHBhcmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTm9uQmluZGFibGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoYXN0LCBwYXJlbnQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlcGFyc2VkRWxlbWVudCA9IHByZXBhcnNlRWxlbWVudChhc3QpO1xuICAgICAgICBpZiAocHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TQ1JJUFQgfHxcbiAgICAgICAgICAgIHByZXBhcnNlZEVsZW1lbnQudHlwZSA9PT0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEUgfHxcbiAgICAgICAgICAgIHByZXBhcnNlZEVsZW1lbnQudHlwZSA9PT0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEVTSEVFVCkge1xuICAgICAgICAgICAgLy8gU2tpcHBpbmcgPHNjcmlwdD4gZm9yIHNlY3VyaXR5IHJlYXNvbnNcbiAgICAgICAgICAgIC8vIFNraXBwaW5nIDxzdHlsZT4gYW5kIHN0eWxlc2hlZXRzIGFzIHdlIGFscmVhZHkgcHJvY2Vzc2VkIHRoZW1cbiAgICAgICAgICAgIC8vIGluIHRoZSBTdHlsZUNvbXBpbGVyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhdHRyTmFtZUFuZFZhbHVlcyA9IGFzdC5hdHRycy5tYXAoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuIFthdHRyLm5hbWUsIGF0dHIudmFsdWVdOyB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VsZWN0b3IgPSBjcmVhdGVFbGVtZW50Q3NzU2VsZWN0b3IoYXN0Lm5hbWUsIGF0dHJOYW1lQW5kVmFsdWVzKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmdDb250ZW50SW5kZXggPSBwYXJlbnQuZmluZE5nQ29udGVudEluZGV4KHNlbGVjdG9yKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hpbGRyZW4gPSB2aXNpdEFsbCh0aGlzLCBhc3QuY2hpbGRyZW4sIEVNUFRZX0VMRU1FTlRfQ09OVEVYVCk7XG4gICAgICAgIHJldHVybiBuZXcgRWxlbWVudEFzdChhc3QubmFtZSwgdmlzaXRBbGwodGhpcywgYXN0LmF0dHJzKSwgW10sIFtdLCBbXSwgW10sIFtdLCBmYWxzZSwgW10sIGNoaWxkcmVuLCBuZ0NvbnRlbnRJbmRleCwgYXN0LnNvdXJjZVNwYW4sIGFzdC5lbmRTb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29tbWVudFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTm9uQmluZGFibGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGF0dHJpYnV0ZVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTm9uQmluZGFibGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdHRyQXN0KGF0dHJpYnV0ZS5uYW1lLCBhdHRyaWJ1dGUudmFsdWUsIGF0dHJpYnV0ZS5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGV4dFxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOb25CaW5kYWJsZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBwYXJlbnQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmdDb250ZW50SW5kZXggPSAoKHBhcmVudC5maW5kTmdDb250ZW50SW5kZXgoVEVYVF9DU1NfU0VMRUNUT1IpKSk7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dEFzdCh0ZXh0LnZhbHVlLCBuZ0NvbnRlbnRJbmRleCwgLyoqIEB0eXBlIHs/fSAqLyAoKHRleHQuc291cmNlU3BhbikpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwYW5zaW9uXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOb25CaW5kYWJsZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGV4cGFuc2lvbiwgY29udGV4dCkgeyByZXR1cm4gZXhwYW5zaW9uOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwYW5zaW9uQ2FzZVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTm9uQmluZGFibGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoZXhwYW5zaW9uQ2FzZSwgY29udGV4dCkgeyByZXR1cm4gZXhwYW5zaW9uQ2FzZTsgfTtcbiAgICByZXR1cm4gTm9uQmluZGFibGVWaXNpdG9yO1xufSgpKTtcbnZhciBFbGVtZW50T3JEaXJlY3RpdmVSZWYgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFbGVtZW50T3JEaXJlY3RpdmVSZWYobmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICByZXR1cm4gRWxlbWVudE9yRGlyZWN0aXZlUmVmO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBjbGFzc0F0dHJWYWx1ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc3BsaXRDbGFzc2VzKGNsYXNzQXR0clZhbHVlKSB7XG4gICAgcmV0dXJuIGNsYXNzQXR0clZhbHVlLnRyaW0oKS5zcGxpdCgvXFxzKy9nKTtcbn1cbnZhciBFbGVtZW50Q29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpc1RlbXBsYXRlRWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gX25nQ29udGVudEluZGV4TWF0Y2hlclxuICAgICAqIEBwYXJhbSB7P30gX3dpbGRjYXJkTmdDb250ZW50SW5kZXhcbiAgICAgKiBAcGFyYW0gez99IHByb3ZpZGVyQ29udGV4dFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEVsZW1lbnRDb250ZXh0KGlzVGVtcGxhdGVFbGVtZW50LCBfbmdDb250ZW50SW5kZXhNYXRjaGVyLCBfd2lsZGNhcmROZ0NvbnRlbnRJbmRleCwgcHJvdmlkZXJDb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaXNUZW1wbGF0ZUVsZW1lbnQgPSBpc1RlbXBsYXRlRWxlbWVudDtcbiAgICAgICAgdGhpcy5fbmdDb250ZW50SW5kZXhNYXRjaGVyID0gX25nQ29udGVudEluZGV4TWF0Y2hlcjtcbiAgICAgICAgdGhpcy5fd2lsZGNhcmROZ0NvbnRlbnRJbmRleCA9IF93aWxkY2FyZE5nQ29udGVudEluZGV4O1xuICAgICAgICB0aGlzLnByb3ZpZGVyQ29udGV4dCA9IHByb3ZpZGVyQ29udGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpc1RlbXBsYXRlRWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlc1xuICAgICAqIEBwYXJhbSB7P30gcHJvdmlkZXJDb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbGVtZW50Q29udGV4dC5jcmVhdGUgPSBmdW5jdGlvbiAoaXNUZW1wbGF0ZUVsZW1lbnQsIGRpcmVjdGl2ZXMsIHByb3ZpZGVyQ29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXRjaGVyID0gbmV3IFNlbGVjdG9yTWF0Y2hlcigpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB3aWxkY2FyZE5nQ29udGVudEluZGV4ID0gKChudWxsKSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBvbmVudCA9IGRpcmVjdGl2ZXMuZmluZChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7IHJldHVybiBkaXJlY3RpdmUuZGlyZWN0aXZlLmlzQ29tcG9uZW50OyB9KTtcbiAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmdDb250ZW50U2VsZWN0b3JzID0gKChjb21wb25lbnQuZGlyZWN0aXZlLnRlbXBsYXRlKSkubmdDb250ZW50U2VsZWN0b3JzO1xuICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IG5nQ29udGVudFNlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlbGVjdG9yID0gbmdDb250ZW50U2VsZWN0b3JzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvciA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbGRjYXJkTmdDb250ZW50SW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlci5hZGRTZWxlY3RhYmxlcyhDc3NTZWxlY3Rvci5wYXJzZShuZ0NvbnRlbnRTZWxlY3RvcnNbaV0pLCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50Q29udGV4dChpc1RlbXBsYXRlRWxlbWVudCwgbWF0Y2hlciwgd2lsZGNhcmROZ0NvbnRlbnRJbmRleCwgcHJvdmlkZXJDb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0b3JcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVsZW1lbnRDb250ZXh0LnByb3RvdHlwZS5maW5kTmdDb250ZW50SW5kZXggPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmdDb250ZW50SW5kaWNlcyA9IFtdO1xuICAgICAgICB0aGlzLl9uZ0NvbnRlbnRJbmRleE1hdGNoZXIubWF0Y2goc2VsZWN0b3IsIGZ1bmN0aW9uIChzZWxlY3RvciwgbmdDb250ZW50SW5kZXgpIHsgbmdDb250ZW50SW5kaWNlcy5wdXNoKG5nQ29udGVudEluZGV4KTsgfSk7XG4gICAgICAgIG5nQ29udGVudEluZGljZXMuc29ydCgpO1xuICAgICAgICBpZiAodGhpcy5fd2lsZGNhcmROZ0NvbnRlbnRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICBuZ0NvbnRlbnRJbmRpY2VzLnB1c2godGhpcy5fd2lsZGNhcmROZ0NvbnRlbnRJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5nQ29udGVudEluZGljZXMubGVuZ3RoID4gMCA/IG5nQ29udGVudEluZGljZXNbMF0gOiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIEVsZW1lbnRDb250ZXh0O1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBlbGVtZW50TmFtZVxuICogQHBhcmFtIHs/fSBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50Q3NzU2VsZWN0b3IoZWxlbWVudE5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjc3NTZWxlY3RvciA9IG5ldyBDc3NTZWxlY3RvcigpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsTmFtZU5vTnMgPSBzcGxpdE5zTmFtZShlbGVtZW50TmFtZSlbMV07XG4gICAgY3NzU2VsZWN0b3Iuc2V0RWxlbWVudChlbE5hbWVOb05zKTtcbiAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhdHRyTmFtZSA9IGF0dHJpYnV0ZXNbaV1bMF07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGF0dHJOYW1lTm9OcyA9IHNwbGl0TnNOYW1lKGF0dHJOYW1lKVsxXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXR0clZhbHVlID0gYXR0cmlidXRlc1tpXVsxXTtcbiAgICAgICAgY3NzU2VsZWN0b3IuYWRkQXR0cmlidXRlKGF0dHJOYW1lTm9OcywgYXR0clZhbHVlKTtcbiAgICAgICAgaWYgKGF0dHJOYW1lLnRvTG93ZXJDYXNlKCkgPT0gQ0xBU1NfQVRUUikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xhc3NlcyA9IHNwbGl0Q2xhc3NlcyhhdHRyVmFsdWUpO1xuICAgICAgICAgICAgY2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbGFzc05hbWUpIHsgcmV0dXJuIGNzc1NlbGVjdG9yLmFkZENsYXNzTmFtZShjbGFzc05hbWUpOyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3NzU2VsZWN0b3I7XG59XG52YXIgRU1QVFlfRUxFTUVOVF9DT05URVhUID0gbmV3IEVsZW1lbnRDb250ZXh0KHRydWUsIG5ldyBTZWxlY3Rvck1hdGNoZXIoKSwgbnVsbCwgbnVsbCk7XG52YXIgTk9OX0JJTkRBQkxFX1ZJU0lUT1IgPSBuZXcgTm9uQmluZGFibGVWaXNpdG9yKCk7XG4vKipcbiAqIEBwYXJhbSB7P30gbm9kZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2lzRW1wdHlUZXh0Tm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBUZXh0ICYmIG5vZGUudmFsdWUudHJpbSgpLmxlbmd0aCA9PSAwO1xufVxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHs/fSBpdGVtc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlU3VtbWFyeUR1cGxpY2F0ZXMoaXRlbXMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXAgPSBuZXcgTWFwKCk7XG4gICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoIW1hcC5nZXQoaXRlbS50eXBlLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgIG1hcC5zZXQoaXRlbS50eXBlLnJlZmVyZW5jZSwgaXRlbSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShtYXAudmFsdWVzKCkpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGFzdFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNFbXB0eUV4cHJlc3Npb24oYXN0KSB7XG4gICAgaWYgKGFzdCBpbnN0YW5jZW9mIEFTVFdpdGhTb3VyY2UpIHtcbiAgICAgICAgYXN0ID0gYXN0LmFzdDtcbiAgICB9XG4gICAgcmV0dXJuIGFzdCBpbnN0YW5jZW9mIEVtcHR5RXhwcjtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBlbFxuICogQHBhcmFtIHs/fSBlbmFibGVMZWdhY3lUZW1wbGF0ZVxuICogQHBhcmFtIHs/fSByZXBvcnREZXByZWNhdGlvblxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNUZW1wbGF0ZShlbCwgZW5hYmxlTGVnYWN5VGVtcGxhdGUsIHJlcG9ydERlcHJlY2F0aW9uKSB7XG4gICAgaWYgKGlzTmdUZW1wbGF0ZShlbC5uYW1lKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGFnTm9OcyA9IHNwbGl0TnNOYW1lKGVsLm5hbWUpWzFdO1xuICAgIC8vIGA8dGVtcGxhdGU+YCBpcyBIVE1MIGFuZCBjYXNlIGluc2Vuc2l0aXZlXG4gICAgaWYgKHRhZ05vTnMudG9Mb3dlckNhc2UoKSA9PT0gVEVNUExBVEVfRUxFTUVOVCkge1xuICAgICAgICBpZiAoZW5hYmxlTGVnYWN5VGVtcGxhdGUgJiYgdGFnTm9Ocy50b0xvd2VyQ2FzZSgpID09PSBURU1QTEFURV9FTEVNRU5UKSB7XG4gICAgICAgICAgICByZXBvcnREZXByZWNhdGlvbihURU1QTEFURV9FTEVNRU5UX0RFUFJFQ0FUSU9OX1dBUk5JTkcsIC8qKiBAdHlwZSB7P30gKi8gKChlbC5zb3VyY2VTcGFuKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBBbiBpbnRlcmZhY2UgZm9yIHJldHJpZXZpbmcgZG9jdW1lbnRzIGJ5IFVSTCB0aGF0IHRoZSBjb21waWxlciB1c2VzXG4gKiB0byBsb2FkIHRlbXBsYXRlcy5cbiAqL1xudmFyIFJlc291cmNlTG9hZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXNvdXJjZUxvYWRlcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlc291cmNlTG9hZGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodXJsKSB7IHJldHVybiAnJzsgfTtcbiAgICByZXR1cm4gUmVzb3VyY2VMb2FkZXI7XG59KCkpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBDcmVhdGUgYSB7XFxAbGluayBVcmxSZXNvbHZlcn0gd2l0aCBubyBwYWNrYWdlIHByZWZpeC5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVVybFJlc29sdmVyV2l0aG91dFBhY2thZ2VQcmVmaXgoKSB7XG4gICAgcmV0dXJuIG5ldyBVcmxSZXNvbHZlcigpO1xufVxuLyoqXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjcmVhdGVPZmZsaW5lQ29tcGlsZVVybFJlc29sdmVyKCkge1xuICAgIHJldHVybiBuZXcgVXJsUmVzb2x2ZXIoJy4nKTtcbn1cbi8qKlxuICogQSBkZWZhdWx0IHByb3ZpZGVyIGZvciB7XFxAbGluayBQQUNLQUdFX1JPT1RfVVJMfSB0aGF0IG1hcHMgdG8gJy8nLlxuICovXG52YXIgREVGQVVMVF9QQUNLQUdFX1VSTF9QUk9WSURFUiA9IHtcbiAgICBwcm92aWRlOiBQQUNLQUdFX1JPT1RfVVJMLFxuICAgIHVzZVZhbHVlOiAnLydcbn07XG4vKipcbiAqIFVzZWQgYnkgdGhlIHtcXEBsaW5rIENvbXBpbGVyfSB3aGVuIHJlc29sdmluZyBIVE1MIGFuZCBDU1MgdGVtcGxhdGUgVVJMcy5cbiAqXG4gKiBUaGlzIGNsYXNzIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBhcHBsaWNhdGlvbiBkZXZlbG9wZXIgdG8gY3JlYXRlIGN1c3RvbSBiZWhhdmlvci5cbiAqXG4gKiBTZWUge1xcQGxpbmsgQ29tcGlsZXJ9XG4gKlxuICogIyMgRXhhbXBsZVxuICpcbiAqIHtcXEBleGFtcGxlIGNvbXBpbGVyL3RzL3VybF9yZXNvbHZlci91cmxfcmVzb2x2ZXIudHMgcmVnaW9uPSd1cmxfcmVzb2x2ZXInfVxuICpcbiAqIFxcQHNlY3VyaXR5IFdoZW4gY29tcGlsaW5nIHRlbXBsYXRlcyBhdCBydW50aW1lLCB5b3UgbXVzdFxuICogZW5zdXJlIHRoYXQgdGhlIGVudGlyZSB0ZW1wbGF0ZSBjb21lcyBmcm9tIGEgdHJ1c3RlZCBzb3VyY2UuXG4gKiBBdHRhY2tlci1jb250cm9sbGVkIGRhdGEgaW50cm9kdWNlZCBieSBhIHRlbXBsYXRlIGNvdWxkIGV4cG9zZSB5b3VyXG4gKiBhcHBsaWNhdGlvbiB0byBYU1Mgcmlza3MuIEZvciBtb3JlIGRldGFpbCwgc2VlIHRoZSBbU2VjdXJpdHkgR3VpZGVdKGh0dHA6Ly9nLmNvL25nL3NlY3VyaXR5KS5cbiAqL1xudmFyIFVybFJlc29sdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBfcGFja2FnZVByZWZpeFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFVybFJlc29sdmVyKF9wYWNrYWdlUHJlZml4KSB7XG4gICAgICAgIGlmIChfcGFja2FnZVByZWZpeCA9PT0gdm9pZCAwKSB7IF9wYWNrYWdlUHJlZml4ID0gbnVsbDsgfVxuICAgICAgICB0aGlzLl9wYWNrYWdlUHJlZml4ID0gX3BhY2thZ2VQcmVmaXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHRoZSBgdXJsYCBnaXZlbiB0aGUgYGJhc2VVcmxgOlxuICAgICAqIC0gd2hlbiB0aGUgYHVybGAgaXMgbnVsbCwgdGhlIGBiYXNlVXJsYCBpcyByZXR1cm5lZCxcbiAgICAgKiAtIGlmIGB1cmxgIGlzIHJlbGF0aXZlICgncGF0aC90by9oZXJlJywgJy4vcGF0aC90by9oZXJlJyksIHRoZSByZXNvbHZlZCB1cmwgaXMgYSBjb21iaW5hdGlvbiBvZlxuICAgICAqIGBiYXNlVXJsYCBhbmQgYHVybGAsXG4gICAgICogLSBpZiBgdXJsYCBpcyBhYnNvbHV0ZSAoaXQgaGFzIGEgc2NoZW1lOiAnaHR0cDovLycsICdodHRwczovLycgb3Igc3RhcnQgd2l0aCAnLycpLCB0aGUgYHVybGAgaXNcbiAgICAgKiByZXR1cm5lZCBhcyBpcyAoaWdub3JpbmcgdGhlIGBiYXNlVXJsYClcbiAgICAgKiBAcGFyYW0gez99IGJhc2VVcmxcbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVXJsUmVzb2x2ZXIucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAoYmFzZVVybCwgdXJsKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc29sdmVkVXJsID0gdXJsO1xuICAgICAgICBpZiAoYmFzZVVybCAhPSBudWxsICYmIGJhc2VVcmwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVzb2x2ZWRVcmwgPSBfcmVzb2x2ZVVybChiYXNlVXJsLCByZXNvbHZlZFVybCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzb2x2ZWRQYXJ0cyA9IF9zcGxpdChyZXNvbHZlZFVybCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZWZpeCA9IHRoaXMuX3BhY2thZ2VQcmVmaXg7XG4gICAgICAgIGlmIChwcmVmaXggIT0gbnVsbCAmJiByZXNvbHZlZFBhcnRzICE9IG51bGwgJiZcbiAgICAgICAgICAgIHJlc29sdmVkUGFydHNbX0NvbXBvbmVudEluZGV4LlNjaGVtZV0gPT0gJ3BhY2thZ2UnKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXRoID0gcmVzb2x2ZWRQYXJ0c1tfQ29tcG9uZW50SW5kZXguUGF0aF07XG4gICAgICAgICAgICBwcmVmaXggPSBwcmVmaXgucmVwbGFjZSgvXFwvKyQvLCAnJyk7XG4gICAgICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9eXFwvKy8sICcnKTtcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyBcIi9cIiArIHBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmVkVXJsO1xuICAgIH07XG4gICAgcmV0dXJuIFVybFJlc29sdmVyO1xufSgpKTtcblVybFJlc29sdmVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21waWxlckluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cblVybFJlc29sdmVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtQQUNLQUdFX1JPT1RfVVJMLF0gfSxdIH0sXG5dOyB9O1xuLyoqXG4gKiBFeHRyYWN0IHRoZSBzY2hlbWUgb2YgYSBVUkwuXG4gKiBAcGFyYW0gez99IHVybFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZ2V0VXJsU2NoZW1lKHVybCkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hdGNoID0gX3NwbGl0KHVybCk7XG4gICAgcmV0dXJuIChtYXRjaCAmJiBtYXRjaFtfQ29tcG9uZW50SW5kZXguU2NoZW1lXSkgfHwgJyc7XG59XG4vKipcbiAqIEJ1aWxkcyBhIFVSSSBzdHJpbmcgZnJvbSBhbHJlYWR5LWVuY29kZWQgcGFydHMuXG4gKlxuICogTm8gZW5jb2RpbmcgaXMgcGVyZm9ybWVkLiAgQW55IGNvbXBvbmVudCBtYXkgYmUgb21pdHRlZCBhcyBlaXRoZXIgbnVsbCBvclxuICogdW5kZWZpbmVkLlxuICpcbiAqIEBwYXJhbSB7Pz19IG9wdF9zY2hlbWUgVGhlIHNjaGVtZSBzdWNoIGFzICdodHRwJy5cbiAqIEBwYXJhbSB7Pz19IG9wdF91c2VySW5mbyBUaGUgdXNlciBuYW1lIGJlZm9yZSB0aGUgJ1xcQCcuXG4gKiBAcGFyYW0gez89fSBvcHRfZG9tYWluIFRoZSBkb21haW4gc3VjaCBhcyAnd3d3Lmdvb2dsZS5jb20nLCBhbHJlYWR5XG4gKiAgICAgVVJJLWVuY29kZWQuXG4gKiBAcGFyYW0gez89fSBvcHRfcG9ydCBUaGUgcG9ydCBudW1iZXIuXG4gKiBAcGFyYW0gez89fSBvcHRfcGF0aCBUaGUgcGF0aCwgYWxyZWFkeSBVUkktZW5jb2RlZC4gIElmIGl0IGlzIG5vdFxuICogICAgIGVtcHR5LCBpdCBtdXN0IGJlZ2luIHdpdGggYSBzbGFzaC5cbiAqIEBwYXJhbSB7Pz19IG9wdF9xdWVyeURhdGEgVGhlIFVSSS1lbmNvZGVkIHF1ZXJ5IGRhdGEuXG4gKiBAcGFyYW0gez89fSBvcHRfZnJhZ21lbnQgVGhlIFVSSS1lbmNvZGVkIGZyYWdtZW50IGlkZW50aWZpZXIuXG4gKiBAcmV0dXJuIHs/fSBUaGUgZnVsbHkgY29tYmluZWQgVVJJLlxuICovXG5mdW5jdGlvbiBfYnVpbGRGcm9tRW5jb2RlZFBhcnRzKG9wdF9zY2hlbWUsIG9wdF91c2VySW5mbywgb3B0X2RvbWFpbiwgb3B0X3BvcnQsIG9wdF9wYXRoLCBvcHRfcXVlcnlEYXRhLCBvcHRfZnJhZ21lbnQpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvdXQgPSBbXTtcbiAgICBpZiAob3B0X3NjaGVtZSAhPSBudWxsKSB7XG4gICAgICAgIG91dC5wdXNoKG9wdF9zY2hlbWUgKyAnOicpO1xuICAgIH1cbiAgICBpZiAob3B0X2RvbWFpbiAhPSBudWxsKSB7XG4gICAgICAgIG91dC5wdXNoKCcvLycpO1xuICAgICAgICBpZiAob3B0X3VzZXJJbmZvICE9IG51bGwpIHtcbiAgICAgICAgICAgIG91dC5wdXNoKG9wdF91c2VySW5mbyArICdAJyk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0LnB1c2gob3B0X2RvbWFpbik7XG4gICAgICAgIGlmIChvcHRfcG9ydCAhPSBudWxsKSB7XG4gICAgICAgICAgICBvdXQucHVzaCgnOicgKyBvcHRfcG9ydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdF9wYXRoICE9IG51bGwpIHtcbiAgICAgICAgb3V0LnB1c2gob3B0X3BhdGgpO1xuICAgIH1cbiAgICBpZiAob3B0X3F1ZXJ5RGF0YSAhPSBudWxsKSB7XG4gICAgICAgIG91dC5wdXNoKCc/JyArIG9wdF9xdWVyeURhdGEpO1xuICAgIH1cbiAgICBpZiAob3B0X2ZyYWdtZW50ICE9IG51bGwpIHtcbiAgICAgICAgb3V0LnB1c2goJyMnICsgb3B0X2ZyYWdtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIG91dC5qb2luKCcnKTtcbn1cbi8qKlxuICogQSByZWd1bGFyIGV4cHJlc3Npb24gZm9yIGJyZWFraW5nIGEgVVJJIGludG8gaXRzIGNvbXBvbmVudCBwYXJ0cy5cbiAqXG4gKiB7XFxAbGluayBodHRwOi8vd3d3LmdiaXYuY29tL3Byb3RvY29scy91cmkvcmZjL3JmYzM5ODYuaHRtbCNSRkMyMjM0fSBzYXlzXG4gKiBBcyB0aGUgXCJmaXJzdC1tYXRjaC13aW5zXCIgYWxnb3JpdGhtIGlzIGlkZW50aWNhbCB0byB0aGUgXCJncmVlZHlcIlxuICogZGlzYW1iaWd1YXRpb24gbWV0aG9kIHVzZWQgYnkgUE9TSVggcmVndWxhciBleHByZXNzaW9ucywgaXQgaXMgbmF0dXJhbCBhbmRcbiAqIGNvbW1vbnBsYWNlIHRvIHVzZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgcGFyc2luZyB0aGUgcG90ZW50aWFsIGZpdmVcbiAqIGNvbXBvbmVudHMgb2YgYSBVUkkgcmVmZXJlbmNlLlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgbGluZSBpcyB0aGUgcmVndWxhciBleHByZXNzaW9uIGZvciBicmVha2luZy1kb3duIGFcbiAqIHdlbGwtZm9ybWVkIFVSSSByZWZlcmVuY2UgaW50byBpdHMgY29tcG9uZW50cy5cbiAqXG4gKiA8cHJlPlxuICogXigoW146Lz8jXSspOik/KC8vKFteLz8jXSopKT8oW14/I10qKShcXD8oW14jXSopKT8oIyguKikpP1xuICogIDEyICAgICAgICAgICAgMyAgNCAgICAgICAgICA1ICAgICAgIDYgIDcgICAgICAgIDggOVxuICogPC9wcmU+XG4gKlxuICogVGhlIG51bWJlcnMgaW4gdGhlIHNlY29uZCBsaW5lIGFib3ZlIGFyZSBvbmx5IHRvIGFzc2lzdCByZWFkYWJpbGl0eTsgdGhleVxuICogaW5kaWNhdGUgdGhlIHJlZmVyZW5jZSBwb2ludHMgZm9yIGVhY2ggc3ViZXhwcmVzc2lvbiAoaS5lLiwgZWFjaCBwYWlyZWRcbiAqIHBhcmVudGhlc2lzKS4gV2UgcmVmZXIgdG8gdGhlIHZhbHVlIG1hdGNoZWQgZm9yIHN1YmV4cHJlc3Npb24gPG4+IGFzICQ8bj4uXG4gKiBGb3IgZXhhbXBsZSwgbWF0Y2hpbmcgdGhlIGFib3ZlIGV4cHJlc3Npb24gdG9cbiAqIDxwcmU+XG4gKiAgICAgaHR0cDovL3d3dy5pY3MudWNpLmVkdS9wdWIvaWV0Zi91cmkvI1JlbGF0ZWRcbiAqIDwvcHJlPlxuICogcmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nIHN1YmV4cHJlc3Npb24gbWF0Y2hlczpcbiAqIDxwcmU+XG4gKiAgICAkMSA9IGh0dHA6XG4gKiAgICAkMiA9IGh0dHBcbiAqICAgICQzID0gLy93d3cuaWNzLnVjaS5lZHVcbiAqICAgICQ0ID0gd3d3Lmljcy51Y2kuZWR1XG4gKiAgICAkNSA9IC9wdWIvaWV0Zi91cmkvXG4gKiAgICAkNiA9IDx1bmRlZmluZWQ+XG4gKiAgICAkNyA9IDx1bmRlZmluZWQ+XG4gKiAgICAkOCA9ICNSZWxhdGVkXG4gKiAgICAkOSA9IFJlbGF0ZWRcbiAqIDwvcHJlPlxuICogd2hlcmUgPHVuZGVmaW5lZD4gaW5kaWNhdGVzIHRoYXQgdGhlIGNvbXBvbmVudCBpcyBub3QgcHJlc2VudCwgYXMgaXMgdGhlXG4gKiBjYXNlIGZvciB0aGUgcXVlcnkgY29tcG9uZW50IGluIHRoZSBhYm92ZSBleGFtcGxlLiBUaGVyZWZvcmUsIHdlIGNhblxuICogZGV0ZXJtaW5lIHRoZSB2YWx1ZSBvZiB0aGUgZml2ZSBjb21wb25lbnRzIGFzXG4gKiA8cHJlPlxuICogICAgc2NoZW1lICAgID0gJDJcbiAqICAgIGF1dGhvcml0eSA9ICQ0XG4gKiAgICBwYXRoICAgICAgPSAkNVxuICogICAgcXVlcnkgICAgID0gJDdcbiAqICAgIGZyYWdtZW50ICA9ICQ5XG4gKiA8L3ByZT5cbiAqXG4gKiBUaGUgcmVndWxhciBleHByZXNzaW9uIGhhcyBiZWVuIG1vZGlmaWVkIHNsaWdodGx5IHRvIGV4cG9zZSB0aGVcbiAqIHVzZXJJbmZvLCBkb21haW4sIGFuZCBwb3J0IHNlcGFyYXRlbHkgZnJvbSB0aGUgYXV0aG9yaXR5LlxuICogVGhlIG1vZGlmaWVkIHZlcnNpb24geWllbGRzXG4gKiA8cHJlPlxuICogICAgJDEgPSBodHRwICAgICAgICAgICAgICBzY2hlbWVcbiAqICAgICQyID0gPHVuZGVmaW5lZD4gICAgICAgdXNlckluZm8gLVxcXG4gKiAgICAkMyA9IHd3dy5pY3MudWNpLmVkdSAgIGRvbWFpbiAgICAgfCBhdXRob3JpdHlcbiAqICAgICQ0ID0gPHVuZGVmaW5lZD4gICAgICAgcG9ydCAgICAgLS9cbiAqICAgICQ1ID0gL3B1Yi9pZXRmL3VyaS8gICAgcGF0aFxuICogICAgJDYgPSA8dW5kZWZpbmVkPiAgICAgICBxdWVyeSB3aXRob3V0ID9cbiAqICAgICQ3ID0gUmVsYXRlZCAgICAgICAgICAgZnJhZ21lbnQgd2l0aG91dCAjXG4gKiA8L3ByZT5cbiAqIFxcQGludGVybmFsXG4gKi9cbnZhciBfc3BsaXRSZSA9IG5ldyBSZWdFeHAoJ14nICtcbiAgICAnKD86JyArXG4gICAgJyhbXjovPyMuXSspJyArXG4gICAgLy8gdXNlZCBieSBvdGhlciBVUkwgcGFydHMgc3VjaCBhcyA6LFxuICAgIC8vID8sIC8sICMsIGFuZCAuXG4gICAgJzopPycgK1xuICAgICcoPzovLycgK1xuICAgICcoPzooW14vPyNdKilAKT8nICtcbiAgICAnKFtcXFxcd1xcXFxkXFxcXC1cXFxcdTAxMDAtXFxcXHVmZmZmLiVdKiknICtcbiAgICAvLyBkaWdpdHMsIGRhc2hlcywgZG90cywgcGVyY2VudFxuICAgIC8vIGVzY2FwZXMsIGFuZCB1bmljb2RlIGNoYXJhY3RlcnMuXG4gICAgJyg/OjooWzAtOV0rKSk/JyArXG4gICAgJyk/JyArXG4gICAgJyhbXj8jXSspPycgK1xuICAgICcoPzpcXFxcPyhbXiNdKikpPycgK1xuICAgICcoPzojKC4qKSk/JyArXG4gICAgJyQnKTtcbnZhciBfQ29tcG9uZW50SW5kZXggPSB7fTtcbl9Db21wb25lbnRJbmRleC5TY2hlbWUgPSAxO1xuX0NvbXBvbmVudEluZGV4LlVzZXJJbmZvID0gMjtcbl9Db21wb25lbnRJbmRleC5Eb21haW4gPSAzO1xuX0NvbXBvbmVudEluZGV4LlBvcnQgPSA0O1xuX0NvbXBvbmVudEluZGV4LlBhdGggPSA1O1xuX0NvbXBvbmVudEluZGV4LlF1ZXJ5RGF0YSA9IDY7XG5fQ29tcG9uZW50SW5kZXguRnJhZ21lbnQgPSA3O1xuX0NvbXBvbmVudEluZGV4W19Db21wb25lbnRJbmRleC5TY2hlbWVdID0gXCJTY2hlbWVcIjtcbl9Db21wb25lbnRJbmRleFtfQ29tcG9uZW50SW5kZXguVXNlckluZm9dID0gXCJVc2VySW5mb1wiO1xuX0NvbXBvbmVudEluZGV4W19Db21wb25lbnRJbmRleC5Eb21haW5dID0gXCJEb21haW5cIjtcbl9Db21wb25lbnRJbmRleFtfQ29tcG9uZW50SW5kZXguUG9ydF0gPSBcIlBvcnRcIjtcbl9Db21wb25lbnRJbmRleFtfQ29tcG9uZW50SW5kZXguUGF0aF0gPSBcIlBhdGhcIjtcbl9Db21wb25lbnRJbmRleFtfQ29tcG9uZW50SW5kZXguUXVlcnlEYXRhXSA9IFwiUXVlcnlEYXRhXCI7XG5fQ29tcG9uZW50SW5kZXhbX0NvbXBvbmVudEluZGV4LkZyYWdtZW50XSA9IFwiRnJhZ21lbnRcIjtcbi8qKlxuICogU3BsaXRzIGEgVVJJIGludG8gaXRzIGNvbXBvbmVudCBwYXJ0cy5cbiAqXG4gKiBFYWNoIGNvbXBvbmVudCBjYW4gYmUgYWNjZXNzZWQgdmlhIHRoZSBjb21wb25lbnQgaW5kaWNlczsgZm9yIGV4YW1wbGU6XG4gKiA8cHJlPlxuICogZ29vZy51cmkudXRpbHMuc3BsaXQoc29tZVN0cilbZ29vZy51cmkudXRpbHMuQ29tcG9udGVudEluZGV4LlFVRVJZX0RBVEFdO1xuICogPC9wcmU+XG4gKlxuICogQHBhcmFtIHs/fSB1cmkgVGhlIFVSSSBzdHJpbmcgdG8gZXhhbWluZS5cbiAqIEByZXR1cm4gez99IEVhY2ggY29tcG9uZW50IHN0aWxsIFVSSS1lbmNvZGVkLlxuICogICAgIEVhY2ggY29tcG9uZW50IHRoYXQgaXMgcHJlc2VudCB3aWxsIGNvbnRhaW4gdGhlIGVuY29kZWQgdmFsdWUsIHdoZXJlYXNcbiAqICAgICBjb21wb25lbnRzIHRoYXQgYXJlIG5vdCBwcmVzZW50IHdpbGwgYmUgdW5kZWZpbmVkIG9yIGVtcHR5LCBkZXBlbmRpbmdcbiAqICAgICBvbiB0aGUgYnJvd3NlcidzIHJlZ3VsYXIgZXhwcmVzc2lvbiBpbXBsZW1lbnRhdGlvbi4gIE5ldmVyIG51bGwsIHNpbmNlXG4gKiAgICAgYXJiaXRyYXJ5IHN0cmluZ3MgbWF5IHN0aWxsIGxvb2sgbGlrZSBwYXRoIG5hbWVzLlxuICovXG5mdW5jdGlvbiBfc3BsaXQodXJpKSB7XG4gICAgcmV0dXJuICgodXJpLm1hdGNoKF9zcGxpdFJlKSkpO1xufVxuLyoqXG4gKiBSZW1vdmVzIGRvdCBzZWdtZW50cyBpbiBnaXZlbiBwYXRoIGNvbXBvbmVudCwgYXMgZGVzY3JpYmVkIGluXG4gKiBSRkMgMzk4Niwgc2VjdGlvbiA1LjIuNC5cbiAqXG4gKiBAcGFyYW0gez99IHBhdGggQSBub24tZW1wdHkgcGF0aCBjb21wb25lbnQuXG4gKiBAcmV0dXJuIHs/fSBQYXRoIGNvbXBvbmVudCB3aXRoIHJlbW92ZWQgZG90IHNlZ21lbnRzLlxuICovXG5mdW5jdGlvbiBfcmVtb3ZlRG90U2VnbWVudHMocGF0aCkge1xuICAgIGlmIChwYXRoID09ICcvJylcbiAgICAgICAgcmV0dXJuICcvJztcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsZWFkaW5nU2xhc2ggPSBwYXRoWzBdID09ICcvJyA/ICcvJyA6ICcnO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYWlsaW5nU2xhc2ggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPT09ICcvJyA/ICcvJyA6ICcnO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLycpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG91dCA9IFtdO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHVwID0gMDtcbiAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIHBvcyA9IDA7IHBvcyA8IHNlZ21lbnRzLmxlbmd0aDsgcG9zKyspIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VnbWVudCA9IHNlZ21lbnRzW3Bvc107XG4gICAgICAgIHN3aXRjaCAoc2VnbWVudCkge1xuICAgICAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgICAgIGNhc2UgJy4nOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnLi4nOlxuICAgICAgICAgICAgICAgIGlmIChvdXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBvdXQucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1cCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goc2VnbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxlYWRpbmdTbGFzaCA9PSAnJykge1xuICAgICAgICB3aGlsZSAodXAtLSA+IDApIHtcbiAgICAgICAgICAgIG91dC51bnNoaWZ0KCcuLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdXQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgb3V0LnB1c2goJy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGxlYWRpbmdTbGFzaCArIG91dC5qb2luKCcvJykgKyB0cmFpbGluZ1NsYXNoO1xufVxuLyoqXG4gKiBUYWtlcyBhbiBhcnJheSBvZiB0aGUgcGFydHMgZnJvbSBzcGxpdCBhbmQgY2Fub25pY2FsaXplcyB0aGUgcGF0aCBwYXJ0XG4gKiBhbmQgdGhlbiBqb2lucyBhbGwgdGhlIHBhcnRzLlxuICogQHBhcmFtIHs/fSBwYXJ0c1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2pvaW5BbmRDYW5vbmljYWxpemVQYXRoKHBhcnRzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGF0aCA9IHBhcnRzW19Db21wb25lbnRJbmRleC5QYXRoXTtcbiAgICBwYXRoID0gcGF0aCA9PSBudWxsID8gJycgOiBfcmVtb3ZlRG90U2VnbWVudHMocGF0aCk7XG4gICAgcGFydHNbX0NvbXBvbmVudEluZGV4LlBhdGhdID0gcGF0aDtcbiAgICByZXR1cm4gX2J1aWxkRnJvbUVuY29kZWRQYXJ0cyhwYXJ0c1tfQ29tcG9uZW50SW5kZXguU2NoZW1lXSwgcGFydHNbX0NvbXBvbmVudEluZGV4LlVzZXJJbmZvXSwgcGFydHNbX0NvbXBvbmVudEluZGV4LkRvbWFpbl0sIHBhcnRzW19Db21wb25lbnRJbmRleC5Qb3J0XSwgcGF0aCwgcGFydHNbX0NvbXBvbmVudEluZGV4LlF1ZXJ5RGF0YV0sIHBhcnRzW19Db21wb25lbnRJbmRleC5GcmFnbWVudF0pO1xufVxuLyoqXG4gKiBSZXNvbHZlcyBhIFVSTC5cbiAqIEBwYXJhbSB7P30gYmFzZSBUaGUgVVJMIGFjdGluZyBhcyB0aGUgYmFzZSBVUkwuXG4gKiBAcGFyYW0gez99IHVybFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX3Jlc29sdmVVcmwoYmFzZSwgdXJsKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFydHMgPSBfc3BsaXQoZW5jb2RlVVJJKHVybCkpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGJhc2VQYXJ0cyA9IF9zcGxpdChiYXNlKTtcbiAgICBpZiAocGFydHNbX0NvbXBvbmVudEluZGV4LlNjaGVtZV0gIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gX2pvaW5BbmRDYW5vbmljYWxpemVQYXRoKHBhcnRzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBhcnRzW19Db21wb25lbnRJbmRleC5TY2hlbWVdID0gYmFzZVBhcnRzW19Db21wb25lbnRJbmRleC5TY2hlbWVdO1xuICAgIH1cbiAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSBfQ29tcG9uZW50SW5kZXguU2NoZW1lOyBpIDw9IF9Db21wb25lbnRJbmRleC5Qb3J0OyBpKyspIHtcbiAgICAgICAgaWYgKHBhcnRzW2ldID09IG51bGwpIHtcbiAgICAgICAgICAgIHBhcnRzW2ldID0gYmFzZVBhcnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJ0c1tfQ29tcG9uZW50SW5kZXguUGF0aF1bMF0gPT0gJy8nKSB7XG4gICAgICAgIHJldHVybiBfam9pbkFuZENhbm9uaWNhbGl6ZVBhdGgocGFydHMpO1xuICAgIH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXRoID0gYmFzZVBhcnRzW19Db21wb25lbnRJbmRleC5QYXRoXTtcbiAgICBpZiAocGF0aCA9PSBudWxsKVxuICAgICAgICBwYXRoID0gJy8nO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGluZGV4ID0gcGF0aC5sYXN0SW5kZXhPZignLycpO1xuICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygwLCBpbmRleCArIDEpICsgcGFydHNbX0NvbXBvbmVudEluZGV4LlBhdGhdO1xuICAgIHBhcnRzW19Db21wb25lbnRJbmRleC5QYXRoXSA9IHBhdGg7XG4gICAgcmV0dXJuIF9qb2luQW5kQ2Fub25pY2FsaXplUGF0aChwYXJ0cyk7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgRGlyZWN0aXZlTm9ybWFsaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfcmVzb3VyY2VMb2FkZXJcbiAgICAgKiBAcGFyYW0gez99IF91cmxSZXNvbHZlclxuICAgICAqIEBwYXJhbSB7P30gX2h0bWxQYXJzZXJcbiAgICAgKiBAcGFyYW0gez99IF9jb25maWdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEaXJlY3RpdmVOb3JtYWxpemVyKF9yZXNvdXJjZUxvYWRlciwgX3VybFJlc29sdmVyLCBfaHRtbFBhcnNlciwgX2NvbmZpZykge1xuICAgICAgICB0aGlzLl9yZXNvdXJjZUxvYWRlciA9IF9yZXNvdXJjZUxvYWRlcjtcbiAgICAgICAgdGhpcy5fdXJsUmVzb2x2ZXIgPSBfdXJsUmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuX2h0bWxQYXJzZXIgPSBfaHRtbFBhcnNlcjtcbiAgICAgICAgdGhpcy5fY29uZmlnID0gX2NvbmZpZztcbiAgICAgICAgdGhpcy5fcmVzb3VyY2VMb2FkZXJDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEaXJlY3RpdmVOb3JtYWxpemVyLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9yZXNvdXJjZUxvYWRlckNhY2hlLmNsZWFyKCk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub3JtYWxpemVkRGlyZWN0aXZlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEaXJlY3RpdmVOb3JtYWxpemVyLnByb3RvdHlwZS5jbGVhckNhY2hlRm9yID0gZnVuY3Rpb24gKG5vcm1hbGl6ZWREaXJlY3RpdmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFub3JtYWxpemVkRGlyZWN0aXZlLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVtcGxhdGUgPSAoKG5vcm1hbGl6ZWREaXJlY3RpdmUudGVtcGxhdGUpKTtcbiAgICAgICAgdGhpcy5fcmVzb3VyY2VMb2FkZXJDYWNoZS5kZWxldGUoLyoqIEB0eXBlIHs/fSAqLyAoKHRlbXBsYXRlLnRlbXBsYXRlVXJsKSkpO1xuICAgICAgICB0ZW1wbGF0ZS5leHRlcm5hbFN0eWxlc2hlZXRzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlc2hlZXQpIHsgX3RoaXMuX3Jlc291cmNlTG9hZGVyQ2FjaGUuZGVsZXRlKC8qKiBAdHlwZSB7P30gKi8gKChzdHlsZXNoZWV0Lm1vZHVsZVVybCkpKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUuX2ZldGNoID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSB0aGlzLl9yZXNvdXJjZUxvYWRlckNhY2hlLmdldCh1cmwpO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fcmVzb3VyY2VMb2FkZXIuZ2V0KHVybCk7XG4gICAgICAgICAgICB0aGlzLl9yZXNvdXJjZUxvYWRlckNhY2hlLnNldCh1cmwsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJlbm9ybURhdGFcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERpcmVjdGl2ZU5vcm1hbGl6ZXIucHJvdG90eXBlLm5vcm1hbGl6ZVRlbXBsYXRlID0gZnVuY3Rpb24gKHByZW5vcm1EYXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChpc0RlZmluZWQocHJlbm9ybURhdGEudGVtcGxhdGUpKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHByZW5vcm1EYXRhLnRlbXBsYXRlVXJsKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHN5bnRheEVycm9yKFwiJ1wiICsgybVzdHJpbmdpZnkocHJlbm9ybURhdGEuY29tcG9uZW50VHlwZSkgKyBcIicgY29tcG9uZW50IGNhbm5vdCBkZWZpbmUgYm90aCB0ZW1wbGF0ZSBhbmQgdGVtcGxhdGVVcmxcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByZW5vcm1EYXRhLnRlbXBsYXRlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IHN5bnRheEVycm9yKFwiVGhlIHRlbXBsYXRlIHNwZWNpZmllZCBmb3IgY29tcG9uZW50IFwiICsgybVzdHJpbmdpZnkocHJlbm9ybURhdGEuY29tcG9uZW50VHlwZSkgKyBcIiBpcyBub3QgYSBzdHJpbmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNEZWZpbmVkKHByZW5vcm1EYXRhLnRlbXBsYXRlVXJsKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcmVub3JtRGF0YS50ZW1wbGF0ZVVybCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBzeW50YXhFcnJvcihcIlRoZSB0ZW1wbGF0ZVVybCBzcGVjaWZpZWQgZm9yIGNvbXBvbmVudCBcIiArIMm1c3RyaW5naWZ5KHByZW5vcm1EYXRhLmNvbXBvbmVudFR5cGUpICsgXCIgaXMgbm90IGEgc3RyaW5nXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgc3ludGF4RXJyb3IoXCJObyB0ZW1wbGF0ZSBzcGVjaWZpZWQgZm9yIGNvbXBvbmVudCBcIiArIMm1c3RyaW5naWZ5KHByZW5vcm1EYXRhLmNvbXBvbmVudFR5cGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3luY0FzeW5jLnRoZW4odGhpcy5ub3JtYWxpemVUZW1wbGF0ZU9ubHkocHJlbm9ybURhdGEpLCBmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiBfdGhpcy5ub3JtYWxpemVFeHRlcm5hbFN0eWxlc2hlZXRzKHJlc3VsdCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcmVub21EYXRhXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEaXJlY3RpdmVOb3JtYWxpemVyLnByb3RvdHlwZS5ub3JtYWxpemVUZW1wbGF0ZU9ubHkgPSBmdW5jdGlvbiAocHJlbm9tRGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wbGF0ZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVtcGxhdGVVcmw7XG4gICAgICAgIGlmIChwcmVub21EYXRhLnRlbXBsYXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRlbXBsYXRlID0gcHJlbm9tRGF0YS50ZW1wbGF0ZTtcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsID0gcHJlbm9tRGF0YS5tb2R1bGVVcmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0ZW1wbGF0ZVVybCA9IHRoaXMuX3VybFJlc29sdmVyLnJlc29sdmUocHJlbm9tRGF0YS5tb2R1bGVVcmwsIC8qKiBAdHlwZSB7P30gKi8gKChwcmVub21EYXRhLnRlbXBsYXRlVXJsKSkpO1xuICAgICAgICAgICAgdGVtcGxhdGUgPSB0aGlzLl9mZXRjaCh0ZW1wbGF0ZVVybCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN5bmNBc3luYy50aGVuKHRlbXBsYXRlLCBmdW5jdGlvbiAodGVtcGxhdGUpIHsgcmV0dXJuIF90aGlzLm5vcm1hbGl6ZUxvYWRlZFRlbXBsYXRlKHByZW5vbURhdGEsIHRlbXBsYXRlLCB0ZW1wbGF0ZVVybCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcmVub3JtRGF0YVxuICAgICAqIEBwYXJhbSB7P30gdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0gez99IHRlbXBsYXRlQWJzVXJsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEaXJlY3RpdmVOb3JtYWxpemVyLnByb3RvdHlwZS5ub3JtYWxpemVMb2FkZWRUZW1wbGF0ZSA9IGZ1bmN0aW9uIChwcmVub3JtRGF0YSwgdGVtcGxhdGUsIHRlbXBsYXRlQWJzVXJsKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzSW5saW5lID0gISFwcmVub3JtRGF0YS50ZW1wbGF0ZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW50ZXJwb2xhdGlvbkNvbmZpZyA9IEludGVycG9sYXRpb25Db25maWcuZnJvbUFycmF5KC8qKiBAdHlwZSB7P30gKi8gKChwcmVub3JtRGF0YS5pbnRlcnBvbGF0aW9uKSkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByb290Tm9kZXNBbmRFcnJvcnMgPSB0aGlzLl9odG1sUGFyc2VyLnBhcnNlKHRlbXBsYXRlLCB0ZW1wbGF0ZVNvdXJjZVVybCh7IHJlZmVyZW5jZTogcHJlbm9ybURhdGEubmdNb2R1bGVUeXBlIH0sIHsgdHlwZTogeyByZWZlcmVuY2U6IHByZW5vcm1EYXRhLmNvbXBvbmVudFR5cGUgfSB9LCB7IGlzSW5saW5lOiBpc0lubGluZSwgdGVtcGxhdGVVcmw6IHRlbXBsYXRlQWJzVXJsIH0pLCB0cnVlLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgaWYgKHJvb3ROb2Rlc0FuZEVycm9ycy5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3JTdHJpbmcgPSByb290Tm9kZXNBbmRFcnJvcnMuZXJyb3JzLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgdGhyb3cgc3ludGF4RXJyb3IoXCJUZW1wbGF0ZSBwYXJzZSBlcnJvcnM6XFxuXCIgKyBlcnJvclN0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVtcGxhdGVNZXRhZGF0YVN0eWxlcyA9IHRoaXMubm9ybWFsaXplU3R5bGVzaGVldChuZXcgQ29tcGlsZVN0eWxlc2hlZXRNZXRhZGF0YSh7XG4gICAgICAgICAgICBzdHlsZXM6IHByZW5vcm1EYXRhLnN0eWxlcyxcbiAgICAgICAgICAgIHN0eWxlVXJsczogcHJlbm9ybURhdGEuc3R5bGVVcmxzLFxuICAgICAgICAgICAgbW9kdWxlVXJsOiBwcmVub3JtRGF0YS5tb2R1bGVVcmxcbiAgICAgICAgfSkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aXNpdG9yID0gbmV3IFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yKCk7XG4gICAgICAgIHZpc2l0QWxsKHZpc2l0b3IsIHJvb3ROb2Rlc0FuZEVycm9ycy5yb290Tm9kZXMpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wbGF0ZVN0eWxlcyA9IHRoaXMubm9ybWFsaXplU3R5bGVzaGVldChuZXcgQ29tcGlsZVN0eWxlc2hlZXRNZXRhZGF0YSh7IHN0eWxlczogdmlzaXRvci5zdHlsZXMsIHN0eWxlVXJsczogdmlzaXRvci5zdHlsZVVybHMsIG1vZHVsZVVybDogdGVtcGxhdGVBYnNVcmwgfSkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbmNhcHN1bGF0aW9uID0gcHJlbm9ybURhdGEuZW5jYXBzdWxhdGlvbjtcbiAgICAgICAgaWYgKGVuY2Fwc3VsYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbiA9IHRoaXMuX2NvbmZpZy5kZWZhdWx0RW5jYXBzdWxhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZXMgPSB0ZW1wbGF0ZU1ldGFkYXRhU3R5bGVzLnN0eWxlcy5jb25jYXQodGVtcGxhdGVTdHlsZXMuc3R5bGVzKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVVcmxzID0gdGVtcGxhdGVNZXRhZGF0YVN0eWxlcy5zdHlsZVVybHMuY29uY2F0KHRlbXBsYXRlU3R5bGVzLnN0eWxlVXJscyk7XG4gICAgICAgIGlmIChlbmNhcHN1bGF0aW9uID09PSBWaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZCAmJiBzdHlsZXMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICBzdHlsZVVybHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uID0gVmlld0VuY2Fwc3VsYXRpb24uTm9uZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhKHtcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IGVuY2Fwc3VsYXRpb24sXG4gICAgICAgICAgICB0ZW1wbGF0ZTogdGVtcGxhdGUsXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogdGVtcGxhdGVBYnNVcmwsIHN0eWxlczogc3R5bGVzLCBzdHlsZVVybHM6IHN0eWxlVXJscyxcbiAgICAgICAgICAgIG5nQ29udGVudFNlbGVjdG9yczogdmlzaXRvci5uZ0NvbnRlbnRTZWxlY3RvcnMsXG4gICAgICAgICAgICBhbmltYXRpb25zOiBwcmVub3JtRGF0YS5hbmltYXRpb25zLFxuICAgICAgICAgICAgaW50ZXJwb2xhdGlvbjogcHJlbm9ybURhdGEuaW50ZXJwb2xhdGlvbiwgaXNJbmxpbmU6IGlzSW5saW5lLFxuICAgICAgICAgICAgZXh0ZXJuYWxTdHlsZXNoZWV0czogW11cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRlbXBsYXRlTWV0YVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUubm9ybWFsaXplRXh0ZXJuYWxTdHlsZXNoZWV0cyA9IGZ1bmN0aW9uICh0ZW1wbGF0ZU1ldGEpIHtcbiAgICAgICAgcmV0dXJuIFN5bmNBc3luYy50aGVuKHRoaXMuX2xvYWRNaXNzaW5nRXh0ZXJuYWxTdHlsZXNoZWV0cyh0ZW1wbGF0ZU1ldGEuc3R5bGVVcmxzKSwgZnVuY3Rpb24gKGV4dGVybmFsU3R5bGVzaGVldHMpIHsgcmV0dXJuIG5ldyBDb21waWxlVGVtcGxhdGVNZXRhZGF0YSh7XG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiB0ZW1wbGF0ZU1ldGEuZW5jYXBzdWxhdGlvbixcbiAgICAgICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZU1ldGEudGVtcGxhdGUsXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogdGVtcGxhdGVNZXRhLnRlbXBsYXRlVXJsLFxuICAgICAgICAgICAgc3R5bGVzOiB0ZW1wbGF0ZU1ldGEuc3R5bGVzLFxuICAgICAgICAgICAgc3R5bGVVcmxzOiB0ZW1wbGF0ZU1ldGEuc3R5bGVVcmxzLFxuICAgICAgICAgICAgZXh0ZXJuYWxTdHlsZXNoZWV0czogZXh0ZXJuYWxTdHlsZXNoZWV0cyxcbiAgICAgICAgICAgIG5nQ29udGVudFNlbGVjdG9yczogdGVtcGxhdGVNZXRhLm5nQ29udGVudFNlbGVjdG9ycyxcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IHRlbXBsYXRlTWV0YS5hbmltYXRpb25zLFxuICAgICAgICAgICAgaW50ZXJwb2xhdGlvbjogdGVtcGxhdGVNZXRhLmludGVycG9sYXRpb24sXG4gICAgICAgICAgICBpc0lubGluZTogdGVtcGxhdGVNZXRhLmlzSW5saW5lLFxuICAgICAgICB9KTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlVXJsc1xuICAgICAqIEBwYXJhbSB7Pz19IGxvYWRlZFN0eWxlc2hlZXRzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEaXJlY3RpdmVOb3JtYWxpemVyLnByb3RvdHlwZS5fbG9hZE1pc3NpbmdFeHRlcm5hbFN0eWxlc2hlZXRzID0gZnVuY3Rpb24gKHN0eWxlVXJscywgbG9hZGVkU3R5bGVzaGVldHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGxvYWRlZFN0eWxlc2hlZXRzID09PSB2b2lkIDApIHsgbG9hZGVkU3R5bGVzaGVldHMgPSBuZXcgTWFwKCk7IH1cbiAgICAgICAgcmV0dXJuIFN5bmNBc3luYy50aGVuKFN5bmNBc3luYy5hbGwoc3R5bGVVcmxzLmZpbHRlcihmdW5jdGlvbiAoc3R5bGVVcmwpIHsgcmV0dXJuICFsb2FkZWRTdHlsZXNoZWV0cy5oYXMoc3R5bGVVcmwpOyB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoc3R5bGVVcmwpIHsgcmV0dXJuIFN5bmNBc3luYy50aGVuKF90aGlzLl9mZXRjaChzdHlsZVVybCksIGZ1bmN0aW9uIChsb2FkZWRTdHlsZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVzaGVldCA9IF90aGlzLm5vcm1hbGl6ZVN0eWxlc2hlZXQobmV3IENvbXBpbGVTdHlsZXNoZWV0TWV0YWRhdGEoeyBzdHlsZXM6IFtsb2FkZWRTdHlsZV0sIG1vZHVsZVVybDogc3R5bGVVcmwgfSkpO1xuICAgICAgICAgICAgbG9hZGVkU3R5bGVzaGVldHMuc2V0KHN0eWxlVXJsLCBzdHlsZXNoZWV0KTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fbG9hZE1pc3NpbmdFeHRlcm5hbFN0eWxlc2hlZXRzKHN0eWxlc2hlZXQuc3R5bGVVcmxzLCBsb2FkZWRTdHlsZXNoZWV0cyk7XG4gICAgICAgIH0pOyB9KSksIGZ1bmN0aW9uIChfKSB7IHJldHVybiBBcnJheS5mcm9tKGxvYWRlZFN0eWxlc2hlZXRzLnZhbHVlcygpKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlc2hlZXRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERpcmVjdGl2ZU5vcm1hbGl6ZXIucHJvdG90eXBlLm5vcm1hbGl6ZVN0eWxlc2hlZXQgPSBmdW5jdGlvbiAoc3R5bGVzaGVldCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtb2R1bGVVcmwgPSAoKHN0eWxlc2hlZXQubW9kdWxlVXJsKSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFsbFN0eWxlVXJscyA9IHN0eWxlc2hlZXQuc3R5bGVVcmxzLmZpbHRlcihpc1N0eWxlVXJsUmVzb2x2YWJsZSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHVybCkgeyByZXR1cm4gX3RoaXMuX3VybFJlc29sdmVyLnJlc29sdmUobW9kdWxlVXJsLCB1cmwpOyB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWxsU3R5bGVzID0gc3R5bGVzaGVldC5zdHlsZXMubWFwKGZ1bmN0aW9uIChzdHlsZSQkMSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVXaXRoSW1wb3J0cyA9IGV4dHJhY3RTdHlsZVVybHMoX3RoaXMuX3VybFJlc29sdmVyLCBtb2R1bGVVcmwsIHN0eWxlJCQxKTtcbiAgICAgICAgICAgIGFsbFN0eWxlVXJscy5wdXNoLmFwcGx5KGFsbFN0eWxlVXJscywgc3R5bGVXaXRoSW1wb3J0cy5zdHlsZVVybHMpO1xuICAgICAgICAgICAgcmV0dXJuIHN0eWxlV2l0aEltcG9ydHMuc3R5bGU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVTdHlsZXNoZWV0TWV0YWRhdGEoeyBzdHlsZXM6IGFsbFN0eWxlcywgc3R5bGVVcmxzOiBhbGxTdHlsZVVybHMsIG1vZHVsZVVybDogbW9kdWxlVXJsIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIERpcmVjdGl2ZU5vcm1hbGl6ZXI7XG59KCkpO1xuRGlyZWN0aXZlTm9ybWFsaXplci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcGlsZXJJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5EaXJlY3RpdmVOb3JtYWxpemVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogUmVzb3VyY2VMb2FkZXIsIH0sXG4gICAgeyB0eXBlOiBVcmxSZXNvbHZlciwgfSxcbiAgICB7IHR5cGU6IEh0bWxQYXJzZXIsIH0sXG4gICAgeyB0eXBlOiBDb21waWxlckNvbmZpZywgfSxcbl07IH07XG52YXIgVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yKCkge1xuICAgICAgICB0aGlzLm5nQ29udGVudFNlbGVjdG9ycyA9IFtdO1xuICAgICAgICB0aGlzLnN0eWxlcyA9IFtdO1xuICAgICAgICB0aGlzLnN0eWxlVXJscyA9IFtdO1xuICAgICAgICB0aGlzLm5nTm9uQmluZGFibGVTdGFja0NvdW50ID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZXBhcnNlZEVsZW1lbnQgPSBwcmVwYXJzZUVsZW1lbnQoYXN0KTtcbiAgICAgICAgc3dpdGNoIChwcmVwYXJzZWRFbGVtZW50LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgUHJlcGFyc2VkRWxlbWVudFR5cGUuTkdfQ09OVEVOVDpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uZ05vbkJpbmRhYmxlU3RhY2tDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5nQ29udGVudFNlbGVjdG9ycy5wdXNoKHByZXBhcnNlZEVsZW1lbnQuc2VsZWN0QXR0cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRTpcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZXh0Q29udGVudF8xID0gJyc7XG4gICAgICAgICAgICAgICAgYXN0LmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRDb250ZW50XzEgKz0gY2hpbGQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlcy5wdXNoKHRleHRDb250ZW50XzEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRVNIRUVUOlxuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVVcmxzLnB1c2gocHJlcGFyc2VkRWxlbWVudC5ocmVmQXR0cik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVwYXJzZWRFbGVtZW50Lm5vbkJpbmRhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLm5nTm9uQmluZGFibGVTdGFja0NvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgdmlzaXRBbGwodGhpcywgYXN0LmNoaWxkcmVuKTtcbiAgICAgICAgaWYgKHByZXBhcnNlZEVsZW1lbnQubm9uQmluZGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMubmdOb25CaW5kYWJsZVN0YWNrQ291bnQtLTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVByZXBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb24gPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHZpc2l0QWxsKHRoaXMsIGFzdC5jYXNlcyk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZpc2l0QWxsKHRoaXMsIGFzdC5leHByZXNzaW9uKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVByZXBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0QXR0cmlidXRlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgcmV0dXJuIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yO1xufSgpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBEaXJlY3RpdmVSZXNvbHZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfcmVmbGVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGlyZWN0aXZlUmVzb2x2ZXIoX3JlZmxlY3Rvcikge1xuICAgICAgICB0aGlzLl9yZWZsZWN0b3IgPSBfcmVmbGVjdG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERpcmVjdGl2ZVJlc29sdmVyLnByb3RvdHlwZS5pc0RpcmVjdGl2ZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHR5cGVNZXRhZGF0YSA9IHRoaXMuX3JlZmxlY3Rvci5hbm5vdGF0aW9ucyhyZXNvbHZlRm9yd2FyZFJlZih0eXBlKSk7XG4gICAgICAgIHJldHVybiB0eXBlTWV0YWRhdGEgJiYgdHlwZU1ldGFkYXRhLnNvbWUoaXNEaXJlY3RpdmVNZXRhZGF0YSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSB0aHJvd0lmTm90Rm91bmRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERpcmVjdGl2ZVJlc29sdmVyLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKHR5cGUsIHRocm93SWZOb3RGb3VuZCkge1xuICAgICAgICBpZiAodGhyb3dJZk5vdEZvdW5kID09PSB2b2lkIDApIHsgdGhyb3dJZk5vdEZvdW5kID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0eXBlTWV0YWRhdGEgPSB0aGlzLl9yZWZsZWN0b3IuYW5ub3RhdGlvbnMocmVzb2x2ZUZvcndhcmRSZWYodHlwZSkpO1xuICAgICAgICBpZiAodHlwZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZXRhZGF0YSA9IGZpbmRMYXN0KHR5cGVNZXRhZGF0YSwgaXNEaXJlY3RpdmVNZXRhZGF0YSk7XG4gICAgICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9wZXJ0eU1ldGFkYXRhID0gdGhpcy5fcmVmbGVjdG9yLnByb3BNZXRhZGF0YSh0eXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbWVyZ2VXaXRoUHJvcGVydHlNZXRhZGF0YShtZXRhZGF0YSwgcHJvcGVydHlNZXRhZGF0YSwgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRocm93SWZOb3RGb3VuZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gRGlyZWN0aXZlIGFubm90YXRpb24gZm91bmQgb24gXCIgKyDJtXN0cmluZ2lmeSh0eXBlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRtXG4gICAgICogQHBhcmFtIHs/fSBwcm9wZXJ0eU1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3RpdmVUeXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEaXJlY3RpdmVSZXNvbHZlci5wcm90b3R5cGUuX21lcmdlV2l0aFByb3BlcnR5TWV0YWRhdGEgPSBmdW5jdGlvbiAoZG0sIHByb3BlcnR5TWV0YWRhdGEsIGRpcmVjdGl2ZVR5cGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5wdXRzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG91dHB1dHMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaG9zdCA9IHt9O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdWVyaWVzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKHByb3BlcnR5TWV0YWRhdGEpLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnB1dCA9IGZpbmRMYXN0KHByb3BlcnR5TWV0YWRhdGFbcHJvcE5hbWVdLCBmdW5jdGlvbiAoYSkgeyByZXR1cm4gYSBpbnN0YW5jZW9mIElucHV0OyB9KTtcbiAgICAgICAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5iaW5kaW5nUHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0cy5wdXNoKHByb3BOYW1lICsgXCI6IFwiICsgaW5wdXQuYmluZGluZ1Byb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dHMucHVzaChwcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3V0cHV0ID0gZmluZExhc3QocHJvcGVydHlNZXRhZGF0YVtwcm9wTmFtZV0sIGZ1bmN0aW9uIChhKSB7IHJldHVybiBhIGluc3RhbmNlb2YgT3V0cHV0OyB9KTtcbiAgICAgICAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAob3V0cHV0LmJpbmRpbmdQcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0cy5wdXNoKHByb3BOYW1lICsgXCI6IFwiICsgb3V0cHV0LmJpbmRpbmdQcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0cy5wdXNoKHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBob3N0QmluZGluZ3MgPSBwcm9wZXJ0eU1ldGFkYXRhW3Byb3BOYW1lXS5maWx0ZXIoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEgJiYgYSBpbnN0YW5jZW9mIEhvc3RCaW5kaW5nOyB9KTtcbiAgICAgICAgICAgIGhvc3RCaW5kaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChob3N0QmluZGluZykge1xuICAgICAgICAgICAgICAgIGlmIChob3N0QmluZGluZy5ob3N0UHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0V2l0aCA9IGhvc3RCaW5kaW5nLmhvc3RQcm9wZXJ0eU5hbWVbMF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydFdpdGggPT09ICcoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQEhvc3RCaW5kaW5nIGNhbiBub3QgYmluZCB0byBldmVudHMuIFVzZSBASG9zdExpc3RlbmVyIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0V2l0aCA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJASG9zdEJpbmRpbmcgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHByb3BlcnR5IG5hbWUsICdjbGFzcy48bmFtZT4nLCBvciAnYXR0ci48bmFtZT4nLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBob3N0W1wiW1wiICsgaG9zdEJpbmRpbmcuaG9zdFByb3BlcnR5TmFtZSArIFwiXVwiXSA9IHByb3BOYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdFtcIltcIiArIHByb3BOYW1lICsgXCJdXCJdID0gcHJvcE5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBob3N0TGlzdGVuZXJzID0gcHJvcGVydHlNZXRhZGF0YVtwcm9wTmFtZV0uZmlsdGVyKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhICYmIGEgaW5zdGFuY2VvZiBIb3N0TGlzdGVuZXI7IH0pO1xuICAgICAgICAgICAgaG9zdExpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChob3N0TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhcmdzID0gaG9zdExpc3RlbmVyLmFyZ3MgfHwgW107XG4gICAgICAgICAgICAgICAgaG9zdFtcIihcIiArIGhvc3RMaXN0ZW5lci5ldmVudE5hbWUgKyBcIilcIl0gPSBwcm9wTmFtZSArIFwiKFwiICsgYXJncy5qb2luKCcsJykgKyBcIilcIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVlcnkgPSBmaW5kTGFzdChwcm9wZXJ0eU1ldGFkYXRhW3Byb3BOYW1lXSwgZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEgaW5zdGFuY2VvZiBRdWVyeTsgfSk7XG4gICAgICAgICAgICBpZiAocXVlcnkpIHtcbiAgICAgICAgICAgICAgICBxdWVyaWVzW3Byb3BOYW1lXSA9IHF1ZXJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lcmdlKGRtLCBpbnB1dHMsIG91dHB1dHMsIGhvc3QsIHF1ZXJpZXMsIGRpcmVjdGl2ZVR5cGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkZWZcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERpcmVjdGl2ZVJlc29sdmVyLnByb3RvdHlwZS5fZXh0cmFjdFB1YmxpY05hbWUgPSBmdW5jdGlvbiAoZGVmKSB7IHJldHVybiBzcGxpdEF0Q29sb24oZGVmLCBbLyoqIEB0eXBlIHs/fSAqLyAoKG51bGwpKSwgZGVmXSlbMV0udHJpbSgpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYmluZGluZ3NcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERpcmVjdGl2ZVJlc29sdmVyLnByb3RvdHlwZS5fZGVkdXBlQmluZGluZ3MgPSBmdW5jdGlvbiAoYmluZGluZ3MpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJldmVyc2VkUmVzdWx0ID0gW107XG4gICAgICAgIC8vIGdvIGxhc3QgdG8gZmlyc3QgdG8gYWxsb3cgbGF0ZXIgZW50cmllcyB0byBvdmVyd3JpdGUgcHJldmlvdXMgZW50cmllc1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSBiaW5kaW5ncy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmluZGluZyA9IGJpbmRpbmdzW2ldO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZSA9IHRoaXMuX2V4dHJhY3RQdWJsaWNOYW1lKGJpbmRpbmcpO1xuICAgICAgICAgICAgaWYgKCFuYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBuYW1lcy5hZGQobmFtZSk7XG4gICAgICAgICAgICAgICAgcmV2ZXJzZWRSZXN1bHQucHVzaChiaW5kaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV2ZXJzZWRSZXN1bHQucmV2ZXJzZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3RpdmVcbiAgICAgKiBAcGFyYW0gez99IGlucHV0c1xuICAgICAqIEBwYXJhbSB7P30gb3V0cHV0c1xuICAgICAqIEBwYXJhbSB7P30gaG9zdFxuICAgICAqIEBwYXJhbSB7P30gcXVlcmllc1xuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGlyZWN0aXZlUmVzb2x2ZXIucHJvdG90eXBlLl9tZXJnZSA9IGZ1bmN0aW9uIChkaXJlY3RpdmUsIGlucHV0cywgb3V0cHV0cywgaG9zdCwgcXVlcmllcywgZGlyZWN0aXZlVHlwZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZXJnZWRJbnB1dHMgPSB0aGlzLl9kZWR1cGVCaW5kaW5ncyhkaXJlY3RpdmUuaW5wdXRzID8gZGlyZWN0aXZlLmlucHV0cy5jb25jYXQoaW5wdXRzKSA6IGlucHV0cyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lcmdlZE91dHB1dHMgPSB0aGlzLl9kZWR1cGVCaW5kaW5ncyhkaXJlY3RpdmUub3V0cHV0cyA/IGRpcmVjdGl2ZS5vdXRwdXRzLmNvbmNhdChvdXRwdXRzKSA6IG91dHB1dHMpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZXJnZWRIb3N0ID0gZGlyZWN0aXZlLmhvc3QgPyBPYmplY3QuYXNzaWduKHt9LCBkaXJlY3RpdmUuaG9zdCwgaG9zdCkgOiBob3N0O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZXJnZWRRdWVyaWVzID0gZGlyZWN0aXZlLnF1ZXJpZXMgPyBPYmplY3QuYXNzaWduKHt9LCBkaXJlY3RpdmUucXVlcmllcywgcXVlcmllcykgOiBxdWVyaWVzO1xuICAgICAgICBpZiAoZGlyZWN0aXZlIGluc3RhbmNlb2YgQ29tcG9uZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBvbmVudCh7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6IGRpcmVjdGl2ZS5zZWxlY3RvcixcbiAgICAgICAgICAgICAgICBpbnB1dHM6IG1lcmdlZElucHV0cyxcbiAgICAgICAgICAgICAgICBvdXRwdXRzOiBtZXJnZWRPdXRwdXRzLFxuICAgICAgICAgICAgICAgIGhvc3Q6IG1lcmdlZEhvc3QsXG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6IGRpcmVjdGl2ZS5leHBvcnRBcyxcbiAgICAgICAgICAgICAgICBtb2R1bGVJZDogZGlyZWN0aXZlLm1vZHVsZUlkLFxuICAgICAgICAgICAgICAgIHF1ZXJpZXM6IG1lcmdlZFF1ZXJpZXMsXG4gICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBkaXJlY3RpdmUuY2hhbmdlRGV0ZWN0aW9uLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogZGlyZWN0aXZlLnByb3ZpZGVycyxcbiAgICAgICAgICAgICAgICB2aWV3UHJvdmlkZXJzOiBkaXJlY3RpdmUudmlld1Byb3ZpZGVycyxcbiAgICAgICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IGRpcmVjdGl2ZS5lbnRyeUNvbXBvbmVudHMsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGRpcmVjdGl2ZS50ZW1wbGF0ZSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogZGlyZWN0aXZlLnRlbXBsYXRlVXJsLFxuICAgICAgICAgICAgICAgIHN0eWxlczogZGlyZWN0aXZlLnN0eWxlcyxcbiAgICAgICAgICAgICAgICBzdHlsZVVybHM6IGRpcmVjdGl2ZS5zdHlsZVVybHMsXG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogZGlyZWN0aXZlLmVuY2Fwc3VsYXRpb24sXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uczogZGlyZWN0aXZlLmFuaW1hdGlvbnMsXG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvbjogZGlyZWN0aXZlLmludGVycG9sYXRpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEaXJlY3RpdmUoe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBkaXJlY3RpdmUuc2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBtZXJnZWRJbnB1dHMsXG4gICAgICAgICAgICAgICAgb3V0cHV0czogbWVyZ2VkT3V0cHV0cyxcbiAgICAgICAgICAgICAgICBob3N0OiBtZXJnZWRIb3N0LFxuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiBkaXJlY3RpdmUuZXhwb3J0QXMsXG4gICAgICAgICAgICAgICAgcXVlcmllczogbWVyZ2VkUXVlcmllcyxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IGRpcmVjdGl2ZS5wcm92aWRlcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRGlyZWN0aXZlUmVzb2x2ZXI7XG59KCkpO1xuRGlyZWN0aXZlUmVzb2x2ZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBpbGVySW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuRGlyZWN0aXZlUmVzb2x2ZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBDb21waWxlUmVmbGVjdG9yLCB9LFxuXTsgfTtcbi8qKlxuICogQHBhcmFtIHs/fSB0eXBlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc0RpcmVjdGl2ZU1ldGFkYXRhKHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZSBpbnN0YW5jZW9mIERpcmVjdGl2ZTtcbn1cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7P30gYXJyXG4gKiBAcGFyYW0gez99IGNvbmRpdGlvblxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZmluZExhc3QoYXJyLCBjb25kaXRpb24pIHtcbiAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbihhcnJbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIFNUUklQX1NSQ19GSUxFX1NVRkZJWEVTID0gLyhcXC50c3xcXC5kXFwudHN8XFwuanN8XFwuanN4fFxcLnRzeCkkLztcbnZhciBHRU5FUkFURURfRklMRSA9IC9cXC5uZ2ZhY3RvcnlcXC58XFwubmdzdW1tYXJ5XFwuLztcbnZhciBKSVRfU1VNTUFSWV9GSUxFID0gL1xcLm5nc3VtbWFyeVxcLi87XG52YXIgSklUX1NVTU1BUllfTkFNRSA9IC9OZ1N1bW1hcnkkLztcbi8qKlxuICogQHBhcmFtIHs/fSBmaWxlUGF0aFxuICogQHBhcmFtIHs/PX0gZm9yY2VTb3VyY2VGaWxlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBuZ2ZhY3RvcnlGaWxlUGF0aChmaWxlUGF0aCwgZm9yY2VTb3VyY2VGaWxlKSB7XG4gICAgaWYgKGZvcmNlU291cmNlRmlsZSA9PT0gdm9pZCAwKSB7IGZvcmNlU291cmNlRmlsZSA9IGZhbHNlOyB9XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXJsV2l0aFN1ZmZpeCA9IHNwbGl0VHlwZXNjcmlwdFN1ZmZpeChmaWxlUGF0aCwgZm9yY2VTb3VyY2VGaWxlKTtcbiAgICByZXR1cm4gdXJsV2l0aFN1ZmZpeFswXSArIFwiLm5nZmFjdG9yeVwiICsgdXJsV2l0aFN1ZmZpeFsxXTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBmaWxlUGF0aFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc3RyaXBHZW5lcmF0ZWRGaWxlU3VmZml4KGZpbGVQYXRoKSB7XG4gICAgcmV0dXJuIGZpbGVQYXRoLnJlcGxhY2UoR0VORVJBVEVEX0ZJTEUsICcuJyk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZmlsZVBhdGhcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzR2VuZXJhdGVkRmlsZShmaWxlUGF0aCkge1xuICAgIHJldHVybiBHRU5FUkFURURfRklMRS50ZXN0KGZpbGVQYXRoKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBwYXRoXG4gKiBAcGFyYW0gez89fSBmb3JjZVNvdXJjZUZpbGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHNwbGl0VHlwZXNjcmlwdFN1ZmZpeChwYXRoLCBmb3JjZVNvdXJjZUZpbGUpIHtcbiAgICBpZiAoZm9yY2VTb3VyY2VGaWxlID09PSB2b2lkIDApIHsgZm9yY2VTb3VyY2VGaWxlID0gZmFsc2U7IH1cbiAgICBpZiAocGF0aC5lbmRzV2l0aCgnLmQudHMnKSkge1xuICAgICAgICByZXR1cm4gW3BhdGguc2xpY2UoMCwgLTUpLCBmb3JjZVNvdXJjZUZpbGUgPyAnLnRzJyA6ICcuZC50cyddO1xuICAgIH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsYXN0RG90ID0gcGF0aC5sYXN0SW5kZXhPZignLicpO1xuICAgIGlmIChsYXN0RG90ICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gW3BhdGguc3Vic3RyaW5nKDAsIGxhc3REb3QpLCBwYXRoLnN1YnN0cmluZyhsYXN0RG90KV07XG4gICAgfVxuICAgIHJldHVybiBbcGF0aCwgJyddO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGZpbGVOYW1lXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzdW1tYXJ5RmlsZU5hbWUoZmlsZU5hbWUpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmaWxlTmFtZVdpdGhvdXRTdWZmaXggPSBmaWxlTmFtZS5yZXBsYWNlKFNUUklQX1NSQ19GSUxFX1NVRkZJWEVTLCAnJyk7XG4gICAgcmV0dXJuIGZpbGVOYW1lV2l0aG91dFN1ZmZpeCArIFwiLm5nc3VtbWFyeS5qc29uXCI7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZmlsZU5hbWVcbiAqIEBwYXJhbSB7Pz19IGZvcmNlU291cmNlRmlsZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc3VtbWFyeUZvckppdEZpbGVOYW1lKGZpbGVOYW1lLCBmb3JjZVNvdXJjZUZpbGUpIHtcbiAgICBpZiAoZm9yY2VTb3VyY2VGaWxlID09PSB2b2lkIDApIHsgZm9yY2VTb3VyY2VGaWxlID0gZmFsc2U7IH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1cmxXaXRoU3VmZml4ID0gc3BsaXRUeXBlc2NyaXB0U3VmZml4KHN0cmlwR2VuZXJhdGVkRmlsZVN1ZmZpeChmaWxlTmFtZSksIGZvcmNlU291cmNlRmlsZSk7XG4gICAgcmV0dXJuIHVybFdpdGhTdWZmaXhbMF0gKyBcIi5uZ3N1bW1hcnlcIiArIHVybFdpdGhTdWZmaXhbMV07XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZmlsZVBhdGhcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHN0cmlwU3VtbWFyeUZvckppdEZpbGVTdWZmaXgoZmlsZVBhdGgpIHtcbiAgICByZXR1cm4gZmlsZVBhdGgucmVwbGFjZShKSVRfU1VNTUFSWV9GSUxFLCAnLicpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHN5bWJvbE5hbWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHN1bW1hcnlGb3JKaXROYW1lKHN5bWJvbE5hbWUpIHtcbiAgICByZXR1cm4gc3ltYm9sTmFtZSArIFwiTmdTdW1tYXJ5XCI7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gc3ltYm9sTmFtZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc3RyaXBTdW1tYXJ5Rm9ySml0TmFtZVN1ZmZpeChzeW1ib2xOYW1lKSB7XG4gICAgcmV0dXJuIHN5bWJvbE5hbWUucmVwbGFjZShKSVRfU1VNTUFSWV9OQU1FLCAnJyk7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgTGlmZWN5Y2xlSG9va3MgPSB7fTtcbkxpZmVjeWNsZUhvb2tzLk9uSW5pdCA9IDA7XG5MaWZlY3ljbGVIb29rcy5PbkRlc3Ryb3kgPSAxO1xuTGlmZWN5Y2xlSG9va3MuRG9DaGVjayA9IDI7XG5MaWZlY3ljbGVIb29rcy5PbkNoYW5nZXMgPSAzO1xuTGlmZWN5Y2xlSG9va3MuQWZ0ZXJDb250ZW50SW5pdCA9IDQ7XG5MaWZlY3ljbGVIb29rcy5BZnRlckNvbnRlbnRDaGVja2VkID0gNTtcbkxpZmVjeWNsZUhvb2tzLkFmdGVyVmlld0luaXQgPSA2O1xuTGlmZWN5Y2xlSG9va3MuQWZ0ZXJWaWV3Q2hlY2tlZCA9IDc7XG5MaWZlY3ljbGVIb29rc1tMaWZlY3ljbGVIb29rcy5PbkluaXRdID0gXCJPbkluaXRcIjtcbkxpZmVjeWNsZUhvb2tzW0xpZmVjeWNsZUhvb2tzLk9uRGVzdHJveV0gPSBcIk9uRGVzdHJveVwiO1xuTGlmZWN5Y2xlSG9va3NbTGlmZWN5Y2xlSG9va3MuRG9DaGVja10gPSBcIkRvQ2hlY2tcIjtcbkxpZmVjeWNsZUhvb2tzW0xpZmVjeWNsZUhvb2tzLk9uQ2hhbmdlc10gPSBcIk9uQ2hhbmdlc1wiO1xuTGlmZWN5Y2xlSG9va3NbTGlmZWN5Y2xlSG9va3MuQWZ0ZXJDb250ZW50SW5pdF0gPSBcIkFmdGVyQ29udGVudEluaXRcIjtcbkxpZmVjeWNsZUhvb2tzW0xpZmVjeWNsZUhvb2tzLkFmdGVyQ29udGVudENoZWNrZWRdID0gXCJBZnRlckNvbnRlbnRDaGVja2VkXCI7XG5MaWZlY3ljbGVIb29rc1tMaWZlY3ljbGVIb29rcy5BZnRlclZpZXdJbml0XSA9IFwiQWZ0ZXJWaWV3SW5pdFwiO1xuTGlmZWN5Y2xlSG9va3NbTGlmZWN5Y2xlSG9va3MuQWZ0ZXJWaWV3Q2hlY2tlZF0gPSBcIkFmdGVyVmlld0NoZWNrZWRcIjtcbnZhciBMSUZFQ1lDTEVfSE9PS1NfVkFMVUVTID0gW1xuICAgIExpZmVjeWNsZUhvb2tzLk9uSW5pdCwgTGlmZWN5Y2xlSG9va3MuT25EZXN0cm95LCBMaWZlY3ljbGVIb29rcy5Eb0NoZWNrLCBMaWZlY3ljbGVIb29rcy5PbkNoYW5nZXMsXG4gICAgTGlmZWN5Y2xlSG9va3MuQWZ0ZXJDb250ZW50SW5pdCwgTGlmZWN5Y2xlSG9va3MuQWZ0ZXJDb250ZW50Q2hlY2tlZCwgTGlmZWN5Y2xlSG9va3MuQWZ0ZXJWaWV3SW5pdCxcbiAgICBMaWZlY3ljbGVIb29rcy5BZnRlclZpZXdDaGVja2VkXG5dO1xuLyoqXG4gKiBAcGFyYW0gez99IHJlZmxlY3RvclxuICogQHBhcmFtIHs/fSBob29rXG4gKiBAcGFyYW0gez99IHRva2VuXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBoYXNMaWZlY3ljbGVIb29rKHJlZmxlY3RvciwgaG9vaywgdG9rZW4pIHtcbiAgICByZXR1cm4gcmVmbGVjdG9yLmhhc0xpZmVjeWNsZUhvb2sodG9rZW4sIGdldEhvb2tOYW1lKGhvb2spKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSByZWZsZWN0b3JcbiAqIEBwYXJhbSB7P30gdG9rZW5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGdldEFsbExpZmVjeWNsZUhvb2tzKHJlZmxlY3RvciwgdG9rZW4pIHtcbiAgICByZXR1cm4gTElGRUNZQ0xFX0hPT0tTX1ZBTFVFUy5maWx0ZXIoZnVuY3Rpb24gKGhvb2spIHsgcmV0dXJuIGhhc0xpZmVjeWNsZUhvb2socmVmbGVjdG9yLCBob29rLCB0b2tlbik7IH0pO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGhvb2tcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tOYW1lKGhvb2spIHtcbiAgICBzd2l0Y2ggKGhvb2spIHtcbiAgICAgICAgY2FzZSBMaWZlY3ljbGVIb29rcy5PbkluaXQ6XG4gICAgICAgICAgICByZXR1cm4gJ25nT25Jbml0JztcbiAgICAgICAgY2FzZSBMaWZlY3ljbGVIb29rcy5PbkRlc3Ryb3k6XG4gICAgICAgICAgICByZXR1cm4gJ25nT25EZXN0cm95JztcbiAgICAgICAgY2FzZSBMaWZlY3ljbGVIb29rcy5Eb0NoZWNrOlxuICAgICAgICAgICAgcmV0dXJuICduZ0RvQ2hlY2snO1xuICAgICAgICBjYXNlIExpZmVjeWNsZUhvb2tzLk9uQ2hhbmdlczpcbiAgICAgICAgICAgIHJldHVybiAnbmdPbkNoYW5nZXMnO1xuICAgICAgICBjYXNlIExpZmVjeWNsZUhvb2tzLkFmdGVyQ29udGVudEluaXQ6XG4gICAgICAgICAgICByZXR1cm4gJ25nQWZ0ZXJDb250ZW50SW5pdCc7XG4gICAgICAgIGNhc2UgTGlmZWN5Y2xlSG9va3MuQWZ0ZXJDb250ZW50Q2hlY2tlZDpcbiAgICAgICAgICAgIHJldHVybiAnbmdBZnRlckNvbnRlbnRDaGVja2VkJztcbiAgICAgICAgY2FzZSBMaWZlY3ljbGVIb29rcy5BZnRlclZpZXdJbml0OlxuICAgICAgICAgICAgcmV0dXJuICduZ0FmdGVyVmlld0luaXQnO1xuICAgICAgICBjYXNlIExpZmVjeWNsZUhvb2tzLkFmdGVyVmlld0NoZWNrZWQ6XG4gICAgICAgICAgICByZXR1cm4gJ25nQWZ0ZXJWaWV3Q2hlY2tlZCc7XG4gICAgfVxufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAcGFyYW0gez99IG9ialxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2lzTmdNb2R1bGVNZXRhZGF0YShvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgTmdNb2R1bGU7XG59XG4vKipcbiAqIFJlc29sdmVzIHR5cGVzIHRvIHtcXEBsaW5rIE5nTW9kdWxlfS5cbiAqL1xudmFyIE5nTW9kdWxlUmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX3JlZmxlY3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE5nTW9kdWxlUmVzb2x2ZXIoX3JlZmxlY3Rvcikge1xuICAgICAgICB0aGlzLl9yZWZsZWN0b3IgPSBfcmVmbGVjdG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5nTW9kdWxlUmVzb2x2ZXIucHJvdG90eXBlLmlzTmdNb2R1bGUgPSBmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdGhpcy5fcmVmbGVjdG9yLmFubm90YXRpb25zKHR5cGUpLnNvbWUoX2lzTmdNb2R1bGVNZXRhZGF0YSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gdGhyb3dJZk5vdEZvdW5kXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOZ01vZHVsZVJlc29sdmVyLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKHR5cGUsIHRocm93SWZOb3RGb3VuZCkge1xuICAgICAgICBpZiAodGhyb3dJZk5vdEZvdW5kID09PSB2b2lkIDApIHsgdGhyb3dJZk5vdEZvdW5kID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZ01vZHVsZU1ldGEgPSBmaW5kTGFzdCh0aGlzLl9yZWZsZWN0b3IuYW5ub3RhdGlvbnModHlwZSksIF9pc05nTW9kdWxlTWV0YWRhdGEpO1xuICAgICAgICBpZiAobmdNb2R1bGVNZXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gbmdNb2R1bGVNZXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRocm93SWZOb3RGb3VuZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIE5nTW9kdWxlIG1ldGFkYXRhIGZvdW5kIGZvciAnXCIgKyDJtXN0cmluZ2lmeSh0eXBlKSArIFwiJy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE5nTW9kdWxlUmVzb2x2ZXI7XG59KCkpO1xuTmdNb2R1bGVSZXNvbHZlci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcGlsZXJJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5OZ01vZHVsZVJlc29sdmVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogQ29tcGlsZVJlZmxlY3RvciwgfSxcbl07IH07XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEBwYXJhbSB7P30gdHlwZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2lzUGlwZU1ldGFkYXRhKHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZSBpbnN0YW5jZW9mIFBpcGU7XG59XG4vKipcbiAqIFJlc29sdmUgYSBgVHlwZWAgZm9yIHtcXEBsaW5rIFBpcGV9LlxuICpcbiAqIFRoaXMgaW50ZXJmYWNlIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBhcHBsaWNhdGlvbiBkZXZlbG9wZXIgdG8gY3JlYXRlIGN1c3RvbSBiZWhhdmlvci5cbiAqXG4gKiBTZWUge1xcQGxpbmsgQ29tcGlsZXJ9XG4gKi9cbnZhciBQaXBlUmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX3JlZmxlY3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBpcGVSZXNvbHZlcihfcmVmbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuX3JlZmxlY3RvciA9IF9yZWZsZWN0b3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGlwZVJlc29sdmVyLnByb3RvdHlwZS5pc1BpcGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0eXBlTWV0YWRhdGEgPSB0aGlzLl9yZWZsZWN0b3IuYW5ub3RhdGlvbnMocmVzb2x2ZUZvcndhcmRSZWYodHlwZSkpO1xuICAgICAgICByZXR1cm4gdHlwZU1ldGFkYXRhICYmIHR5cGVNZXRhZGF0YS5zb21lKF9pc1BpcGVNZXRhZGF0YSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4ge1xcQGxpbmsgUGlwZX0gZm9yIGEgZ2l2ZW4gYFR5cGVgLlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IHRocm93SWZOb3RGb3VuZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGlwZVJlc29sdmVyLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKHR5cGUsIHRocm93SWZOb3RGb3VuZCkge1xuICAgICAgICBpZiAodGhyb3dJZk5vdEZvdW5kID09PSB2b2lkIDApIHsgdGhyb3dJZk5vdEZvdW5kID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZXRhcyA9IHRoaXMuX3JlZmxlY3Rvci5hbm5vdGF0aW9ucyhyZXNvbHZlRm9yd2FyZFJlZih0eXBlKSk7XG4gICAgICAgIGlmIChtZXRhcykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYW5ub3RhdGlvbiA9IGZpbmRMYXN0KG1ldGFzLCBfaXNQaXBlTWV0YWRhdGEpO1xuICAgICAgICAgICAgaWYgKGFubm90YXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5ub3RhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhyb3dJZk5vdEZvdW5kKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBQaXBlIGRlY29yYXRvciBmb3VuZCBvbiBcIiArIMm1c3RyaW5naWZ5KHR5cGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBQaXBlUmVzb2x2ZXI7XG59KCkpO1xuUGlwZVJlc29sdmVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21waWxlckluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cblBpcGVSZXNvbHZlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IENvbXBpbGVSZWZsZWN0b3IsIH0sXG5dOyB9O1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAYWJzdHJhY3RcbiAqL1xudmFyIFN1bW1hcnlSZXNvbHZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3VtbWFyeVJlc29sdmVyKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IGZpbGVOYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdW1tYXJ5UmVzb2x2ZXIucHJvdG90eXBlLmlzTGlicmFyeUZpbGUgPSBmdW5jdGlvbiAoZmlsZU5hbWUpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IGZpbGVOYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdW1tYXJ5UmVzb2x2ZXIucHJvdG90eXBlLmdldExpYnJhcnlGaWxlTmFtZSA9IGZ1bmN0aW9uIChmaWxlTmFtZSkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gcmVmZXJlbmNlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdW1tYXJ5UmVzb2x2ZXIucHJvdG90eXBlLnJlc29sdmVTdW1tYXJ5ID0gZnVuY3Rpb24gKHJlZmVyZW5jZSkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gZmlsZVBhdGhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN1bW1hcnlSZXNvbHZlci5wcm90b3R5cGUuZ2V0U3ltYm9sc09mID0gZnVuY3Rpb24gKGZpbGVQYXRoKSB7IH07XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSByZWZlcmVuY2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN1bW1hcnlSZXNvbHZlci5wcm90b3R5cGUuZ2V0SW1wb3J0QXMgPSBmdW5jdGlvbiAocmVmZXJlbmNlKSB7IH07XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSBzdW1tYXJ5XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdW1tYXJ5UmVzb2x2ZXIucHJvdG90eXBlLmFkZFN1bW1hcnkgPSBmdW5jdGlvbiAoc3VtbWFyeSkgeyB9O1xuICAgIHJldHVybiBTdW1tYXJ5UmVzb2x2ZXI7XG59KCkpO1xudmFyIEppdFN1bW1hcnlSZXNvbHZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSml0U3VtbWFyeVJlc29sdmVyKCkge1xuICAgICAgICB0aGlzLl9zdW1tYXJpZXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZmlsZU5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEppdFN1bW1hcnlSZXNvbHZlci5wcm90b3R5cGUuaXNMaWJyYXJ5RmlsZSA9IGZ1bmN0aW9uIChmaWxlTmFtZSkgeyByZXR1cm4gZmFsc2U7IH07XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZmlsZU5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEppdFN1bW1hcnlSZXNvbHZlci5wcm90b3R5cGUuZ2V0TGlicmFyeUZpbGVOYW1lID0gZnVuY3Rpb24gKGZpbGVOYW1lKSB7IHJldHVybiBudWxsOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVmZXJlbmNlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRTdW1tYXJ5UmVzb2x2ZXIucHJvdG90eXBlLnJlc29sdmVTdW1tYXJ5ID0gZnVuY3Rpb24gKHJlZmVyZW5jZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3VtbWFyaWVzLmdldChyZWZlcmVuY2UpIHx8IG51bGw7XG4gICAgfTtcbiAgICA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmaWxlUGF0aFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSml0U3VtbWFyeVJlc29sdmVyLnByb3RvdHlwZS5nZXRTeW1ib2xzT2YgPSBmdW5jdGlvbiAoZmlsZVBhdGgpIHsgcmV0dXJuIFtdOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVmZXJlbmNlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRTdW1tYXJ5UmVzb2x2ZXIucHJvdG90eXBlLmdldEltcG9ydEFzID0gZnVuY3Rpb24gKHJlZmVyZW5jZSkgeyByZXR1cm4gcmVmZXJlbmNlOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3VtbWFyeVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSml0U3VtbWFyeVJlc29sdmVyLnByb3RvdHlwZS5hZGRTdW1tYXJ5ID0gZnVuY3Rpb24gKHN1bW1hcnkpIHsgdGhpcy5fc3VtbWFyaWVzLnNldChzdW1tYXJ5LnN5bWJvbCwgc3VtbWFyeSk7IH07XG4gICAgO1xuICAgIHJldHVybiBKaXRTdW1tYXJ5UmVzb2x2ZXI7XG59KCkpO1xuSml0U3VtbWFyeVJlc29sdmVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21waWxlckluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkppdFN1bW1hcnlSZXNvbHZlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEVSUk9SX0NPTExFQ1RPUl9UT0tFTiA9IG5ldyBJbmplY3Rpb25Ub2tlbignRXJyb3JDb2xsZWN0b3InKTtcbnZhciBDb21waWxlTWV0YWRhdGFSZXNvbHZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfY29uZmlnXG4gICAgICogQHBhcmFtIHs/fSBfbmdNb2R1bGVSZXNvbHZlclxuICAgICAqIEBwYXJhbSB7P30gX2RpcmVjdGl2ZVJlc29sdmVyXG4gICAgICogQHBhcmFtIHs/fSBfcGlwZVJlc29sdmVyXG4gICAgICogQHBhcmFtIHs/fSBfc3VtbWFyeVJlc29sdmVyXG4gICAgICogQHBhcmFtIHs/fSBfc2NoZW1hUmVnaXN0cnlcbiAgICAgKiBAcGFyYW0gez99IF9kaXJlY3RpdmVOb3JtYWxpemVyXG4gICAgICogQHBhcmFtIHs/fSBfY29uc29sZVxuICAgICAqIEBwYXJhbSB7P30gX3N0YXRpY1N5bWJvbENhY2hlXG4gICAgICogQHBhcmFtIHs/fSBfcmVmbGVjdG9yXG4gICAgICogQHBhcmFtIHs/PX0gX2Vycm9yQ29sbGVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIoX2NvbmZpZywgX25nTW9kdWxlUmVzb2x2ZXIsIF9kaXJlY3RpdmVSZXNvbHZlciwgX3BpcGVSZXNvbHZlciwgX3N1bW1hcnlSZXNvbHZlciwgX3NjaGVtYVJlZ2lzdHJ5LCBfZGlyZWN0aXZlTm9ybWFsaXplciwgX2NvbnNvbGUsIF9zdGF0aWNTeW1ib2xDYWNoZSwgX3JlZmxlY3RvciwgX2Vycm9yQ29sbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IF9jb25maWc7XG4gICAgICAgIHRoaXMuX25nTW9kdWxlUmVzb2x2ZXIgPSBfbmdNb2R1bGVSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5fZGlyZWN0aXZlUmVzb2x2ZXIgPSBfZGlyZWN0aXZlUmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuX3BpcGVSZXNvbHZlciA9IF9waXBlUmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuX3N1bW1hcnlSZXNvbHZlciA9IF9zdW1tYXJ5UmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuX3NjaGVtYVJlZ2lzdHJ5ID0gX3NjaGVtYVJlZ2lzdHJ5O1xuICAgICAgICB0aGlzLl9kaXJlY3RpdmVOb3JtYWxpemVyID0gX2RpcmVjdGl2ZU5vcm1hbGl6ZXI7XG4gICAgICAgIHRoaXMuX2NvbnNvbGUgPSBfY29uc29sZTtcbiAgICAgICAgdGhpcy5fc3RhdGljU3ltYm9sQ2FjaGUgPSBfc3RhdGljU3ltYm9sQ2FjaGU7XG4gICAgICAgIHRoaXMuX3JlZmxlY3RvciA9IF9yZWZsZWN0b3I7XG4gICAgICAgIHRoaXMuX2Vycm9yQ29sbGVjdG9yID0gX2Vycm9yQ29sbGVjdG9yO1xuICAgICAgICB0aGlzLl9ub25Ob3JtYWxpemVkRGlyZWN0aXZlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2RpcmVjdGl2ZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9zdW1tYXJ5Q2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3BpcGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fbmdNb2R1bGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fbmdNb2R1bGVPZlR5cGVzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRSZWZsZWN0b3IgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yZWZsZWN0b3I7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuY2xlYXJDYWNoZUZvciA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpck1ldGEgPSB0aGlzLl9kaXJlY3RpdmVDYWNoZS5nZXQodHlwZSk7XG4gICAgICAgIHRoaXMuX2RpcmVjdGl2ZUNhY2hlLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgdGhpcy5fbm9uTm9ybWFsaXplZERpcmVjdGl2ZUNhY2hlLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgdGhpcy5fc3VtbWFyeUNhY2hlLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgdGhpcy5fcGlwZUNhY2hlLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgdGhpcy5fbmdNb2R1bGVPZlR5cGVzLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgLy8gQ2xlYXIgYWxsIG9mIHRoZSBOZ01vZHVsZSBhcyB0aGV5IGNvbnRhaW4gdHJhbnNpdGl2ZSBpbmZvcm1hdGlvbiFcbiAgICAgICAgdGhpcy5fbmdNb2R1bGVDYWNoZS5jbGVhcigpO1xuICAgICAgICBpZiAoZGlyTWV0YSkge1xuICAgICAgICAgICAgdGhpcy5fZGlyZWN0aXZlTm9ybWFsaXplci5jbGVhckNhY2hlRm9yKGRpck1ldGEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9kaXJlY3RpdmVDYWNoZS5jbGVhcigpO1xuICAgICAgICB0aGlzLl9ub25Ob3JtYWxpemVkRGlyZWN0aXZlQ2FjaGUuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fc3VtbWFyeUNhY2hlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX3BpcGVDYWNoZS5jbGVhcigpO1xuICAgICAgICB0aGlzLl9uZ01vZHVsZUNhY2hlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX25nTW9kdWxlT2ZUeXBlcy5jbGVhcigpO1xuICAgICAgICB0aGlzLl9kaXJlY3RpdmVOb3JtYWxpemVyLmNsZWFyQ2FjaGUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYmFzZVR5cGVcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fY3JlYXRlUHJveHlDbGFzcyA9IGZ1bmN0aW9uIChiYXNlVHlwZSwgbmFtZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZWxlZ2F0ZSA9IG51bGw7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb3h5Q2xhc3MgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFkZWxlZ2F0ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgc3RhdGU6IENsYXNzIFwiICsgbmFtZSArIFwiIGZvciB0eXBlIFwiICsgybVzdHJpbmdpZnkoYmFzZVR5cGUpICsgXCIgaXMgbm90IGNvbXBpbGVkIHlldCFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByb3h5Q2xhc3Muc2V0RGVsZWdhdGUgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgZGVsZWdhdGUgPSBkO1xuICAgICAgICAgICAgKChwcm94eUNsYXNzKSkucHJvdG90eXBlID0gZC5wcm90b3R5cGU7XG4gICAgICAgIH07XG4gICAgICAgIC8vIE1ha2Ugc3RyaW5naWZ5IHdvcmsgY29ycmVjdGx5XG4gICAgICAgICgocHJveHlDbGFzcykpLm92ZXJyaWRkZW5OYW1lID0gbmFtZTtcbiAgICAgICAgcmV0dXJuIHByb3h5Q2xhc3M7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRpclR5cGVcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRHZW5lcmF0ZWRDbGFzcyA9IGZ1bmN0aW9uIChkaXJUeXBlLCBuYW1lKSB7XG4gICAgICAgIGlmIChkaXJUeXBlIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGljU3ltYm9sQ2FjaGUuZ2V0KG5nZmFjdG9yeUZpbGVQYXRoKGRpclR5cGUuZmlsZVBhdGgpLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVQcm94eUNsYXNzKGRpclR5cGUsIG5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRpclR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRDb21wb25lbnRWaWV3Q2xhc3MgPSBmdW5jdGlvbiAoZGlyVHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRHZW5lcmF0ZWRDbGFzcyhkaXJUeXBlLCB2aWV3Q2xhc3NOYW1lKGRpclR5cGUsIDApKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGlyVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldEhvc3RDb21wb25lbnRWaWV3Q2xhc3MgPSBmdW5jdGlvbiAoZGlyVHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRHZW5lcmF0ZWRDbGFzcyhkaXJUeXBlLCBob3N0Vmlld0NsYXNzTmFtZShkaXJUeXBlKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRpclR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRIb3N0Q29tcG9uZW50VHlwZSA9IGZ1bmN0aW9uIChkaXJUeXBlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWUgPSBpZGVudGlmaWVyTmFtZSh7IHJlZmVyZW5jZTogZGlyVHlwZSB9KSArIFwiX0hvc3RcIjtcbiAgICAgICAgaWYgKGRpclR5cGUgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0aWNTeW1ib2xDYWNoZS5nZXQoZGlyVHlwZS5maWxlUGF0aCwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBIb3N0Q2xhc3MgPSAoZnVuY3Rpb24gSG9zdENsYXNzKCkgeyB9KTtcbiAgICAgICAgICAgIEhvc3RDbGFzcy5vdmVycmlkZGVuTmFtZSA9IG5hbWU7XG4gICAgICAgICAgICByZXR1cm4gSG9zdENsYXNzO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRpclR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRSZW5kZXJlclR5cGUgPSBmdW5jdGlvbiAoZGlyVHlwZSkge1xuICAgICAgICBpZiAoZGlyVHlwZSBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRpY1N5bWJvbENhY2hlLmdldChuZ2ZhY3RvcnlGaWxlUGF0aChkaXJUeXBlLmZpbGVQYXRoKSwgcmVuZGVyZXJUeXBlTmFtZShkaXJUeXBlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyByZXR1cm5pbmcgYW4gb2JqZWN0IGFzIHByb3h5LFxuICAgICAgICAgICAgLy8gdGhhdCB3ZSBmaWxsIGxhdGVyIGR1cmluZyBydW50aW1lIGNvbXBpbGF0aW9uLlxuICAgICAgICAgICAgcmV0dXJuICh7fSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IGRpclR5cGVcbiAgICAgKiBAcGFyYW0gez99IGlucHV0c1xuICAgICAqIEBwYXJhbSB7P30gb3V0cHV0c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldENvbXBvbmVudEZhY3RvcnkgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIGRpclR5cGUsIGlucHV0cywgb3V0cHV0cykge1xuICAgICAgICBpZiAoZGlyVHlwZSBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRpY1N5bWJvbENhY2hlLmdldChuZ2ZhY3RvcnlGaWxlUGF0aChkaXJUeXBlLmZpbGVQYXRoKSwgY29tcG9uZW50RmFjdG9yeU5hbWUoZGlyVHlwZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaG9zdFZpZXcgPSB0aGlzLmdldEhvc3RDb21wb25lbnRWaWV3Q2xhc3MoZGlyVHlwZSk7XG4gICAgICAgICAgICAvLyBOb3RlOiBuZ0NvbnRlbnRTZWxlY3RvcnMgd2lsbCBiZSBmaWxsZWQgbGF0ZXIgb25jZSB0aGUgdGVtcGxhdGUgaXNcbiAgICAgICAgICAgIC8vIGxvYWRlZC5cbiAgICAgICAgICAgIHJldHVybiDJtWNjZihzZWxlY3RvciwgZGlyVHlwZSwgLyoqIEB0eXBlIHs/fSAqLyAoaG9zdFZpZXcpLCBpbnB1dHMsIG91dHB1dHMsIFtdKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmYWN0b3J5XG4gICAgICogQHBhcmFtIHs/fSBuZ0NvbnRlbnRTZWxlY3RvcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5pbml0Q29tcG9uZW50RmFjdG9yeSA9IGZ1bmN0aW9uIChmYWN0b3J5LCBuZ0NvbnRlbnRTZWxlY3RvcnMpIHtcbiAgICAgICAgaWYgKCEoZmFjdG9yeSBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkpIHtcbiAgICAgICAgICAgIChfYSA9IGZhY3RvcnkubmdDb250ZW50U2VsZWN0b3JzKS5wdXNoLmFwcGx5KF9hLCBuZ0NvbnRlbnRTZWxlY3RvcnMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7P30ga2luZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9sb2FkU3VtbWFyeSA9IGZ1bmN0aW9uICh0eXBlLCBraW5kKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHR5cGVTdW1tYXJ5ID0gdGhpcy5fc3VtbWFyeUNhY2hlLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKCF0eXBlU3VtbWFyeSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3VtbWFyeSA9IHRoaXMuX3N1bW1hcnlSZXNvbHZlci5yZXNvbHZlU3VtbWFyeSh0eXBlKTtcbiAgICAgICAgICAgIHR5cGVTdW1tYXJ5ID0gc3VtbWFyeSA/IHN1bW1hcnkudHlwZSA6IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9zdW1tYXJ5Q2FjaGUuc2V0KHR5cGUsIHR5cGVTdW1tYXJ5IHx8IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlU3VtbWFyeSAmJiB0eXBlU3VtbWFyeS5zdW1tYXJ5S2luZCA9PT0ga2luZCA/IHR5cGVTdW1tYXJ5IDogbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmdNb2R1bGVUeXBlXG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3RpdmVUeXBlXG4gICAgICogQHBhcmFtIHs/fSBpc1N5bmNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5sb2FkRGlyZWN0aXZlTWV0YWRhdGEgPSBmdW5jdGlvbiAobmdNb2R1bGVUeXBlLCBkaXJlY3RpdmVUeXBlLCBpc1N5bmMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGl2ZUNhY2hlLmhhcyhkaXJlY3RpdmVUeXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZGlyZWN0aXZlVHlwZSA9IHJlc29sdmVGb3J3YXJkUmVmKGRpcmVjdGl2ZVR5cGUpO1xuICAgICAgICB2YXIgX2EgPSAoKHRoaXMuZ2V0Tm9uTm9ybWFsaXplZERpcmVjdGl2ZU1ldGFkYXRhKGRpcmVjdGl2ZVR5cGUpKSksIGFubm90YXRpb24gPSBfYS5hbm5vdGF0aW9uLCBtZXRhZGF0YSA9IF9hLm1ldGFkYXRhO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjcmVhdGVEaXJlY3RpdmVNZXRhZGF0YSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub3JtYWxpemVkRGlyTWV0YSA9IG5ldyBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEoe1xuICAgICAgICAgICAgICAgIGlzSG9zdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgdHlwZTogbWV0YWRhdGEudHlwZSxcbiAgICAgICAgICAgICAgICBpc0NvbXBvbmVudDogbWV0YWRhdGEuaXNDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6IG1ldGFkYXRhLnNlbGVjdG9yLFxuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiBtZXRhZGF0YS5leHBvcnRBcyxcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IG1ldGFkYXRhLmNoYW5nZURldGVjdGlvbixcbiAgICAgICAgICAgICAgICBpbnB1dHM6IG1ldGFkYXRhLmlucHV0cyxcbiAgICAgICAgICAgICAgICBvdXRwdXRzOiBtZXRhZGF0YS5vdXRwdXRzLFxuICAgICAgICAgICAgICAgIGhvc3RMaXN0ZW5lcnM6IG1ldGFkYXRhLmhvc3RMaXN0ZW5lcnMsXG4gICAgICAgICAgICAgICAgaG9zdFByb3BlcnRpZXM6IG1ldGFkYXRhLmhvc3RQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgIGhvc3RBdHRyaWJ1dGVzOiBtZXRhZGF0YS5ob3N0QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IG1ldGFkYXRhLnByb3ZpZGVycyxcbiAgICAgICAgICAgICAgICB2aWV3UHJvdmlkZXJzOiBtZXRhZGF0YS52aWV3UHJvdmlkZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJpZXM6IG1ldGFkYXRhLnF1ZXJpZXMsXG4gICAgICAgICAgICAgICAgdmlld1F1ZXJpZXM6IG1ldGFkYXRhLnZpZXdRdWVyaWVzLFxuICAgICAgICAgICAgICAgIGVudHJ5Q29tcG9uZW50czogbWV0YWRhdGEuZW50cnlDb21wb25lbnRzLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudFZpZXdUeXBlOiBtZXRhZGF0YS5jb21wb25lbnRWaWV3VHlwZSxcbiAgICAgICAgICAgICAgICByZW5kZXJlclR5cGU6IG1ldGFkYXRhLnJlbmRlcmVyVHlwZSxcbiAgICAgICAgICAgICAgICBjb21wb25lbnRGYWN0b3J5OiBtZXRhZGF0YS5jb21wb25lbnRGYWN0b3J5LFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZU1ldGFkYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0ZW1wbGF0ZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaW5pdENvbXBvbmVudEZhY3RvcnkoLyoqIEB0eXBlIHs/fSAqLyAoKG1ldGFkYXRhLmNvbXBvbmVudEZhY3RvcnkpKSwgdGVtcGxhdGVNZXRhZGF0YS5uZ0NvbnRlbnRTZWxlY3RvcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuX2RpcmVjdGl2ZUNhY2hlLnNldChkaXJlY3RpdmVUeXBlLCBub3JtYWxpemVkRGlyTWV0YSk7XG4gICAgICAgICAgICBfdGhpcy5fc3VtbWFyeUNhY2hlLnNldChkaXJlY3RpdmVUeXBlLCBub3JtYWxpemVkRGlyTWV0YS50b1N1bW1hcnkoKSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG1ldGFkYXRhLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wbGF0ZSA9ICgobWV0YWRhdGEudGVtcGxhdGUpKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlbXBsYXRlTWV0YSA9IHRoaXMuX2RpcmVjdGl2ZU5vcm1hbGl6ZXIubm9ybWFsaXplVGVtcGxhdGUoe1xuICAgICAgICAgICAgICAgIG5nTW9kdWxlVHlwZTogbmdNb2R1bGVUeXBlLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudFR5cGU6IGRpcmVjdGl2ZVR5cGUsXG4gICAgICAgICAgICAgICAgbW9kdWxlVXJsOiB0aGlzLl9yZWZsZWN0b3IuY29tcG9uZW50TW9kdWxlVXJsKGRpcmVjdGl2ZVR5cGUsIGFubm90YXRpb24pLFxuICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IHRlbXBsYXRlLmVuY2Fwc3VsYXRpb24sXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IHRlbXBsYXRlLnRlbXBsYXRlLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiB0ZW1wbGF0ZS50ZW1wbGF0ZVVybCxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IHRlbXBsYXRlLnN0eWxlcyxcbiAgICAgICAgICAgICAgICBzdHlsZVVybHM6IHRlbXBsYXRlLnN0eWxlVXJscyxcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zOiB0ZW1wbGF0ZS5hbmltYXRpb25zLFxuICAgICAgICAgICAgICAgIGludGVycG9sYXRpb246IHRlbXBsYXRlLmludGVycG9sYXRpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKMm1aXNQcm9taXNlKHRlbXBsYXRlTWV0YSkgJiYgaXNTeW5jKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoY29tcG9uZW50U3RpbGxMb2FkaW5nRXJyb3IoZGlyZWN0aXZlVHlwZSksIGRpcmVjdGl2ZVR5cGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFN5bmNBc3luYy50aGVuKHRlbXBsYXRlTWV0YSwgY3JlYXRlRGlyZWN0aXZlTWV0YWRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZGlyZWN0aXZlXG4gICAgICAgICAgICBjcmVhdGVEaXJlY3RpdmVNZXRhZGF0YShudWxsKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZVR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXROb25Ob3JtYWxpemVkRGlyZWN0aXZlTWV0YWRhdGEgPSBmdW5jdGlvbiAoZGlyZWN0aXZlVHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBkaXJlY3RpdmVUeXBlID0gcmVzb2x2ZUZvcndhcmRSZWYoZGlyZWN0aXZlVHlwZSk7XG4gICAgICAgIGlmICghZGlyZWN0aXZlVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2FjaGVFbnRyeSA9IHRoaXMuX25vbk5vcm1hbGl6ZWREaXJlY3RpdmVDYWNoZS5nZXQoZGlyZWN0aXZlVHlwZSk7XG4gICAgICAgIGlmIChjYWNoZUVudHJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVFbnRyeTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXJNZXRhID0gdGhpcy5fZGlyZWN0aXZlUmVzb2x2ZXIucmVzb2x2ZShkaXJlY3RpdmVUeXBlLCBmYWxzZSk7XG4gICAgICAgIGlmICghZGlyTWV0YSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9uTm9ybWFsaXplZFRlbXBsYXRlTWV0YWRhdGEgPSAoKHVuZGVmaW5lZCkpO1xuICAgICAgICBpZiAoZGlyTWV0YSBpbnN0YW5jZW9mIENvbXBvbmVudCkge1xuICAgICAgICAgICAgLy8gY29tcG9uZW50XG4gICAgICAgICAgICBhc3NlcnRBcnJheU9mU3RyaW5ncygnc3R5bGVzJywgZGlyTWV0YS5zdHlsZXMpO1xuICAgICAgICAgICAgYXNzZXJ0QXJyYXlPZlN0cmluZ3MoJ3N0eWxlVXJscycsIGRpck1ldGEuc3R5bGVVcmxzKTtcbiAgICAgICAgICAgIGFzc2VydEludGVycG9sYXRpb25TeW1ib2xzKCdpbnRlcnBvbGF0aW9uJywgZGlyTWV0YS5pbnRlcnBvbGF0aW9uKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFuaW1hdGlvbnMgPSBkaXJNZXRhLmFuaW1hdGlvbnM7XG4gICAgICAgICAgICBub25Ob3JtYWxpemVkVGVtcGxhdGVNZXRhZGF0YSA9IG5ldyBDb21waWxlVGVtcGxhdGVNZXRhZGF0YSh7XG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogbm9VbmRlZmluZWQoZGlyTWV0YS5lbmNhcHN1bGF0aW9uKSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogbm9VbmRlZmluZWQoZGlyTWV0YS50ZW1wbGF0ZSksXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6IG5vVW5kZWZpbmVkKGRpck1ldGEudGVtcGxhdGVVcmwpLFxuICAgICAgICAgICAgICAgIHN0eWxlczogZGlyTWV0YS5zdHlsZXMgfHwgW10sXG4gICAgICAgICAgICAgICAgc3R5bGVVcmxzOiBkaXJNZXRhLnN0eWxlVXJscyB8fCBbXSxcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zOiBhbmltYXRpb25zIHx8IFtdLFxuICAgICAgICAgICAgICAgIGludGVycG9sYXRpb246IG5vVW5kZWZpbmVkKGRpck1ldGEuaW50ZXJwb2xhdGlvbiksXG4gICAgICAgICAgICAgICAgaXNJbmxpbmU6ICEhZGlyTWV0YS50ZW1wbGF0ZSxcbiAgICAgICAgICAgICAgICBleHRlcm5hbFN0eWxlc2hlZXRzOiBbXSxcbiAgICAgICAgICAgICAgICBuZ0NvbnRlbnRTZWxlY3RvcnM6IFtdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSA9ICgobnVsbCkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aWV3UHJvdmlkZXJzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVudHJ5Q29tcG9uZW50TWV0YWRhdGEgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VsZWN0b3IgPSBkaXJNZXRhLnNlbGVjdG9yO1xuICAgICAgICBpZiAoZGlyTWV0YSBpbnN0YW5jZW9mIENvbXBvbmVudCkge1xuICAgICAgICAgICAgLy8gQ29tcG9uZW50XG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSA9ICgoZGlyTWV0YS5jaGFuZ2VEZXRlY3Rpb24pKTtcbiAgICAgICAgICAgIGlmIChkaXJNZXRhLnZpZXdQcm92aWRlcnMpIHtcbiAgICAgICAgICAgICAgICB2aWV3UHJvdmlkZXJzID0gdGhpcy5fZ2V0UHJvdmlkZXJzTWV0YWRhdGEoZGlyTWV0YS52aWV3UHJvdmlkZXJzLCBlbnRyeUNvbXBvbmVudE1ldGFkYXRhLCBcInZpZXdQcm92aWRlcnMgZm9yIFxcXCJcIiArIHN0cmluZ2lmeVR5cGUoZGlyZWN0aXZlVHlwZSkgKyBcIlxcXCJcIiwgW10sIGRpcmVjdGl2ZVR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpck1ldGEuZW50cnlDb21wb25lbnRzKSB7XG4gICAgICAgICAgICAgICAgZW50cnlDb21wb25lbnRNZXRhZGF0YSA9IGZsYXR0ZW5BbmREZWR1cGVBcnJheShkaXJNZXRhLmVudHJ5Q29tcG9uZW50cylcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gKChfdGhpcy5fZ2V0RW50cnlDb21wb25lbnRNZXRhZGF0YSh0eXBlKSkpOyB9KVxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KGVudHJ5Q29tcG9uZW50TWV0YWRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gdGhpcy5fc2NoZW1hUmVnaXN0cnkuZ2V0RGVmYXVsdENvbXBvbmVudEVsZW1lbnROYW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBEaXJlY3RpdmVcbiAgICAgICAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIkRpcmVjdGl2ZSBcIiArIHN0cmluZ2lmeVR5cGUoZGlyZWN0aXZlVHlwZSkgKyBcIiBoYXMgbm8gc2VsZWN0b3IsIHBsZWFzZSBhZGQgaXQhXCIpLCBkaXJlY3RpdmVUeXBlKTtcbiAgICAgICAgICAgICAgICBzZWxlY3RvciA9ICdlcnJvcic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvdmlkZXJzID0gW107XG4gICAgICAgIGlmIChkaXJNZXRhLnByb3ZpZGVycyAhPSBudWxsKSB7XG4gICAgICAgICAgICBwcm92aWRlcnMgPSB0aGlzLl9nZXRQcm92aWRlcnNNZXRhZGF0YShkaXJNZXRhLnByb3ZpZGVycywgZW50cnlDb21wb25lbnRNZXRhZGF0YSwgXCJwcm92aWRlcnMgZm9yIFxcXCJcIiArIHN0cmluZ2lmeVR5cGUoZGlyZWN0aXZlVHlwZSkgKyBcIlxcXCJcIiwgW10sIGRpcmVjdGl2ZVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1ZXJpZXMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlld1F1ZXJpZXMgPSBbXTtcbiAgICAgICAgaWYgKGRpck1ldGEucXVlcmllcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBxdWVyaWVzID0gdGhpcy5fZ2V0UXVlcmllc01ldGFkYXRhKGRpck1ldGEucXVlcmllcywgZmFsc2UsIGRpcmVjdGl2ZVR5cGUpO1xuICAgICAgICAgICAgdmlld1F1ZXJpZXMgPSB0aGlzLl9nZXRRdWVyaWVzTWV0YWRhdGEoZGlyTWV0YS5xdWVyaWVzLCB0cnVlLCBkaXJlY3RpdmVUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZXRhZGF0YSA9IENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YS5jcmVhdGUoe1xuICAgICAgICAgICAgaXNIb3N0OiBmYWxzZSxcbiAgICAgICAgICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICAgICAgICAgIGV4cG9ydEFzOiBub1VuZGVmaW5lZChkaXJNZXRhLmV4cG9ydEFzKSxcbiAgICAgICAgICAgIGlzQ29tcG9uZW50OiAhIW5vbk5vcm1hbGl6ZWRUZW1wbGF0ZU1ldGFkYXRhLFxuICAgICAgICAgICAgdHlwZTogdGhpcy5fZ2V0VHlwZU1ldGFkYXRhKGRpcmVjdGl2ZVR5cGUpLFxuICAgICAgICAgICAgdGVtcGxhdGU6IG5vbk5vcm1hbGl6ZWRUZW1wbGF0ZU1ldGFkYXRhLFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBjaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgICAgICAgICAgIGlucHV0czogZGlyTWV0YS5pbnB1dHMgfHwgW10sXG4gICAgICAgICAgICBvdXRwdXRzOiBkaXJNZXRhLm91dHB1dHMgfHwgW10sXG4gICAgICAgICAgICBob3N0OiBkaXJNZXRhLmhvc3QgfHwge30sXG4gICAgICAgICAgICBwcm92aWRlcnM6IHByb3ZpZGVycyB8fCBbXSxcbiAgICAgICAgICAgIHZpZXdQcm92aWRlcnM6IHZpZXdQcm92aWRlcnMgfHwgW10sXG4gICAgICAgICAgICBxdWVyaWVzOiBxdWVyaWVzIHx8IFtdLFxuICAgICAgICAgICAgdmlld1F1ZXJpZXM6IHZpZXdRdWVyaWVzIHx8IFtdLFxuICAgICAgICAgICAgZW50cnlDb21wb25lbnRzOiBlbnRyeUNvbXBvbmVudE1ldGFkYXRhLFxuICAgICAgICAgICAgY29tcG9uZW50Vmlld1R5cGU6IG5vbk5vcm1hbGl6ZWRUZW1wbGF0ZU1ldGFkYXRhID8gdGhpcy5nZXRDb21wb25lbnRWaWV3Q2xhc3MoZGlyZWN0aXZlVHlwZSkgOlxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICByZW5kZXJlclR5cGU6IG5vbk5vcm1hbGl6ZWRUZW1wbGF0ZU1ldGFkYXRhID8gdGhpcy5nZXRSZW5kZXJlclR5cGUoZGlyZWN0aXZlVHlwZSkgOiBudWxsLFxuICAgICAgICAgICAgY29tcG9uZW50RmFjdG9yeTogbnVsbFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG5vbk5vcm1hbGl6ZWRUZW1wbGF0ZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICBtZXRhZGF0YS5jb21wb25lbnRGYWN0b3J5ID1cbiAgICAgICAgICAgICAgICB0aGlzLmdldENvbXBvbmVudEZhY3Rvcnkoc2VsZWN0b3IsIGRpcmVjdGl2ZVR5cGUsIG1ldGFkYXRhLmlucHV0cywgbWV0YWRhdGEub3V0cHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgY2FjaGVFbnRyeSA9IHsgbWV0YWRhdGE6IG1ldGFkYXRhLCBhbm5vdGF0aW9uOiBkaXJNZXRhIH07XG4gICAgICAgIHRoaXMuX25vbk5vcm1hbGl6ZWREaXJlY3RpdmVDYWNoZS5zZXQoZGlyZWN0aXZlVHlwZSwgY2FjaGVFbnRyeSk7XG4gICAgICAgIHJldHVybiBjYWNoZUVudHJ5O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbWV0YWRhdGEgZm9yIHRoZSBnaXZlbiBkaXJlY3RpdmUuXG4gICAgICogVGhpcyBhc3N1bWVzIGBsb2FkTmdNb2R1bGVEaXJlY3RpdmVBbmRQaXBlTWV0YWRhdGFgIGhhcyBiZWVuIGNhbGxlZCBmaXJzdC5cbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZVR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXREaXJlY3RpdmVNZXRhZGF0YSA9IGZ1bmN0aW9uIChkaXJlY3RpdmVUeXBlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpck1ldGEgPSAoKHRoaXMuX2RpcmVjdGl2ZUNhY2hlLmdldChkaXJlY3RpdmVUeXBlKSkpO1xuICAgICAgICBpZiAoIWRpck1ldGEpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiSWxsZWdhbCBzdGF0ZTogZ2V0RGlyZWN0aXZlTWV0YWRhdGEgY2FuIG9ubHkgYmUgY2FsbGVkIGFmdGVyIGxvYWROZ01vZHVsZURpcmVjdGl2ZUFuZFBpcGVNZXRhZGF0YSBmb3IgYSBtb2R1bGUgdGhhdCBkZWNsYXJlcyBpdC4gRGlyZWN0aXZlIFwiICsgc3RyaW5naWZ5VHlwZShkaXJlY3RpdmVUeXBlKSArIFwiLlwiKSwgZGlyZWN0aXZlVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpck1ldGE7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRpclR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXREaXJlY3RpdmVTdW1tYXJ5ID0gZnVuY3Rpb24gKGRpclR5cGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlyU3VtbWFyeSA9ICh0aGlzLl9sb2FkU3VtbWFyeShkaXJUeXBlLCBDb21waWxlU3VtbWFyeUtpbmQuRGlyZWN0aXZlKSk7XG4gICAgICAgIGlmICghZGlyU3VtbWFyeSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJJbGxlZ2FsIHN0YXRlOiBDb3VsZCBub3QgbG9hZCB0aGUgc3VtbWFyeSBmb3IgZGlyZWN0aXZlIFwiICsgc3RyaW5naWZ5VHlwZShkaXJUeXBlKSArIFwiLlwiKSwgZGlyVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpclN1bW1hcnk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5pc0RpcmVjdGl2ZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2xvYWRTdW1tYXJ5KHR5cGUsIENvbXBpbGVTdW1tYXJ5S2luZC5EaXJlY3RpdmUpIHx8XG4gICAgICAgICAgICB0aGlzLl9kaXJlY3RpdmVSZXNvbHZlci5pc0RpcmVjdGl2ZSh0eXBlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmlzUGlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2xvYWRTdW1tYXJ5KHR5cGUsIENvbXBpbGVTdW1tYXJ5S2luZC5QaXBlKSB8fFxuICAgICAgICAgICAgdGhpcy5fcGlwZVJlc29sdmVyLmlzUGlwZSh0eXBlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmlzTmdNb2R1bGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9sb2FkU3VtbWFyeSh0eXBlLCBDb21waWxlU3VtbWFyeUtpbmQuTmdNb2R1bGUpIHx8XG4gICAgICAgICAgICB0aGlzLl9uZ01vZHVsZVJlc29sdmVyLmlzTmdNb2R1bGUodHlwZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1vZHVsZVR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXROZ01vZHVsZVN1bW1hcnkgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtb2R1bGVTdW1tYXJ5ID0gKHRoaXMuX2xvYWRTdW1tYXJ5KG1vZHVsZVR5cGUsIENvbXBpbGVTdW1tYXJ5S2luZC5OZ01vZHVsZSkpO1xuICAgICAgICBpZiAoIW1vZHVsZVN1bW1hcnkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1vZHVsZU1ldGEgPSB0aGlzLmdldE5nTW9kdWxlTWV0YWRhdGEobW9kdWxlVHlwZSwgZmFsc2UpO1xuICAgICAgICAgICAgbW9kdWxlU3VtbWFyeSA9IG1vZHVsZU1ldGEgPyBtb2R1bGVNZXRhLnRvU3VtbWFyeSgpIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChtb2R1bGVTdW1tYXJ5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3VtbWFyeUNhY2hlLnNldChtb2R1bGVUeXBlLCBtb2R1bGVTdW1tYXJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kdWxlU3VtbWFyeTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExvYWRzIHRoZSBkZWNsYXJlZCBkaXJlY3RpdmVzIGFuZCBwaXBlcyBvZiBhbiBOZ01vZHVsZS5cbiAgICAgKiBAcGFyYW0gez99IG1vZHVsZVR5cGVcbiAgICAgKiBAcGFyYW0gez99IGlzU3luY1xuICAgICAqIEBwYXJhbSB7Pz19IHRocm93SWZOb3RGb3VuZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmxvYWROZ01vZHVsZURpcmVjdGl2ZUFuZFBpcGVNZXRhZGF0YSA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlLCBpc1N5bmMsIHRocm93SWZOb3RGb3VuZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhyb3dJZk5vdEZvdW5kID09PSB2b2lkIDApIHsgdGhyb3dJZk5vdEZvdW5kID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZ01vZHVsZSA9IHRoaXMuZ2V0TmdNb2R1bGVNZXRhZGF0YShtb2R1bGVUeXBlLCB0aHJvd0lmTm90Rm91bmQpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsb2FkaW5nID0gW107XG4gICAgICAgIGlmIChuZ01vZHVsZSkge1xuICAgICAgICAgICAgbmdNb2R1bGUuZGVjbGFyZWREaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvbWlzZSA9IF90aGlzLmxvYWREaXJlY3RpdmVNZXRhZGF0YShtb2R1bGVUeXBlLCBpZC5yZWZlcmVuY2UsIGlzU3luYyk7XG4gICAgICAgICAgICAgICAgaWYgKHByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZy5wdXNoKHByb21pc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmdNb2R1bGUuZGVjbGFyZWRQaXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gX3RoaXMuX2xvYWRQaXBlTWV0YWRhdGEoaWQucmVmZXJlbmNlKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGxvYWRpbmcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtb2R1bGVUeXBlXG4gICAgICogQHBhcmFtIHs/PX0gdGhyb3dJZk5vdEZvdW5kXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0TmdNb2R1bGVNZXRhZGF0YSA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlLCB0aHJvd0lmTm90Rm91bmQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRocm93SWZOb3RGb3VuZCA9PT0gdm9pZCAwKSB7IHRocm93SWZOb3RGb3VuZCA9IHRydWU7IH1cbiAgICAgICAgbW9kdWxlVHlwZSA9IHJlc29sdmVGb3J3YXJkUmVmKG1vZHVsZVR5cGUpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21waWxlTWV0YSA9IHRoaXMuX25nTW9kdWxlQ2FjaGUuZ2V0KG1vZHVsZVR5cGUpO1xuICAgICAgICBpZiAoY29tcGlsZU1ldGEpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21waWxlTWV0YTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZXRhID0gdGhpcy5fbmdNb2R1bGVSZXNvbHZlci5yZXNvbHZlKG1vZHVsZVR5cGUsIHRocm93SWZOb3RGb3VuZCk7XG4gICAgICAgIGlmICghbWV0YSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVjbGFyZWREaXJlY3RpdmVzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cG9ydGVkTm9uTW9kdWxlSWRlbnRpZmllcnMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVjbGFyZWRQaXBlcyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbXBvcnRlZE1vZHVsZXMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwb3J0ZWRNb2R1bGVzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb3ZpZGVycyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbnRyeUNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYm9vdHN0cmFwQ29tcG9uZW50cyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzY2hlbWFzID0gW107XG4gICAgICAgIGlmIChtZXRhLmltcG9ydHMpIHtcbiAgICAgICAgICAgIGZsYXR0ZW5BbmREZWR1cGVBcnJheShtZXRhLmltcG9ydHMpLmZvckVhY2goZnVuY3Rpb24gKGltcG9ydGVkVHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGltcG9ydGVkTW9kdWxlVHlwZSA9ICgodW5kZWZpbmVkKSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsaWRUeXBlKGltcG9ydGVkVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0ZWRNb2R1bGVUeXBlID0gaW1wb3J0ZWRUeXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpbXBvcnRlZFR5cGUgJiYgaW1wb3J0ZWRUeXBlLm5nTW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1vZHVsZVdpdGhQcm92aWRlcnMgPSBpbXBvcnRlZFR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGltcG9ydGVkTW9kdWxlVHlwZSA9IG1vZHVsZVdpdGhQcm92aWRlcnMubmdNb2R1bGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2R1bGVXaXRoUHJvdmlkZXJzLnByb3ZpZGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzLnB1c2guYXBwbHkocHJvdmlkZXJzLCBfdGhpcy5fZ2V0UHJvdmlkZXJzTWV0YWRhdGEobW9kdWxlV2l0aFByb3ZpZGVycy5wcm92aWRlcnMsIGVudHJ5Q29tcG9uZW50cywgXCJwcm92aWRlciBmb3IgdGhlIE5nTW9kdWxlICdcIiArIHN0cmluZ2lmeVR5cGUoaW1wb3J0ZWRNb2R1bGVUeXBlKSArIFwiJ1wiLCBbXSwgaW1wb3J0ZWRUeXBlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGltcG9ydGVkTW9kdWxlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2NoZWNrU2VsZkltcG9ydChtb2R1bGVUeXBlLCBpbXBvcnRlZE1vZHVsZVR5cGUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbXBvcnRlZE1vZHVsZVN1bW1hcnkgPSBfdGhpcy5nZXROZ01vZHVsZVN1bW1hcnkoaW1wb3J0ZWRNb2R1bGVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbXBvcnRlZE1vZHVsZVN1bW1hcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIlVuZXhwZWN0ZWQgXCIgKyBfdGhpcy5fZ2V0VHlwZURlc2NyaXB0b3IoaW1wb3J0ZWRUeXBlKSArIFwiICdcIiArIHN0cmluZ2lmeVR5cGUoaW1wb3J0ZWRUeXBlKSArIFwiJyBpbXBvcnRlZCBieSB0aGUgbW9kdWxlICdcIiArIHN0cmluZ2lmeVR5cGUobW9kdWxlVHlwZSkgKyBcIicuIFBsZWFzZSBhZGQgYSBATmdNb2R1bGUgYW5ub3RhdGlvbi5cIiksIG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGltcG9ydGVkTW9kdWxlcy5wdXNoKGltcG9ydGVkTW9kdWxlU3VtbWFyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJVbmV4cGVjdGVkIHZhbHVlICdcIiArIHN0cmluZ2lmeVR5cGUoaW1wb3J0ZWRUeXBlKSArIFwiJyBpbXBvcnRlZCBieSB0aGUgbW9kdWxlICdcIiArIHN0cmluZ2lmeVR5cGUobW9kdWxlVHlwZSkgKyBcIidcIiksIG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuZXhwb3J0cykge1xuICAgICAgICAgICAgZmxhdHRlbkFuZERlZHVwZUFycmF5KG1ldGEuZXhwb3J0cykuZm9yRWFjaChmdW5jdGlvbiAoZXhwb3J0ZWRUeXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkVHlwZShleHBvcnRlZFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIlVuZXhwZWN0ZWQgdmFsdWUgJ1wiICsgc3RyaW5naWZ5VHlwZShleHBvcnRlZFR5cGUpICsgXCInIGV4cG9ydGVkIGJ5IHRoZSBtb2R1bGUgJ1wiICsgc3RyaW5naWZ5VHlwZShtb2R1bGVUeXBlKSArIFwiJ1wiKSwgbW9kdWxlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwb3J0ZWRNb2R1bGVTdW1tYXJ5ID0gX3RoaXMuZ2V0TmdNb2R1bGVTdW1tYXJ5KGV4cG9ydGVkVHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGV4cG9ydGVkTW9kdWxlU3VtbWFyeSkge1xuICAgICAgICAgICAgICAgICAgICBleHBvcnRlZE1vZHVsZXMucHVzaChleHBvcnRlZE1vZHVsZVN1bW1hcnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0ZWROb25Nb2R1bGVJZGVudGlmaWVycy5wdXNoKF90aGlzLl9nZXRJZGVudGlmaWVyTWV0YWRhdGEoZXhwb3J0ZWRUeXBlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZTogVGhpcyB3aWxsIGJlIG1vZGlmaWVkIGxhdGVyLCBzbyB3ZSByZWx5IG9uXG4gICAgICAgIC8vIGdldHRpbmcgYSBuZXcgaW5zdGFuY2UgZXZlcnkgdGltZSFcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNpdGl2ZU1vZHVsZSA9IHRoaXMuX2dldFRyYW5zaXRpdmVOZ01vZHVsZU1ldGFkYXRhKGltcG9ydGVkTW9kdWxlcywgZXhwb3J0ZWRNb2R1bGVzKTtcbiAgICAgICAgaWYgKG1ldGEuZGVjbGFyYXRpb25zKSB7XG4gICAgICAgICAgICBmbGF0dGVuQW5kRGVkdXBlQXJyYXkobWV0YS5kZWNsYXJhdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGRlY2xhcmVkVHlwZSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZFR5cGUoZGVjbGFyZWRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJVbmV4cGVjdGVkIHZhbHVlICdcIiArIHN0cmluZ2lmeVR5cGUoZGVjbGFyZWRUeXBlKSArIFwiJyBkZWNsYXJlZCBieSB0aGUgbW9kdWxlICdcIiArIHN0cmluZ2lmeVR5cGUobW9kdWxlVHlwZSkgKyBcIidcIiksIG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlY2xhcmVkSWRlbnRpZmllciA9IF90aGlzLl9nZXRJZGVudGlmaWVyTWV0YWRhdGEoZGVjbGFyZWRUeXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaXNEaXJlY3RpdmUoZGVjbGFyZWRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aXZlTW9kdWxlLmFkZERpcmVjdGl2ZShkZWNsYXJlZElkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgICAgICBkZWNsYXJlZERpcmVjdGl2ZXMucHVzaChkZWNsYXJlZElkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWRkVHlwZVRvTW9kdWxlKGRlY2xhcmVkVHlwZSwgbW9kdWxlVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLmlzUGlwZShkZWNsYXJlZFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpdmVNb2R1bGUuYWRkUGlwZShkZWNsYXJlZElkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aXZlTW9kdWxlLnBpcGVzLnB1c2goZGVjbGFyZWRJZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyZWRQaXBlcy5wdXNoKGRlY2xhcmVkSWRlbnRpZmllcik7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9hZGRUeXBlVG9Nb2R1bGUoZGVjbGFyZWRUeXBlLCBtb2R1bGVUeXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIlVuZXhwZWN0ZWQgXCIgKyBfdGhpcy5fZ2V0VHlwZURlc2NyaXB0b3IoZGVjbGFyZWRUeXBlKSArIFwiICdcIiArIHN0cmluZ2lmeVR5cGUoZGVjbGFyZWRUeXBlKSArIFwiJyBkZWNsYXJlZCBieSB0aGUgbW9kdWxlICdcIiArIHN0cmluZ2lmeVR5cGUobW9kdWxlVHlwZSkgKyBcIicuIFBsZWFzZSBhZGQgYSBAUGlwZS9ARGlyZWN0aXZlL0BDb21wb25lbnQgYW5ub3RhdGlvbi5cIiksIG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwb3J0ZWREaXJlY3RpdmVzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cG9ydGVkUGlwZXMgPSBbXTtcbiAgICAgICAgZXhwb3J0ZWROb25Nb2R1bGVJZGVudGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChleHBvcnRlZElkKSB7XG4gICAgICAgICAgICBpZiAodHJhbnNpdGl2ZU1vZHVsZS5kaXJlY3RpdmVzU2V0LmhhcyhleHBvcnRlZElkLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgICAgICBleHBvcnRlZERpcmVjdGl2ZXMucHVzaChleHBvcnRlZElkKTtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aXZlTW9kdWxlLmFkZEV4cG9ydGVkRGlyZWN0aXZlKGV4cG9ydGVkSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHJhbnNpdGl2ZU1vZHVsZS5waXBlc1NldC5oYXMoZXhwb3J0ZWRJZC5yZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICAgICAgZXhwb3J0ZWRQaXBlcy5wdXNoKGV4cG9ydGVkSWQpO1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpdmVNb2R1bGUuYWRkRXhwb3J0ZWRQaXBlKGV4cG9ydGVkSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiQ2FuJ3QgZXhwb3J0IFwiICsgX3RoaXMuX2dldFR5cGVEZXNjcmlwdG9yKGV4cG9ydGVkSWQucmVmZXJlbmNlKSArIFwiIFwiICsgc3RyaW5naWZ5VHlwZShleHBvcnRlZElkLnJlZmVyZW5jZSkgKyBcIiBmcm9tIFwiICsgc3RyaW5naWZ5VHlwZShtb2R1bGVUeXBlKSArIFwiIGFzIGl0IHdhcyBuZWl0aGVyIGRlY2xhcmVkIG5vciBpbXBvcnRlZCFcIiksIG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRoZSBwcm92aWRlcnMgb2YgdGhlIG1vZHVsZSBoYXZlIHRvIGdvIGxhc3RcbiAgICAgICAgLy8gc28gdGhhdCB0aGV5IG92ZXJ3cml0ZSBhbnkgb3RoZXIgcHJvdmlkZXIgd2UgYWxyZWFkeSBhZGRlZC5cbiAgICAgICAgaWYgKG1ldGEucHJvdmlkZXJzKSB7XG4gICAgICAgICAgICBwcm92aWRlcnMucHVzaC5hcHBseShwcm92aWRlcnMsIHRoaXMuX2dldFByb3ZpZGVyc01ldGFkYXRhKG1ldGEucHJvdmlkZXJzLCBlbnRyeUNvbXBvbmVudHMsIFwicHJvdmlkZXIgZm9yIHRoZSBOZ01vZHVsZSAnXCIgKyBzdHJpbmdpZnlUeXBlKG1vZHVsZVR5cGUpICsgXCInXCIsIFtdLCBtb2R1bGVUeXBlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuZW50cnlDb21wb25lbnRzKSB7XG4gICAgICAgICAgICBlbnRyeUNvbXBvbmVudHMucHVzaC5hcHBseShlbnRyeUNvbXBvbmVudHMsIGZsYXR0ZW5BbmREZWR1cGVBcnJheShtZXRhLmVudHJ5Q29tcG9uZW50cylcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiAoKF90aGlzLl9nZXRFbnRyeUNvbXBvbmVudE1ldGFkYXRhKHR5cGUpKSk7IH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YS5ib290c3RyYXApIHtcbiAgICAgICAgICAgIGZsYXR0ZW5BbmREZWR1cGVBcnJheShtZXRhLmJvb3RzdHJhcCkuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZFR5cGUodHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiVW5leHBlY3RlZCB2YWx1ZSAnXCIgKyBzdHJpbmdpZnlUeXBlKHR5cGUpICsgXCInIHVzZWQgaW4gdGhlIGJvb3RzdHJhcCBwcm9wZXJ0eSBvZiBtb2R1bGUgJ1wiICsgc3RyaW5naWZ5VHlwZShtb2R1bGVUeXBlKSArIFwiJ1wiKSwgbW9kdWxlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYm9vdHN0cmFwQ29tcG9uZW50cy5wdXNoKF90aGlzLl9nZXRJZGVudGlmaWVyTWV0YWRhdGEodHlwZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZW50cnlDb21wb25lbnRzLnB1c2guYXBwbHkoZW50cnlDb21wb25lbnRzLCBib290c3RyYXBDb21wb25lbnRzLm1hcChmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gKChfdGhpcy5fZ2V0RW50cnlDb21wb25lbnRNZXRhZGF0YSh0eXBlLnJlZmVyZW5jZSkpKTsgfSkpO1xuICAgICAgICBpZiAobWV0YS5zY2hlbWFzKSB7XG4gICAgICAgICAgICBzY2hlbWFzLnB1c2guYXBwbHkoc2NoZW1hcywgZmxhdHRlbkFuZERlZHVwZUFycmF5KG1ldGEuc2NoZW1hcykpO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBpbGVNZXRhID0gbmV3IENvbXBpbGVOZ01vZHVsZU1ldGFkYXRhKHtcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuX2dldFR5cGVNZXRhZGF0YShtb2R1bGVUeXBlKSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogcHJvdmlkZXJzLFxuICAgICAgICAgICAgZW50cnlDb21wb25lbnRzOiBlbnRyeUNvbXBvbmVudHMsXG4gICAgICAgICAgICBib290c3RyYXBDb21wb25lbnRzOiBib290c3RyYXBDb21wb25lbnRzLFxuICAgICAgICAgICAgc2NoZW1hczogc2NoZW1hcyxcbiAgICAgICAgICAgIGRlY2xhcmVkRGlyZWN0aXZlczogZGVjbGFyZWREaXJlY3RpdmVzLFxuICAgICAgICAgICAgZXhwb3J0ZWREaXJlY3RpdmVzOiBleHBvcnRlZERpcmVjdGl2ZXMsXG4gICAgICAgICAgICBkZWNsYXJlZFBpcGVzOiBkZWNsYXJlZFBpcGVzLFxuICAgICAgICAgICAgZXhwb3J0ZWRQaXBlczogZXhwb3J0ZWRQaXBlcyxcbiAgICAgICAgICAgIGltcG9ydGVkTW9kdWxlczogaW1wb3J0ZWRNb2R1bGVzLFxuICAgICAgICAgICAgZXhwb3J0ZWRNb2R1bGVzOiBleHBvcnRlZE1vZHVsZXMsXG4gICAgICAgICAgICB0cmFuc2l0aXZlTW9kdWxlOiB0cmFuc2l0aXZlTW9kdWxlLFxuICAgICAgICAgICAgaWQ6IG1ldGEuaWQgfHwgbnVsbCxcbiAgICAgICAgfSk7XG4gICAgICAgIGVudHJ5Q29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gdHJhbnNpdGl2ZU1vZHVsZS5hZGRFbnRyeUNvbXBvbmVudChpZCk7IH0pO1xuICAgICAgICBwcm92aWRlcnMuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIpIHsgcmV0dXJuIHRyYW5zaXRpdmVNb2R1bGUuYWRkUHJvdmlkZXIocHJvdmlkZXIsIC8qKiBAdHlwZSB7P30gKi8gKChjb21waWxlTWV0YSkpLnR5cGUpOyB9KTtcbiAgICAgICAgdHJhbnNpdGl2ZU1vZHVsZS5hZGRNb2R1bGUoY29tcGlsZU1ldGEudHlwZSk7XG4gICAgICAgIHRoaXMuX25nTW9kdWxlQ2FjaGUuc2V0KG1vZHVsZVR5cGUsIGNvbXBpbGVNZXRhKTtcbiAgICAgICAgcmV0dXJuIGNvbXBpbGVNZXRhO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtb2R1bGVUeXBlXG4gICAgICogQHBhcmFtIHs/fSBpbXBvcnRlZE1vZHVsZVR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fY2hlY2tTZWxmSW1wb3J0ID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUsIGltcG9ydGVkTW9kdWxlVHlwZSkge1xuICAgICAgICBpZiAobW9kdWxlVHlwZSA9PT0gaW1wb3J0ZWRNb2R1bGVUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIidcIiArIHN0cmluZ2lmeVR5cGUobW9kdWxlVHlwZSkgKyBcIicgbW9kdWxlIGNhbid0IGltcG9ydCBpdHNlbGZcIiksIG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2dldFR5cGVEZXNjcmlwdG9yID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJlY3RpdmUodHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnZGlyZWN0aXZlJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1BpcGUodHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAncGlwZSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNOZ01vZHVsZSh0eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuICdtb2R1bGUnO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoKHR5cGUpKS5wcm92aWRlKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3Byb3ZpZGVyJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ3ZhbHVlJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7P30gbW9kdWxlVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9hZGRUeXBlVG9Nb2R1bGUgPSBmdW5jdGlvbiAodHlwZSwgbW9kdWxlVHlwZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvbGRNb2R1bGUgPSB0aGlzLl9uZ01vZHVsZU9mVHlwZXMuZ2V0KHR5cGUpO1xuICAgICAgICBpZiAob2xkTW9kdWxlICYmIG9sZE1vZHVsZSAhPT0gbW9kdWxlVHlwZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJUeXBlIFwiICsgc3RyaW5naWZ5VHlwZSh0eXBlKSArIFwiIGlzIHBhcnQgb2YgdGhlIGRlY2xhcmF0aW9ucyBvZiAyIG1vZHVsZXM6IFwiICsgc3RyaW5naWZ5VHlwZShvbGRNb2R1bGUpICsgXCIgYW5kIFwiICsgc3RyaW5naWZ5VHlwZShtb2R1bGVUeXBlKSArIFwiISBcIiArXG4gICAgICAgICAgICAgICAgKFwiUGxlYXNlIGNvbnNpZGVyIG1vdmluZyBcIiArIHN0cmluZ2lmeVR5cGUodHlwZSkgKyBcIiB0byBhIGhpZ2hlciBtb2R1bGUgdGhhdCBpbXBvcnRzIFwiICsgc3RyaW5naWZ5VHlwZShvbGRNb2R1bGUpICsgXCIgYW5kIFwiICsgc3RyaW5naWZ5VHlwZShtb2R1bGVUeXBlKSArIFwiLiBcIikgK1xuICAgICAgICAgICAgICAgIChcIllvdSBjYW4gYWxzbyBjcmVhdGUgYSBuZXcgTmdNb2R1bGUgdGhhdCBleHBvcnRzIGFuZCBpbmNsdWRlcyBcIiArIHN0cmluZ2lmeVR5cGUodHlwZSkgKyBcIiB0aGVuIGltcG9ydCB0aGF0IE5nTW9kdWxlIGluIFwiICsgc3RyaW5naWZ5VHlwZShvbGRNb2R1bGUpICsgXCIgYW5kIFwiICsgc3RyaW5naWZ5VHlwZShtb2R1bGVUeXBlKSArIFwiLlwiKSksIG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX25nTW9kdWxlT2ZUeXBlcy5zZXQodHlwZSwgbW9kdWxlVHlwZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGltcG9ydGVkTW9kdWxlc1xuICAgICAqIEBwYXJhbSB7P30gZXhwb3J0ZWRNb2R1bGVzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2dldFRyYW5zaXRpdmVOZ01vZHVsZU1ldGFkYXRhID0gZnVuY3Rpb24gKGltcG9ydGVkTW9kdWxlcywgZXhwb3J0ZWRNb2R1bGVzKSB7XG4gICAgICAgIC8vIGNvbGxlY3QgYHByb3ZpZGVyc2AgLyBgZW50cnlDb21wb25lbnRzYCBmcm9tIGFsbCBpbXBvcnRlZCBhbmQgYWxsIGV4cG9ydGVkIG1vZHVsZXNcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gbmV3IFRyYW5zaXRpdmVDb21waWxlTmdNb2R1bGVNZXRhZGF0YSgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtb2R1bGVzQnlUb2tlbiA9IG5ldyBNYXAoKTtcbiAgICAgICAgaW1wb3J0ZWRNb2R1bGVzLmNvbmNhdChleHBvcnRlZE1vZHVsZXMpLmZvckVhY2goZnVuY3Rpb24gKG1vZFN1bW1hcnkpIHtcbiAgICAgICAgICAgIG1vZFN1bW1hcnkubW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2QpIHsgcmV0dXJuIHJlc3VsdC5hZGRNb2R1bGUobW9kKTsgfSk7XG4gICAgICAgICAgICBtb2RTdW1tYXJ5LmVudHJ5Q29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wKSB7IHJldHVybiByZXN1bHQuYWRkRW50cnlDb21wb25lbnQoY29tcCk7IH0pO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWRkZWRUb2tlbnMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBtb2RTdW1tYXJ5LnByb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRva2VuUmVmID0gdG9rZW5SZWZlcmVuY2UoZW50cnkucHJvdmlkZXIudG9rZW4pO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZXZNb2R1bGVzID0gbW9kdWxlc0J5VG9rZW4uZ2V0KHRva2VuUmVmKTtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXZNb2R1bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZNb2R1bGVzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVzQnlUb2tlbi5zZXQodG9rZW5SZWYsIHByZXZNb2R1bGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbW9kdWxlUmVmID0gZW50cnkubW9kdWxlLnJlZmVyZW5jZTtcbiAgICAgICAgICAgICAgICAvLyBOb3RlOiB0aGUgcHJvdmlkZXJzIG9mIG9uZSBtb2R1bGUgbWF5IHN0aWxsIGNvbnRhaW4gbXVsdGlwbGUgcHJvdmlkZXJzXG4gICAgICAgICAgICAgICAgLy8gcGVyIHRva2VuIChlLmcuIGZvciBtdWx0aSBwcm92aWRlcnMpLCBhbmQgd2UgbmVlZCB0byBwcmVzZXJ2ZSB0aGVzZS5cbiAgICAgICAgICAgICAgICBpZiAoYWRkZWRUb2tlbnMuaGFzKHRva2VuUmVmKSB8fCAhcHJldk1vZHVsZXMuaGFzKG1vZHVsZVJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldk1vZHVsZXMuYWRkKG1vZHVsZVJlZik7XG4gICAgICAgICAgICAgICAgICAgIGFkZGVkVG9rZW5zLmFkZCh0b2tlblJlZik7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGRQcm92aWRlcihlbnRyeS5wcm92aWRlciwgZW50cnkubW9kdWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGV4cG9ydGVkTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RTdW1tYXJ5KSB7XG4gICAgICAgICAgICBtb2RTdW1tYXJ5LmV4cG9ydGVkRGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gcmVzdWx0LmFkZEV4cG9ydGVkRGlyZWN0aXZlKGlkKTsgfSk7XG4gICAgICAgICAgICBtb2RTdW1tYXJ5LmV4cG9ydGVkUGlwZXMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIHJlc3VsdC5hZGRFeHBvcnRlZFBpcGUoaWQpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGltcG9ydGVkTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RTdW1tYXJ5KSB7XG4gICAgICAgICAgICBtb2RTdW1tYXJ5LmV4cG9ydGVkRGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gcmVzdWx0LmFkZERpcmVjdGl2ZShpZCk7IH0pO1xuICAgICAgICAgICAgbW9kU3VtbWFyeS5leHBvcnRlZFBpcGVzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7IHJldHVybiByZXN1bHQuYWRkUGlwZShpZCk7IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9nZXRJZGVudGlmaWVyTWV0YWRhdGEgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB0eXBlID0gcmVzb2x2ZUZvcndhcmRSZWYodHlwZSk7XG4gICAgICAgIHJldHVybiB7IHJlZmVyZW5jZTogdHlwZSB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuaXNJbmplY3RhYmxlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYW5ub3RhdGlvbnMgPSB0aGlzLl9yZWZsZWN0b3IuYW5ub3RhdGlvbnModHlwZSk7XG4gICAgICAgIC8vIE5vdGU6IFdlIG5lZWQgYW4gZXhhY3QgY2hlY2sgaGVyZSBhcyBAQ29tcG9uZW50IC8gQERpcmVjdGl2ZSAvIC4uLiBpbmhlcml0XG4gICAgICAgIC8vIGZyb20gQENvbXBpbGVySW5qZWN0YWJsZSFcbiAgICAgICAgcmV0dXJuIGFubm90YXRpb25zLnNvbWUoZnVuY3Rpb24gKGFubikgeyByZXR1cm4gYW5uLmNvbnN0cnVjdG9yID09PSBJbmplY3RhYmxlOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldEluamVjdGFibGVTdW1tYXJ5ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1bW1hcnlLaW5kOiBDb21waWxlU3VtbWFyeUtpbmQuSW5qZWN0YWJsZSxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuX2dldFR5cGVNZXRhZGF0YSh0eXBlLCBudWxsLCBmYWxzZSlcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IGRlcGVuZGVuY2llc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9nZXRJbmplY3RhYmxlTWV0YWRhdGEgPSBmdW5jdGlvbiAodHlwZSwgZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgIGlmIChkZXBlbmRlbmNpZXMgPT09IHZvaWQgMCkgeyBkZXBlbmRlbmNpZXMgPSBudWxsOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHR5cGVTdW1tYXJ5ID0gdGhpcy5fbG9hZFN1bW1hcnkodHlwZSwgQ29tcGlsZVN1bW1hcnlLaW5kLkluamVjdGFibGUpO1xuICAgICAgICBpZiAodHlwZVN1bW1hcnkpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlU3VtbWFyeS50eXBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRUeXBlTWV0YWRhdGEodHlwZSwgZGVwZW5kZW5jaWVzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IGRlcGVuZGVuY2llc1xuICAgICAqIEBwYXJhbSB7Pz19IHRocm93T25Vbmtub3duRGVwc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9nZXRUeXBlTWV0YWRhdGEgPSBmdW5jdGlvbiAodHlwZSwgZGVwZW5kZW5jaWVzLCB0aHJvd09uVW5rbm93bkRlcHMpIHtcbiAgICAgICAgaWYgKGRlcGVuZGVuY2llcyA9PT0gdm9pZCAwKSB7IGRlcGVuZGVuY2llcyA9IG51bGw7IH1cbiAgICAgICAgaWYgKHRocm93T25Vbmtub3duRGVwcyA9PT0gdm9pZCAwKSB7IHRocm93T25Vbmtub3duRGVwcyA9IHRydWU7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaWRlbnRpZmllciA9IHRoaXMuX2dldElkZW50aWZpZXJNZXRhZGF0YSh0eXBlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZTogaWRlbnRpZmllci5yZWZlcmVuY2UsXG4gICAgICAgICAgICBkaURlcHM6IHRoaXMuX2dldERlcGVuZGVuY2llc01ldGFkYXRhKGlkZW50aWZpZXIucmVmZXJlbmNlLCBkZXBlbmRlbmNpZXMsIHRocm93T25Vbmtub3duRGVwcyksXG4gICAgICAgICAgICBsaWZlY3ljbGVIb29rczogZ2V0QWxsTGlmZWN5Y2xlSG9va3ModGhpcy5fcmVmbGVjdG9yLCBpZGVudGlmaWVyLnJlZmVyZW5jZSksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZhY3RvcnlcbiAgICAgKiBAcGFyYW0gez89fSBkZXBlbmRlbmNpZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fZ2V0RmFjdG9yeU1ldGFkYXRhID0gZnVuY3Rpb24gKGZhY3RvcnksIGRlcGVuZGVuY2llcykge1xuICAgICAgICBpZiAoZGVwZW5kZW5jaWVzID09PSB2b2lkIDApIHsgZGVwZW5kZW5jaWVzID0gbnVsbDsgfVxuICAgICAgICBmYWN0b3J5ID0gcmVzb2x2ZUZvcndhcmRSZWYoZmFjdG9yeSk7XG4gICAgICAgIHJldHVybiB7IHJlZmVyZW5jZTogZmFjdG9yeSwgZGlEZXBzOiB0aGlzLl9nZXREZXBlbmRlbmNpZXNNZXRhZGF0YShmYWN0b3J5LCBkZXBlbmRlbmNpZXMpIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtZXRhZGF0YSBmb3IgdGhlIGdpdmVuIHBpcGUuXG4gICAgICogVGhpcyBhc3N1bWVzIGBsb2FkTmdNb2R1bGVEaXJlY3RpdmVBbmRQaXBlTWV0YWRhdGFgIGhhcyBiZWVuIGNhbGxlZCBmaXJzdC5cbiAgICAgKiBAcGFyYW0gez99IHBpcGVUeXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0UGlwZU1ldGFkYXRhID0gZnVuY3Rpb24gKHBpcGVUeXBlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBpcGVNZXRhID0gdGhpcy5fcGlwZUNhY2hlLmdldChwaXBlVHlwZSk7XG4gICAgICAgIGlmICghcGlwZU1ldGEpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiSWxsZWdhbCBzdGF0ZTogZ2V0UGlwZU1ldGFkYXRhIGNhbiBvbmx5IGJlIGNhbGxlZCBhZnRlciBsb2FkTmdNb2R1bGVEaXJlY3RpdmVBbmRQaXBlTWV0YWRhdGEgZm9yIGEgbW9kdWxlIHRoYXQgZGVjbGFyZXMgaXQuIFBpcGUgXCIgKyBzdHJpbmdpZnlUeXBlKHBpcGVUeXBlKSArIFwiLlwiKSwgcGlwZVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwaXBlTWV0YSB8fCBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaXBlVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldFBpcGVTdW1tYXJ5ID0gZnVuY3Rpb24gKHBpcGVUeXBlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBpcGVTdW1tYXJ5ID0gKHRoaXMuX2xvYWRTdW1tYXJ5KHBpcGVUeXBlLCBDb21waWxlU3VtbWFyeUtpbmQuUGlwZSkpO1xuICAgICAgICBpZiAoIXBpcGVTdW1tYXJ5KSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIklsbGVnYWwgc3RhdGU6IENvdWxkIG5vdCBsb2FkIHRoZSBzdW1tYXJ5IGZvciBwaXBlIFwiICsgc3RyaW5naWZ5VHlwZShwaXBlVHlwZSkgKyBcIi5cIiksIHBpcGVUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGlwZVN1bW1hcnk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBpcGVUeXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0T3JMb2FkUGlwZU1ldGFkYXRhID0gZnVuY3Rpb24gKHBpcGVUeXBlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBpcGVNZXRhID0gdGhpcy5fcGlwZUNhY2hlLmdldChwaXBlVHlwZSk7XG4gICAgICAgIGlmICghcGlwZU1ldGEpIHtcbiAgICAgICAgICAgIHBpcGVNZXRhID0gdGhpcy5fbG9hZFBpcGVNZXRhZGF0YShwaXBlVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBpcGVNZXRhO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaXBlVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9sb2FkUGlwZU1ldGFkYXRhID0gZnVuY3Rpb24gKHBpcGVUeXBlKSB7XG4gICAgICAgIHBpcGVUeXBlID0gcmVzb2x2ZUZvcndhcmRSZWYocGlwZVR5cGUpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwaXBlQW5ub3RhdGlvbiA9ICgodGhpcy5fcGlwZVJlc29sdmVyLnJlc29sdmUocGlwZVR5cGUpKSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBpcGVNZXRhID0gbmV3IENvbXBpbGVQaXBlTWV0YWRhdGEoe1xuICAgICAgICAgICAgdHlwZTogdGhpcy5fZ2V0VHlwZU1ldGFkYXRhKHBpcGVUeXBlKSxcbiAgICAgICAgICAgIG5hbWU6IHBpcGVBbm5vdGF0aW9uLm5hbWUsXG4gICAgICAgICAgICBwdXJlOiAhIXBpcGVBbm5vdGF0aW9uLnB1cmVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3BpcGVDYWNoZS5zZXQocGlwZVR5cGUsIHBpcGVNZXRhKTtcbiAgICAgICAgdGhpcy5fc3VtbWFyeUNhY2hlLnNldChwaXBlVHlwZSwgcGlwZU1ldGEudG9TdW1tYXJ5KCkpO1xuICAgICAgICByZXR1cm4gcGlwZU1ldGE7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVPckZ1bmNcbiAgICAgKiBAcGFyYW0gez99IGRlcGVuZGVuY2llc1xuICAgICAqIEBwYXJhbSB7Pz19IHRocm93T25Vbmtub3duRGVwc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9nZXREZXBlbmRlbmNpZXNNZXRhZGF0YSA9IGZ1bmN0aW9uICh0eXBlT3JGdW5jLCBkZXBlbmRlbmNpZXMsIHRocm93T25Vbmtub3duRGVwcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhyb3dPblVua25vd25EZXBzID09PSB2b2lkIDApIHsgdGhyb3dPblVua25vd25EZXBzID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoYXNVbmtub3duRGVwcyA9IGZhbHNlO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJhbXMgPSBkZXBlbmRlbmNpZXMgfHwgdGhpcy5fcmVmbGVjdG9yLnBhcmFtZXRlcnModHlwZU9yRnVuYykgfHwgW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlcGVuZGVuY2llc01ldGFkYXRhID0gcGFyYW1zLm1hcChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzQXR0cmlidXRlID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc0hvc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzU2VsZiA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNTa2lwU2VsZiA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNPcHRpb25hbCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9rZW4gPSBudWxsO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW0pKSB7XG4gICAgICAgICAgICAgICAgcGFyYW0uZm9yRWFjaChmdW5jdGlvbiAocGFyYW1FbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1FbnRyeSBpbnN0YW5jZW9mIEhvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzSG9zdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1FbnRyeSBpbnN0YW5jZW9mIFNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU2VsZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1FbnRyeSBpbnN0YW5jZW9mIFNraXBTZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1NraXBTZWxmID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbUVudHJ5IGluc3RhbmNlb2YgT3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzT3B0aW9uYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtRW50cnkgaW5zdGFuY2VvZiBBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQXR0cmlidXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gcGFyYW1FbnRyeS5hdHRyaWJ1dGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtRW50cnkgaW5zdGFuY2VvZiBJbmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gcGFyYW1FbnRyeS50b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbUVudHJ5IGluc3RhbmNlb2YgSW5qZWN0aW9uVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gcGFyYW1FbnRyeTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1ZhbGlkVHlwZShwYXJhbUVudHJ5KSAmJiB0b2tlbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHBhcmFtRW50cnk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRva2VuID0gcGFyYW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGhhc1Vua25vd25EZXBzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKChudWxsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlzQXR0cmlidXRlOiBpc0F0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgICBpc0hvc3Q6IGlzSG9zdCxcbiAgICAgICAgICAgICAgICBpc1NlbGY6IGlzU2VsZixcbiAgICAgICAgICAgICAgICBpc1NraXBTZWxmOiBpc1NraXBTZWxmLFxuICAgICAgICAgICAgICAgIGlzT3B0aW9uYWw6IGlzT3B0aW9uYWwsXG4gICAgICAgICAgICAgICAgdG9rZW46IF90aGlzLl9nZXRUb2tlbk1ldGFkYXRhKHRva2VuKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChoYXNVbmtub3duRGVwcykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVwc1Rva2VucyA9IGRlcGVuZGVuY2llc01ldGFkYXRhLm1hcChmdW5jdGlvbiAoZGVwKSB7IHJldHVybiBkZXAgPyBzdHJpbmdpZnlUeXBlKGRlcC50b2tlbikgOiAnPyc7IH0pLmpvaW4oJywgJyk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZXNzYWdlID0gXCJDYW4ndCByZXNvbHZlIGFsbCBwYXJhbWV0ZXJzIGZvciBcIiArIHN0cmluZ2lmeVR5cGUodHlwZU9yRnVuYykgKyBcIjogKFwiICsgZGVwc1Rva2VucyArIFwiKS5cIjtcbiAgICAgICAgICAgIGlmICh0aHJvd09uVW5rbm93bkRlcHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihtZXNzYWdlKSwgdHlwZU9yRnVuYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zb2xlLndhcm4oXCJXYXJuaW5nOiBcIiArIG1lc3NhZ2UgKyBcIiBUaGlzIHdpbGwgYmVjb21lIGFuIGVycm9yIGluIEFuZ3VsYXIgdjUueFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVwZW5kZW5jaWVzTWV0YWRhdGE7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRva2VuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2dldFRva2VuTWV0YWRhdGEgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgdG9rZW4gPSByZXNvbHZlRm9yd2FyZFJlZih0b2tlbik7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBpbGVUb2tlbjtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbXBpbGVUb2tlbiA9IHsgdmFsdWU6IHRva2VuIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb21waWxlVG9rZW4gPSB7IGlkZW50aWZpZXI6IHsgcmVmZXJlbmNlOiB0b2tlbiB9IH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBpbGVUb2tlbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJvdmlkZXJzXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRFbnRyeUNvbXBvbmVudHNcbiAgICAgKiBAcGFyYW0gez89fSBkZWJ1Z0luZm9cbiAgICAgKiBAcGFyYW0gez89fSBjb21waWxlUHJvdmlkZXJzXG4gICAgICogQHBhcmFtIHs/PX0gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9nZXRQcm92aWRlcnNNZXRhZGF0YSA9IGZ1bmN0aW9uIChwcm92aWRlcnMsIHRhcmdldEVudHJ5Q29tcG9uZW50cywgZGVidWdJbmZvLCBjb21waWxlUHJvdmlkZXJzLCB0eXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChjb21waWxlUHJvdmlkZXJzID09PSB2b2lkIDApIHsgY29tcGlsZVByb3ZpZGVycyA9IFtdOyB9XG4gICAgICAgIHByb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlciwgcHJvdmlkZXJJZHgpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3ZpZGVyKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9nZXRQcm92aWRlcnNNZXRhZGF0YShwcm92aWRlciwgdGFyZ2V0RW50cnlDb21wb25lbnRzLCBkZWJ1Z0luZm8sIGNvbXBpbGVQcm92aWRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXIgPSByZXNvbHZlRm9yd2FyZFJlZihwcm92aWRlcik7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvdmlkZXJNZXRhID0gKCh1bmRlZmluZWQpKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvdmlkZXIgJiYgdHlwZW9mIHByb3ZpZGVyID09PSAnb2JqZWN0JyAmJiBwcm92aWRlci5oYXNPd25Qcm9wZXJ0eSgncHJvdmlkZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl92YWxpZGF0ZVByb3ZpZGVyKHByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhID0gbmV3IFByb3ZpZGVyTWV0YShwcm92aWRlci5wcm92aWRlLCBwcm92aWRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzVmFsaWRUeXBlKHByb3ZpZGVyKSkge1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGEgPSBuZXcgUHJvdmlkZXJNZXRhKHByb3ZpZGVyLCB7IHVzZUNsYXNzOiBwcm92aWRlciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJFbmNvdW50ZXJlZCB1bmRlZmluZWQgcHJvdmlkZXIhIFVzdWFsbHkgdGhpcyBtZWFucyB5b3UgaGF2ZSBhIGNpcmN1bGFyIGRlcGVuZGVuY2llcyAobWlnaHQgYmUgY2F1c2VkIGJ5IHVzaW5nICdiYXJyZWwnIGluZGV4LnRzIGZpbGVzLlwiKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb3ZpZGVyc0luZm8gPSAoKHByb3ZpZGVycy5yZWR1Y2UoZnVuY3Rpb24gKHNvRmFyLCBzZWVuUHJvdmlkZXIsIHNlZW5Qcm92aWRlcklkeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlZW5Qcm92aWRlcklkeCA8IHByb3ZpZGVySWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29GYXIucHVzaChcIlwiICsgc3RyaW5naWZ5VHlwZShzZWVuUHJvdmlkZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlZW5Qcm92aWRlcklkeCA9PSBwcm92aWRlcklkeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvRmFyLnB1c2goXCI/XCIgKyBzdHJpbmdpZnlUeXBlKHNlZW5Qcm92aWRlcikgKyBcIj9cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzZWVuUHJvdmlkZXJJZHggPT0gcHJvdmlkZXJJZHggKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29GYXIucHVzaCgnLi4uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc29GYXI7XG4gICAgICAgICAgICAgICAgICAgIH0sIFtdKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuam9pbignLCAnKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiSW52YWxpZCBcIiArIChkZWJ1Z0luZm8gPyBkZWJ1Z0luZm8gOiAncHJvdmlkZXInKSArIFwiIC0gb25seSBpbnN0YW5jZXMgb2YgUHJvdmlkZXIgYW5kIFR5cGUgYXJlIGFsbG93ZWQsIGdvdDogW1wiICsgcHJvdmlkZXJzSW5mbyArIFwiXVwiKSwgdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyTWV0YS50b2tlbiA9PT1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlZmxlY3Rvci5yZXNvbHZlRXh0ZXJuYWxSZWZlcmVuY2UoSWRlbnRpZmllcnMuQU5BTFlaRV9GT1JfRU5UUllfQ09NUE9ORU5UUykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RW50cnlDb21wb25lbnRzLnB1c2guYXBwbHkodGFyZ2V0RW50cnlDb21wb25lbnRzLCBfdGhpcy5fZ2V0RW50cnlDb21wb25lbnRzRnJvbVByb3ZpZGVyKHByb3ZpZGVyTWV0YSwgdHlwZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGlsZVByb3ZpZGVycy5wdXNoKF90aGlzLmdldFByb3ZpZGVyTWV0YWRhdGEocHJvdmlkZXJNZXRhKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbXBpbGVQcm92aWRlcnM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHByb3ZpZGVyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX3ZhbGlkYXRlUHJvdmlkZXIgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgaWYgKHByb3ZpZGVyLmhhc093blByb3BlcnR5KCd1c2VDbGFzcycpICYmIHByb3ZpZGVyLnVzZUNsYXNzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiSW52YWxpZCBwcm92aWRlciBmb3IgXCIgKyBzdHJpbmdpZnlUeXBlKHByb3ZpZGVyLnByb3ZpZGUpICsgXCIuIHVzZUNsYXNzIGNhbm5vdCBiZSBcIiArIHByb3ZpZGVyLnVzZUNsYXNzICsgXCIuXFxuICAgICAgICAgICBVc3VhbGx5IGl0IGhhcHBlbnMgd2hlbjpcXG4gICAgICAgICAgIDEuIFRoZXJlJ3MgYSBjaXJjdWxhciBkZXBlbmRlbmN5IChtaWdodCBiZSBjYXVzZWQgYnkgdXNpbmcgaW5kZXgudHMgKGJhcnJlbCkgZmlsZXMpLlxcbiAgICAgICAgICAgMi4gQ2xhc3Mgd2FzIHVzZWQgYmVmb3JlIGl0IHdhcyBkZWNsYXJlZC4gVXNlIGZvcndhcmRSZWYgaW4gdGhpcyBjYXNlLlwiKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJvdmlkZXJcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2dldEVudHJ5Q29tcG9uZW50c0Zyb21Qcm92aWRlciA9IGZ1bmN0aW9uIChwcm92aWRlciwgdHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wb25lbnRzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbGxlY3RlZElkZW50aWZpZXJzID0gW107XG4gICAgICAgIGlmIChwcm92aWRlci51c2VGYWN0b3J5IHx8IHByb3ZpZGVyLnVzZUV4aXN0aW5nIHx8IHByb3ZpZGVyLnVzZUNsYXNzKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIlRoZSBBTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTIHRva2VuIG9ubHkgc3VwcG9ydHMgdXNlVmFsdWUhXCIpLCB0eXBlKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXByb3ZpZGVyLm11bHRpKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIlRoZSBBTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTIHRva2VuIG9ubHkgc3VwcG9ydHMgJ211bHRpID0gdHJ1ZSchXCIpLCB0eXBlKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBleHRyYWN0SWRlbnRpZmllcnMocHJvdmlkZXIudXNlVmFsdWUsIGNvbGxlY3RlZElkZW50aWZpZXJzKTtcbiAgICAgICAgY29sbGVjdGVkSWRlbnRpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAoaWRlbnRpZmllcikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW50cnkgPSBfdGhpcy5fZ2V0RW50cnlDb21wb25lbnRNZXRhZGF0YShpZGVudGlmaWVyLnJlZmVyZW5jZSwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkaXJUeXBlXG4gICAgICogQHBhcmFtIHs/PX0gdGhyb3dJZk5vdEZvdW5kXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2dldEVudHJ5Q29tcG9uZW50TWV0YWRhdGEgPSBmdW5jdGlvbiAoZGlyVHlwZSwgdGhyb3dJZk5vdEZvdW5kKSB7XG4gICAgICAgIGlmICh0aHJvd0lmTm90Rm91bmQgPT09IHZvaWQgMCkgeyB0aHJvd0lmTm90Rm91bmQgPSB0cnVlOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpck1ldGEgPSB0aGlzLmdldE5vbk5vcm1hbGl6ZWREaXJlY3RpdmVNZXRhZGF0YShkaXJUeXBlKTtcbiAgICAgICAgaWYgKGRpck1ldGEgJiYgZGlyTWV0YS5tZXRhZGF0YS5pc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgY29tcG9uZW50VHlwZTogZGlyVHlwZSwgY29tcG9uZW50RmFjdG9yeTogLyoqIEB0eXBlIHs/fSAqLyAoKGRpck1ldGEubWV0YWRhdGEuY29tcG9uZW50RmFjdG9yeSkpIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlyU3VtbWFyeSA9ICh0aGlzLl9sb2FkU3VtbWFyeShkaXJUeXBlLCBDb21waWxlU3VtbWFyeUtpbmQuRGlyZWN0aXZlKSk7XG4gICAgICAgIGlmIChkaXJTdW1tYXJ5ICYmIGRpclN1bW1hcnkuaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNvbXBvbmVudFR5cGU6IGRpclR5cGUsIGNvbXBvbmVudEZhY3Rvcnk6IC8qKiBAdHlwZSB7P30gKi8gKChkaXJTdW1tYXJ5LmNvbXBvbmVudEZhY3RvcnkpKSB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aHJvd0lmTm90Rm91bmQpIHtcbiAgICAgICAgICAgIHRocm93IHN5bnRheEVycm9yKGRpclR5cGUubmFtZSArIFwiIGNhbm5vdCBiZSB1c2VkIGFzIGFuIGVudHJ5IGNvbXBvbmVudC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHByb3ZpZGVyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0UHJvdmlkZXJNZXRhZGF0YSA9IGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21waWxlRGVwcyA9ICgodW5kZWZpbmVkKSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBpbGVUeXBlTWV0YWRhdGEgPSAoKG51bGwpKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcGlsZUZhY3RvcnlNZXRhZGF0YSA9ICgobnVsbCkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b2tlbiA9IHRoaXMuX2dldFRva2VuTWV0YWRhdGEocHJvdmlkZXIudG9rZW4pO1xuICAgICAgICBpZiAocHJvdmlkZXIudXNlQ2xhc3MpIHtcbiAgICAgICAgICAgIGNvbXBpbGVUeXBlTWV0YWRhdGEgPSB0aGlzLl9nZXRJbmplY3RhYmxlTWV0YWRhdGEocHJvdmlkZXIudXNlQ2xhc3MsIHByb3ZpZGVyLmRlcGVuZGVuY2llcyk7XG4gICAgICAgICAgICBjb21waWxlRGVwcyA9IGNvbXBpbGVUeXBlTWV0YWRhdGEuZGlEZXBzO1xuICAgICAgICAgICAgaWYgKHByb3ZpZGVyLnRva2VuID09PSBwcm92aWRlci51c2VDbGFzcykge1xuICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgY29tcGlsZVR5cGVNZXRhZGF0YSBhcyBpdCBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCBsaWZlY3ljbGVIb29rcy4uLlxuICAgICAgICAgICAgICAgIHRva2VuID0geyBpZGVudGlmaWVyOiBjb21waWxlVHlwZU1ldGFkYXRhIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIudXNlRmFjdG9yeSkge1xuICAgICAgICAgICAgY29tcGlsZUZhY3RvcnlNZXRhZGF0YSA9IHRoaXMuX2dldEZhY3RvcnlNZXRhZGF0YShwcm92aWRlci51c2VGYWN0b3J5LCBwcm92aWRlci5kZXBlbmRlbmNpZXMpO1xuICAgICAgICAgICAgY29tcGlsZURlcHMgPSBjb21waWxlRmFjdG9yeU1ldGFkYXRhLmRpRGVwcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9rZW46IHRva2VuLFxuICAgICAgICAgICAgdXNlQ2xhc3M6IGNvbXBpbGVUeXBlTWV0YWRhdGEsXG4gICAgICAgICAgICB1c2VWYWx1ZTogcHJvdmlkZXIudXNlVmFsdWUsXG4gICAgICAgICAgICB1c2VGYWN0b3J5OiBjb21waWxlRmFjdG9yeU1ldGFkYXRhLFxuICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IHByb3ZpZGVyLnVzZUV4aXN0aW5nID8gdGhpcy5fZ2V0VG9rZW5NZXRhZGF0YShwcm92aWRlci51c2VFeGlzdGluZykgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBkZXBzOiBjb21waWxlRGVwcyxcbiAgICAgICAgICAgIG11bHRpOiBwcm92aWRlci5tdWx0aVxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBxdWVyaWVzXG4gICAgICogQHBhcmFtIHs/fSBpc1ZpZXdRdWVyeVxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9nZXRRdWVyaWVzTWV0YWRhdGEgPSBmdW5jdGlvbiAocXVlcmllcywgaXNWaWV3UXVlcnksIGRpcmVjdGl2ZVR5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzID0gW107XG4gICAgICAgIE9iamVjdC5rZXlzKHF1ZXJpZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5TmFtZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVlcnkgPSBxdWVyaWVzW3Byb3BlcnR5TmFtZV07XG4gICAgICAgICAgICBpZiAocXVlcnkuaXNWaWV3UXVlcnkgPT09IGlzVmlld1F1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2goX3RoaXMuX2dldFF1ZXJ5TWV0YWRhdGEocXVlcnksIHByb3BlcnR5TmFtZSwgZGlyZWN0aXZlVHlwZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0b3JcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fcXVlcnlWYXJCaW5kaW5ncyA9IGZ1bmN0aW9uIChzZWxlY3RvcikgeyByZXR1cm4gc2VsZWN0b3Iuc3BsaXQoL1xccyosXFxzKi8pOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcVxuICAgICAqIEBwYXJhbSB7P30gcHJvcGVydHlOYW1lXG4gICAgICogQHBhcmFtIHs/fSB0eXBlT3JGdW5jXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2dldFF1ZXJ5TWV0YWRhdGEgPSBmdW5jdGlvbiAocSwgcHJvcGVydHlOYW1lLCB0eXBlT3JGdW5jKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlbGVjdG9ycztcbiAgICAgICAgaWYgKHR5cGVvZiBxLnNlbGVjdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc2VsZWN0b3JzID1cbiAgICAgICAgICAgICAgICB0aGlzLl9xdWVyeVZhckJpbmRpbmdzKHEuc2VsZWN0b3IpLm1hcChmdW5jdGlvbiAodmFyTmFtZSkgeyByZXR1cm4gX3RoaXMuX2dldFRva2VuTWV0YWRhdGEodmFyTmFtZSk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFxLnNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJDYW4ndCBjb25zdHJ1Y3QgYSBxdWVyeSBmb3IgdGhlIHByb3BlcnR5IFxcXCJcIiArIHByb3BlcnR5TmFtZSArIFwiXFxcIiBvZiBcXFwiXCIgKyBzdHJpbmdpZnlUeXBlKHR5cGVPckZ1bmMpICsgXCJcXFwiIHNpbmNlIHRoZSBxdWVyeSBzZWxlY3RvciB3YXNuJ3QgZGVmaW5lZC5cIiksIHR5cGVPckZ1bmMpO1xuICAgICAgICAgICAgICAgIHNlbGVjdG9ycyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3JzID0gW3RoaXMuX2dldFRva2VuTWV0YWRhdGEocS5zZWxlY3RvcildO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZWxlY3RvcnM6IHNlbGVjdG9ycyxcbiAgICAgICAgICAgIGZpcnN0OiBxLmZpcnN0LFxuICAgICAgICAgICAgZGVzY2VuZGFudHM6IHEuZGVzY2VuZGFudHMsIHByb3BlcnR5TmFtZTogcHJvcGVydHlOYW1lLFxuICAgICAgICAgICAgcmVhZDogcS5yZWFkID8gdGhpcy5fZ2V0VG9rZW5NZXRhZGF0YShxLnJlYWQpIDogKChudWxsKSlcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gb3RoZXJUeXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX3JlcG9ydEVycm9yID0gZnVuY3Rpb24gKGVycm9yLCB0eXBlLCBvdGhlclR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Vycm9yQ29sbGVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9lcnJvckNvbGxlY3RvcihlcnJvciwgdHlwZSk7XG4gICAgICAgICAgICBpZiAob3RoZXJUeXBlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXJyb3JDb2xsZWN0b3IoZXJyb3IsIG90aGVyVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyO1xufSgpKTtcbkNvbXBpbGVNZXRhZGF0YVJlc29sdmVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21waWxlckluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkNvbXBpbGVNZXRhZGF0YVJlc29sdmVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogQ29tcGlsZXJDb25maWcsIH0sXG4gICAgeyB0eXBlOiBOZ01vZHVsZVJlc29sdmVyLCB9LFxuICAgIHsgdHlwZTogRGlyZWN0aXZlUmVzb2x2ZXIsIH0sXG4gICAgeyB0eXBlOiBQaXBlUmVzb2x2ZXIsIH0sXG4gICAgeyB0eXBlOiBTdW1tYXJ5UmVzb2x2ZXIsIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50U2NoZW1hUmVnaXN0cnksIH0sXG4gICAgeyB0eXBlOiBEaXJlY3RpdmVOb3JtYWxpemVyLCB9LFxuICAgIHsgdHlwZTogybVDb25zb2xlLCB9LFxuICAgIHsgdHlwZTogU3RhdGljU3ltYm9sQ2FjaGUsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgIHsgdHlwZTogQ29tcGlsZVJlZmxlY3RvciwgfSxcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSwgeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtFUlJPUl9DT0xMRUNUT1JfVE9LRU4sXSB9LF0gfSxcbl07IH07XG4vKipcbiAqIEBwYXJhbSB7P30gdHJlZVxuICogQHBhcmFtIHs/PX0gb3V0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBmbGF0dGVuQXJyYXkodHJlZSwgb3V0KSB7XG4gICAgaWYgKG91dCA9PT0gdm9pZCAwKSB7IG91dCA9IFtdOyB9XG4gICAgaWYgKHRyZWUpIHtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGl0ZW0gPSByZXNvbHZlRm9yd2FyZFJlZih0cmVlW2ldKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgZmxhdHRlbkFycmF5KGl0ZW0sIG91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXQucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGFycmF5XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBkZWR1cGVBcnJheShhcnJheSkge1xuICAgIGlmIChhcnJheSkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KGFycmF5KSk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSB0cmVlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBmbGF0dGVuQW5kRGVkdXBlQXJyYXkodHJlZSkge1xuICAgIHJldHVybiBkZWR1cGVBcnJheShmbGF0dGVuQXJyYXkodHJlZSkpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHZhbHVlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkVHlwZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHx8ICh2YWx1ZSBpbnN0YW5jZW9mIFR5cGUpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHZhbHVlXG4gKiBAcGFyYW0gez99IHRhcmdldElkZW50aWZpZXJzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBleHRyYWN0SWRlbnRpZmllcnModmFsdWUsIHRhcmdldElkZW50aWZpZXJzKSB7XG4gICAgdmlzaXRWYWx1ZSh2YWx1ZSwgbmV3IF9Db21waWxlVmFsdWVDb252ZXJ0ZXIoKSwgdGFyZ2V0SWRlbnRpZmllcnMpO1xufVxudmFyIF9Db21waWxlVmFsdWVDb252ZXJ0ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKF9Db21waWxlVmFsdWVDb252ZXJ0ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gX0NvbXBpbGVWYWx1ZUNvbnZlcnRlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRJZGVudGlmaWVyc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0NvbXBpbGVWYWx1ZUNvbnZlcnRlci5wcm90b3R5cGUudmlzaXRPdGhlciA9IGZ1bmN0aW9uICh2YWx1ZSwgdGFyZ2V0SWRlbnRpZmllcnMpIHtcbiAgICAgICAgdGFyZ2V0SWRlbnRpZmllcnMucHVzaCh7IHJlZmVyZW5jZTogdmFsdWUgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gX0NvbXBpbGVWYWx1ZUNvbnZlcnRlcjtcbn0oVmFsdWVUcmFuc2Zvcm1lcikpO1xuLyoqXG4gKiBAcGFyYW0gez99IHR5cGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeVR5cGUodHlwZSkge1xuICAgIGlmICh0eXBlIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSB7XG4gICAgICAgIHJldHVybiB0eXBlLm5hbWUgKyBcIiBpbiBcIiArIHR5cGUuZmlsZVBhdGg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gybVzdHJpbmdpZnkodHlwZSk7XG4gICAgfVxufVxuLyoqXG4gKiBJbmRpY2F0ZXMgdGhhdCBhIGNvbXBvbmVudCBpcyBzdGlsbCBiZWluZyBsb2FkZWQgaW4gYSBzeW5jaHJvbm91cyBjb21waWxlLlxuICogQHBhcmFtIHs/fSBjb21wVHlwZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY29tcG9uZW50U3RpbGxMb2FkaW5nRXJyb3IoY29tcFR5cGUpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvciA9IEVycm9yKFwiQ2FuJ3QgY29tcGlsZSBzeW5jaHJvbm91c2x5IGFzIFwiICsgybVzdHJpbmdpZnkoY29tcFR5cGUpICsgXCIgaXMgc3RpbGwgYmVpbmcgbG9hZGVkIVwiKTtcbiAgICAoKGVycm9yKSlbybVFUlJPUl9DT01QT05FTlRfVFlQRV0gPSBjb21wVHlwZTtcbiAgICByZXR1cm4gZXJyb3I7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgVHlwZU1vZGlmaWVyID0ge307XG5UeXBlTW9kaWZpZXIuQ29uc3QgPSAwO1xuVHlwZU1vZGlmaWVyW1R5cGVNb2RpZmllci5Db25zdF0gPSBcIkNvbnN0XCI7XG4vKipcbiAqIEBhYnN0cmFjdFxuICovXG52YXIgVHlwZSQxID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBtb2RpZmllcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUeXBlJDEobW9kaWZpZXJzKSB7XG4gICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgIHRoaXMubW9kaWZpZXJzID0gbW9kaWZpZXJzO1xuICAgICAgICBpZiAoIW1vZGlmaWVycykge1xuICAgICAgICAgICAgdGhpcy5tb2RpZmllcnMgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFR5cGUkMS5wcm90b3R5cGUudmlzaXRUeXBlID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1vZGlmaWVyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUeXBlJDEucHJvdG90eXBlLmhhc01vZGlmaWVyID0gZnVuY3Rpb24gKG1vZGlmaWVyKSB7IHJldHVybiAoKHRoaXMubW9kaWZpZXJzKSkuaW5kZXhPZihtb2RpZmllcikgIT09IC0xOyB9O1xuICAgIHJldHVybiBUeXBlJDE7XG59KCkpO1xudmFyIEJ1aWx0aW5UeXBlTmFtZSA9IHt9O1xuQnVpbHRpblR5cGVOYW1lLkR5bmFtaWMgPSAwO1xuQnVpbHRpblR5cGVOYW1lLkJvb2wgPSAxO1xuQnVpbHRpblR5cGVOYW1lLlN0cmluZyA9IDI7XG5CdWlsdGluVHlwZU5hbWUuSW50ID0gMztcbkJ1aWx0aW5UeXBlTmFtZS5OdW1iZXIgPSA0O1xuQnVpbHRpblR5cGVOYW1lLkZ1bmN0aW9uID0gNTtcbkJ1aWx0aW5UeXBlTmFtZS5JbmZlcnJlZCA9IDY7XG5CdWlsdGluVHlwZU5hbWVbQnVpbHRpblR5cGVOYW1lLkR5bmFtaWNdID0gXCJEeW5hbWljXCI7XG5CdWlsdGluVHlwZU5hbWVbQnVpbHRpblR5cGVOYW1lLkJvb2xdID0gXCJCb29sXCI7XG5CdWlsdGluVHlwZU5hbWVbQnVpbHRpblR5cGVOYW1lLlN0cmluZ10gPSBcIlN0cmluZ1wiO1xuQnVpbHRpblR5cGVOYW1lW0J1aWx0aW5UeXBlTmFtZS5JbnRdID0gXCJJbnRcIjtcbkJ1aWx0aW5UeXBlTmFtZVtCdWlsdGluVHlwZU5hbWUuTnVtYmVyXSA9IFwiTnVtYmVyXCI7XG5CdWlsdGluVHlwZU5hbWVbQnVpbHRpblR5cGVOYW1lLkZ1bmN0aW9uXSA9IFwiRnVuY3Rpb25cIjtcbkJ1aWx0aW5UeXBlTmFtZVtCdWlsdGluVHlwZU5hbWUuSW5mZXJyZWRdID0gXCJJbmZlcnJlZFwiO1xudmFyIEJ1aWx0aW5UeXBlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhCdWlsdGluVHlwZSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez89fSBtb2RpZmllcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCdWlsdGluVHlwZShuYW1lLCBtb2RpZmllcnMpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbW9kaWZpZXJzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJ1aWx0aW5UeXBlLnByb3RvdHlwZS52aXNpdFR5cGUgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEJ1aWx0aW50VHlwZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBCdWlsdGluVHlwZTtcbn0oVHlwZSQxKSk7XG52YXIgRXhwcmVzc2lvblR5cGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEV4cHJlc3Npb25UeXBlLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez89fSBtb2RpZmllcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFeHByZXNzaW9uVHlwZSh2YWx1ZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1vZGlmaWVycykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4cHJlc3Npb25UeXBlLnByb3RvdHlwZS52aXNpdFR5cGUgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEV4cHJlc3Npb25UeXBlKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEV4cHJlc3Npb25UeXBlO1xufShUeXBlJDEpKTtcbnZhciBBcnJheVR5cGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEFycmF5VHlwZSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG9mXG4gICAgICogQHBhcmFtIHs/PX0gbW9kaWZpZXJzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQXJyYXlUeXBlKG9mLCBtb2RpZmllcnMpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbW9kaWZpZXJzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vZiA9IG9mO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXJyYXlUeXBlLnByb3RvdHlwZS52aXNpdFR5cGUgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFycmF5VHlwZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBBcnJheVR5cGU7XG59KFR5cGUkMSkpO1xudmFyIE1hcFR5cGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKE1hcFR5cGUsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBtb2RpZmllcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNYXBUeXBlKHZhbHVlVHlwZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1vZGlmaWVycykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmFsdWVUeXBlID0gdmFsdWVUeXBlIHx8IG51bGw7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNYXBUeXBlLnByb3RvdHlwZS52aXNpdFR5cGUgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdE1hcFR5cGUodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIE1hcFR5cGU7XG59KFR5cGUkMSkpO1xudmFyIERZTkFNSUNfVFlQRSA9IG5ldyBCdWlsdGluVHlwZShCdWlsdGluVHlwZU5hbWUuRHluYW1pYyk7XG52YXIgSU5GRVJSRURfVFlQRSA9IG5ldyBCdWlsdGluVHlwZShCdWlsdGluVHlwZU5hbWUuSW5mZXJyZWQpO1xudmFyIEJPT0xfVFlQRSA9IG5ldyBCdWlsdGluVHlwZShCdWlsdGluVHlwZU5hbWUuQm9vbCk7XG52YXIgSU5UX1RZUEUgPSBuZXcgQnVpbHRpblR5cGUoQnVpbHRpblR5cGVOYW1lLkludCk7XG52YXIgTlVNQkVSX1RZUEUgPSBuZXcgQnVpbHRpblR5cGUoQnVpbHRpblR5cGVOYW1lLk51bWJlcik7XG52YXIgU1RSSU5HX1RZUEUgPSBuZXcgQnVpbHRpblR5cGUoQnVpbHRpblR5cGVOYW1lLlN0cmluZyk7XG52YXIgRlVOQ1RJT05fVFlQRSA9IG5ldyBCdWlsdGluVHlwZShCdWlsdGluVHlwZU5hbWUuRnVuY3Rpb24pO1xudmFyIEJpbmFyeU9wZXJhdG9yID0ge307XG5CaW5hcnlPcGVyYXRvci5FcXVhbHMgPSAwO1xuQmluYXJ5T3BlcmF0b3IuTm90RXF1YWxzID0gMTtcbkJpbmFyeU9wZXJhdG9yLklkZW50aWNhbCA9IDI7XG5CaW5hcnlPcGVyYXRvci5Ob3RJZGVudGljYWwgPSAzO1xuQmluYXJ5T3BlcmF0b3IuTWludXMgPSA0O1xuQmluYXJ5T3BlcmF0b3IuUGx1cyA9IDU7XG5CaW5hcnlPcGVyYXRvci5EaXZpZGUgPSA2O1xuQmluYXJ5T3BlcmF0b3IuTXVsdGlwbHkgPSA3O1xuQmluYXJ5T3BlcmF0b3IuTW9kdWxvID0gODtcbkJpbmFyeU9wZXJhdG9yLkFuZCA9IDk7XG5CaW5hcnlPcGVyYXRvci5PciA9IDEwO1xuQmluYXJ5T3BlcmF0b3IuTG93ZXIgPSAxMTtcbkJpbmFyeU9wZXJhdG9yLkxvd2VyRXF1YWxzID0gMTI7XG5CaW5hcnlPcGVyYXRvci5CaWdnZXIgPSAxMztcbkJpbmFyeU9wZXJhdG9yLkJpZ2dlckVxdWFscyA9IDE0O1xuQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3IuRXF1YWxzXSA9IFwiRXF1YWxzXCI7XG5CaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvci5Ob3RFcXVhbHNdID0gXCJOb3RFcXVhbHNcIjtcbkJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yLklkZW50aWNhbF0gPSBcIklkZW50aWNhbFwiO1xuQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3IuTm90SWRlbnRpY2FsXSA9IFwiTm90SWRlbnRpY2FsXCI7XG5CaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvci5NaW51c10gPSBcIk1pbnVzXCI7XG5CaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvci5QbHVzXSA9IFwiUGx1c1wiO1xuQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3IuRGl2aWRlXSA9IFwiRGl2aWRlXCI7XG5CaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvci5NdWx0aXBseV0gPSBcIk11bHRpcGx5XCI7XG5CaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvci5Nb2R1bG9dID0gXCJNb2R1bG9cIjtcbkJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yLkFuZF0gPSBcIkFuZFwiO1xuQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3IuT3JdID0gXCJPclwiO1xuQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3IuTG93ZXJdID0gXCJMb3dlclwiO1xuQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3IuTG93ZXJFcXVhbHNdID0gXCJMb3dlckVxdWFsc1wiO1xuQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3IuQmlnZ2VyXSA9IFwiQmlnZ2VyXCI7XG5CaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvci5CaWdnZXJFcXVhbHNdID0gXCJCaWdnZXJFcXVhbHNcIjtcbi8qKlxuICogQGFic3RyYWN0XG4gKi9cbnZhciBFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gRXhwcmVzc2lvbih0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbiB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUucHJvcCA9IGZ1bmN0aW9uIChuYW1lLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVhZFByb3BFeHByKHRoaXMsIG5hbWUsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbmRleFxuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5rZXkgPSBmdW5jdGlvbiAoaW5kZXgsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWFkS2V5RXhwcih0aGlzLCBpbmRleCwgdHlwZSwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmNhbGxNZXRob2QgPSBmdW5jdGlvbiAobmFtZSwgcGFyYW1zLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW52b2tlTWV0aG9kRXhwcih0aGlzLCBuYW1lLCBwYXJhbXMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5jYWxsRm4gPSBmdW5jdGlvbiAocGFyYW1zLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW52b2tlRnVuY3Rpb25FeHByKHRoaXMsIHBhcmFtcywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5pbnN0YW50aWF0ZSA9IGZ1bmN0aW9uIChwYXJhbXMsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnN0YW50aWF0ZUV4cHIodGhpcywgcGFyYW1zLCB0eXBlLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHJ1ZUNhc2VcbiAgICAgKiBAcGFyYW0gez89fSBmYWxzZUNhc2VcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5jb25kaXRpb25hbCA9IGZ1bmN0aW9uICh0cnVlQ2FzZSwgZmFsc2VDYXNlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIGlmIChmYWxzZUNhc2UgPT09IHZvaWQgMCkgeyBmYWxzZUNhc2UgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiBuZXcgQ29uZGl0aW9uYWxFeHByKHRoaXMsIHRydWVDYXNlLCBmYWxzZUNhc2UsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByaHNcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkVxdWFscywgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmhzXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUubm90RXF1YWxzID0gZnVuY3Rpb24gKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5Ob3RFcXVhbHMsIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJoc1xuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmlkZW50aWNhbCA9IGZ1bmN0aW9uIChyaHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuSWRlbnRpY2FsLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByaHNcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5ub3RJZGVudGljYWwgPSBmdW5jdGlvbiAocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLk5vdElkZW50aWNhbCwgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmhzXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUubWludXMgPSBmdW5jdGlvbiAocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLk1pbnVzLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByaHNcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5wbHVzID0gZnVuY3Rpb24gKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5QbHVzLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByaHNcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiAocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkRpdmlkZSwgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmhzXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLk11bHRpcGx5LCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByaHNcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5tb2R1bG8gPSBmdW5jdGlvbiAocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLk1vZHVsbywgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmhzXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5BbmQsIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJoc1xuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5PciwgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmhzXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUubG93ZXIgPSBmdW5jdGlvbiAocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkxvd2VyLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByaHNcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5sb3dlckVxdWFscyA9IGZ1bmN0aW9uIChyaHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuTG93ZXJFcXVhbHMsIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJoc1xuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmJpZ2dlciA9IGZ1bmN0aW9uIChyaHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuQmlnZ2VyLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByaHNcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5iaWdnZXJFcXVhbHMgPSBmdW5jdGlvbiAocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkJpZ2dlckVxdWFscywgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmlzQmxhbmsgPSBmdW5jdGlvbiAoc291cmNlU3Bhbikge1xuICAgICAgICAvLyBOb3RlOiBXZSB1c2UgZXF1YWxzIGJ5IHB1cnBvc2UgaGVyZSB0byBjb21wYXJlIHRvIG51bGwgYW5kIHVuZGVmaW5lZCBpbiBKUy5cbiAgICAgICAgLy8gV2UgdXNlIHRoZSB0eXBlZCBudWxsIHRvIGFsbG93IHN0cmljdE51bGxDaGVja3MgdG8gbmFycm93IHR5cGVzLlxuICAgICAgICByZXR1cm4gdGhpcy5lcXVhbHMoVFlQRURfTlVMTF9FWFBSLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmNhc3QgPSBmdW5jdGlvbiAodHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IENhc3RFeHByKHRoaXMsIHR5cGUsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS50b1N0bXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgRXhwcmVzc2lvblN0YXRlbWVudCh0aGlzLCBudWxsKTsgfTtcbiAgICByZXR1cm4gRXhwcmVzc2lvbjtcbn0oKSk7XG52YXIgQnVpbHRpblZhciA9IHt9O1xuQnVpbHRpblZhci5UaGlzID0gMDtcbkJ1aWx0aW5WYXIuU3VwZXIgPSAxO1xuQnVpbHRpblZhci5DYXRjaEVycm9yID0gMjtcbkJ1aWx0aW5WYXIuQ2F0Y2hTdGFjayA9IDM7XG5CdWlsdGluVmFyW0J1aWx0aW5WYXIuVGhpc10gPSBcIlRoaXNcIjtcbkJ1aWx0aW5WYXJbQnVpbHRpblZhci5TdXBlcl0gPSBcIlN1cGVyXCI7XG5CdWlsdGluVmFyW0J1aWx0aW5WYXIuQ2F0Y2hFcnJvcl0gPSBcIkNhdGNoRXJyb3JcIjtcbkJ1aWx0aW5WYXJbQnVpbHRpblZhci5DYXRjaFN0YWNrXSA9IFwiQ2F0Y2hTdGFja1wiO1xudmFyIFJlYWRWYXJFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhSZWFkVmFyRXhwciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlYWRWYXJFeHByKG5hbWUsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICBfdGhpcy5idWlsdGluID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLm5hbWUgPSBudWxsO1xuICAgICAgICAgICAgX3RoaXMuYnVpbHRpbiA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlYWRWYXJFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFJlYWRWYXJFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVhZFZhckV4cHIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMubmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQnVpbHQgaW4gdmFyaWFibGUgXCIgKyB0aGlzLmJ1aWx0aW4gKyBcIiBjYW4gbm90IGJlIGFzc2lnbmVkIHRvLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFdyaXRlVmFyRXhwcih0aGlzLm5hbWUsIHZhbHVlLCBudWxsLCB0aGlzLnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgcmV0dXJuIFJlYWRWYXJFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgV3JpdGVWYXJFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhXcml0ZVZhckV4cHIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gV3JpdGVWYXJFeHByKG5hbWUsIHZhbHVlLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUgfHwgdmFsdWUudHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBXcml0ZVZhckV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0V3JpdGVWYXJFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IG1vZGlmaWVyc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV3JpdGVWYXJFeHByLnByb3RvdHlwZS50b0RlY2xTdG10ID0gZnVuY3Rpb24gKHR5cGUsIG1vZGlmaWVycykge1xuICAgICAgICByZXR1cm4gbmV3IERlY2xhcmVWYXJTdG10KHRoaXMubmFtZSwgdGhpcy52YWx1ZSwgdHlwZSwgbW9kaWZpZXJzLCB0aGlzLnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgcmV0dXJuIFdyaXRlVmFyRXhwcjtcbn0oRXhwcmVzc2lvbikpO1xudmFyIFdyaXRlS2V5RXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoV3JpdGVLZXlFeHByLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVjZWl2ZXJcbiAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gV3JpdGVLZXlFeHByKHJlY2VpdmVyLCBpbmRleCwgdmFsdWUsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSB8fCB2YWx1ZS50eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICBfdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV3JpdGVLZXlFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFdyaXRlS2V5RXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBXcml0ZUtleUV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBXcml0ZVByb3BFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhXcml0ZVByb3BFeHByLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVjZWl2ZXJcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/PX0gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBXcml0ZVByb3BFeHByKHJlY2VpdmVyLCBuYW1lLCB2YWx1ZSwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlIHx8IHZhbHVlLnR5cGUsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV3JpdGVQcm9wRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRXcml0ZVByb3BFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFdyaXRlUHJvcEV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBCdWlsdGluTWV0aG9kID0ge307XG5CdWlsdGluTWV0aG9kLkNvbmNhdEFycmF5ID0gMDtcbkJ1aWx0aW5NZXRob2QuU3Vic2NyaWJlT2JzZXJ2YWJsZSA9IDE7XG5CdWlsdGluTWV0aG9kLkJpbmQgPSAyO1xuQnVpbHRpbk1ldGhvZFtCdWlsdGluTWV0aG9kLkNvbmNhdEFycmF5XSA9IFwiQ29uY2F0QXJyYXlcIjtcbkJ1aWx0aW5NZXRob2RbQnVpbHRpbk1ldGhvZC5TdWJzY3JpYmVPYnNlcnZhYmxlXSA9IFwiU3Vic2NyaWJlT2JzZXJ2YWJsZVwiO1xuQnVpbHRpbk1ldGhvZFtCdWlsdGluTWV0aG9kLkJpbmRdID0gXCJCaW5kXCI7XG52YXIgSW52b2tlTWV0aG9kRXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSW52b2tlTWV0aG9kRXhwciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlY2VpdmVyXG4gICAgICogQHBhcmFtIHs/fSBtZXRob2RcbiAgICAgKiBAcGFyYW0gez99IGFyZ3NcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEludm9rZU1ldGhvZEV4cHIocmVjZWl2ZXIsIG1ldGhvZCwgYXJncywgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICBfdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBfdGhpcy5uYW1lID0gbWV0aG9kO1xuICAgICAgICAgICAgX3RoaXMuYnVpbHRpbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5uYW1lID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLmJ1aWx0aW4gPSBtZXRob2Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEludm9rZU1ldGhvZEV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SW52b2tlTWV0aG9kRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBJbnZva2VNZXRob2RFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgSW52b2tlRnVuY3Rpb25FeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhJbnZva2VGdW5jdGlvbkV4cHIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEBwYXJhbSB7P30gYXJnc1xuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gSW52b2tlRnVuY3Rpb25FeHByKGZuLCBhcmdzLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmZuID0gZm47XG4gICAgICAgIF90aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSW52b2tlRnVuY3Rpb25FeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEludm9rZUZ1bmN0aW9uRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBJbnZva2VGdW5jdGlvbkV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBJbnN0YW50aWF0ZUV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEluc3RhbnRpYXRlRXhwciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNsYXNzRXhwclxuICAgICAqIEBwYXJhbSB7P30gYXJnc1xuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gSW5zdGFudGlhdGVFeHByKGNsYXNzRXhwciwgYXJncywgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jbGFzc0V4cHIgPSBjbGFzc0V4cHI7XG4gICAgICAgIF90aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSW5zdGFudGlhdGVFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEluc3RhbnRpYXRlRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBJbnN0YW50aWF0ZUV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBMaXRlcmFsRXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTGl0ZXJhbEV4cHIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTGl0ZXJhbEV4cHIodmFsdWUsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIExpdGVyYWxFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdExpdGVyYWxFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIExpdGVyYWxFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgRXh0ZXJuYWxFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhFeHRlcm5hbEV4cHIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlUGFyYW1zXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEV4dGVybmFsRXhwcih2YWx1ZSwgdHlwZSwgdHlwZVBhcmFtcywgc291cmNlU3Bhbikge1xuICAgICAgICBpZiAodHlwZVBhcmFtcyA9PT0gdm9pZCAwKSB7IHR5cGVQYXJhbXMgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIF90aGlzLnR5cGVQYXJhbXMgPSB0eXBlUGFyYW1zO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXh0ZXJuYWxFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEV4dGVybmFsRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBFeHRlcm5hbEV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBFeHRlcm5hbFJlZmVyZW5jZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtb2R1bGVOYW1lXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBydW50aW1lXG4gICAgICovXG4gICAgZnVuY3Rpb24gRXh0ZXJuYWxSZWZlcmVuY2UobW9kdWxlTmFtZSwgbmFtZSwgcnVudGltZSkge1xuICAgICAgICB0aGlzLm1vZHVsZU5hbWUgPSBtb2R1bGVOYW1lO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnJ1bnRpbWUgPSBydW50aW1lO1xuICAgIH1cbiAgICByZXR1cm4gRXh0ZXJuYWxSZWZlcmVuY2U7XG59KCkpO1xudmFyIENvbmRpdGlvbmFsRXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQ29uZGl0aW9uYWxFeHByLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29uZGl0aW9uXG4gICAgICogQHBhcmFtIHs/fSB0cnVlQ2FzZVxuICAgICAqIEBwYXJhbSB7Pz19IGZhbHNlQ2FzZVxuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29uZGl0aW9uYWxFeHByKGNvbmRpdGlvbiwgdHJ1ZUNhc2UsIGZhbHNlQ2FzZSwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICBpZiAoZmFsc2VDYXNlID09PSB2b2lkIDApIHsgZmFsc2VDYXNlID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlIHx8IHRydWVDYXNlLnR5cGUsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICAgICAgX3RoaXMuZmFsc2VDYXNlID0gZmFsc2VDYXNlO1xuICAgICAgICBfdGhpcy50cnVlQ2FzZSA9IHRydWVDYXNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29uZGl0aW9uYWxFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENvbmRpdGlvbmFsRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBDb25kaXRpb25hbEV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBOb3RFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhOb3RFeHByLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29uZGl0aW9uXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE5vdEV4cHIoY29uZGl0aW9uLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIEJPT0xfVFlQRSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTm90RXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXROb3RFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIE5vdEV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBBc3NlcnROb3ROdWxsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhBc3NlcnROb3ROdWxsLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29uZGl0aW9uXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFzc2VydE5vdE51bGwoY29uZGl0aW9uLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbmRpdGlvbi50eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3NlcnROb3ROdWxsLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFzc2VydE5vdE51bGxFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEFzc2VydE5vdE51bGw7XG59KEV4cHJlc3Npb24pKTtcbnZhciBDYXN0RXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQ2FzdEV4cHIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2FzdEV4cHIodmFsdWUsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENhc3RFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENhc3RFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIENhc3RFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgRm5QYXJhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/PX0gdHlwZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEZuUGFyYW0obmFtZSwgdHlwZSkge1xuICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgfVxuICAgIHJldHVybiBGblBhcmFtO1xufSgpKTtcbnZhciBGdW5jdGlvbkV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEZ1bmN0aW9uRXhwciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7P30gc3RhdGVtZW50c1xuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gRnVuY3Rpb25FeHByKHBhcmFtcywgc3RhdGVtZW50cywgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgIF90aGlzLnN0YXRlbWVudHMgPSBzdGF0ZW1lbnRzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRnVuY3Rpb25FeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEZ1bmN0aW9uRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7Pz19IG1vZGlmaWVyc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRnVuY3Rpb25FeHByLnByb3RvdHlwZS50b0RlY2xTdG10ID0gZnVuY3Rpb24gKG5hbWUsIG1vZGlmaWVycykge1xuICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gbmV3IERlY2xhcmVGdW5jdGlvblN0bXQobmFtZSwgdGhpcy5wYXJhbXMsIHRoaXMuc3RhdGVtZW50cywgdGhpcy50eXBlLCBtb2RpZmllcnMsIHRoaXMuc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICByZXR1cm4gRnVuY3Rpb25FeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgQmluYXJ5T3BlcmF0b3JFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhCaW5hcnlPcGVyYXRvckV4cHIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBvcGVyYXRvclxuICAgICAqIEBwYXJhbSB7P30gbGhzXG4gICAgICogQHBhcmFtIHs/fSByaHNcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJpbmFyeU9wZXJhdG9yRXhwcihvcGVyYXRvciwgbGhzLCByaHMsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSB8fCBsaHMudHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgX3RoaXMucmhzID0gcmhzO1xuICAgICAgICBfdGhpcy5saHMgPSBsaHM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5hcnlPcGVyYXRvckV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QmluYXJ5T3BlcmF0b3JFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEJpbmFyeU9wZXJhdG9yRXhwcjtcbn0oRXhwcmVzc2lvbikpO1xudmFyIFJlYWRQcm9wRXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoUmVhZFByb3BFeHByLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVjZWl2ZXJcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlYWRQcm9wRXhwcihyZWNlaXZlciwgbmFtZSwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlYWRQcm9wRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRSZWFkUHJvcEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWFkUHJvcEV4cHIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFdyaXRlUHJvcEV4cHIodGhpcy5yZWNlaXZlciwgdGhpcy5uYW1lLCB2YWx1ZSwgbnVsbCwgdGhpcy5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIHJldHVybiBSZWFkUHJvcEV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBSZWFkS2V5RXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoUmVhZEtleUV4cHIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByZWNlaXZlclxuICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlYWRLZXlFeHByKHJlY2VpdmVyLCBpbmRleCwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICBfdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVhZEtleUV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UmVhZEtleUV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWFkS2V5RXhwci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgV3JpdGVLZXlFeHByKHRoaXMucmVjZWl2ZXIsIHRoaXMuaW5kZXgsIHZhbHVlLCBudWxsLCB0aGlzLnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgcmV0dXJuIFJlYWRLZXlFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgTGl0ZXJhbEFycmF5RXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTGl0ZXJhbEFycmF5RXhwciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVudHJpZXNcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExpdGVyYWxBcnJheUV4cHIoZW50cmllcywgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5lbnRyaWVzID0gZW50cmllcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIExpdGVyYWxBcnJheUV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TGl0ZXJhbEFycmF5RXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBMaXRlcmFsQXJyYXlFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgTGl0ZXJhbE1hcEVudHJ5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGtleVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IHF1b3RlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExpdGVyYWxNYXBFbnRyeShrZXksIHZhbHVlLCBxdW90ZWQpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5xdW90ZWQgPSBxdW90ZWQ7XG4gICAgfVxuICAgIHJldHVybiBMaXRlcmFsTWFwRW50cnk7XG59KCkpO1xudmFyIExpdGVyYWxNYXBFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhMaXRlcmFsTWFwRXhwciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVudHJpZXNcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExpdGVyYWxNYXBFeHByKGVudHJpZXMsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZW50cmllcyA9IGVudHJpZXM7XG4gICAgICAgIF90aGlzLnZhbHVlVHlwZSA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICBfdGhpcy52YWx1ZVR5cGUgPSB0eXBlLnZhbHVlVHlwZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTGl0ZXJhbE1hcEV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TGl0ZXJhbE1hcEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gTGl0ZXJhbE1hcEV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBDb21tYUV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKENvbW1hRXhwciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBhcnRzXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbW1hRXhwcihwYXJ0cywgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXS50eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5wYXJ0cyA9IHBhcnRzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tbWFFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENvbW1hRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBDb21tYUV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBUSElTX0VYUFIgPSBuZXcgUmVhZFZhckV4cHIoQnVpbHRpblZhci5UaGlzLCBudWxsLCBudWxsKTtcbnZhciBTVVBFUl9FWFBSID0gbmV3IFJlYWRWYXJFeHByKEJ1aWx0aW5WYXIuU3VwZXIsIG51bGwsIG51bGwpO1xudmFyIENBVENIX0VSUk9SX1ZBUiA9IG5ldyBSZWFkVmFyRXhwcihCdWlsdGluVmFyLkNhdGNoRXJyb3IsIG51bGwsIG51bGwpO1xudmFyIENBVENIX1NUQUNLX1ZBUiA9IG5ldyBSZWFkVmFyRXhwcihCdWlsdGluVmFyLkNhdGNoU3RhY2ssIG51bGwsIG51bGwpO1xudmFyIE5VTExfRVhQUiA9IG5ldyBMaXRlcmFsRXhwcihudWxsLCBudWxsLCBudWxsKTtcbnZhciBUWVBFRF9OVUxMX0VYUFIgPSBuZXcgTGl0ZXJhbEV4cHIobnVsbCwgSU5GRVJSRURfVFlQRSwgbnVsbCk7XG52YXIgU3RtdE1vZGlmaWVyID0ge307XG5TdG10TW9kaWZpZXIuRmluYWwgPSAwO1xuU3RtdE1vZGlmaWVyLlByaXZhdGUgPSAxO1xuU3RtdE1vZGlmaWVyLkV4cG9ydGVkID0gMjtcblN0bXRNb2RpZmllcltTdG10TW9kaWZpZXIuRmluYWxdID0gXCJGaW5hbFwiO1xuU3RtdE1vZGlmaWVyW1N0bXRNb2RpZmllci5Qcml2YXRlXSA9IFwiUHJpdmF0ZVwiO1xuU3RtdE1vZGlmaWVyW1N0bXRNb2RpZmllci5FeHBvcnRlZF0gPSBcIkV4cG9ydGVkXCI7XG4vKipcbiAqIEBhYnN0cmFjdFxuICovXG52YXIgU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBtb2RpZmllcnNcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3RhdGVtZW50KG1vZGlmaWVycywgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLm1vZGlmaWVycyA9IG1vZGlmaWVycyB8fCBbXTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbiB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudC5wcm90b3R5cGUudmlzaXRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbW9kaWZpZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudC5wcm90b3R5cGUuaGFzTW9kaWZpZXIgPSBmdW5jdGlvbiAobW9kaWZpZXIpIHsgcmV0dXJuICgodGhpcy5tb2RpZmllcnMpKS5pbmRleE9mKG1vZGlmaWVyKSAhPT0gLTE7IH07XG4gICAgcmV0dXJuIFN0YXRlbWVudDtcbn0oKSk7XG52YXIgRGVjbGFyZVZhclN0bXQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKERlY2xhcmVWYXJTdG10LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gbW9kaWZpZXJzXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERlY2xhcmVWYXJTdG10KG5hbWUsIHZhbHVlLCB0eXBlLCBtb2RpZmllcnMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbW9kaWZpZXJzLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgX3RoaXMudHlwZSA9IHR5cGUgfHwgdmFsdWUudHlwZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERlY2xhcmVWYXJTdG10LnByb3RvdHlwZS52aXNpdFN0YXRlbWVudCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RGVjbGFyZVZhclN0bXQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVjbGFyZVZhclN0bXQ7XG59KFN0YXRlbWVudCkpO1xudmFyIERlY2xhcmVGdW5jdGlvblN0bXQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKERlY2xhcmVGdW5jdGlvblN0bXQsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0gez99IHN0YXRlbWVudHNcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gbW9kaWZpZXJzXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERlY2xhcmVGdW5jdGlvblN0bXQobmFtZSwgcGFyYW1zLCBzdGF0ZW1lbnRzLCB0eXBlLCBtb2RpZmllcnMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbW9kaWZpZXJzLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICBfdGhpcy5zdGF0ZW1lbnRzID0gc3RhdGVtZW50cztcbiAgICAgICAgX3RoaXMudHlwZSA9IHR5cGUgfHwgbnVsbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERlY2xhcmVGdW5jdGlvblN0bXQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXREZWNsYXJlRnVuY3Rpb25TdG10KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIERlY2xhcmVGdW5jdGlvblN0bXQ7XG59KFN0YXRlbWVudCkpO1xudmFyIEV4cHJlc3Npb25TdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEV4cHJlc3Npb25TdGF0ZW1lbnQsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHByXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEV4cHJlc3Npb25TdGF0ZW1lbnQoZXhwciwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBudWxsLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5leHByID0gZXhwcjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRFeHByZXNzaW9uU3RtdCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBFeHByZXNzaW9uU3RhdGVtZW50O1xufShTdGF0ZW1lbnQpKTtcbnZhciBSZXR1cm5TdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFJldHVyblN0YXRlbWVudCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJldHVyblN0YXRlbWVudCh2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBudWxsLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmV0dXJuU3RhdGVtZW50LnByb3RvdHlwZS52aXNpdFN0YXRlbWVudCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UmV0dXJuU3RtdCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBSZXR1cm5TdGF0ZW1lbnQ7XG59KFN0YXRlbWVudCkpO1xudmFyIEFic3RyYWN0Q2xhc3NQYXJ0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez99IG1vZGlmaWVyc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFic3RyYWN0Q2xhc3NQYXJ0KHR5cGUsIG1vZGlmaWVycykge1xuICAgICAgICB0aGlzLm1vZGlmaWVycyA9IG1vZGlmaWVycztcbiAgICAgICAgaWYgKCFtb2RpZmllcnMpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZpZXJzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50eXBlID0gdHlwZSB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1vZGlmaWVyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdENsYXNzUGFydC5wcm90b3R5cGUuaGFzTW9kaWZpZXIgPSBmdW5jdGlvbiAobW9kaWZpZXIpIHsgcmV0dXJuICgodGhpcy5tb2RpZmllcnMpKS5pbmRleE9mKG1vZGlmaWVyKSAhPT0gLTE7IH07XG4gICAgcmV0dXJuIEFic3RyYWN0Q2xhc3NQYXJ0O1xufSgpKTtcbnZhciBDbGFzc01ldGhvZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQ2xhc3NNZXRob2QsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0gez99IGJvZHlcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gbW9kaWZpZXJzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2xhc3NNZXRob2QobmFtZSwgcGFyYW1zLCBib2R5LCB0eXBlLCBtb2RpZmllcnMpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgbW9kaWZpZXJzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICBfdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ2xhc3NNZXRob2Q7XG59KEFic3RyYWN0Q2xhc3NQYXJ0KSk7XG52YXIgQ2xhc3NHZXR0ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKENsYXNzR2V0dGVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gYm9keVxuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBtb2RpZmllcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDbGFzc0dldHRlcihuYW1lLCBib2R5LCB0eXBlLCBtb2RpZmllcnMpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgbW9kaWZpZXJzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RoaXMuYm9keSA9IGJvZHk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENsYXNzR2V0dGVyO1xufShBYnN0cmFjdENsYXNzUGFydCkpO1xudmFyIENsYXNzU3RtdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQ2xhc3NTdG10LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHBhcmFtIHs/fSBmaWVsZHNcbiAgICAgKiBAcGFyYW0gez99IGdldHRlcnNcbiAgICAgKiBAcGFyYW0gez99IGNvbnN0cnVjdG9yTWV0aG9kXG4gICAgICogQHBhcmFtIHs/fSBtZXRob2RzXG4gICAgICogQHBhcmFtIHs/PX0gbW9kaWZpZXJzXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENsYXNzU3RtdChuYW1lLCBwYXJlbnQsIGZpZWxkcywgZ2V0dGVycywgY29uc3RydWN0b3JNZXRob2QsIG1ldGhvZHMsIG1vZGlmaWVycywgc291cmNlU3Bhbikge1xuICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtb2RpZmllcnMsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIF90aGlzLmZpZWxkcyA9IGZpZWxkcztcbiAgICAgICAgX3RoaXMuZ2V0dGVycyA9IGdldHRlcnM7XG4gICAgICAgIF90aGlzLmNvbnN0cnVjdG9yTWV0aG9kID0gY29uc3RydWN0b3JNZXRob2Q7XG4gICAgICAgIF90aGlzLm1ldGhvZHMgPSBtZXRob2RzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ2xhc3NTdG10LnByb3RvdHlwZS52aXNpdFN0YXRlbWVudCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RGVjbGFyZUNsYXNzU3RtdCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBDbGFzc1N0bXQ7XG59KFN0YXRlbWVudCkpO1xudmFyIElmU3RtdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSWZTdG10LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29uZGl0aW9uXG4gICAgICogQHBhcmFtIHs/fSB0cnVlQ2FzZVxuICAgICAqIEBwYXJhbSB7Pz19IGZhbHNlQ2FzZVxuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJZlN0bXQoY29uZGl0aW9uLCB0cnVlQ2FzZSwgZmFsc2VDYXNlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIGlmIChmYWxzZUNhc2UgPT09IHZvaWQgMCkgeyBmYWxzZUNhc2UgPSBbXTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBudWxsLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XG4gICAgICAgIF90aGlzLnRydWVDYXNlID0gdHJ1ZUNhc2U7XG4gICAgICAgIF90aGlzLmZhbHNlQ2FzZSA9IGZhbHNlQ2FzZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIElmU3RtdC5wcm90b3R5cGUudmlzaXRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdElmU3RtdCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBJZlN0bXQ7XG59KFN0YXRlbWVudCkpO1xudmFyIENvbW1lbnRTdG10ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhDb21tZW50U3RtdCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbW1lbnRcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tbWVudFN0bXQoY29tbWVudCwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBudWxsLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jb21tZW50ID0gY29tbWVudDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbW1lbnRTdG10LnByb3RvdHlwZS52aXNpdFN0YXRlbWVudCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q29tbWVudFN0bXQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29tbWVudFN0bXQ7XG59KFN0YXRlbWVudCkpO1xudmFyIFRyeUNhdGNoU3RtdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoVHJ5Q2F0Y2hTdG10LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYm9keVN0bXRzXG4gICAgICogQHBhcmFtIHs/fSBjYXRjaFN0bXRzXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRyeUNhdGNoU3RtdChib2R5U3RtdHMsIGNhdGNoU3RtdHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbnVsbCwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYm9keVN0bXRzID0gYm9keVN0bXRzO1xuICAgICAgICBfdGhpcy5jYXRjaFN0bXRzID0gY2F0Y2hTdG10cztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyeUNhdGNoU3RtdC5wcm90b3R5cGUudmlzaXRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFRyeUNhdGNoU3RtdCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBUcnlDYXRjaFN0bXQ7XG59KFN0YXRlbWVudCkpO1xudmFyIFRocm93U3RtdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoVGhyb3dTdG10LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gVGhyb3dTdG10KGVycm9yLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG51bGwsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaHJvd1N0bXQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRUaHJvd1N0bXQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gVGhyb3dTdG10O1xufShTdGF0ZW1lbnQpKTtcbnZhciBBc3RUcmFuc2Zvcm1lciQxID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBc3RUcmFuc2Zvcm1lciQxKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnRyYW5zZm9ybUV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY29udGV4dCkgeyByZXR1cm4gZXhwcjsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnRyYW5zZm9ybVN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkgeyByZXR1cm4gc3RtdDsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXRSZWFkVmFyRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihhc3QsIGNvbnRleHQpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXRXcml0ZVZhckV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKG5ldyBXcml0ZVZhckV4cHIoZXhwci5uYW1lLCBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgZXhwci50eXBlLCBleHByLnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXRXcml0ZUtleUV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKG5ldyBXcml0ZUtleUV4cHIoZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGV4cHIuaW5kZXgudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgZXhwci50eXBlLCBleHByLnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXRXcml0ZVByb3BFeHByID0gZnVuY3Rpb24gKGV4cHIsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihuZXcgV3JpdGVQcm9wRXhwcihleHByLnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgZXhwci5uYW1lLCBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgZXhwci50eXBlLCBleHByLnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdEludm9rZU1ldGhvZEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1ldGhvZCA9IGFzdC5idWlsdGluIHx8IGFzdC5uYW1lO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKG5ldyBJbnZva2VNZXRob2RFeHByKGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIC8qKiBAdHlwZSB7P30gKi8gKChtZXRob2QpKSwgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5hcmdzLCBjb250ZXh0KSwgYXN0LnR5cGUsIGFzdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXRJbnZva2VGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUV4cHIobmV3IEludm9rZUZ1bmN0aW9uRXhwcihhc3QuZm4udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGNvbnRleHQpLCBhc3QudHlwZSwgYXN0LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdEluc3RhbnRpYXRlRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihuZXcgSW5zdGFudGlhdGVFeHByKGFzdC5jbGFzc0V4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGNvbnRleHQpLCBhc3QudHlwZSwgYXN0LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdExpdGVyYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKGFzdCwgY29udGV4dCk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0RXh0ZXJuYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKGFzdCwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXRDb25kaXRpb25hbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUV4cHIobmV3IENvbmRpdGlvbmFsRXhwcihhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgYXN0LnRydWVDYXNlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgLyoqIEB0eXBlIHs/fSAqLyAoKGFzdC5mYWxzZUNhc2UpKS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC50eXBlLCBhc3Quc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0Tm90RXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihuZXcgTm90RXhwcihhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgYXN0LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdEFzc2VydE5vdE51bGxFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKG5ldyBBc3NlcnROb3ROdWxsKGFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBhc3Quc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0Q2FzdEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUV4cHIobmV3IENhc3RFeHByKGFzdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC50eXBlLCBhc3Quc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25FeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKG5ldyBGdW5jdGlvbkV4cHIoYXN0LnBhcmFtcywgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoYXN0LnN0YXRlbWVudHMsIGNvbnRleHQpLCBhc3QudHlwZSwgYXN0LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdEJpbmFyeU9wZXJhdG9yRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihuZXcgQmluYXJ5T3BlcmF0b3JFeHByKGFzdC5vcGVyYXRvciwgYXN0Lmxocy52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC5yaHMudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBhc3QudHlwZSwgYXN0LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdFJlYWRQcm9wRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihuZXcgUmVhZFByb3BFeHByKGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC5uYW1lLCBhc3QudHlwZSwgYXN0LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdFJlYWRLZXlFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKG5ldyBSZWFkS2V5RXhwcihhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBhc3QuaW5kZXgudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBhc3QudHlwZSwgYXN0LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUV4cHIobmV3IExpdGVyYWxBcnJheUV4cHIodGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5lbnRyaWVzLCBjb250ZXh0KSwgYXN0LnR5cGUsIGFzdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXRMaXRlcmFsTWFwRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW50cmllcyA9IGFzdC5lbnRyaWVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIG5ldyBMaXRlcmFsTWFwRW50cnkoZW50cnkua2V5LCBlbnRyeS52YWx1ZS52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGNvbnRleHQpLCBlbnRyeS5xdW90ZWQpOyB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWFwVHlwZSA9IG5ldyBNYXBUeXBlKGFzdC52YWx1ZVR5cGUsIG51bGwpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKG5ldyBMaXRlcmFsTWFwRXhwcihlbnRyaWVzLCBtYXBUeXBlLCBhc3Quc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0Q29tbWFFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKG5ldyBDb21tYUV4cHIodGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5wYXJ0cywgY29udGV4dCksIGFzdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cHJzXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdEFsbEV4cHJlc3Npb25zID0gZnVuY3Rpb24gKGV4cHJzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBleHBycy5tYXAoZnVuY3Rpb24gKGV4cHIpIHsgcmV0dXJuIGV4cHIudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0RGVjbGFyZVZhclN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1TdG10KG5ldyBEZWNsYXJlVmFyU3RtdChzdG10Lm5hbWUsIHN0bXQudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBzdG10LnR5cGUsIHN0bXQubW9kaWZpZXJzLCBzdG10LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXREZWNsYXJlRnVuY3Rpb25TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtU3RtdChuZXcgRGVjbGFyZUZ1bmN0aW9uU3RtdChzdG10Lm5hbWUsIHN0bXQucGFyYW1zLCB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LnN0YXRlbWVudHMsIGNvbnRleHQpLCBzdG10LnR5cGUsIHN0bXQubW9kaWZpZXJzLCBzdG10LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybVN0bXQobmV3IEV4cHJlc3Npb25TdGF0ZW1lbnQoc3RtdC5leHByLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgc3RtdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0UmV0dXJuU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybVN0bXQobmV3IFJldHVyblN0YXRlbWVudChzdG10LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgc3RtdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0RGVjbGFyZUNsYXNzU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmVudCA9ICgoc3RtdC5wYXJlbnQpKS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGdldHRlcnMgPSBzdG10LmdldHRlcnMubWFwKGZ1bmN0aW9uIChnZXR0ZXIpIHsgcmV0dXJuIG5ldyBDbGFzc0dldHRlcihnZXR0ZXIubmFtZSwgX3RoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKGdldHRlci5ib2R5LCBjb250ZXh0KSwgZ2V0dGVyLnR5cGUsIGdldHRlci5tb2RpZmllcnMpOyB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3Rvck1ldGhvZCA9IHN0bXQuY29uc3RydWN0b3JNZXRob2QgJiZcbiAgICAgICAgICAgIG5ldyBDbGFzc01ldGhvZChzdG10LmNvbnN0cnVjdG9yTWV0aG9kLm5hbWUsIHN0bXQuY29uc3RydWN0b3JNZXRob2QucGFyYW1zLCB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmNvbnN0cnVjdG9yTWV0aG9kLmJvZHksIGNvbnRleHQpLCBzdG10LmNvbnN0cnVjdG9yTWV0aG9kLnR5cGUsIHN0bXQuY29uc3RydWN0b3JNZXRob2QubW9kaWZpZXJzKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWV0aG9kcyA9IHN0bXQubWV0aG9kcy5tYXAoZnVuY3Rpb24gKG1ldGhvZCkgeyByZXR1cm4gbmV3IENsYXNzTWV0aG9kKG1ldGhvZC5uYW1lLCBtZXRob2QucGFyYW1zLCBfdGhpcy52aXNpdEFsbFN0YXRlbWVudHMobWV0aG9kLmJvZHksIGNvbnRleHQpLCBtZXRob2QudHlwZSwgbWV0aG9kLm1vZGlmaWVycyk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1TdG10KG5ldyBDbGFzc1N0bXQoc3RtdC5uYW1lLCBwYXJlbnQsIHN0bXQuZmllbGRzLCBnZXR0ZXJzLCBjdG9yTWV0aG9kLCBtZXRob2RzLCBzdG10Lm1vZGlmaWVycywgc3RtdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0SWZTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtU3RtdChuZXcgSWZTdG10KHN0bXQuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC50cnVlQ2FzZSwgY29udGV4dCksIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuZmFsc2VDYXNlLCBjb250ZXh0KSwgc3RtdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0VHJ5Q2F0Y2hTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtU3RtdChuZXcgVHJ5Q2F0Y2hTdG10KHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuYm9keVN0bXRzLCBjb250ZXh0KSwgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5jYXRjaFN0bXRzLCBjb250ZXh0KSwgc3RtdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0VGhyb3dTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtU3RtdChuZXcgVGhyb3dTdG10KHN0bXQuZXJyb3IudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBzdG10LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXRDb21tZW50U3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybVN0bXQoc3RtdCwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRzXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdEFsbFN0YXRlbWVudHMgPSBmdW5jdGlvbiAoc3RtdHMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHN0bXRzLm1hcChmdW5jdGlvbiAoc3RtdCkgeyByZXR1cm4gc3RtdC52aXNpdFN0YXRlbWVudChfdGhpcywgY29udGV4dCk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEFzdFRyYW5zZm9ybWVyJDE7XG59KCkpO1xudmFyIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVjdXJzaXZlQXN0VmlzaXRvciQxKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdFJlYWRWYXJFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gYXN0OyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdFdyaXRlVmFyRXhwciA9IGZ1bmN0aW9uIChleHByLCBjb250ZXh0KSB7XG4gICAgICAgIGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdFdyaXRlS2V5RXhwciA9IGZ1bmN0aW9uIChleHByLCBjb250ZXh0KSB7XG4gICAgICAgIGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBleHByLmluZGV4LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHByXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0V3JpdGVQcm9wRXhwciA9IGZ1bmN0aW9uIChleHByLCBjb250ZXh0KSB7XG4gICAgICAgIGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdEludm9rZU1ldGhvZEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuYXJncywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdEludm9rZUZ1bmN0aW9uRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LmZuLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0SW5zdGFudGlhdGVFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QuY2xhc3NFeHByLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBhc3Q7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRFeHRlcm5hbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBhc3Q7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRDb25kaXRpb25hbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBhc3QudHJ1ZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpOyAvKiogQHR5cGUgez99ICovXG4gICAgICAgICgoYXN0LmZhbHNlQ2FzZSkpLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0Tm90RXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdEFzc2VydE5vdE51bGxFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0Q2FzdEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdEZ1bmN0aW9uRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoYXN0LnN0YXRlbWVudHMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRCaW5hcnlPcGVyYXRvckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5saHMudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBhc3QucmhzLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0UmVhZFByb3BFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRSZWFkS2V5RXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgYXN0LmluZGV4LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5RXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5lbnRyaWVzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0TGl0ZXJhbE1hcEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGFzdC5lbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBlbnRyeS52YWx1ZS52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0Q29tbWFFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LnBhcnRzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwcnNcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRBbGxFeHByZXNzaW9ucyA9IGZ1bmN0aW9uIChleHBycywgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBleHBycy5mb3JFYWNoKGZ1bmN0aW9uIChleHByKSB7IHJldHVybiBleHByLnZpc2l0RXhwcmVzc2lvbihfdGhpcywgY29udGV4dCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0RGVjbGFyZVZhclN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICBzdG10LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXREZWNsYXJlRnVuY3Rpb25TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5zdGF0ZW1lbnRzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHN0bXQuZXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBzdG10O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0UmV0dXJuU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHN0bXQudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gc3RtdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdERlY2xhcmVDbGFzc1N0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAoKHN0bXQucGFyZW50KSkudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBzdG10LmdldHRlcnMuZm9yRWFjaChmdW5jdGlvbiAoZ2V0dGVyKSB7IHJldHVybiBfdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoZ2V0dGVyLmJvZHksIGNvbnRleHQpOyB9KTtcbiAgICAgICAgaWYgKHN0bXQuY29uc3RydWN0b3JNZXRob2QpIHtcbiAgICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuY29uc3RydWN0b3JNZXRob2QuYm9keSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RtdC5tZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkgeyByZXR1cm4gX3RoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKG1ldGhvZC5ib2R5LCBjb250ZXh0KTsgfSk7XG4gICAgICAgIHJldHVybiBzdG10O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0SWZTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgc3RtdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LnRydWVDYXNlLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5mYWxzZUNhc2UsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gc3RtdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdFRyeUNhdGNoU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuYm9keVN0bXRzLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5jYXRjaFN0bXRzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRUaHJvd1N0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICBzdG10LmVycm9yLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRDb21tZW50U3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7IHJldHVybiBzdG10OyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdHNcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRBbGxTdGF0ZW1lbnRzID0gZnVuY3Rpb24gKHN0bXRzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHN0bXRzLmZvckVhY2goZnVuY3Rpb24gKHN0bXQpIHsgcmV0dXJuIHN0bXQudmlzaXRTdGF0ZW1lbnQoX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBSZWN1cnNpdmVBc3RWaXNpdG9yJDE7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IHN0bXRzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBmaW5kUmVhZFZhck5hbWVzKHN0bXRzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlzaXRvciA9IG5ldyBfUmVhZFZhclZpc2l0b3IoKTtcbiAgICB2aXNpdG9yLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10cywgbnVsbCk7XG4gICAgcmV0dXJuIHZpc2l0b3IudmFyTmFtZXM7XG59XG52YXIgX1JlYWRWYXJWaXNpdG9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhfUmVhZFZhclZpc2l0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gX1JlYWRWYXJWaXNpdG9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52YXJOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9SZWFkVmFyVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlRnVuY3Rpb25TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgLy8gRG9uJ3QgZGVzY2VuZCBpbnRvIG5lc3RlZCBmdW5jdGlvbnNcbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9SZWFkVmFyVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlQ2xhc3NTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgLy8gRG9uJ3QgZGVzY2VuZCBpbnRvIG5lc3RlZCBjbGFzc2VzXG4gICAgICAgIHJldHVybiBzdG10O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9SZWFkVmFyVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZWFkVmFyRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGFzdC5uYW1lKSB7XG4gICAgICAgICAgICB0aGlzLnZhck5hbWVzLmFkZChhc3QubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gX1JlYWRWYXJWaXNpdG9yO1xufShSZWN1cnNpdmVBc3RWaXNpdG9yJDEpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBzdG10XG4gKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGFwcGx5U291cmNlU3BhblRvU3RhdGVtZW50SWZOZWVkZWQoc3RtdCwgc291cmNlU3Bhbikge1xuICAgIGlmICghc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gc3RtdDtcbiAgICB9XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNmb3JtZXIgPSBuZXcgX0FwcGx5U291cmNlU3BhblRyYW5zZm9ybWVyKHNvdXJjZVNwYW4pO1xuICAgIHJldHVybiBzdG10LnZpc2l0U3RhdGVtZW50KHRyYW5zZm9ybWVyLCBudWxsKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBleHByXG4gKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGFwcGx5U291cmNlU3BhblRvRXhwcmVzc2lvbklmTmVlZGVkKGV4cHIsIHNvdXJjZVNwYW4pIHtcbiAgICBpZiAoIXNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zZm9ybWVyID0gbmV3IF9BcHBseVNvdXJjZVNwYW5UcmFuc2Zvcm1lcihzb3VyY2VTcGFuKTtcbiAgICByZXR1cm4gZXhwci52aXNpdEV4cHJlc3Npb24odHJhbnNmb3JtZXIsIG51bGwpO1xufVxudmFyIF9BcHBseVNvdXJjZVNwYW5UcmFuc2Zvcm1lciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoX0FwcGx5U291cmNlU3BhblRyYW5zZm9ybWVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9BcHBseVNvdXJjZVNwYW5UcmFuc2Zvcm1lcihzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gb2JqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQXBwbHlTb3VyY2VTcGFuVHJhbnNmb3JtZXIucHJvdG90eXBlLl9jbG9uZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xvbmUgPSBPYmplY3QuY3JlYXRlKG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICBjbG9uZVtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9BcHBseVNvdXJjZVNwYW5UcmFuc2Zvcm1lci5wcm90b3R5cGUudHJhbnNmb3JtRXhwciA9IGZ1bmN0aW9uIChleHByLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghZXhwci5zb3VyY2VTcGFuKSB7XG4gICAgICAgICAgICBleHByID0gdGhpcy5fY2xvbmUoZXhwcik7XG4gICAgICAgICAgICBleHByLnNvdXJjZVNwYW4gPSB0aGlzLnNvdXJjZVNwYW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9BcHBseVNvdXJjZVNwYW5UcmFuc2Zvcm1lci5wcm90b3R5cGUudHJhbnNmb3JtU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghc3RtdC5zb3VyY2VTcGFuKSB7XG4gICAgICAgICAgICBzdG10ID0gdGhpcy5fY2xvbmUoc3RtdCk7XG4gICAgICAgICAgICBzdG10LnNvdXJjZVNwYW4gPSB0aGlzLnNvdXJjZVNwYW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfTtcbiAgICByZXR1cm4gX0FwcGx5U291cmNlU3BhblRyYW5zZm9ybWVyO1xufShBc3RUcmFuc2Zvcm1lciQxKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gbmFtZVxuICogQHBhcmFtIHs/PX0gdHlwZVxuICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdmFyaWFibGUobmFtZSwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgIHJldHVybiBuZXcgUmVhZFZhckV4cHIobmFtZSwgdHlwZSwgc291cmNlU3Bhbik7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gaWRcbiAqIEBwYXJhbSB7Pz19IHR5cGVQYXJhbXNcbiAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGltcG9ydEV4cHIoaWQsIHR5cGVQYXJhbXMsIHNvdXJjZVNwYW4pIHtcbiAgICBpZiAodHlwZVBhcmFtcyA9PT0gdm9pZCAwKSB7IHR5cGVQYXJhbXMgPSBudWxsOyB9XG4gICAgcmV0dXJuIG5ldyBFeHRlcm5hbEV4cHIoaWQsIG51bGwsIHR5cGVQYXJhbXMsIHNvdXJjZVNwYW4pO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGlkXG4gKiBAcGFyYW0gez89fSB0eXBlUGFyYW1zXG4gKiBAcGFyYW0gez89fSB0eXBlTW9kaWZpZXJzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpbXBvcnRUeXBlKGlkLCB0eXBlUGFyYW1zLCB0eXBlTW9kaWZpZXJzKSB7XG4gICAgaWYgKHR5cGVQYXJhbXMgPT09IHZvaWQgMCkgeyB0eXBlUGFyYW1zID0gbnVsbDsgfVxuICAgIGlmICh0eXBlTW9kaWZpZXJzID09PSB2b2lkIDApIHsgdHlwZU1vZGlmaWVycyA9IG51bGw7IH1cbiAgICByZXR1cm4gaWQgIT0gbnVsbCA/IGV4cHJlc3Npb25UeXBlKGltcG9ydEV4cHIoaWQsIHR5cGVQYXJhbXMsIG51bGwpLCB0eXBlTW9kaWZpZXJzKSA6IG51bGw7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZXhwclxuICogQHBhcmFtIHs/PX0gdHlwZU1vZGlmaWVyc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZXhwcmVzc2lvblR5cGUoZXhwciwgdHlwZU1vZGlmaWVycykge1xuICAgIGlmICh0eXBlTW9kaWZpZXJzID09PSB2b2lkIDApIHsgdHlwZU1vZGlmaWVycyA9IG51bGw7IH1cbiAgICByZXR1cm4gZXhwciAhPSBudWxsID8gKChuZXcgRXhwcmVzc2lvblR5cGUoZXhwciwgdHlwZU1vZGlmaWVycykpKSA6IG51bGw7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdmFsdWVzXG4gKiBAcGFyYW0gez89fSB0eXBlXG4gKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBsaXRlcmFsQXJyKHZhbHVlcywgdHlwZSwgc291cmNlU3Bhbikge1xuICAgIHJldHVybiBuZXcgTGl0ZXJhbEFycmF5RXhwcih2YWx1ZXMsIHR5cGUsIHNvdXJjZVNwYW4pO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHZhbHVlc1xuICogQHBhcmFtIHs/PX0gdHlwZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gbGl0ZXJhbE1hcCh2YWx1ZXMsIHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgcmV0dXJuIG5ldyBMaXRlcmFsTWFwRXhwcih2YWx1ZXMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBuZXcgTGl0ZXJhbE1hcEVudHJ5KGUua2V5LCBlLnZhbHVlLCBlLnF1b3RlZCk7IH0pLCB0eXBlLCBudWxsKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBleHByXG4gKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBub3QoZXhwciwgc291cmNlU3Bhbikge1xuICAgIHJldHVybiBuZXcgTm90RXhwcihleHByLCBzb3VyY2VTcGFuKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBleHByXG4gKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBhc3NlcnROb3ROdWxsKGV4cHIsIHNvdXJjZVNwYW4pIHtcbiAgICByZXR1cm4gbmV3IEFzc2VydE5vdE51bGwoZXhwciwgc291cmNlU3Bhbik7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gcGFyYW1zXG4gKiBAcGFyYW0gez99IGJvZHlcbiAqIEBwYXJhbSB7Pz19IHR5cGVcbiAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGZuKHBhcmFtcywgYm9keSwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb25FeHByKHBhcmFtcywgYm9keSwgdHlwZSwgc291cmNlU3Bhbik7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdmFsdWVcbiAqIEBwYXJhbSB7Pz19IHR5cGVcbiAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGxpdGVyYWwodmFsdWUsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICByZXR1cm4gbmV3IExpdGVyYWxFeHByKHZhbHVlLCB0eXBlLCBzb3VyY2VTcGFuKTtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBRVU9URURfS0VZUyA9ICckcXVvdGVkJCc7XG4vKipcbiAqIEBwYXJhbSB7P30gY3R4XG4gKiBAcGFyYW0gez99IHZhbHVlXG4gKiBAcGFyYW0gez89fSB0eXBlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjb252ZXJ0VmFsdWVUb091dHB1dEFzdChjdHgsIHZhbHVlLCB0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgIHJldHVybiB2aXNpdFZhbHVlKHZhbHVlLCBuZXcgX1ZhbHVlT3V0cHV0QXN0VHJhbnNmb3JtZXIoY3R4KSwgdHlwZSk7XG59XG52YXIgX1ZhbHVlT3V0cHV0QXN0VHJhbnNmb3JtZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICovXG4gICAgZnVuY3Rpb24gX1ZhbHVlT3V0cHV0QXN0VHJhbnNmb3JtZXIoY3R4KSB7XG4gICAgICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFyclxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1ZhbHVlT3V0cHV0QXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0QXJyYXkgPSBmdW5jdGlvbiAoYXJyLCB0eXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBsaXRlcmFsQXJyKGFyci5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2aXNpdFZhbHVlKHZhbHVlLCBfdGhpcywgbnVsbCk7IH0pLCB0eXBlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWFwXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmFsdWVPdXRwdXRBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRTdHJpbmdNYXAgPSBmdW5jdGlvbiAobWFwLCB0eXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVudHJpZXMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVvdGVkU2V0ID0gbmV3IFNldChtYXAgJiYgbWFwW1FVT1RFRF9LRVlTXSk7XG4gICAgICAgIE9iamVjdC5rZXlzKG1hcCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBlbnRyaWVzLnB1c2gobmV3IExpdGVyYWxNYXBFbnRyeShrZXksIHZpc2l0VmFsdWUobWFwW2tleV0sIF90aGlzLCBudWxsKSwgcXVvdGVkU2V0LmhhcyhrZXkpKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxNYXBFeHByKGVudHJpZXMsIHR5cGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1ZhbHVlT3V0cHV0QXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0UHJpbWl0aXZlID0gZnVuY3Rpb24gKHZhbHVlLCB0eXBlKSB7IHJldHVybiBsaXRlcmFsKHZhbHVlLCB0eXBlKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmFsdWVPdXRwdXRBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRPdGhlciA9IGZ1bmN0aW9uICh2YWx1ZSwgdHlwZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdHguaW1wb3J0RXhwcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBfVmFsdWVPdXRwdXRBc3RUcmFuc2Zvcm1lcjtcbn0oKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEBwYXJhbSB7P30gY3R4XG4gKiBAcGFyYW0gez99IHByb3ZpZGVyQXN0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBwcm92aWRlckRlZihjdHgsIHByb3ZpZGVyQXN0KSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmxhZ3MgPSAwO1xuICAgIGlmICghcHJvdmlkZXJBc3QuZWFnZXIpIHtcbiAgICAgICAgZmxhZ3MgfD0gNDA5NiAvKiBMYXp5UHJvdmlkZXIgKi87XG4gICAgfVxuICAgIGlmIChwcm92aWRlckFzdC5wcm92aWRlclR5cGUgPT09IFByb3ZpZGVyQXN0VHlwZS5Qcml2YXRlU2VydmljZSkge1xuICAgICAgICBmbGFncyB8PSA4MTkyIC8qIFByaXZhdGVQcm92aWRlciAqLztcbiAgICB9XG4gICAgcHJvdmlkZXJBc3QubGlmZWN5Y2xlSG9va3MuZm9yRWFjaChmdW5jdGlvbiAobGlmZWN5Y2xlSG9vaykge1xuICAgICAgICAvLyBmb3IgcmVndWxhciBwcm92aWRlcnMsIHdlIG9ubHkgc3VwcG9ydCBuZ09uRGVzdHJveVxuICAgICAgICBpZiAobGlmZWN5Y2xlSG9vayA9PT0gTGlmZWN5Y2xlSG9va3MuT25EZXN0cm95IHx8XG4gICAgICAgICAgICBwcm92aWRlckFzdC5wcm92aWRlclR5cGUgPT09IFByb3ZpZGVyQXN0VHlwZS5EaXJlY3RpdmUgfHxcbiAgICAgICAgICAgIHByb3ZpZGVyQXN0LnByb3ZpZGVyVHlwZSA9PT0gUHJvdmlkZXJBc3RUeXBlLkNvbXBvbmVudCkge1xuICAgICAgICAgICAgZmxhZ3MgfD0gbGlmZWN5Y2xlSG9va1RvTm9kZUZsYWcobGlmZWN5Y2xlSG9vayk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgX2EgPSBwcm92aWRlckFzdC5tdWx0aVByb3ZpZGVyID9cbiAgICAgICAgbXVsdGlQcm92aWRlckRlZihjdHgsIGZsYWdzLCBwcm92aWRlckFzdC5wcm92aWRlcnMpIDpcbiAgICAgICAgc2luZ2xlUHJvdmlkZXJEZWYoY3R4LCBmbGFncywgcHJvdmlkZXJBc3QucHJvdmlkZXJUeXBlLCBwcm92aWRlckFzdC5wcm92aWRlcnNbMF0pLCBwcm92aWRlckV4cHIgPSBfYS5wcm92aWRlckV4cHIsIHByb3ZpZGVyRmxhZ3MgPSBfYS5mbGFncywgZGVwc0V4cHIgPSBfYS5kZXBzRXhwcjtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcm92aWRlckV4cHI6IHByb3ZpZGVyRXhwcixcbiAgICAgICAgZmxhZ3M6IHByb3ZpZGVyRmxhZ3MsIGRlcHNFeHByOiBkZXBzRXhwcixcbiAgICAgICAgdG9rZW5FeHByOiB0b2tlbkV4cHIoY3R4LCBwcm92aWRlckFzdC50b2tlbiksXG4gICAgfTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBjdHhcbiAqIEBwYXJhbSB7P30gZmxhZ3NcbiAqIEBwYXJhbSB7P30gcHJvdmlkZXJzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBtdWx0aVByb3ZpZGVyRGVmKGN0eCwgZmxhZ3MsIHByb3ZpZGVycykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGFsbERlcERlZnMgPSBbXTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbGxQYXJhbXMgPSBbXTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHBycyA9IHByb3ZpZGVycy5tYXAoZnVuY3Rpb24gKHByb3ZpZGVyLCBwcm92aWRlckluZGV4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cHI7XG4gICAgICAgIGlmIChwcm92aWRlci51c2VDbGFzcykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVwRXhwcnMgPSBjb252ZXJ0RGVwcyhwcm92aWRlckluZGV4LCBwcm92aWRlci5kZXBzIHx8IHByb3ZpZGVyLnVzZUNsYXNzLmRpRGVwcyk7XG4gICAgICAgICAgICBleHByID0gY3R4LmltcG9ydEV4cHIocHJvdmlkZXIudXNlQ2xhc3MucmVmZXJlbmNlKS5pbnN0YW50aWF0ZShkZXBFeHBycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIudXNlRmFjdG9yeSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVwRXhwcnMgPSBjb252ZXJ0RGVwcyhwcm92aWRlckluZGV4LCBwcm92aWRlci5kZXBzIHx8IHByb3ZpZGVyLnVzZUZhY3RvcnkuZGlEZXBzKTtcbiAgICAgICAgICAgIGV4cHIgPSBjdHguaW1wb3J0RXhwcihwcm92aWRlci51c2VGYWN0b3J5LnJlZmVyZW5jZSkuY2FsbEZuKGRlcEV4cHJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm92aWRlci51c2VFeGlzdGluZykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVwRXhwcnMgPSBjb252ZXJ0RGVwcyhwcm92aWRlckluZGV4LCBbeyB0b2tlbjogcHJvdmlkZXIudXNlRXhpc3RpbmcgfV0pO1xuICAgICAgICAgICAgZXhwciA9IGRlcEV4cHJzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXhwciA9IGNvbnZlcnRWYWx1ZVRvT3V0cHV0QXN0KGN0eCwgcHJvdmlkZXIudXNlVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH0pO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb3ZpZGVyRXhwciA9IGZuKGFsbFBhcmFtcywgW25ldyBSZXR1cm5TdGF0ZW1lbnQobGl0ZXJhbEFycihleHBycykpXSwgSU5GRVJSRURfVFlQRSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvdmlkZXJFeHByOiBwcm92aWRlckV4cHIsXG4gICAgICAgIGZsYWdzOiBmbGFncyB8IDEwMjQgLyogVHlwZUZhY3RvcnlQcm92aWRlciAqLyxcbiAgICAgICAgZGVwc0V4cHI6IGxpdGVyYWxBcnIoYWxsRGVwRGVmcylcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJvdmlkZXJJbmRleFxuICAgICAqIEBwYXJhbSB7P30gZGVwc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gY29udmVydERlcHMocHJvdmlkZXJJbmRleCwgZGVwcykge1xuICAgICAgICByZXR1cm4gZGVwcy5tYXAoZnVuY3Rpb24gKGRlcCwgZGVwSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmFtTmFtZSA9IFwicFwiICsgcHJvdmlkZXJJbmRleCArIFwiX1wiICsgZGVwSW5kZXg7XG4gICAgICAgICAgICBhbGxQYXJhbXMucHVzaChuZXcgRm5QYXJhbShwYXJhbU5hbWUsIERZTkFNSUNfVFlQRSkpO1xuICAgICAgICAgICAgYWxsRGVwRGVmcy5wdXNoKGRlcERlZihjdHgsIGRlcCkpO1xuICAgICAgICAgICAgcmV0dXJuIHZhcmlhYmxlKHBhcmFtTmFtZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogQHBhcmFtIHs/fSBjdHhcbiAqIEBwYXJhbSB7P30gZmxhZ3NcbiAqIEBwYXJhbSB7P30gcHJvdmlkZXJUeXBlXG4gKiBAcGFyYW0gez99IHByb3ZpZGVyTWV0YVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc2luZ2xlUHJvdmlkZXJEZWYoY3R4LCBmbGFncywgcHJvdmlkZXJUeXBlLCBwcm92aWRlck1ldGEpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm92aWRlckV4cHI7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVwcztcbiAgICBpZiAocHJvdmlkZXJUeXBlID09PSBQcm92aWRlckFzdFR5cGUuRGlyZWN0aXZlIHx8IHByb3ZpZGVyVHlwZSA9PT0gUHJvdmlkZXJBc3RUeXBlLkNvbXBvbmVudCkge1xuICAgICAgICBwcm92aWRlckV4cHIgPSBjdHguaW1wb3J0RXhwcigvKiogQHR5cGUgez99ICovICgocHJvdmlkZXJNZXRhLnVzZUNsYXNzKSkucmVmZXJlbmNlKTtcbiAgICAgICAgZmxhZ3MgfD0gMTYzODQgLyogVHlwZURpcmVjdGl2ZSAqLztcbiAgICAgICAgZGVwcyA9IHByb3ZpZGVyTWV0YS5kZXBzIHx8ICgocHJvdmlkZXJNZXRhLnVzZUNsYXNzKSkuZGlEZXBzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHByb3ZpZGVyTWV0YS51c2VDbGFzcykge1xuICAgICAgICAgICAgcHJvdmlkZXJFeHByID0gY3R4LmltcG9ydEV4cHIocHJvdmlkZXJNZXRhLnVzZUNsYXNzLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICBmbGFncyB8PSA1MTIgLyogVHlwZUNsYXNzUHJvdmlkZXIgKi87XG4gICAgICAgICAgICBkZXBzID0gcHJvdmlkZXJNZXRhLmRlcHMgfHwgcHJvdmlkZXJNZXRhLnVzZUNsYXNzLmRpRGVwcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm92aWRlck1ldGEudXNlRmFjdG9yeSkge1xuICAgICAgICAgICAgcHJvdmlkZXJFeHByID0gY3R4LmltcG9ydEV4cHIocHJvdmlkZXJNZXRhLnVzZUZhY3RvcnkucmVmZXJlbmNlKTtcbiAgICAgICAgICAgIGZsYWdzIHw9IDEwMjQgLyogVHlwZUZhY3RvcnlQcm92aWRlciAqLztcbiAgICAgICAgICAgIGRlcHMgPSBwcm92aWRlck1ldGEuZGVwcyB8fCBwcm92aWRlck1ldGEudXNlRmFjdG9yeS5kaURlcHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvdmlkZXJNZXRhLnVzZUV4aXN0aW5nKSB7XG4gICAgICAgICAgICBwcm92aWRlckV4cHIgPSBOVUxMX0VYUFI7XG4gICAgICAgICAgICBmbGFncyB8PSAyMDQ4IC8qIFR5cGVVc2VFeGlzdGluZ1Byb3ZpZGVyICovO1xuICAgICAgICAgICAgZGVwcyA9IFt7IHRva2VuOiBwcm92aWRlck1ldGEudXNlRXhpc3RpbmcgfV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcm92aWRlckV4cHIgPSBjb252ZXJ0VmFsdWVUb091dHB1dEFzdChjdHgsIHByb3ZpZGVyTWV0YS51c2VWYWx1ZSk7XG4gICAgICAgICAgICBmbGFncyB8PSAyNTYgLyogVHlwZVZhbHVlUHJvdmlkZXIgKi87XG4gICAgICAgICAgICBkZXBzID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVwc0V4cHIgPSBsaXRlcmFsQXJyKGRlcHMubWFwKGZ1bmN0aW9uIChkZXApIHsgcmV0dXJuIGRlcERlZihjdHgsIGRlcCk7IH0pKTtcbiAgICByZXR1cm4geyBwcm92aWRlckV4cHI6IHByb3ZpZGVyRXhwciwgZmxhZ3M6IGZsYWdzLCBkZXBzRXhwcjogZGVwc0V4cHIgfTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBjdHhcbiAqIEBwYXJhbSB7P30gdG9rZW5NZXRhXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB0b2tlbkV4cHIoY3R4LCB0b2tlbk1ldGEpIHtcbiAgICByZXR1cm4gdG9rZW5NZXRhLmlkZW50aWZpZXIgPyBjdHguaW1wb3J0RXhwcih0b2tlbk1ldGEuaWRlbnRpZmllci5yZWZlcmVuY2UpIDpcbiAgICAgICAgbGl0ZXJhbCh0b2tlbk1ldGEudmFsdWUpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGN0eFxuICogQHBhcmFtIHs/fSBkZXBcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGRlcERlZihjdHgsIGRlcCkge1xuICAgIC8vIE5vdGU6IHRoZSBmb2xsb3dpbmcgZmllbGRzIGhhdmUgYWxyZWFkeSBiZWVuIG5vcm1hbGl6ZWQgb3V0IGJ5IHByb3ZpZGVyX2FuYWx5emVyOlxuICAgIC8vIC0gaXNBdHRyaWJ1dGUsIGlzU2VsZiwgaXNIb3N0XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwciA9IGRlcC5pc1ZhbHVlID8gY29udmVydFZhbHVlVG9PdXRwdXRBc3QoY3R4LCBkZXAudmFsdWUpIDogdG9rZW5FeHByKGN0eCwgLyoqIEB0eXBlIHs/fSAqLyAoKGRlcC50b2tlbikpKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmbGFncyA9IDA7XG4gICAgaWYgKGRlcC5pc1NraXBTZWxmKSB7XG4gICAgICAgIGZsYWdzIHw9IDEgLyogU2tpcFNlbGYgKi87XG4gICAgfVxuICAgIGlmIChkZXAuaXNPcHRpb25hbCkge1xuICAgICAgICBmbGFncyB8PSAyIC8qIE9wdGlvbmFsICovO1xuICAgIH1cbiAgICBpZiAoZGVwLmlzVmFsdWUpIHtcbiAgICAgICAgZmxhZ3MgfD0gOCAvKiBWYWx1ZSAqLztcbiAgICB9XG4gICAgcmV0dXJuIGZsYWdzID09PSAwIC8qIE5vbmUgKi8gPyBleHByIDogbGl0ZXJhbEFycihbbGl0ZXJhbChmbGFncyksIGV4cHJdKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBsaWZlY3ljbGVIb29rXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBsaWZlY3ljbGVIb29rVG9Ob2RlRmxhZyhsaWZlY3ljbGVIb29rKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZUZsYWcgPSAwO1xuICAgIHN3aXRjaCAobGlmZWN5Y2xlSG9vaykge1xuICAgICAgICBjYXNlIExpZmVjeWNsZUhvb2tzLkFmdGVyQ29udGVudENoZWNrZWQ6XG4gICAgICAgICAgICBub2RlRmxhZyA9IDIwOTcxNTIgLyogQWZ0ZXJDb250ZW50Q2hlY2tlZCAqLztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIExpZmVjeWNsZUhvb2tzLkFmdGVyQ29udGVudEluaXQ6XG4gICAgICAgICAgICBub2RlRmxhZyA9IDEwNDg1NzYgLyogQWZ0ZXJDb250ZW50SW5pdCAqLztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIExpZmVjeWNsZUhvb2tzLkFmdGVyVmlld0NoZWNrZWQ6XG4gICAgICAgICAgICBub2RlRmxhZyA9IDgzODg2MDggLyogQWZ0ZXJWaWV3Q2hlY2tlZCAqLztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIExpZmVjeWNsZUhvb2tzLkFmdGVyVmlld0luaXQ6XG4gICAgICAgICAgICBub2RlRmxhZyA9IDQxOTQzMDQgLyogQWZ0ZXJWaWV3SW5pdCAqLztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIExpZmVjeWNsZUhvb2tzLkRvQ2hlY2s6XG4gICAgICAgICAgICBub2RlRmxhZyA9IDI2MjE0NCAvKiBEb0NoZWNrICovO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTGlmZWN5Y2xlSG9va3MuT25DaGFuZ2VzOlxuICAgICAgICAgICAgbm9kZUZsYWcgPSA1MjQyODggLyogT25DaGFuZ2VzICovO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTGlmZWN5Y2xlSG9va3MuT25EZXN0cm95OlxuICAgICAgICAgICAgbm9kZUZsYWcgPSAxMzEwNzIgLyogT25EZXN0cm95ICovO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTGlmZWN5Y2xlSG9va3MuT25Jbml0OlxuICAgICAgICAgICAgbm9kZUZsYWcgPSA2NTUzNiAvKiBPbkluaXQgKi87XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVGbGFnO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHJlZmxlY3RvclxuICogQHBhcmFtIHs/fSBjdHhcbiAqIEBwYXJhbSB7P30gZmxhZ3NcbiAqIEBwYXJhbSB7P30gZW50cnlDb21wb25lbnRzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjb21wb25lbnRGYWN0b3J5UmVzb2x2ZXJQcm92aWRlckRlZihyZWZsZWN0b3IsIGN0eCwgZmxhZ3MsIGVudHJ5Q29tcG9uZW50cykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGVudHJ5Q29tcG9uZW50RmFjdG9yaWVzID0gZW50cnlDb21wb25lbnRzLm1hcChmdW5jdGlvbiAoZW50cnlDb21wb25lbnQpIHsgcmV0dXJuIGN0eC5pbXBvcnRFeHByKGVudHJ5Q29tcG9uZW50LmNvbXBvbmVudEZhY3RvcnkpOyB9KTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b2tlbiA9IGNyZWF0ZVRva2VuRm9yRXh0ZXJuYWxSZWZlcmVuY2UocmVmbGVjdG9yLCBJZGVudGlmaWVycy5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsYXNzTWV0YSA9IHtcbiAgICAgICAgZGlEZXBzOiBbXG4gICAgICAgICAgICB7IGlzVmFsdWU6IHRydWUsIHZhbHVlOiBsaXRlcmFsQXJyKGVudHJ5Q29tcG9uZW50RmFjdG9yaWVzKSB9LFxuICAgICAgICAgICAgeyB0b2tlbjogdG9rZW4sIGlzU2tpcFNlbGY6IHRydWUsIGlzT3B0aW9uYWw6IHRydWUgfSxcbiAgICAgICAgICAgIHsgdG9rZW46IGNyZWF0ZVRva2VuRm9yRXh0ZXJuYWxSZWZlcmVuY2UocmVmbGVjdG9yLCBJZGVudGlmaWVycy5OZ01vZHVsZVJlZikgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbGlmZWN5Y2xlSG9va3M6IFtdLFxuICAgICAgICByZWZlcmVuY2U6IHJlZmxlY3Rvci5yZXNvbHZlRXh0ZXJuYWxSZWZlcmVuY2UoSWRlbnRpZmllcnMuQ29kZWdlbkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcilcbiAgICB9O1xuICAgIHZhciBfYSA9IHNpbmdsZVByb3ZpZGVyRGVmKGN0eCwgZmxhZ3MsIFByb3ZpZGVyQXN0VHlwZS5Qcml2YXRlU2VydmljZSwge1xuICAgICAgICB0b2tlbjogdG9rZW4sXG4gICAgICAgIG11bHRpOiBmYWxzZSxcbiAgICAgICAgdXNlQ2xhc3M6IGNsYXNzTWV0YSxcbiAgICB9KSwgcHJvdmlkZXJFeHByID0gX2EucHJvdmlkZXJFeHByLCBwcm92aWRlckZsYWdzID0gX2EuZmxhZ3MsIGRlcHNFeHByID0gX2EuZGVwc0V4cHI7XG4gICAgcmV0dXJuIHsgcHJvdmlkZXJFeHByOiBwcm92aWRlckV4cHIsIGZsYWdzOiBwcm92aWRlckZsYWdzLCBkZXBzRXhwcjogZGVwc0V4cHIsIHRva2VuRXhwcjogdG9rZW5FeHByKGN0eCwgdG9rZW4pIH07XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgTmdNb2R1bGVDb21waWxlUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5nTW9kdWxlRmFjdG9yeVZhclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE5nTW9kdWxlQ29tcGlsZVJlc3VsdChuZ01vZHVsZUZhY3RvcnlWYXIpIHtcbiAgICAgICAgdGhpcy5uZ01vZHVsZUZhY3RvcnlWYXIgPSBuZ01vZHVsZUZhY3RvcnlWYXI7XG4gICAgfVxuICAgIHJldHVybiBOZ01vZHVsZUNvbXBpbGVSZXN1bHQ7XG59KCkpO1xudmFyIExPR19WQVIgPSB2YXJpYWJsZSgnX2wnKTtcbnZhciBOZ01vZHVsZUNvbXBpbGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlZmxlY3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE5nTW9kdWxlQ29tcGlsZXIocmVmbGVjdG9yKSB7XG4gICAgICAgIHRoaXMucmVmbGVjdG9yID0gcmVmbGVjdG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEBwYXJhbSB7P30gbmdNb2R1bGVNZXRhXG4gICAgICogQHBhcmFtIHs/fSBleHRyYVByb3ZpZGVyc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTmdNb2R1bGVDb21waWxlci5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uIChjdHgsIG5nTW9kdWxlTWV0YSwgZXh0cmFQcm92aWRlcnMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlU3BhbiA9IHR5cGVTb3VyY2VTcGFuKCdOZ01vZHVsZScsIG5nTW9kdWxlTWV0YS50eXBlKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW50cnlDb21wb25lbnRGYWN0b3JpZXMgPSBuZ01vZHVsZU1ldGEudHJhbnNpdGl2ZU1vZHVsZS5lbnRyeUNvbXBvbmVudHM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJvb3RzdHJhcENvbXBvbmVudHMgPSBuZ01vZHVsZU1ldGEuYm9vdHN0cmFwQ29tcG9uZW50cztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvdmlkZXJQYXJzZXIgPSBuZXcgTmdNb2R1bGVQcm92aWRlckFuYWx5emVyKHRoaXMucmVmbGVjdG9yLCBuZ01vZHVsZU1ldGEsIGV4dHJhUHJvdmlkZXJzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvdmlkZXJEZWZzID0gW2NvbXBvbmVudEZhY3RvcnlSZXNvbHZlclByb3ZpZGVyRGVmKHRoaXMucmVmbGVjdG9yLCBjdHgsIDAgLyogTm9uZSAqLywgZW50cnlDb21wb25lbnRGYWN0b3JpZXMpXVxuICAgICAgICAgICAgLmNvbmNhdChwcm92aWRlclBhcnNlci5wYXJzZSgpLm1hcChmdW5jdGlvbiAocHJvdmlkZXIpIHsgcmV0dXJuIHByb3ZpZGVyRGVmKGN0eCwgcHJvdmlkZXIpOyB9KSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgcHJvdmlkZXJFeHByID0gX2EucHJvdmlkZXJFeHByLCBkZXBzRXhwciA9IF9hLmRlcHNFeHByLCBmbGFncyA9IF9hLmZsYWdzLCB0b2tlbkV4cHIgPSBfYS50b2tlbkV4cHI7XG4gICAgICAgICAgICByZXR1cm4gaW1wb3J0RXhwcihJZGVudGlmaWVycy5tb2R1bGVQcm92aWRlckRlZikuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICBsaXRlcmFsKGZsYWdzKSwgdG9rZW5FeHByLCBwcm92aWRlckV4cHIsIGRlcHNFeHByXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nTW9kdWxlRGVmID0gaW1wb3J0RXhwcihJZGVudGlmaWVycy5tb2R1bGVEZWYpLmNhbGxGbihbbGl0ZXJhbEFycihwcm92aWRlckRlZnMpXSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nTW9kdWxlRGVmRmFjdG9yeSA9IGZuKFtuZXcgRm5QYXJhbSgvKiogQHR5cGUgez99ICovICgoTE9HX1ZBUi5uYW1lKSkpXSwgW25ldyBSZXR1cm5TdGF0ZW1lbnQobmdNb2R1bGVEZWYpXSwgSU5GRVJSRURfVFlQRSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nTW9kdWxlRmFjdG9yeVZhciA9IGlkZW50aWZpZXJOYW1lKG5nTW9kdWxlTWV0YS50eXBlKSArIFwiTmdGYWN0b3J5XCI7XG4gICAgICAgIHRoaXMuX2NyZWF0ZU5nTW9kdWxlRmFjdG9yeShjdHgsIG5nTW9kdWxlTWV0YS50eXBlLnJlZmVyZW5jZSwgaW1wb3J0RXhwcihJZGVudGlmaWVycy5jcmVhdGVNb2R1bGVGYWN0b3J5KS5jYWxsRm4oW1xuICAgICAgICAgICAgY3R4LmltcG9ydEV4cHIobmdNb2R1bGVNZXRhLnR5cGUucmVmZXJlbmNlKSxcbiAgICAgICAgICAgIGxpdGVyYWxBcnIoYm9vdHN0cmFwQ29tcG9uZW50cy5tYXAoZnVuY3Rpb24gKGlkKSB7IHJldHVybiBjdHguaW1wb3J0RXhwcihpZC5yZWZlcmVuY2UpOyB9KSksXG4gICAgICAgICAgICBuZ01vZHVsZURlZkZhY3RvcnlcbiAgICAgICAgXSkpO1xuICAgICAgICBpZiAobmdNb2R1bGVNZXRhLmlkKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWdpc3RlckZhY3RvcnlTdG10ID0gaW1wb3J0RXhwcihJZGVudGlmaWVycy5SZWdpc3Rlck1vZHVsZUZhY3RvcnlGbilcbiAgICAgICAgICAgICAgICAuY2FsbEZuKFtsaXRlcmFsKG5nTW9kdWxlTWV0YS5pZCksIHZhcmlhYmxlKG5nTW9kdWxlRmFjdG9yeVZhcildKVxuICAgICAgICAgICAgICAgIC50b1N0bXQoKTtcbiAgICAgICAgICAgIGN0eC5zdGF0ZW1lbnRzLnB1c2gocmVnaXN0ZXJGYWN0b3J5U3RtdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBOZ01vZHVsZUNvbXBpbGVSZXN1bHQobmdNb2R1bGVGYWN0b3J5VmFyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHBhcmFtIHs/fSBuZ01vZHVsZVJlZmVyZW5jZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTmdNb2R1bGVDb21waWxlci5wcm90b3R5cGUuY3JlYXRlU3R1YiA9IGZ1bmN0aW9uIChjdHgsIG5nTW9kdWxlUmVmZXJlbmNlKSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZU5nTW9kdWxlRmFjdG9yeShjdHgsIG5nTW9kdWxlUmVmZXJlbmNlLCBOVUxMX0VYUFIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcGFyYW0gez99IHJlZmVyZW5jZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5nTW9kdWxlQ29tcGlsZXIucHJvdG90eXBlLl9jcmVhdGVOZ01vZHVsZUZhY3RvcnkgPSBmdW5jdGlvbiAoY3R4LCByZWZlcmVuY2UsIHZhbHVlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nTW9kdWxlRmFjdG9yeVZhciA9IGlkZW50aWZpZXJOYW1lKHsgcmVmZXJlbmNlOiByZWZlcmVuY2UgfSkgKyBcIk5nRmFjdG9yeVwiO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZ01vZHVsZUZhY3RvcnlTdG10ID0gdmFyaWFibGUobmdNb2R1bGVGYWN0b3J5VmFyKVxuICAgICAgICAgICAgLnNldCh2YWx1ZSlcbiAgICAgICAgICAgIC50b0RlY2xTdG10KGltcG9ydFR5cGUoSWRlbnRpZmllcnMuTmdNb2R1bGVGYWN0b3J5LCBbLyoqIEB0eXBlIHs/fSAqLyAoKGV4cHJlc3Npb25UeXBlKGN0eC5pbXBvcnRFeHByKHJlZmVyZW5jZSkpKSldLCBbVHlwZU1vZGlmaWVyLkNvbnN0XSksIFtTdG10TW9kaWZpZXIuRmluYWwsIFN0bXRNb2RpZmllci5FeHBvcnRlZF0pO1xuICAgICAgICBjdHguc3RhdGVtZW50cy5wdXNoKG5nTW9kdWxlRmFjdG9yeVN0bXQpO1xuICAgIH07XG4gICAgcmV0dXJuIE5nTW9kdWxlQ29tcGlsZXI7XG59KCkpO1xuTmdNb2R1bGVDb21waWxlci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcGlsZXJJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5OZ01vZHVsZUNvbXBpbGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogQ29tcGlsZVJlZmxlY3RvciwgfSxcbl07IH07XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vLyBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kb2N1bWVudC9kLzFVMVJHQWVoUXdSeXBVVG92RjFLUmxwaU9GemUwYi1fMmdjNmZBSDBLWTBrL2VkaXRcbnZhciBWRVJTSU9OJDEgPSAzO1xudmFyIEpTX0I2NF9QUkVGSVggPSAnIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsJztcbnZhciBTb3VyY2VNYXBHZW5lcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IGZpbGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3IoZmlsZSkge1xuICAgICAgICBpZiAoZmlsZSA9PT0gdm9pZCAwKSB7IGZpbGUgPSBudWxsOyB9XG4gICAgICAgIHRoaXMuZmlsZSA9IGZpbGU7XG4gICAgICAgIHRoaXMuc291cmNlc0NvbnRlbnQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubGluZXMgPSBbXTtcbiAgICAgICAgdGhpcy5sYXN0Q29sMCA9IDA7XG4gICAgICAgIHRoaXMuaGFzTWFwcGluZ3MgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFkZFNvdXJjZSA9IGZ1bmN0aW9uICh1cmwsIGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKGNvbnRlbnQgPT09IHZvaWQgMCkgeyBjb250ZW50ID0gbnVsbDsgfVxuICAgICAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQuaGFzKHVybCkpIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlc0NvbnRlbnQuc2V0KHVybCwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYWRkTGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5saW5lcy5wdXNoKFtdKTtcbiAgICAgICAgdGhpcy5sYXN0Q29sMCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb2wwXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlVXJsXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlTGluZTBcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VDb2wwXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFkZE1hcHBpbmcgPSBmdW5jdGlvbiAoY29sMCwgc291cmNlVXJsLCBzb3VyY2VMaW5lMCwgc291cmNlQ29sMCkge1xuICAgICAgICBpZiAoIXRoaXMuY3VycmVudExpbmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgbGluZSBtdXN0IGJlIGFkZGVkIGJlZm9yZSBtYXBwaW5ncyBjYW4gYmUgYWRkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZVVybCAhPSBudWxsICYmICF0aGlzLnNvdXJjZXNDb250ZW50Lmhhcyhzb3VyY2VVcmwpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHNvdXJjZSBmaWxlIFxcXCJcIiArIHNvdXJjZVVybCArIFwiXFxcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sMCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY29sdW1uIGluIHRoZSBnZW5lcmF0ZWQgY29kZSBtdXN0IGJlIHByb3ZpZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2wwIDwgdGhpcy5sYXN0Q29sMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFwcGluZyBzaG91bGQgYmUgYWRkZWQgaW4gb3V0cHV0IG9yZGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2VVcmwgJiYgKHNvdXJjZUxpbmUwID09IG51bGwgfHwgc291cmNlQ29sMCA9PSBudWxsKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHNvdXJjZSBsb2NhdGlvbiBtdXN0IGJlIHByb3ZpZGVkIHdoZW4gYSBzb3VyY2UgdXJsIGlzIHByb3ZpZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFzTWFwcGluZ3MgPSB0cnVlO1xuICAgICAgICB0aGlzLmxhc3RDb2wwID0gY29sMDtcbiAgICAgICAgdGhpcy5jdXJyZW50TGluZS5wdXNoKHsgY29sMDogY29sMCwgc291cmNlVXJsOiBzb3VyY2VVcmwsIHNvdXJjZUxpbmUwOiBzb3VyY2VMaW5lMCwgc291cmNlQ29sMDogc291cmNlQ29sMCB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZSwgXCJjdXJyZW50TGluZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmxpbmVzLnNsaWNlKC0xKVswXTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmhhc01hcHBpbmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzb3VyY2VzSW5kZXggPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvdXJjZXMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlc0NvbnRlbnQgPSBbXTtcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLnNvdXJjZXNDb250ZW50LmtleXMoKSkuZm9yRWFjaChmdW5jdGlvbiAodXJsLCBpKSB7XG4gICAgICAgICAgICBzb3VyY2VzSW5kZXguc2V0KHVybCwgaSk7XG4gICAgICAgICAgICBzb3VyY2VzLnB1c2godXJsKTtcbiAgICAgICAgICAgIHNvdXJjZXNDb250ZW50LnB1c2goX3RoaXMuc291cmNlc0NvbnRlbnQuZ2V0KHVybCkgfHwgbnVsbCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXBwaW5ncyA9ICcnO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsYXN0Q29sMCA9IDA7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxhc3RTb3VyY2VJbmRleCA9IDA7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxhc3RTb3VyY2VMaW5lMCA9IDA7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxhc3RTb3VyY2VDb2wwID0gMDtcbiAgICAgICAgdGhpcy5saW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChzZWdtZW50cykge1xuICAgICAgICAgICAgbGFzdENvbDAgPSAwO1xuICAgICAgICAgICAgbWFwcGluZ3MgKz0gc2VnbWVudHNcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gemVyby1iYXNlZCBzdGFydGluZyBjb2x1bW4gb2YgdGhlIGxpbmUgaW4gdGhlIGdlbmVyYXRlZCBjb2RlXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VnQXNTdHIgPSB0b0Jhc2U2NFZMUShzZWdtZW50LmNvbDAgLSBsYXN0Q29sMCk7XG4gICAgICAgICAgICAgICAgbGFzdENvbDAgPSBzZWdtZW50LmNvbDA7XG4gICAgICAgICAgICAgICAgaWYgKHNlZ21lbnQuc291cmNlVXJsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gemVyby1iYXNlZCBpbmRleCBpbnRvIHRoZSDigJxzb3VyY2Vz4oCdIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgc2VnQXNTdHIgKz1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRvQmFzZTY0VkxRKC8qKiBAdHlwZSB7P30gKi8gKChzb3VyY2VzSW5kZXguZ2V0KHNlZ21lbnQuc291cmNlVXJsKSkpIC0gbGFzdFNvdXJjZUluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFNvdXJjZUluZGV4ID0gKChzb3VyY2VzSW5kZXguZ2V0KHNlZ21lbnQuc291cmNlVXJsKSkpO1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgemVyby1iYXNlZCBzdGFydGluZyBsaW5lIGluIHRoZSBvcmlnaW5hbCBzb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgc2VnQXNTdHIgKz0gdG9CYXNlNjRWTFEoLyoqIEB0eXBlIHs/fSAqLyAoKHNlZ21lbnQuc291cmNlTGluZTApKSAtIGxhc3RTb3VyY2VMaW5lMCk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTb3VyY2VMaW5lMCA9ICgoc2VnbWVudC5zb3VyY2VMaW5lMCkpO1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgemVyby1iYXNlZCBzdGFydGluZyBjb2x1bW4gaW4gdGhlIG9yaWdpbmFsIHNvdXJjZVxuICAgICAgICAgICAgICAgICAgICBzZWdBc1N0ciArPSB0b0Jhc2U2NFZMUSgvKiogQHR5cGUgez99ICovICgoc2VnbWVudC5zb3VyY2VDb2wwKSkgLSBsYXN0U291cmNlQ29sMCk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTb3VyY2VDb2wwID0gKChzZWdtZW50LnNvdXJjZUNvbDApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlZ0FzU3RyO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuam9pbignLCcpO1xuICAgICAgICAgICAgbWFwcGluZ3MgKz0gJzsnO1xuICAgICAgICB9KTtcbiAgICAgICAgbWFwcGluZ3MgPSBtYXBwaW5ncy5zbGljZSgwLCAtMSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnZmlsZSc6IHRoaXMuZmlsZSB8fCAnJyxcbiAgICAgICAgICAgICd2ZXJzaW9uJzogVkVSU0lPTiQxLFxuICAgICAgICAgICAgJ3NvdXJjZVJvb3QnOiAnJyxcbiAgICAgICAgICAgICdzb3VyY2VzJzogc291cmNlcyxcbiAgICAgICAgICAgICdzb3VyY2VzQ29udGVudCc6IHNvdXJjZXNDb250ZW50LFxuICAgICAgICAgICAgJ21hcHBpbmdzJzogbWFwcGluZ3MsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9Kc0NvbW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc01hcHBpbmdzID8gJy8vJyArIEpTX0I2NF9QUkVGSVggKyB0b0Jhc2U2NFN0cmluZyhKU09OLnN0cmluZ2lmeSh0aGlzLCBudWxsLCAwKSkgOlxuICAgICAgICAgICAgJyc7XG4gICAgfTtcbiAgICByZXR1cm4gU291cmNlTWFwR2VuZXJhdG9yO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSB2YWx1ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdG9CYXNlNjRTdHJpbmcodmFsdWUpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiNjQgPSAnJztcbiAgICB2YWx1ZSA9IHV0ZjhFbmNvZGUodmFsdWUpO1xuICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGkxID0gdmFsdWUuY2hhckNvZGVBdChpKyspO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpMiA9IHZhbHVlLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaTMgPSB2YWx1ZS5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgIGI2NCArPSB0b0Jhc2U2NERpZ2l0KGkxID4+IDIpO1xuICAgICAgICBiNjQgKz0gdG9CYXNlNjREaWdpdCgoKGkxICYgMykgPDwgNCkgfCAoaXNOYU4oaTIpID8gMCA6IGkyID4+IDQpKTtcbiAgICAgICAgYjY0ICs9IGlzTmFOKGkyKSA/ICc9JyA6IHRvQmFzZTY0RGlnaXQoKChpMiAmIDE1KSA8PCAyKSB8IChpMyA+PiA2KSk7XG4gICAgICAgIGI2NCArPSBpc05hTihpMikgfHwgaXNOYU4oaTMpID8gJz0nIDogdG9CYXNlNjREaWdpdChpMyAmIDYzKTtcbiAgICB9XG4gICAgcmV0dXJuIGI2NDtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSB2YWx1ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdG9CYXNlNjRWTFEodmFsdWUpIHtcbiAgICB2YWx1ZSA9IHZhbHVlIDwgMCA/ICgoLXZhbHVlKSA8PCAxKSArIDEgOiB2YWx1ZSA8PCAxO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG91dCA9ICcnO1xuICAgIGRvIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlnaXQgPSB2YWx1ZSAmIDMxO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlID4+IDU7XG4gICAgICAgIGlmICh2YWx1ZSA+IDApIHtcbiAgICAgICAgICAgIGRpZ2l0ID0gZGlnaXQgfCAzMjtcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gdG9CYXNlNjREaWdpdChkaWdpdCk7XG4gICAgfSB3aGlsZSAodmFsdWUgPiAwKTtcbiAgICByZXR1cm4gb3V0O1xufVxudmFyIEI2NF9ESUdJVFMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG4vKipcbiAqIEBwYXJhbSB7P30gdmFsdWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHRvQmFzZTY0RGlnaXQodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID49IDY0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBvbmx5IGVuY29kZSB2YWx1ZSBpbiB0aGUgcmFuZ2UgWzAsIDYzXVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIEI2NF9ESUdJVFNbdmFsdWVdO1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIF9TSU5HTEVfUVVPVEVfRVNDQVBFX1NUUklOR19SRSA9IC8nfFxcXFx8XFxufFxccnxcXCQvZztcbnZhciBfTEVHQUxfSURFTlRJRklFUl9SRSA9IC9eWyRBLVpfXVswLTlBLVpfJF0qJC9pO1xudmFyIF9JTkRFTlRfV0lUSCA9ICcgICc7XG52YXIgQ0FUQ0hfRVJST1JfVkFSJDEgPSB2YXJpYWJsZSgnZXJyb3InLCBudWxsLCBudWxsKTtcbnZhciBDQVRDSF9TVEFDS19WQVIkMSA9IHZhcmlhYmxlKCdzdGFjaycsIG51bGwsIG51bGwpO1xuLyoqXG4gKiBAYWJzdHJhY3RcbiAqL1xudmFyIF9FbWl0dGVkTGluZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbmRlbnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfRW1pdHRlZExpbmUoaW5kZW50KSB7XG4gICAgICAgIHRoaXMuaW5kZW50ID0gaW5kZW50O1xuICAgICAgICB0aGlzLnBhcnRzTGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wYXJ0cyA9IFtdO1xuICAgICAgICB0aGlzLnNyY1NwYW5zID0gW107XG4gICAgfVxuICAgIHJldHVybiBfRW1pdHRlZExpbmU7XG59KCkpO1xudmFyIEVtaXR0ZXJWaXNpdG9yQ29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfaW5kZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gRW1pdHRlclZpc2l0b3JDb250ZXh0KF9pbmRlbnQpIHtcbiAgICAgICAgdGhpcy5faW5kZW50ID0gX2luZGVudDtcbiAgICAgICAgdGhpcy5fY2xhc3NlcyA9IFtdO1xuICAgICAgICB0aGlzLl9wcmVhbWJsZUxpbmVDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuX2xpbmVzID0gW25ldyBfRW1pdHRlZExpbmUoX2luZGVudCldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5jcmVhdGVSb290ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEVtaXR0ZXJWaXNpdG9yQ29udGV4dCgwKTsgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZSwgXCJfY3VycmVudExpbmVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbGluZXNbdGhpcy5fbGluZXMubGVuZ3RoIC0gMV07IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IGZyb21cbiAgICAgKiBAcGFyYW0gez89fSBsYXN0UGFydFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS5wcmludGxuID0gZnVuY3Rpb24gKGZyb20sIGxhc3RQYXJ0KSB7XG4gICAgICAgIGlmIChsYXN0UGFydCA9PT0gdm9pZCAwKSB7IGxhc3RQYXJ0ID0gJyc7IH1cbiAgICAgICAgdGhpcy5wcmludChmcm9tIHx8IG51bGwsIGxhc3RQYXJ0LCB0cnVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS5saW5lSXNFbXB0eSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2N1cnJlbnRMaW5lLnBhcnRzLmxlbmd0aCA9PT0gMDsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUubGluZUxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRMaW5lLmluZGVudCAqIF9JTkRFTlRfV0lUSC5sZW5ndGggKyB0aGlzLl9jdXJyZW50TGluZS5wYXJ0c0xlbmd0aDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZnJvbVxuICAgICAqIEBwYXJhbSB7P30gcGFydFxuICAgICAqIEBwYXJhbSB7Pz19IG5ld0xpbmVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUucHJpbnQgPSBmdW5jdGlvbiAoZnJvbSwgcGFydCwgbmV3TGluZSkge1xuICAgICAgICBpZiAobmV3TGluZSA9PT0gdm9pZCAwKSB7IG5ld0xpbmUgPSBmYWxzZTsgfVxuICAgICAgICBpZiAocGFydC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50TGluZS5wYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudExpbmUucGFydHNMZW5ndGggKz0gcGFydC5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50TGluZS5zcmNTcGFucy5wdXNoKGZyb20gJiYgZnJvbS5zb3VyY2VTcGFuIHx8IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdMaW5lKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lcy5wdXNoKG5ldyBfRW1pdHRlZExpbmUodGhpcy5faW5kZW50KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS5yZW1vdmVFbXB0eUxhc3RMaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5saW5lSXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lcy5wb3AoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLmluY0luZGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faW5kZW50Kys7XG4gICAgICAgIGlmICh0aGlzLmxpbmVJc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMaW5lLmluZGVudCA9IHRoaXMuX2luZGVudDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLmRlY0luZGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faW5kZW50LS07XG4gICAgICAgIGlmICh0aGlzLmxpbmVJc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMaW5lLmluZGVudCA9IHRoaXMuX2luZGVudDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjbGF6elxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS5wdXNoQ2xhc3MgPSBmdW5jdGlvbiAoY2xhenopIHsgdGhpcy5fY2xhc3Nlcy5wdXNoKGNsYXp6KTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUucG9wQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoKHRoaXMuX2NsYXNzZXMucG9wKCkpKTsgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZSwgXCJjdXJyZW50Q2xhc3NcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NsYXNzZXMubGVuZ3RoID4gMCA/IHRoaXMuX2NsYXNzZXNbdGhpcy5fY2xhc3Nlcy5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS50b1NvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlTGluZXNcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGwpIHsgcmV0dXJuIGwucGFydHMubGVuZ3RoID4gMCA/IF9jcmVhdGVJbmRlbnQobC5pbmRlbnQpICsgbC5wYXJ0cy5qb2luKCcnKSA6ICcnOyB9KVxuICAgICAgICAgICAgLmpvaW4oJ1xcbicpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VGaWxlUGF0aFxuICAgICAqIEBwYXJhbSB7P30gZ2VuRmlsZVBhdGhcbiAgICAgKiBAcGFyYW0gez89fSBzdGFydHNBdExpbmVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUudG9Tb3VyY2VNYXBHZW5lcmF0b3IgPSBmdW5jdGlvbiAoc291cmNlRmlsZVBhdGgsIGdlbkZpbGVQYXRoLCBzdGFydHNBdExpbmUpIHtcbiAgICAgICAgaWYgKHN0YXJ0c0F0TGluZSA9PT0gdm9pZCAwKSB7IHN0YXJ0c0F0TGluZSA9IDA7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWFwID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcihnZW5GaWxlUGF0aCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZpcnN0T2Zmc2V0TWFwcGVkID0gZmFsc2U7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hcEZpcnN0T2Zmc2V0SWZOZWVkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWZpcnN0T2Zmc2V0TWFwcGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGEgc2luZ2xlIHNwYWNlIHNvIHRoYXQgdG9vbHMgd29uJ3QgdHJ5IHRvIGxvYWQgdGhlIGZpbGUgZnJvbSBkaXNrLlxuICAgICAgICAgICAgICAgIC8vIE5vdGU6IFdlIGFyZSB1c2luZyB2aXJ0dWFsIHVybHMgbGlrZSBgbmc6Ly8vYCwgc28gd2UgaGF2ZSB0b1xuICAgICAgICAgICAgICAgIC8vIHByb3ZpZGUgYSBjb250ZW50IGhlcmUuXG4gICAgICAgICAgICAgICAgbWFwLmFkZFNvdXJjZShzb3VyY2VGaWxlUGF0aCwgJyAnKS5hZGRNYXBwaW5nKDAsIHNvdXJjZUZpbGVQYXRoLCAwLCAwKTtcbiAgICAgICAgICAgICAgICBmaXJzdE9mZnNldE1hcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBzdGFydHNBdExpbmU7IGkrKykge1xuICAgICAgICAgICAgbWFwLmFkZExpbmUoKTtcbiAgICAgICAgICAgIG1hcEZpcnN0T2Zmc2V0SWZOZWVkZWQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvdXJjZUxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUsIGxpbmVJZHgpIHtcbiAgICAgICAgICAgIG1hcC5hZGRMaW5lKCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzcGFucyA9IGxpbmUuc3JjU3BhbnM7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJ0cyA9IGxpbmUucGFydHM7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb2wwID0gbGluZS5pbmRlbnQgKiBfSU5ERU5UX1dJVEgubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3BhbklkeCA9IDA7XG4gICAgICAgICAgICAvLyBza2lwIGxlYWRpbmcgcGFydHMgd2l0aG91dCBzb3VyY2Ugc3BhbnNcbiAgICAgICAgICAgIHdoaWxlIChzcGFuSWR4IDwgc3BhbnMubGVuZ3RoICYmICFzcGFuc1tzcGFuSWR4XSkge1xuICAgICAgICAgICAgICAgIGNvbDAgKz0gcGFydHNbc3BhbklkeF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHNwYW5JZHgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzcGFuSWR4IDwgc3BhbnMubGVuZ3RoICYmIGxpbmVJZHggPT09IDAgJiYgY29sMCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGZpcnN0T2Zmc2V0TWFwcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hcEZpcnN0T2Zmc2V0SWZOZWVkZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChzcGFuSWR4IDwgc3BhbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3BhbiA9ICgoc3BhbnNbc3BhbklkeF0pKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzb3VyY2UgPSBzcGFuLnN0YXJ0LmZpbGU7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlTGluZSA9IHNwYW4uc3RhcnQubGluZTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzb3VyY2VDb2wgPSBzcGFuLnN0YXJ0LmNvbDtcbiAgICAgICAgICAgICAgICBtYXAuYWRkU291cmNlKHNvdXJjZS51cmwsIHNvdXJjZS5jb250ZW50KVxuICAgICAgICAgICAgICAgICAgICAuYWRkTWFwcGluZyhjb2wwLCBzb3VyY2UudXJsLCBzb3VyY2VMaW5lLCBzb3VyY2VDb2wpO1xuICAgICAgICAgICAgICAgIGNvbDAgKz0gcGFydHNbc3BhbklkeF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHNwYW5JZHgrKztcbiAgICAgICAgICAgICAgICAvLyBhc3NpZ24gcGFydHMgd2l0aG91dCBzcGFuIG9yIHRoZSBzYW1lIHNwYW4gdG8gdGhlIHByZXZpb3VzIHNlZ21lbnRcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3BhbklkeCA8IHNwYW5zLmxlbmd0aCAmJiAoc3BhbiA9PT0gc3BhbnNbc3BhbklkeF0gfHwgIXNwYW5zW3NwYW5JZHhdKSkge1xuICAgICAgICAgICAgICAgICAgICBjb2wwICs9IHBhcnRzW3NwYW5JZHhdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgc3BhbklkeCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvdW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLnNldFByZWFtYmxlTGluZUNvdW50ID0gZnVuY3Rpb24gKGNvdW50KSB7IHJldHVybiB0aGlzLl9wcmVhbWJsZUxpbmVDb3VudCA9IGNvdW50OyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbGluZVxuICAgICAqIEBwYXJhbSB7P30gY29sdW1uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLnNwYW5PZiA9IGZ1bmN0aW9uIChsaW5lLCBjb2x1bW4pIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW1pdHRlZExpbmUgPSB0aGlzLl9saW5lc1tsaW5lIC0gdGhpcy5fcHJlYW1ibGVMaW5lQ291bnRdO1xuICAgICAgICBpZiAoZW1pdHRlZExpbmUpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbHVtbnNMZWZ0ID0gY29sdW1uIC0gZW1pdHRlZExpbmUuaW5kZW50O1xuICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJ0SW5kZXggPSAwOyBwYXJ0SW5kZXggPCBlbWl0dGVkTGluZS5wYXJ0cy5sZW5ndGg7IHBhcnRJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFydCA9IGVtaXR0ZWRMaW5lLnBhcnRzW3BhcnRJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKHBhcnQubGVuZ3RoID4gY29sdW1uc0xlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVtaXR0ZWRMaW5lLnNyY1NwYW5zW3BhcnRJbmRleF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbHVtbnNMZWZ0IC09IHBhcnQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUsIFwic291cmNlTGluZXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xpbmVzLmxlbmd0aCAmJiB0aGlzLl9saW5lc1t0aGlzLl9saW5lcy5sZW5ndGggLSAxXS5wYXJ0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGluZXMuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gRW1pdHRlclZpc2l0b3JDb250ZXh0O1xufSgpKTtcbi8qKlxuICogQGFic3RyYWN0XG4gKi9cbnZhciBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9lc2NhcGVEb2xsYXJJblN0cmluZ3NcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yKF9lc2NhcGVEb2xsYXJJblN0cmluZ3MpIHtcbiAgICAgICAgdGhpcy5fZXNjYXBlRG9sbGFySW5TdHJpbmdzID0gX2VzY2FwZURvbGxhckluU3RyaW5ncztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIHN0bXQuZXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgJzsnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZXR1cm5TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCJyZXR1cm4gXCIpO1xuICAgICAgICBzdG10LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCAnOycpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENhc3RFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmVDbGFzc1N0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWZTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCJpZiAoXCIpO1xuICAgICAgICBzdG10LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KHN0bXQsIFwiKSB7XCIpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoYXNFbHNlQ2FzZSA9IHN0bXQuZmFsc2VDYXNlICE9IG51bGwgJiYgc3RtdC5mYWxzZUNhc2UubGVuZ3RoID4gMDtcbiAgICAgICAgaWYgKHN0bXQudHJ1ZUNhc2UubGVuZ3RoIDw9IDEgJiYgIWhhc0Vsc2VDYXNlKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCIgXCIpO1xuICAgICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC50cnVlQ2FzZSwgY3R4KTtcbiAgICAgICAgICAgIGN0eC5yZW1vdmVFbXB0eUxhc3RMaW5lKCk7XG4gICAgICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCIgXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3R4LnByaW50bG4oKTtcbiAgICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQudHJ1ZUNhc2UsIGN0eCk7XG4gICAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgICBpZiAoaGFzRWxzZUNhc2UpIHtcbiAgICAgICAgICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIn0gZWxzZSB7XCIpO1xuICAgICAgICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmZhbHNlQ2FzZSwgY3R4KTtcbiAgICAgICAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ9XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRyeUNhdGNoU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUaHJvd1N0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChzdG10LCBcInRocm93IFwiKTtcbiAgICAgICAgc3RtdC5lcnJvci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCI7XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1lbnRTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsaW5lcyA9IHN0bXQuY29tbWVudC5zcGxpdCgnXFxuJyk7XG4gICAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHsgY3R4LnByaW50bG4oc3RtdCwgXCIvLyBcIiArIGxpbmUpOyB9KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlVmFyU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cHJcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRXcml0ZVZhckV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxpbmVXYXNFbXB0eSA9IGN0eC5saW5lSXNFbXB0eSgpO1xuICAgICAgICBpZiAoIWxpbmVXYXNFbXB0eSkge1xuICAgICAgICAgICAgY3R4LnByaW50KGV4cHIsICcoJyk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50KGV4cHIsIGV4cHIubmFtZSArIFwiID0gXCIpO1xuICAgICAgICBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBpZiAoIWxpbmVXYXNFbXB0eSkge1xuICAgICAgICAgICAgY3R4LnByaW50KGV4cHIsICcpJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cHJcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRXcml0ZUtleUV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxpbmVXYXNFbXB0eSA9IGN0eC5saW5lSXNFbXB0eSgpO1xuICAgICAgICBpZiAoIWxpbmVXYXNFbXB0eSkge1xuICAgICAgICAgICAgY3R4LnByaW50KGV4cHIsICcoJyk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGV4cHIsIFwiW1wiKTtcbiAgICAgICAgZXhwci5pbmRleC52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGV4cHIsIFwiXSA9IFwiKTtcbiAgICAgICAgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgaWYgKCFsaW5lV2FzRW1wdHkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChleHByLCAnKScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHByXG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0V3JpdGVQcm9wRXhwciA9IGZ1bmN0aW9uIChleHByLCBjdHgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGluZVdhc0VtcHR5ID0gY3R4LmxpbmVJc0VtcHR5KCk7XG4gICAgICAgIGlmICghbGluZVdhc0VtcHR5KSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoZXhwciwgJygnKTtcbiAgICAgICAgfVxuICAgICAgICBleHByLnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoZXhwciwgXCIuXCIgKyBleHByLm5hbWUgKyBcIiA9IFwiKTtcbiAgICAgICAgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgaWYgKCFsaW5lV2FzRW1wdHkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChleHByLCAnKScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHByXG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW52b2tlTWV0aG9kRXhwciA9IGZ1bmN0aW9uIChleHByLCBjdHgpIHtcbiAgICAgICAgZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZSA9IGV4cHIubmFtZTtcbiAgICAgICAgaWYgKGV4cHIuYnVpbHRpbiAhPSBudWxsKSB7XG4gICAgICAgICAgICBuYW1lID0gdGhpcy5nZXRCdWlsdGluTWV0aG9kTmFtZShleHByLmJ1aWx0aW4pO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIHNvbWUgYnVpbHRpbnMganVzdCBtZWFuIHRvIHNraXAgdGhlIGNhbGwuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50KGV4cHIsIFwiLlwiICsgbmFtZSArIFwiKFwiKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGV4cHIuYXJncywgY3R4LCBcIixcIik7XG4gICAgICAgIGN0eC5wcmludChleHByLCBcIilcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSBtZXRob2RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLmdldEJ1aWx0aW5NZXRob2ROYW1lID0gZnVuY3Rpb24gKG1ldGhvZCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwclxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEludm9rZUZ1bmN0aW9uRXhwciA9IGZ1bmN0aW9uIChleHByLCBjdHgpIHtcbiAgICAgICAgZXhwci5mbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGV4cHIsIFwiKFwiKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGV4cHIuYXJncywgY3R4LCAnLCcpO1xuICAgICAgICBjdHgucHJpbnQoZXhwciwgXCIpXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVhZFZhckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFyTmFtZSA9ICgoYXN0Lm5hbWUpKTtcbiAgICAgICAgaWYgKGFzdC5idWlsdGluICE9IG51bGwpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoYXN0LmJ1aWx0aW4pIHtcbiAgICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5WYXIuU3VwZXI6XG4gICAgICAgICAgICAgICAgICAgIHZhck5hbWUgPSAnc3VwZXInO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5WYXIuVGhpczpcbiAgICAgICAgICAgICAgICAgICAgdmFyTmFtZSA9ICd0aGlzJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBCdWlsdGluVmFyLkNhdGNoRXJyb3I6XG4gICAgICAgICAgICAgICAgICAgIHZhck5hbWUgPSAoKENBVENIX0VSUk9SX1ZBUiQxLm5hbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBCdWlsdGluVmFyLkNhdGNoU3RhY2s6XG4gICAgICAgICAgICAgICAgICAgIHZhck5hbWUgPSAoKENBVENIX1NUQUNLX1ZBUiQxLm5hbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBidWlsdGluIHZhcmlhYmxlIFwiICsgYXN0LmJ1aWx0aW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChhc3QsIHZhck5hbWUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW5zdGFudGlhdGVFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwibmV3IFwiKTtcbiAgICAgICAgYXN0LmNsYXNzRXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCIoXCIpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGN0eCwgJywnKTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCIpXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSBhc3QudmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoYXN0LCBlc2NhcGVJZGVudGlmaWVyKHZhbHVlLCB0aGlzLl9lc2NhcGVEb2xsYXJJblN0cmluZ3MpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5wcmludChhc3QsIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4dGVybmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29uZGl0aW9uYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiKFwiKTtcbiAgICAgICAgYXN0LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgJz8gJyk7XG4gICAgICAgIGFzdC50cnVlQ2FzZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgJzogJyk7IC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgKChhc3QuZmFsc2VDYXNlKSkudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdE5vdEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgJyEnKTtcbiAgICAgICAgYXN0LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFzc2VydE5vdE51bGxFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZUZ1bmN0aW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRCaW5hcnlPcGVyYXRvckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3BTdHI7XG4gICAgICAgIHN3aXRjaCAoYXN0Lm9wZXJhdG9yKSB7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkVxdWFsczpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICc9PSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLklkZW50aWNhbDpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICc9PT0nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Ob3RFcXVhbHM6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnIT0nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Ob3RJZGVudGljYWw6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnIT09JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuQW5kOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJyYmJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuT3I6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnfHwnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5QbHVzOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJysnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5NaW51czpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICctJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuRGl2aWRlOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJy8nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5NdWx0aXBseTpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICcqJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuTW9kdWxvOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJyUnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Mb3dlcjpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICc8JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuTG93ZXJFcXVhbHM6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnPD0nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5CaWdnZXI6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnPic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkJpZ2dlckVxdWFsczpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICc+PSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3BlcmF0b3IgXCIgKyBhc3Qub3BlcmF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiKFwiKTtcbiAgICAgICAgYXN0Lmxocy52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCIgXCIgKyBvcFN0ciArIFwiIFwiKTtcbiAgICAgICAgYXN0LnJocy52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCIpXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVhZFByb3BFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCIuXCIpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBhc3QubmFtZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZWFkS2V5RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiW1wiKTtcbiAgICAgICAgYXN0LmluZGV4LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIl1cIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXlFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiW1wiKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5lbnRyaWVzLCBjdHgsICcsJyk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiXVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXBFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwie1wiKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbE9iamVjdHMoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoYXN0LCBlc2NhcGVJZGVudGlmaWVyKGVudHJ5LmtleSwgX3RoaXMuX2VzY2FwZURvbGxhckluU3RyaW5ncywgZW50cnkucXVvdGVkKSArIFwiOlwiKTtcbiAgICAgICAgICAgIGVudHJ5LnZhbHVlLnZpc2l0RXhwcmVzc2lvbihfdGhpcywgY3R4KTtcbiAgICAgICAgfSwgYXN0LmVudHJpZXMsIGN0eCwgJywnKTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCJ9XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29tbWFFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChhc3QsICcoJyk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QucGFydHMsIGN0eCwgJywnKTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgJyknKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cHJlc3Npb25zXG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcGFyYW0gez99IHNlcGFyYXRvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbGxFeHByZXNzaW9ucyA9IGZ1bmN0aW9uIChleHByZXNzaW9ucywgY3R4LCBzZXBhcmF0b3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy52aXNpdEFsbE9iamVjdHMoZnVuY3Rpb24gKGV4cHIpIHsgcmV0dXJuIGV4cHIudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjdHgpOyB9LCBleHByZXNzaW9ucywgY3R4LCBzZXBhcmF0b3IpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0gez99IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0gez99IGV4cHJlc3Npb25zXG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcGFyYW0gez99IHNlcGFyYXRvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbGxPYmplY3RzID0gZnVuY3Rpb24gKGhhbmRsZXIsIGV4cHJlc3Npb25zLCBjdHgsIHNlcGFyYXRvcikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmNyZW1lbnRlZEluZGVudCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgZXhwcmVzc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChjdHgubGluZUxlbmd0aCgpID4gODApIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnByaW50KG51bGwsIHNlcGFyYXRvciwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5jcmVtZW50ZWRJbmRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVhdGlvbiBhcmUgbWFya2VkIHdpdGggZG91YmxlIGluZGVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY3JlbWVudGVkSW5kZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnByaW50KG51bGwsIHNlcGFyYXRvciwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZXIoZXhwcmVzc2lvbnNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmNyZW1lbnRlZEluZGVudCkge1xuICAgICAgICAgICAgLy8gY29udGludWF0aW9uIGFyZSBtYXJrZWQgd2l0aCBkb3VibGUgaW5kZW50LlxuICAgICAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXRlbWVudHNcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbGxTdGF0ZW1lbnRzID0gZnVuY3Rpb24gKHN0YXRlbWVudHMsIGN0eCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBzdGF0ZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKHN0bXQpIHsgcmV0dXJuIHN0bXQudmlzaXRTdGF0ZW1lbnQoX3RoaXMsIGN0eCk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEFic3RyYWN0RW1pdHRlclZpc2l0b3I7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IGlucHV0XG4gKiBAcGFyYW0gez99IGVzY2FwZURvbGxhclxuICogQHBhcmFtIHs/PX0gYWx3YXlzUXVvdGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUlkZW50aWZpZXIoaW5wdXQsIGVzY2FwZURvbGxhciwgYWx3YXlzUXVvdGUpIHtcbiAgICBpZiAoYWx3YXlzUXVvdGUgPT09IHZvaWQgMCkgeyBhbHdheXNRdW90ZSA9IHRydWU7IH1cbiAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYm9keSA9IGlucHV0LnJlcGxhY2UoX1NJTkdMRV9RVU9URV9FU0NBUEVfU1RSSU5HX1JFLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgbWF0Y2hbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2hbMF0gPT0gJyQnKSB7XG4gICAgICAgICAgICByZXR1cm4gZXNjYXBlRG9sbGFyID8gJ1xcXFwkJyA6ICckJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtYXRjaFswXSA9PSAnXFxuJykge1xuICAgICAgICAgICAgcmV0dXJuICdcXFxcbic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWF0Y2hbMF0gPT0gJ1xccicpIHtcbiAgICAgICAgICAgIHJldHVybiAnXFxcXHInO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiXFxcXFwiICsgbWF0Y2hbMF07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXF1aXJlc1F1b3RlcyA9IGFsd2F5c1F1b3RlIHx8ICFfTEVHQUxfSURFTlRJRklFUl9SRS50ZXN0KGJvZHkpO1xuICAgIHJldHVybiByZXF1aXJlc1F1b3RlcyA/IFwiJ1wiICsgYm9keSArIFwiJ1wiIDogYm9keTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBjb3VudFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2NyZWF0ZUluZGVudChjb3VudCkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlcyA9ICcnO1xuICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIHJlcyArPSBfSU5ERU5UX1dJVEg7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEBwYXJhbSB7P30gYXN0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBkZWJ1Z091dHB1dEFzdEFzVHlwZVNjcmlwdChhc3QpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb252ZXJ0ZXIgPSBuZXcgX1RzRW1pdHRlclZpc2l0b3IoKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdHggPSBFbWl0dGVyVmlzaXRvckNvbnRleHQuY3JlYXRlUm9vdCgpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdHMgPSBBcnJheS5pc0FycmF5KGFzdCkgPyBhc3QgOiBbYXN0XTtcbiAgICBhc3RzLmZvckVhY2goZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICBpZiAoYXN0IGluc3RhbmNlb2YgU3RhdGVtZW50KSB7XG4gICAgICAgICAgICBhc3QudmlzaXRTdGF0ZW1lbnQoY29udmVydGVyLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFzdCBpbnN0YW5jZW9mIEV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIGFzdC52aXNpdEV4cHJlc3Npb24oY29udmVydGVyLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFzdCBpbnN0YW5jZW9mIFR5cGUkMSkge1xuICAgICAgICAgICAgYXN0LnZpc2l0VHlwZShjb252ZXJ0ZXIsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEb24ndCBrbm93IGhvdyB0byBwcmludCBkZWJ1ZyBpbmZvIGZvciBcIiArIGFzdCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY3R4LnRvU291cmNlKCk7XG59XG52YXIgVHlwZVNjcmlwdEVtaXR0ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFR5cGVTY3JpcHRFbWl0dGVyKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNyY0ZpbGVQYXRoXG4gICAgICogQHBhcmFtIHs/fSBnZW5GaWxlUGF0aFxuICAgICAqIEBwYXJhbSB7P30gc3RtdHNcbiAgICAgKiBAcGFyYW0gez89fSBwcmVhbWJsZVxuICAgICAqIEBwYXJhbSB7Pz19IGVtaXRTb3VyY2VNYXBzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUeXBlU2NyaXB0RW1pdHRlci5wcm90b3R5cGUuZW1pdFN0YXRlbWVudHNBbmRDb250ZXh0ID0gZnVuY3Rpb24gKHNyY0ZpbGVQYXRoLCBnZW5GaWxlUGF0aCwgc3RtdHMsIHByZWFtYmxlLCBlbWl0U291cmNlTWFwcykge1xuICAgICAgICBpZiAocHJlYW1ibGUgPT09IHZvaWQgMCkgeyBwcmVhbWJsZSA9ICcnOyB9XG4gICAgICAgIGlmIChlbWl0U291cmNlTWFwcyA9PT0gdm9pZCAwKSB7IGVtaXRTb3VyY2VNYXBzID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb252ZXJ0ZXIgPSBuZXcgX1RzRW1pdHRlclZpc2l0b3IoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3R4ID0gRW1pdHRlclZpc2l0b3JDb250ZXh0LmNyZWF0ZVJvb3QoKTtcbiAgICAgICAgY29udmVydGVyLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10cywgY3R4KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlYW1ibGVMaW5lcyA9IHByZWFtYmxlID8gcHJlYW1ibGUuc3BsaXQoJ1xcbicpIDogW107XG4gICAgICAgIGNvbnZlcnRlci5yZWV4cG9ydHMuZm9yRWFjaChmdW5jdGlvbiAocmVleHBvcnRzLCBleHBvcnRlZE1vZHVsZU5hbWUpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlZXhwb3J0c0NvZGUgPSByZWV4cG9ydHMubWFwKGZ1bmN0aW9uIChyZWV4cG9ydCkgeyByZXR1cm4gcmVleHBvcnQubmFtZSArIFwiIGFzIFwiICsgcmVleHBvcnQuYXM7IH0pLmpvaW4oJywnKTtcbiAgICAgICAgICAgIHByZWFtYmxlTGluZXMucHVzaChcImV4cG9ydCB7XCIgKyByZWV4cG9ydHNDb2RlICsgXCJ9IGZyb20gJ1wiICsgZXhwb3J0ZWRNb2R1bGVOYW1lICsgXCInO1wiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnZlcnRlci5pbXBvcnRzV2l0aFByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCwgaW1wb3J0ZWRNb2R1bGVOYW1lKSB7XG4gICAgICAgICAgICAvLyBOb3RlOiBjYW4ndCB3cml0ZSB0aGUgcmVhbCB3b3JkIGZvciBpbXBvcnQgYXMgaXQgc2NyZXdzIHVwIHN5c3RlbS5qcyBhdXRvIGRldGVjdGlvbi4uLlxuICAgICAgICAgICAgcHJlYW1ibGVMaW5lcy5wdXNoKFwiaW1wXCIgK1xuICAgICAgICAgICAgICAgIChcIm9ydCAqIGFzIFwiICsgcHJlZml4ICsgXCIgZnJvbSAnXCIgKyBpbXBvcnRlZE1vZHVsZU5hbWUgKyBcIic7XCIpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNtID0gZW1pdFNvdXJjZU1hcHMgP1xuICAgICAgICAgICAgY3R4LnRvU291cmNlTWFwR2VuZXJhdG9yKHNyY0ZpbGVQYXRoLCBnZW5GaWxlUGF0aCwgcHJlYW1ibGVMaW5lcy5sZW5ndGgpLnRvSnNDb21tZW50KCkgOlxuICAgICAgICAgICAgJyc7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxpbmVzID0gcHJlYW1ibGVMaW5lcy5jb25jYXQoW2N0eC50b1NvdXJjZSgpLCBzbV0pO1xuICAgICAgICBpZiAoc20pIHtcbiAgICAgICAgICAgIC8vIGFsd2F5cyBhZGQgYSBuZXdsaW5lIGF0IHRoZSBlbmQsIGFzIHNvbWUgdG9vbHMgaGF2ZSBidWdzIHdpdGhvdXQgaXQuXG4gICAgICAgICAgICBsaW5lcy5wdXNoKCcnKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguc2V0UHJlYW1ibGVMaW5lQ291bnQocHJlYW1ibGVMaW5lcy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4geyBzb3VyY2VUZXh0OiBsaW5lcy5qb2luKCdcXG4nKSwgY29udGV4dDogY3R4IH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNyY0ZpbGVQYXRoXG4gICAgICogQHBhcmFtIHs/fSBnZW5GaWxlUGF0aFxuICAgICAqIEBwYXJhbSB7P30gc3RtdHNcbiAgICAgKiBAcGFyYW0gez89fSBwcmVhbWJsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHlwZVNjcmlwdEVtaXR0ZXIucHJvdG90eXBlLmVtaXRTdGF0ZW1lbnRzID0gZnVuY3Rpb24gKHNyY0ZpbGVQYXRoLCBnZW5GaWxlUGF0aCwgc3RtdHMsIHByZWFtYmxlKSB7XG4gICAgICAgIGlmIChwcmVhbWJsZSA9PT0gdm9pZCAwKSB7IHByZWFtYmxlID0gJyc7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdFN0YXRlbWVudHNBbmRDb250ZXh0KHNyY0ZpbGVQYXRoLCBnZW5GaWxlUGF0aCwgc3RtdHMsIHByZWFtYmxlKS5zb3VyY2VUZXh0O1xuICAgIH07XG4gICAgcmV0dXJuIFR5cGVTY3JpcHRFbWl0dGVyO1xufSgpKTtcbnZhciBfVHNFbWl0dGVyVmlzaXRvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoX1RzRW1pdHRlclZpc2l0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gX1RzRW1pdHRlclZpc2l0b3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGZhbHNlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50eXBlRXhwcmVzc2lvbiA9IDA7XG4gICAgICAgIF90aGlzLmltcG9ydHNXaXRoUHJlZml4ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIF90aGlzLnJlZXhwb3J0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEBwYXJhbSB7Pz19IGRlZmF1bHRUeXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUeXBlID0gZnVuY3Rpb24gKHQsIGN0eCwgZGVmYXVsdFR5cGUpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRUeXBlID09PSB2b2lkIDApIHsgZGVmYXVsdFR5cGUgPSAnYW55JzsgfVxuICAgICAgICBpZiAodCkge1xuICAgICAgICAgICAgdGhpcy50eXBlRXhwcmVzc2lvbisrO1xuICAgICAgICAgICAgdC52aXNpdFR5cGUodGhpcywgY3R4KTtcbiAgICAgICAgICAgIHRoaXMudHlwZUV4cHJlc3Npb24tLTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5wcmludChudWxsLCBkZWZhdWx0VHlwZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gYXN0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCAmJiBhc3QudHlwZSAhPSBJTkZFUlJFRF9UWVBFKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoYXN0LCBcIihcIiArIHZhbHVlICsgXCIgYXMgYW55KVwiKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEV4cHIuY2FsbCh0aGlzLCBhc3QsIGN0eCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXlFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGlmIChhc3QuZW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGN0eC5wcmludChhc3QsICcoJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gX3N1cGVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheUV4cHIuY2FsbCh0aGlzLCBhc3QsIGN0eCk7XG4gICAgICAgIGlmIChhc3QuZW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGN0eC5wcmludChhc3QsICcgYXMgYW55W10pJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4dGVybmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB0aGlzLl92aXNpdElkZW50aWZpZXIoYXN0LnZhbHVlLCBhc3QudHlwZVBhcmFtcywgY3R4KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBc3NlcnROb3ROdWxsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSBfc3VwZXIucHJvdG90eXBlLnZpc2l0QXNzZXJ0Tm90TnVsbEV4cHIuY2FsbCh0aGlzLCBhc3QsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsICchJyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZVZhclN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIGlmIChzdG10Lmhhc01vZGlmaWVyKFN0bXRNb2RpZmllci5FeHBvcnRlZCkgJiYgc3RtdC52YWx1ZSBpbnN0YW5jZW9mIEV4dGVybmFsRXhwciAmJlxuICAgICAgICAgICAgIXN0bXQudHlwZSkge1xuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGEgcmVleHBvcnRcbiAgICAgICAgICAgIHZhciBfYSA9IHN0bXQudmFsdWUudmFsdWUsIG5hbWUgPSBfYS5uYW1lLCBtb2R1bGVOYW1lID0gX2EubW9kdWxlTmFtZTtcbiAgICAgICAgICAgIGlmIChtb2R1bGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVleHBvcnRzID0gdGhpcy5yZWV4cG9ydHMuZ2V0KG1vZHVsZU5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICghcmVleHBvcnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZXhwb3J0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZXhwb3J0cy5zZXQobW9kdWxlTmFtZSwgcmVleHBvcnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVleHBvcnRzLnB1c2goeyBuYW1lOiAvKiogQHR5cGUgez99ICovICgobmFtZSkpLCBhczogc3RtdC5uYW1lIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdG10Lmhhc01vZGlmaWVyKFN0bXRNb2RpZmllci5FeHBvcnRlZCkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChzdG10LCBcImV4cG9ydCBcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0bXQuaGFzTW9kaWZpZXIoU3RtdE1vZGlmaWVyLkZpbmFsKSkge1xuICAgICAgICAgICAgY3R4LnByaW50KHN0bXQsIFwiY29uc3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCJ2YXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50KHN0bXQsIFwiIFwiICsgc3RtdC5uYW1lKTtcbiAgICAgICAgdGhpcy5fcHJpbnRDb2xvblR5cGUoc3RtdC50eXBlLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCIgPSBcIik7XG4gICAgICAgIHN0bXQudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwiO1wiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRDYXN0RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIig8XCIpOyAvKiogQHR5cGUgez99ICovXG4gICAgICAgICgoYXN0LnR5cGUpKS52aXNpdFR5cGUodGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCI+XCIpO1xuICAgICAgICBhc3QudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRJbnN0YW50aWF0ZUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCJuZXcgXCIpO1xuICAgICAgICB0aGlzLnR5cGVFeHByZXNzaW9uKys7XG4gICAgICAgIGFzdC5jbGFzc0V4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIHRoaXMudHlwZUV4cHJlc3Npb24tLTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCIoXCIpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGN0eCwgJywnKTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCIpXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlQ2xhc3NTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBjdHgucHVzaENsYXNzKHN0bXQpO1xuICAgICAgICBpZiAoc3RtdC5oYXNNb2RpZmllcihTdG10TW9kaWZpZXIuRXhwb3J0ZWQpKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCJleHBvcnQgXCIpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChzdG10LCBcImNsYXNzIFwiICsgc3RtdC5uYW1lKTtcbiAgICAgICAgaWYgKHN0bXQucGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChzdG10LCBcIiBleHRlbmRzIFwiKTtcbiAgICAgICAgICAgIHRoaXMudHlwZUV4cHJlc3Npb24rKztcbiAgICAgICAgICAgIHN0bXQucGFyZW50LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgICAgdGhpcy50eXBlRXhwcmVzc2lvbi0tO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwiIHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgc3RtdC5maWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIF90aGlzLl92aXNpdENsYXNzRmllbGQoZmllbGQsIGN0eCk7IH0pO1xuICAgICAgICBpZiAoc3RtdC5jb25zdHJ1Y3Rvck1ldGhvZCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl92aXNpdENsYXNzQ29uc3RydWN0b3Ioc3RtdCwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBzdG10LmdldHRlcnMuZm9yRWFjaChmdW5jdGlvbiAoZ2V0dGVyKSB7IHJldHVybiBfdGhpcy5fdmlzaXRDbGFzc0dldHRlcihnZXR0ZXIsIGN0eCk7IH0pO1xuICAgICAgICBzdG10Lm1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7IHJldHVybiBfdGhpcy5fdmlzaXRDbGFzc01ldGhvZChtZXRob2QsIGN0eCk7IH0pO1xuICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwifVwiKTtcbiAgICAgICAgY3R4LnBvcENsYXNzKCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmaWVsZFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0Q2xhc3NGaWVsZCA9IGZ1bmN0aW9uIChmaWVsZCwgY3R4KSB7XG4gICAgICAgIGlmIChmaWVsZC5oYXNNb2RpZmllcihTdG10TW9kaWZpZXIuUHJpdmF0ZSkpIHtcbiAgICAgICAgICAgIC8vIGNvbW1lbnQgb3V0IGFzIGEgd29ya2Fyb3VuZCBmb3IgIzEwOTY3XG4gICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgXCIvKnByaXZhdGUqLyBcIik7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50KG51bGwsIGZpZWxkLm5hbWUpO1xuICAgICAgICB0aGlzLl9wcmludENvbG9uVHlwZShmaWVsZC50eXBlLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnRsbihudWxsLCBcIjtcIik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGdldHRlclxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0Q2xhc3NHZXR0ZXIgPSBmdW5jdGlvbiAoZ2V0dGVyLCBjdHgpIHtcbiAgICAgICAgaWYgKGdldHRlci5oYXNNb2RpZmllcihTdG10TW9kaWZpZXIuUHJpdmF0ZSkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChudWxsLCBcInByaXZhdGUgXCIpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChudWxsLCBcImdldCBcIiArIGdldHRlci5uYW1lICsgXCIoKVwiKTtcbiAgICAgICAgdGhpcy5fcHJpbnRDb2xvblR5cGUoZ2V0dGVyLnR5cGUsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludGxuKG51bGwsIFwiIHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoZ2V0dGVyLmJvZHksIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4obnVsbCwgXCJ9XCIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRDbGFzc0NvbnN0cnVjdG9yID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCJjb25zdHJ1Y3RvcihcIik7XG4gICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKHN0bXQuY29uc3RydWN0b3JNZXRob2QucGFyYW1zLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIikge1wiKTtcbiAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmNvbnN0cnVjdG9yTWV0aG9kLmJvZHksIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ9XCIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXRob2RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdENsYXNzTWV0aG9kID0gZnVuY3Rpb24gKG1ldGhvZCwgY3R4KSB7XG4gICAgICAgIGlmIChtZXRob2QuaGFzTW9kaWZpZXIoU3RtdE1vZGlmaWVyLlByaXZhdGUpKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgXCJwcml2YXRlIFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnQobnVsbCwgbWV0aG9kLm5hbWUgKyBcIihcIik7XG4gICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKG1ldGhvZC5wYXJhbXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChudWxsLCBcIilcIik7XG4gICAgICAgIHRoaXMuX3ByaW50Q29sb25UeXBlKG1ldGhvZC50eXBlLCBjdHgsICd2b2lkJyk7XG4gICAgICAgIGN0eC5wcmludGxuKG51bGwsIFwiIHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMobWV0aG9kLmJvZHksIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4obnVsbCwgXCJ9XCIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25FeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiKFwiKTtcbiAgICAgICAgdGhpcy5fdmlzaXRQYXJhbXMoYXN0LnBhcmFtcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCIpXCIpO1xuICAgICAgICB0aGlzLl9wcmludENvbG9uVHlwZShhc3QudHlwZSwgY3R4LCAndm9pZCcpO1xuICAgICAgICBjdHgucHJpbnRsbihhc3QsIFwiID0+IHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoYXN0LnN0YXRlbWVudHMsIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCJ9XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlRnVuY3Rpb25TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBpZiAoc3RtdC5oYXNNb2RpZmllcihTdG10TW9kaWZpZXIuRXhwb3J0ZWQpKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCJleHBvcnQgXCIpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChzdG10LCBcImZ1bmN0aW9uIFwiICsgc3RtdC5uYW1lICsgXCIoXCIpO1xuICAgICAgICB0aGlzLl92aXNpdFBhcmFtcyhzdG10LnBhcmFtcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KHN0bXQsIFwiKVwiKTtcbiAgICAgICAgdGhpcy5fcHJpbnRDb2xvblR5cGUoc3RtdC50eXBlLCBjdHgsICd2b2lkJyk7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwiIHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5zdGF0ZW1lbnRzLCBjdHgpO1xuICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwifVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VHJ5Q2F0Y2hTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcInRyeSB7XCIpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuYm9keVN0bXRzLCBjdHgpO1xuICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwifSBjYXRjaCAoXCIgKyBDQVRDSF9FUlJPUl9WQVIkMS5uYW1lICsgXCIpIHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2F0Y2hTdG10cyA9IFsvKiogQHR5cGUgez99ICovIChDQVRDSF9TVEFDS19WQVIkMS5zZXQoQ0FUQ0hfRVJST1JfVkFSJDEucHJvcCgnc3RhY2snLCBudWxsKSkudG9EZWNsU3RtdChudWxsLCBbXG4gICAgICAgICAgICAgICAgU3RtdE1vZGlmaWVyLkZpbmFsXG4gICAgICAgICAgICBdKSldLmNvbmNhdChzdG10LmNhdGNoU3RtdHMpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhjYXRjaFN0bXRzLCBjdHgpO1xuICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwifVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0QnVpbHRpbnRUeXBlID0gZnVuY3Rpb24gKHR5cGUsIGN0eCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0eXBlU3RyO1xuICAgICAgICBzd2l0Y2ggKHR5cGUubmFtZSkge1xuICAgICAgICAgICAgY2FzZSBCdWlsdGluVHlwZU5hbWUuQm9vbDpcbiAgICAgICAgICAgICAgICB0eXBlU3RyID0gJ2Jvb2xlYW4nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCdWlsdGluVHlwZU5hbWUuRHluYW1pYzpcbiAgICAgICAgICAgICAgICB0eXBlU3RyID0gJ2FueSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJ1aWx0aW5UeXBlTmFtZS5GdW5jdGlvbjpcbiAgICAgICAgICAgICAgICB0eXBlU3RyID0gJ0Z1bmN0aW9uJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQnVpbHRpblR5cGVOYW1lLk51bWJlcjpcbiAgICAgICAgICAgICAgICB0eXBlU3RyID0gJ251bWJlcic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJ1aWx0aW5UeXBlTmFtZS5JbnQ6XG4gICAgICAgICAgICAgICAgdHlwZVN0ciA9ICdudW1iZXInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCdWlsdGluVHlwZU5hbWUuU3RyaW5nOlxuICAgICAgICAgICAgICAgIHR5cGVTdHIgPSAnc3RyaW5nJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgYnVpbHRpbiB0eXBlIFwiICsgdHlwZS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnQobnVsbCwgdHlwZVN0cik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvblR5cGUgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgYXN0LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBcnJheVR5cGUgPSBmdW5jdGlvbiAodHlwZSwgY3R4KSB7XG4gICAgICAgIHRoaXMudmlzaXRUeXBlKHR5cGUub2YsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChudWxsLCBcIltdXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRNYXBUeXBlID0gZnVuY3Rpb24gKHR5cGUsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQobnVsbCwgXCJ7W2tleTogc3RyaW5nXTpcIik7XG4gICAgICAgIHRoaXMudmlzaXRUeXBlKHR5cGUudmFsdWVUeXBlLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQobnVsbCwgXCJ9XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWV0aG9kXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuZ2V0QnVpbHRpbk1ldGhvZE5hbWUgPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWU7XG4gICAgICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlIEJ1aWx0aW5NZXRob2QuQ29uY2F0QXJyYXk6XG4gICAgICAgICAgICAgICAgbmFtZSA9ICdjb25jYXQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCdWlsdGluTWV0aG9kLlN1YnNjcmliZU9ic2VydmFibGU6XG4gICAgICAgICAgICAgICAgbmFtZSA9ICdzdWJzY3JpYmUnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCdWlsdGluTWV0aG9kLkJpbmQ6XG4gICAgICAgICAgICAgICAgbmFtZSA9ICdiaW5kJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBidWlsdGluIG1ldGhvZDogXCIgKyBtZXRob2QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdFBhcmFtcyA9IGZ1bmN0aW9uIChwYXJhbXMsIGN0eCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnZpc2l0QWxsT2JqZWN0cyhmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgICAgIGN0eC5wcmludChudWxsLCBwYXJhbS5uYW1lKTtcbiAgICAgICAgICAgIF90aGlzLl9wcmludENvbG9uVHlwZShwYXJhbS50eXBlLCBjdHgpO1xuICAgICAgICB9LCBwYXJhbXMsIGN0eCwgJywnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IHR5cGVQYXJhbXNcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdElkZW50aWZpZXIgPSBmdW5jdGlvbiAodmFsdWUsIHR5cGVQYXJhbXMsIGN0eCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUsIG1vZHVsZU5hbWUgPSB2YWx1ZS5tb2R1bGVOYW1lO1xuICAgICAgICBpZiAobW9kdWxlTmFtZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlZml4ID0gdGhpcy5pbXBvcnRzV2l0aFByZWZpeGVzLmdldChtb2R1bGVOYW1lKTtcbiAgICAgICAgICAgIGlmIChwcmVmaXggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHByZWZpeCA9IFwiaVwiICsgdGhpcy5pbXBvcnRzV2l0aFByZWZpeGVzLnNpemU7XG4gICAgICAgICAgICAgICAgdGhpcy5pbXBvcnRzV2l0aFByZWZpeGVzLnNldChtb2R1bGVOYW1lLCBwcmVmaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnByaW50KG51bGwsIHByZWZpeCArIFwiLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnQobnVsbCwgLyoqIEB0eXBlIHs/fSAqLyAoKG5hbWUpKSk7XG4gICAgICAgIGlmICh0aGlzLnR5cGVFeHByZXNzaW9uID4gMCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGluIGEgdHlwZSBleHByZXNzaW9uIHRoYXQgcmVmZXJzIHRvIGEgZ2VuZXJpYyB0eXBlIHRoZW4gc3VwcGx5XG4gICAgICAgICAgICAvLyB0aGUgcmVxdWlyZWQgdHlwZSBwYXJhbWV0ZXJzLiBJZiB0aGVyZSB3ZXJlIG5vdCBlbm91Z2ggdHlwZSBwYXJhbWV0ZXJzXG4gICAgICAgICAgICAvLyBzdXBwbGllZCwgc3VwcGx5IGFueSBhcyB0aGUgdHlwZS4gT3V0c2lkZSBhIHR5cGUgZXhwcmVzc2lvbiB0aGUgcmVmZXJlbmNlXG4gICAgICAgICAgICAvLyBzaG91bGQgbm90IHN1cHBseSB0eXBlIHBhcmFtZXRlcnMgYW5kIGJlIHRyZWF0ZWQgYXMgYSBzaW1wbGUgdmFsdWUgcmVmZXJlbmNlXG4gICAgICAgICAgICAvLyB0byB0aGUgY29uc3RydWN0b3IgZnVuY3Rpb24gaXRzZWxmLlxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3VwcGxpZWRQYXJhbWV0ZXJzID0gdHlwZVBhcmFtcyB8fCBbXTtcbiAgICAgICAgICAgIGlmIChzdXBwbGllZFBhcmFtZXRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGN0eC5wcmludChudWxsLCBcIjxcIik7XG4gICAgICAgICAgICAgICAgdGhpcy52aXNpdEFsbE9iamVjdHMoZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIHR5cGUudmlzaXRUeXBlKF90aGlzLCBjdHgpOyB9LCAvKiogQHR5cGUgez99ICovICgodHlwZVBhcmFtcykpLCBjdHgsICcsJyk7XG4gICAgICAgICAgICAgICAgY3R4LnByaW50KG51bGwsIFwiPlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcGFyYW0gez89fSBkZWZhdWx0VHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl9wcmludENvbG9uVHlwZSA9IGZ1bmN0aW9uICh0eXBlLCBjdHgsIGRlZmF1bHRUeXBlKSB7XG4gICAgICAgIGlmICh0eXBlICE9PSBJTkZFUlJFRF9UWVBFKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgJzonKTtcbiAgICAgICAgICAgIHRoaXMudmlzaXRUeXBlKHR5cGUsIGN0eCwgZGVmYXVsdFR5cGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gX1RzRW1pdHRlclZpc2l0b3I7XG59KEFic3RyYWN0RW1pdHRlclZpc2l0b3IpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogTWFwIGZyb20gdGFnTmFtZXxwcm9wZXJ0eU5hbWUgU2VjdXJpdHlDb250ZXh0LiBQcm9wZXJ0aWVzIGFwcGx5aW5nIHRvIGFsbCB0YWdzIHVzZSAnKicuXG4gKi9cbnZhciBTRUNVUklUWV9TQ0hFTUEgPSB7fTtcbi8qKlxuICogQHBhcmFtIHs/fSBjdHhcbiAqIEBwYXJhbSB7P30gc3BlY3NcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyQ29udGV4dChjdHgsIHNwZWNzKSB7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBzcGVjc18xID0gc3BlY3M7IF9pIDwgc3BlY3NfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHNwZWMgPSBzcGVjc18xW19pXTtcbiAgICAgICAgU0VDVVJJVFlfU0NIRU1BW3NwZWMudG9Mb3dlckNhc2UoKV0gPSBjdHg7XG4gICAgfVxufVxuLy8gQ2FzZSBpcyBpbnNpZ25pZmljYW50IGJlbG93LCBhbGwgZWxlbWVudCBhbmQgYXR0cmlidXRlIG5hbWVzIGFyZSBsb3dlci1jYXNlZCBmb3IgbG9va3VwLlxucmVnaXN0ZXJDb250ZXh0KFNlY3VyaXR5Q29udGV4dC5IVE1MLCBbXG4gICAgJ2lmcmFtZXxzcmNkb2MnLFxuICAgICcqfGlubmVySFRNTCcsXG4gICAgJyp8b3V0ZXJIVE1MJyxcbl0pO1xucmVnaXN0ZXJDb250ZXh0KFNlY3VyaXR5Q29udGV4dC5TVFlMRSwgWycqfHN0eWxlJ10pO1xuLy8gTkI6IG5vIFNDUklQVCBjb250ZXh0cyBoZXJlLCB0aGV5IGFyZSBuZXZlciBhbGxvd2VkIGR1ZSB0byB0aGUgcGFyc2VyIHN0cmlwcGluZyB0aGVtLlxucmVnaXN0ZXJDb250ZXh0KFNlY3VyaXR5Q29udGV4dC5VUkwsIFtcbiAgICAnKnxmb3JtQWN0aW9uJywgJ2FyZWF8aHJlZicsICdhcmVhfHBpbmcnLCAnYXVkaW98c3JjJywgJ2F8aHJlZicsXG4gICAgJ2F8cGluZycsICdibG9ja3F1b3RlfGNpdGUnLCAnYm9keXxiYWNrZ3JvdW5kJywgJ2RlbHxjaXRlJywgJ2Zvcm18YWN0aW9uJyxcbiAgICAnaW1nfHNyYycsICdpbWd8c3Jjc2V0JywgJ2lucHV0fHNyYycsICdpbnN8Y2l0ZScsICdxfGNpdGUnLFxuICAgICdzb3VyY2V8c3JjJywgJ3NvdXJjZXxzcmNzZXQnLCAndHJhY2t8c3JjJywgJ3ZpZGVvfHBvc3RlcicsICd2aWRlb3xzcmMnLFxuXSk7XG5yZWdpc3RlckNvbnRleHQoU2VjdXJpdHlDb250ZXh0LlJFU09VUkNFX1VSTCwgW1xuICAgICdhcHBsZXR8Y29kZScsXG4gICAgJ2FwcGxldHxjb2RlYmFzZScsXG4gICAgJ2Jhc2V8aHJlZicsXG4gICAgJ2VtYmVkfHNyYycsXG4gICAgJ2ZyYW1lfHNyYycsXG4gICAgJ2hlYWR8cHJvZmlsZScsXG4gICAgJ2h0bWx8bWFuaWZlc3QnLFxuICAgICdpZnJhbWV8c3JjJyxcbiAgICAnbGlua3xocmVmJyxcbiAgICAnbWVkaWF8c3JjJyxcbiAgICAnb2JqZWN0fGNvZGViYXNlJyxcbiAgICAnb2JqZWN0fGRhdGEnLFxuICAgICdzY3JpcHR8c3JjJyxcbl0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEJPT0xFQU4gPSAnYm9vbGVhbic7XG52YXIgTlVNQkVSID0gJ251bWJlcic7XG52YXIgU1RSSU5HID0gJ3N0cmluZyc7XG52YXIgT0JKRUNUID0gJ29iamVjdCc7XG4vKipcbiAqIFRoaXMgYXJyYXkgcmVwcmVzZW50cyB0aGUgRE9NIHNjaGVtYS4gSXQgZW5jb2RlcyBpbmhlcml0YW5jZSwgcHJvcGVydGllcywgYW5kIGV2ZW50cy5cbiAqXG4gKiAjIyBPdmVydmlld1xuICpcbiAqIEVhY2ggbGluZSByZXByZXNlbnRzIG9uZSBraW5kIG9mIGVsZW1lbnQuIFRoZSBgZWxlbWVudF9pbmhlcml0YW5jZWAgYW5kIHByb3BlcnRpZXMgYXJlIGpvaW5lZFxuICogdXNpbmcgYGVsZW1lbnRfaW5oZXJpdGFuY2V8cHJvcGVydGllc2Agc3ludGF4LlxuICpcbiAqICMjIEVsZW1lbnQgSW5oZXJpdGFuY2VcbiAqXG4gKiBUaGUgYGVsZW1lbnRfaW5oZXJpdGFuY2VgIGNhbiBiZSBmdXJ0aGVyIHN1YmRpdmlkZWQgYXMgYGVsZW1lbnQxLGVsZW1lbnQyLC4uLl5wYXJlbnRFbGVtZW50YC5cbiAqIEhlcmUgdGhlIGluZGl2aWR1YWwgZWxlbWVudHMgYXJlIHNlcGFyYXRlZCBieSBgLGAgKGNvbW1hcykuIEV2ZXJ5IGVsZW1lbnQgaW4gdGhlIGxpc3RcbiAqIGhhcyBpZGVudGljYWwgcHJvcGVydGllcy5cbiAqXG4gKiBBbiBgZWxlbWVudGAgbWF5IGluaGVyaXQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGZyb20gYHBhcmVudEVsZW1lbnRgIElmIG5vIGBecGFyZW50RWxlbWVudGAgaXNcbiAqIHNwZWNpZmllZCB0aGVuIGBcIlwiYCAoYmxhbmspIGVsZW1lbnQgaXMgYXNzdW1lZC5cbiAqXG4gKiBOT1RFOiBUaGUgYmxhbmsgZWxlbWVudCBpbmhlcml0cyBmcm9tIHJvb3QgYFtFbGVtZW50XWAgZWxlbWVudCwgdGhlIHN1cGVyIGVsZW1lbnQgb2YgYWxsXG4gKiBlbGVtZW50cy5cbiAqXG4gKiBOT1RFIGFuIGVsZW1lbnQgcHJlZml4IHN1Y2ggYXMgYDpzdmc6YCBoYXMgbm8gc3BlY2lhbCBtZWFuaW5nIHRvIHRoZSBzY2hlbWEuXG4gKlxuICogIyMgUHJvcGVydGllc1xuICpcbiAqIEVhY2ggZWxlbWVudCBoYXMgYSBzZXQgb2YgcHJvcGVydGllcyBzZXBhcmF0ZWQgYnkgYCxgIChjb21tYXMpLiBFYWNoIHByb3BlcnR5IGNhbiBiZSBwcmVmaXhlZFxuICogYnkgYSBzcGVjaWFsIGNoYXJhY3RlciBkZXNpZ25hdGluZyBpdHMgdHlwZTpcbiAqXG4gKiAtIChubyBwcmVmaXgpOiBwcm9wZXJ0eSBpcyBhIHN0cmluZy5cbiAqIC0gYCpgOiBwcm9wZXJ0eSByZXByZXNlbnRzIGFuIGV2ZW50LlxuICogLSBgIWA6IHByb3BlcnR5IGlzIGEgYm9vbGVhbi5cbiAqIC0gYCNgOiBwcm9wZXJ0eSBpcyBhIG51bWJlci5cbiAqIC0gYCVgOiBwcm9wZXJ0eSBpcyBhbiBvYmplY3QuXG4gKlxuICogIyMgUXVlcnlcbiAqXG4gKiBUaGUgY2xhc3MgY3JlYXRlcyBhbiBpbnRlcm5hbCBzcXVhcyByZXByZXNlbnRhdGlvbiB3aGljaCBhbGxvd3MgdG8gZWFzaWx5IGFuc3dlciB0aGUgcXVlcnkgb2ZcbiAqIGlmIGEgZ2l2ZW4gcHJvcGVydHkgZXhpc3Qgb24gYSBnaXZlbiBlbGVtZW50LlxuICpcbiAqIE5PVEU6IFdlIGRvbid0IHlldCBzdXBwb3J0IHF1ZXJ5aW5nIGZvciB0eXBlcyBvciBldmVudHMuXG4gKiBOT1RFOiBUaGlzIHNjaGVtYSBpcyBhdXRvIGV4dHJhY3RlZCBmcm9tIGBzY2hlbWFfZXh0cmFjdG9yLnRzYCBsb2NhdGVkIGluIHRoZSB0ZXN0IGZvbGRlcixcbiAqICAgICAgIHNlZSBkb21fZWxlbWVudF9zY2hlbWFfcmVnaXN0cnlfc3BlYy50c1xuICovXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyA9PT09PT09PT09PSBTIFQgTyBQICAgLSAgUyBUIE8gUCAgIC0gIFMgVCBPIFAgICAtICBTIFQgTyBQICAgLSAgUyBUIE8gUCAgIC0gIFMgVCBPIFAgID09PT09PT09PT09XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vL1xuLy8gICAgICAgICAgICAgICAgICAgICAgIERPIE5PVCBFRElUIFRISVMgRE9NIFNDSEVNQSBXSVRIT1VUIEEgU0VDVVJJVFkgUkVWSUVXIVxuLy9cbi8vIE5ld2x5IGFkZGVkIHByb3BlcnRpZXMgbXVzdCBiZSBzZWN1cml0eSByZXZpZXdlZCBhbmQgYXNzaWduZWQgYW4gYXBwcm9wcmlhdGUgU2VjdXJpdHlDb250ZXh0IGluXG4vLyBkb21fc2VjdXJpdHlfc2NoZW1hLnRzLiBSZWFjaCBvdXQgdG8gbXByb2JzdCAmIHJqYW1ldCBmb3IgZGV0YWlscy5cbi8vXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG52YXIgU0NIRU1BID0gW1xuICAgICdbRWxlbWVudF18dGV4dENvbnRlbnQsJWNsYXNzTGlzdCxjbGFzc05hbWUsaWQsaW5uZXJIVE1MLCpiZWZvcmVjb3B5LCpiZWZvcmVjdXQsKmJlZm9yZXBhc3RlLCpjb3B5LCpjdXQsKnBhc3RlLCpzZWFyY2gsKnNlbGVjdHN0YXJ0LCp3ZWJraXRmdWxsc2NyZWVuY2hhbmdlLCp3ZWJraXRmdWxsc2NyZWVuZXJyb3IsKndoZWVsLG91dGVySFRNTCwjc2Nyb2xsTGVmdCwjc2Nyb2xsVG9wLHNsb3QnICtcbiAgICAgICAgLyogYWRkZWQgbWFudWFsbHkgdG8gYXZvaWQgYnJlYWtpbmcgY2hhbmdlcyAqL1xuICAgICAgICAnLCptZXNzYWdlLCptb3pmdWxsc2NyZWVuY2hhbmdlLCptb3pmdWxsc2NyZWVuZXJyb3IsKm1venBvaW50ZXJsb2NrY2hhbmdlLCptb3pwb2ludGVybG9ja2Vycm9yLCp3ZWJnbGNvbnRleHRjcmVhdGlvbmVycm9yLCp3ZWJnbGNvbnRleHRsb3N0LCp3ZWJnbGNvbnRleHRyZXN0b3JlZCcsXG4gICAgJ1tIVE1MRWxlbWVudF1eW0VsZW1lbnRdfGFjY2Vzc0tleSxjb250ZW50RWRpdGFibGUsZGlyLCFkcmFnZ2FibGUsIWhpZGRlbixpbm5lclRleHQsbGFuZywqYWJvcnQsKmF1eGNsaWNrLCpibHVyLCpjYW5jZWwsKmNhbnBsYXksKmNhbnBsYXl0aHJvdWdoLCpjaGFuZ2UsKmNsaWNrLCpjbG9zZSwqY29udGV4dG1lbnUsKmN1ZWNoYW5nZSwqZGJsY2xpY2ssKmRyYWcsKmRyYWdlbmQsKmRyYWdlbnRlciwqZHJhZ2xlYXZlLCpkcmFnb3ZlciwqZHJhZ3N0YXJ0LCpkcm9wLCpkdXJhdGlvbmNoYW5nZSwqZW1wdGllZCwqZW5kZWQsKmVycm9yLCpmb2N1cywqZ290cG9pbnRlcmNhcHR1cmUsKmlucHV0LCppbnZhbGlkLCprZXlkb3duLCprZXlwcmVzcywqa2V5dXAsKmxvYWQsKmxvYWRlZGRhdGEsKmxvYWRlZG1ldGFkYXRhLCpsb2Fkc3RhcnQsKmxvc3Rwb2ludGVyY2FwdHVyZSwqbW91c2Vkb3duLCptb3VzZWVudGVyLCptb3VzZWxlYXZlLCptb3VzZW1vdmUsKm1vdXNlb3V0LCptb3VzZW92ZXIsKm1vdXNldXAsKm1vdXNld2hlZWwsKnBhdXNlLCpwbGF5LCpwbGF5aW5nLCpwb2ludGVyY2FuY2VsLCpwb2ludGVyZG93biwqcG9pbnRlcmVudGVyLCpwb2ludGVybGVhdmUsKnBvaW50ZXJtb3ZlLCpwb2ludGVyb3V0LCpwb2ludGVyb3ZlciwqcG9pbnRlcnVwLCpwcm9ncmVzcywqcmF0ZWNoYW5nZSwqcmVzZXQsKnJlc2l6ZSwqc2Nyb2xsLCpzZWVrZWQsKnNlZWtpbmcsKnNlbGVjdCwqc2hvdywqc3RhbGxlZCwqc3VibWl0LCpzdXNwZW5kLCp0aW1ldXBkYXRlLCp0b2dnbGUsKnZvbHVtZWNoYW5nZSwqd2FpdGluZyxvdXRlclRleHQsIXNwZWxsY2hlY2ssJXN0eWxlLCN0YWJJbmRleCx0aXRsZSwhdHJhbnNsYXRlJyxcbiAgICAnYWJicixhZGRyZXNzLGFydGljbGUsYXNpZGUsYixiZGksYmRvLGNpdGUsY29kZSxkZCxkZm4sZHQsZW0sZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGhlYWRlcixpLGtiZCxtYWluLG1hcmssbmF2LG5vc2NyaXB0LHJiLHJwLHJ0LHJ0YyxydWJ5LHMsc2FtcCxzZWN0aW9uLHNtYWxsLHN0cm9uZyxzdWIsc3VwLHUsdmFyLHdicl5bSFRNTEVsZW1lbnRdfGFjY2Vzc0tleSxjb250ZW50RWRpdGFibGUsZGlyLCFkcmFnZ2FibGUsIWhpZGRlbixpbm5lclRleHQsbGFuZywqYWJvcnQsKmF1eGNsaWNrLCpibHVyLCpjYW5jZWwsKmNhbnBsYXksKmNhbnBsYXl0aHJvdWdoLCpjaGFuZ2UsKmNsaWNrLCpjbG9zZSwqY29udGV4dG1lbnUsKmN1ZWNoYW5nZSwqZGJsY2xpY2ssKmRyYWcsKmRyYWdlbmQsKmRyYWdlbnRlciwqZHJhZ2xlYXZlLCpkcmFnb3ZlciwqZHJhZ3N0YXJ0LCpkcm9wLCpkdXJhdGlvbmNoYW5nZSwqZW1wdGllZCwqZW5kZWQsKmVycm9yLCpmb2N1cywqZ290cG9pbnRlcmNhcHR1cmUsKmlucHV0LCppbnZhbGlkLCprZXlkb3duLCprZXlwcmVzcywqa2V5dXAsKmxvYWQsKmxvYWRlZGRhdGEsKmxvYWRlZG1ldGFkYXRhLCpsb2Fkc3RhcnQsKmxvc3Rwb2ludGVyY2FwdHVyZSwqbW91c2Vkb3duLCptb3VzZWVudGVyLCptb3VzZWxlYXZlLCptb3VzZW1vdmUsKm1vdXNlb3V0LCptb3VzZW92ZXIsKm1vdXNldXAsKm1vdXNld2hlZWwsKnBhdXNlLCpwbGF5LCpwbGF5aW5nLCpwb2ludGVyY2FuY2VsLCpwb2ludGVyZG93biwqcG9pbnRlcmVudGVyLCpwb2ludGVybGVhdmUsKnBvaW50ZXJtb3ZlLCpwb2ludGVyb3V0LCpwb2ludGVyb3ZlciwqcG9pbnRlcnVwLCpwcm9ncmVzcywqcmF0ZWNoYW5nZSwqcmVzZXQsKnJlc2l6ZSwqc2Nyb2xsLCpzZWVrZWQsKnNlZWtpbmcsKnNlbGVjdCwqc2hvdywqc3RhbGxlZCwqc3VibWl0LCpzdXNwZW5kLCp0aW1ldXBkYXRlLCp0b2dnbGUsKnZvbHVtZWNoYW5nZSwqd2FpdGluZyxvdXRlclRleHQsIXNwZWxsY2hlY2ssJXN0eWxlLCN0YWJJbmRleCx0aXRsZSwhdHJhbnNsYXRlJyxcbiAgICAnbWVkaWFeW0hUTUxFbGVtZW50XXwhYXV0b3BsYXksIWNvbnRyb2xzLCVjb250cm9sc0xpc3QsJWNyb3NzT3JpZ2luLCNjdXJyZW50VGltZSwhZGVmYXVsdE11dGVkLCNkZWZhdWx0UGxheWJhY2tSYXRlLCFkaXNhYmxlUmVtb3RlUGxheWJhY2ssIWxvb3AsIW11dGVkLCplbmNyeXB0ZWQsKndhaXRpbmdmb3JrZXksI3BsYXliYWNrUmF0ZSxwcmVsb2FkLHNyYywlc3JjT2JqZWN0LCN2b2x1bWUnLFxuICAgICc6c3ZnOl5bSFRNTEVsZW1lbnRdfCphYm9ydCwqYXV4Y2xpY2ssKmJsdXIsKmNhbmNlbCwqY2FucGxheSwqY2FucGxheXRocm91Z2gsKmNoYW5nZSwqY2xpY2ssKmNsb3NlLCpjb250ZXh0bWVudSwqY3VlY2hhbmdlLCpkYmxjbGljaywqZHJhZywqZHJhZ2VuZCwqZHJhZ2VudGVyLCpkcmFnbGVhdmUsKmRyYWdvdmVyLCpkcmFnc3RhcnQsKmRyb3AsKmR1cmF0aW9uY2hhbmdlLCplbXB0aWVkLCplbmRlZCwqZXJyb3IsKmZvY3VzLCpnb3Rwb2ludGVyY2FwdHVyZSwqaW5wdXQsKmludmFsaWQsKmtleWRvd24sKmtleXByZXNzLCprZXl1cCwqbG9hZCwqbG9hZGVkZGF0YSwqbG9hZGVkbWV0YWRhdGEsKmxvYWRzdGFydCwqbG9zdHBvaW50ZXJjYXB0dXJlLCptb3VzZWRvd24sKm1vdXNlZW50ZXIsKm1vdXNlbGVhdmUsKm1vdXNlbW92ZSwqbW91c2VvdXQsKm1vdXNlb3ZlciwqbW91c2V1cCwqbW91c2V3aGVlbCwqcGF1c2UsKnBsYXksKnBsYXlpbmcsKnBvaW50ZXJjYW5jZWwsKnBvaW50ZXJkb3duLCpwb2ludGVyZW50ZXIsKnBvaW50ZXJsZWF2ZSwqcG9pbnRlcm1vdmUsKnBvaW50ZXJvdXQsKnBvaW50ZXJvdmVyLCpwb2ludGVydXAsKnByb2dyZXNzLCpyYXRlY2hhbmdlLCpyZXNldCwqcmVzaXplLCpzY3JvbGwsKnNlZWtlZCwqc2Vla2luZywqc2VsZWN0LCpzaG93LCpzdGFsbGVkLCpzdWJtaXQsKnN1c3BlbmQsKnRpbWV1cGRhdGUsKnRvZ2dsZSwqdm9sdW1lY2hhbmdlLCp3YWl0aW5nLCVzdHlsZSwjdGFiSW5kZXgnLFxuICAgICc6c3ZnOmdyYXBoaWNzXjpzdmc6fCcsXG4gICAgJzpzdmc6YW5pbWF0aW9uXjpzdmc6fCpiZWdpbiwqZW5kLCpyZXBlYXQnLFxuICAgICc6c3ZnOmdlb21ldHJ5Xjpzdmc6fCcsXG4gICAgJzpzdmc6Y29tcG9uZW50VHJhbnNmZXJGdW5jdGlvbl46c3ZnOnwnLFxuICAgICc6c3ZnOmdyYWRpZW50Xjpzdmc6fCcsXG4gICAgJzpzdmc6dGV4dENvbnRlbnReOnN2ZzpncmFwaGljc3wnLFxuICAgICc6c3ZnOnRleHRQb3NpdGlvbmluZ146c3ZnOnRleHRDb250ZW50fCcsXG4gICAgJ2FeW0hUTUxFbGVtZW50XXxjaGFyc2V0LGNvb3Jkcyxkb3dubG9hZCxoYXNoLGhvc3QsaG9zdG5hbWUsaHJlZixocmVmbGFuZyxuYW1lLHBhc3N3b3JkLHBhdGhuYW1lLHBpbmcscG9ydCxwcm90b2NvbCxyZWZlcnJlclBvbGljeSxyZWwscmV2LHNlYXJjaCxzaGFwZSx0YXJnZXQsdGV4dCx0eXBlLHVzZXJuYW1lJyxcbiAgICAnYXJlYV5bSFRNTEVsZW1lbnRdfGFsdCxjb29yZHMsZG93bmxvYWQsaGFzaCxob3N0LGhvc3RuYW1lLGhyZWYsIW5vSHJlZixwYXNzd29yZCxwYXRobmFtZSxwaW5nLHBvcnQscHJvdG9jb2wscmVmZXJyZXJQb2xpY3kscmVsLHNlYXJjaCxzaGFwZSx0YXJnZXQsdXNlcm5hbWUnLFxuICAgICdhdWRpb15tZWRpYXwnLFxuICAgICdicl5bSFRNTEVsZW1lbnRdfGNsZWFyJyxcbiAgICAnYmFzZV5bSFRNTEVsZW1lbnRdfGhyZWYsdGFyZ2V0JyxcbiAgICAnYm9keV5bSFRNTEVsZW1lbnRdfGFMaW5rLGJhY2tncm91bmQsYmdDb2xvcixsaW5rLCpiZWZvcmV1bmxvYWQsKmJsdXIsKmVycm9yLCpmb2N1cywqaGFzaGNoYW5nZSwqbGFuZ3VhZ2VjaGFuZ2UsKmxvYWQsKm1lc3NhZ2UsKm9mZmxpbmUsKm9ubGluZSwqcGFnZWhpZGUsKnBhZ2VzaG93LCpwb3BzdGF0ZSwqcmVqZWN0aW9uaGFuZGxlZCwqcmVzaXplLCpzY3JvbGwsKnN0b3JhZ2UsKnVuaGFuZGxlZHJlamVjdGlvbiwqdW5sb2FkLHRleHQsdkxpbmsnLFxuICAgICdidXR0b25eW0hUTUxFbGVtZW50XXwhYXV0b2ZvY3VzLCFkaXNhYmxlZCxmb3JtQWN0aW9uLGZvcm1FbmN0eXBlLGZvcm1NZXRob2QsIWZvcm1Ob1ZhbGlkYXRlLGZvcm1UYXJnZXQsbmFtZSx0eXBlLHZhbHVlJyxcbiAgICAnY2FudmFzXltIVE1MRWxlbWVudF18I2hlaWdodCwjd2lkdGgnLFxuICAgICdjb250ZW50XltIVE1MRWxlbWVudF18c2VsZWN0JyxcbiAgICAnZGxeW0hUTUxFbGVtZW50XXwhY29tcGFjdCcsXG4gICAgJ2RhdGFsaXN0XltIVE1MRWxlbWVudF18JyxcbiAgICAnZGV0YWlsc15bSFRNTEVsZW1lbnRdfCFvcGVuJyxcbiAgICAnZGlhbG9nXltIVE1MRWxlbWVudF18IW9wZW4scmV0dXJuVmFsdWUnLFxuICAgICdkaXJeW0hUTUxFbGVtZW50XXwhY29tcGFjdCcsXG4gICAgJ2Rpdl5bSFRNTEVsZW1lbnRdfGFsaWduJyxcbiAgICAnZW1iZWReW0hUTUxFbGVtZW50XXxhbGlnbixoZWlnaHQsbmFtZSxzcmMsdHlwZSx3aWR0aCcsXG4gICAgJ2ZpZWxkc2V0XltIVE1MRWxlbWVudF18IWRpc2FibGVkLG5hbWUnLFxuICAgICdmb250XltIVE1MRWxlbWVudF18Y29sb3IsZmFjZSxzaXplJyxcbiAgICAnZm9ybV5bSFRNTEVsZW1lbnRdfGFjY2VwdENoYXJzZXQsYWN0aW9uLGF1dG9jb21wbGV0ZSxlbmNvZGluZyxlbmN0eXBlLG1ldGhvZCxuYW1lLCFub1ZhbGlkYXRlLHRhcmdldCcsXG4gICAgJ2ZyYW1lXltIVE1MRWxlbWVudF18ZnJhbWVCb3JkZXIsbG9uZ0Rlc2MsbWFyZ2luSGVpZ2h0LG1hcmdpbldpZHRoLG5hbWUsIW5vUmVzaXplLHNjcm9sbGluZyxzcmMnLFxuICAgICdmcmFtZXNldF5bSFRNTEVsZW1lbnRdfGNvbHMsKmJlZm9yZXVubG9hZCwqYmx1ciwqZXJyb3IsKmZvY3VzLCpoYXNoY2hhbmdlLCpsYW5ndWFnZWNoYW5nZSwqbG9hZCwqbWVzc2FnZSwqb2ZmbGluZSwqb25saW5lLCpwYWdlaGlkZSwqcGFnZXNob3csKnBvcHN0YXRlLCpyZWplY3Rpb25oYW5kbGVkLCpyZXNpemUsKnNjcm9sbCwqc3RvcmFnZSwqdW5oYW5kbGVkcmVqZWN0aW9uLCp1bmxvYWQscm93cycsXG4gICAgJ2hyXltIVE1MRWxlbWVudF18YWxpZ24sY29sb3IsIW5vU2hhZGUsc2l6ZSx3aWR0aCcsXG4gICAgJ2hlYWReW0hUTUxFbGVtZW50XXwnLFxuICAgICdoMSxoMixoMyxoNCxoNSxoNl5bSFRNTEVsZW1lbnRdfGFsaWduJyxcbiAgICAnaHRtbF5bSFRNTEVsZW1lbnRdfHZlcnNpb24nLFxuICAgICdpZnJhbWVeW0hUTUxFbGVtZW50XXxhbGlnbiwhYWxsb3dGdWxsc2NyZWVuLGZyYW1lQm9yZGVyLGhlaWdodCxsb25nRGVzYyxtYXJnaW5IZWlnaHQsbWFyZ2luV2lkdGgsbmFtZSxyZWZlcnJlclBvbGljeSwlc2FuZGJveCxzY3JvbGxpbmcsc3JjLHNyY2RvYyx3aWR0aCcsXG4gICAgJ2ltZ15bSFRNTEVsZW1lbnRdfGFsaWduLGFsdCxib3JkZXIsJWNyb3NzT3JpZ2luLCNoZWlnaHQsI2hzcGFjZSwhaXNNYXAsbG9uZ0Rlc2MsbG93c3JjLG5hbWUscmVmZXJyZXJQb2xpY3ksc2l6ZXMsc3JjLHNyY3NldCx1c2VNYXAsI3ZzcGFjZSwjd2lkdGgnLFxuICAgICdpbnB1dF5bSFRNTEVsZW1lbnRdfGFjY2VwdCxhbGlnbixhbHQsYXV0b2NhcGl0YWxpemUsYXV0b2NvbXBsZXRlLCFhdXRvZm9jdXMsIWNoZWNrZWQsIWRlZmF1bHRDaGVja2VkLGRlZmF1bHRWYWx1ZSxkaXJOYW1lLCFkaXNhYmxlZCwlZmlsZXMsZm9ybUFjdGlvbixmb3JtRW5jdHlwZSxmb3JtTWV0aG9kLCFmb3JtTm9WYWxpZGF0ZSxmb3JtVGFyZ2V0LCNoZWlnaHQsIWluY3JlbWVudGFsLCFpbmRldGVybWluYXRlLG1heCwjbWF4TGVuZ3RoLG1pbiwjbWluTGVuZ3RoLCFtdWx0aXBsZSxuYW1lLHBhdHRlcm4scGxhY2Vob2xkZXIsIXJlYWRPbmx5LCFyZXF1aXJlZCxzZWxlY3Rpb25EaXJlY3Rpb24sI3NlbGVjdGlvbkVuZCwjc2VsZWN0aW9uU3RhcnQsI3NpemUsc3JjLHN0ZXAsdHlwZSx1c2VNYXAsdmFsdWUsJXZhbHVlQXNEYXRlLCN2YWx1ZUFzTnVtYmVyLCN3aWR0aCcsXG4gICAgJ2xpXltIVE1MRWxlbWVudF18dHlwZSwjdmFsdWUnLFxuICAgICdsYWJlbF5bSFRNTEVsZW1lbnRdfGh0bWxGb3InLFxuICAgICdsZWdlbmReW0hUTUxFbGVtZW50XXxhbGlnbicsXG4gICAgJ2xpbmteW0hUTUxFbGVtZW50XXxhcyxjaGFyc2V0LCVjcm9zc09yaWdpbiwhZGlzYWJsZWQsaHJlZixocmVmbGFuZyxpbnRlZ3JpdHksbWVkaWEscmVmZXJyZXJQb2xpY3kscmVsLCVyZWxMaXN0LHJldiwlc2l6ZXMsdGFyZ2V0LHR5cGUnLFxuICAgICdtYXBeW0hUTUxFbGVtZW50XXxuYW1lJyxcbiAgICAnbWFycXVlZV5bSFRNTEVsZW1lbnRdfGJlaGF2aW9yLGJnQ29sb3IsZGlyZWN0aW9uLGhlaWdodCwjaHNwYWNlLCNsb29wLCNzY3JvbGxBbW91bnQsI3Njcm9sbERlbGF5LCF0cnVlU3BlZWQsI3ZzcGFjZSx3aWR0aCcsXG4gICAgJ21lbnVeW0hUTUxFbGVtZW50XXwhY29tcGFjdCcsXG4gICAgJ21ldGFeW0hUTUxFbGVtZW50XXxjb250ZW50LGh0dHBFcXVpdixuYW1lLHNjaGVtZScsXG4gICAgJ21ldGVyXltIVE1MRWxlbWVudF18I2hpZ2gsI2xvdywjbWF4LCNtaW4sI29wdGltdW0sI3ZhbHVlJyxcbiAgICAnaW5zLGRlbF5bSFRNTEVsZW1lbnRdfGNpdGUsZGF0ZVRpbWUnLFxuICAgICdvbF5bSFRNTEVsZW1lbnRdfCFjb21wYWN0LCFyZXZlcnNlZCwjc3RhcnQsdHlwZScsXG4gICAgJ29iamVjdF5bSFRNTEVsZW1lbnRdfGFsaWduLGFyY2hpdmUsYm9yZGVyLGNvZGUsY29kZUJhc2UsY29kZVR5cGUsZGF0YSwhZGVjbGFyZSxoZWlnaHQsI2hzcGFjZSxuYW1lLHN0YW5kYnksdHlwZSx1c2VNYXAsI3ZzcGFjZSx3aWR0aCcsXG4gICAgJ29wdGdyb3VwXltIVE1MRWxlbWVudF18IWRpc2FibGVkLGxhYmVsJyxcbiAgICAnb3B0aW9uXltIVE1MRWxlbWVudF18IWRlZmF1bHRTZWxlY3RlZCwhZGlzYWJsZWQsbGFiZWwsIXNlbGVjdGVkLHRleHQsdmFsdWUnLFxuICAgICdvdXRwdXReW0hUTUxFbGVtZW50XXxkZWZhdWx0VmFsdWUsJWh0bWxGb3IsbmFtZSx2YWx1ZScsXG4gICAgJ3BeW0hUTUxFbGVtZW50XXxhbGlnbicsXG4gICAgJ3BhcmFtXltIVE1MRWxlbWVudF18bmFtZSx0eXBlLHZhbHVlLHZhbHVlVHlwZScsXG4gICAgJ3BpY3R1cmVeW0hUTUxFbGVtZW50XXwnLFxuICAgICdwcmVeW0hUTUxFbGVtZW50XXwjd2lkdGgnLFxuICAgICdwcm9ncmVzc15bSFRNTEVsZW1lbnRdfCNtYXgsI3ZhbHVlJyxcbiAgICAncSxibG9ja3F1b3RlLGNpdGVeW0hUTUxFbGVtZW50XXwnLFxuICAgICdzY3JpcHReW0hUTUxFbGVtZW50XXwhYXN5bmMsY2hhcnNldCwlY3Jvc3NPcmlnaW4sIWRlZmVyLGV2ZW50LGh0bWxGb3IsaW50ZWdyaXR5LHNyYyx0ZXh0LHR5cGUnLFxuICAgICdzZWxlY3ReW0hUTUxFbGVtZW50XXwhYXV0b2ZvY3VzLCFkaXNhYmxlZCwjbGVuZ3RoLCFtdWx0aXBsZSxuYW1lLCFyZXF1aXJlZCwjc2VsZWN0ZWRJbmRleCwjc2l6ZSx2YWx1ZScsXG4gICAgJ3NoYWRvd15bSFRNTEVsZW1lbnRdfCcsXG4gICAgJ3Nsb3ReW0hUTUxFbGVtZW50XXxuYW1lJyxcbiAgICAnc291cmNlXltIVE1MRWxlbWVudF18bWVkaWEsc2l6ZXMsc3JjLHNyY3NldCx0eXBlJyxcbiAgICAnc3Bhbl5bSFRNTEVsZW1lbnRdfCcsXG4gICAgJ3N0eWxlXltIVE1MRWxlbWVudF18IWRpc2FibGVkLG1lZGlhLHR5cGUnLFxuICAgICdjYXB0aW9uXltIVE1MRWxlbWVudF18YWxpZ24nLFxuICAgICd0aCx0ZF5bSFRNTEVsZW1lbnRdfGFiYnIsYWxpZ24sYXhpcyxiZ0NvbG9yLGNoLGNoT2ZmLCNjb2xTcGFuLGhlYWRlcnMsaGVpZ2h0LCFub1dyYXAsI3Jvd1NwYW4sc2NvcGUsdkFsaWduLHdpZHRoJyxcbiAgICAnY29sLGNvbGdyb3VwXltIVE1MRWxlbWVudF18YWxpZ24sY2gsY2hPZmYsI3NwYW4sdkFsaWduLHdpZHRoJyxcbiAgICAndGFibGVeW0hUTUxFbGVtZW50XXxhbGlnbixiZ0NvbG9yLGJvcmRlciwlY2FwdGlvbixjZWxsUGFkZGluZyxjZWxsU3BhY2luZyxmcmFtZSxydWxlcyxzdW1tYXJ5LCV0Rm9vdCwldEhlYWQsd2lkdGgnLFxuICAgICd0cl5bSFRNTEVsZW1lbnRdfGFsaWduLGJnQ29sb3IsY2gsY2hPZmYsdkFsaWduJyxcbiAgICAndGZvb3QsdGhlYWQsdGJvZHleW0hUTUxFbGVtZW50XXxhbGlnbixjaCxjaE9mZix2QWxpZ24nLFxuICAgICd0ZW1wbGF0ZV5bSFRNTEVsZW1lbnRdfCcsXG4gICAgJ3RleHRhcmVhXltIVE1MRWxlbWVudF18YXV0b2NhcGl0YWxpemUsIWF1dG9mb2N1cywjY29scyxkZWZhdWx0VmFsdWUsZGlyTmFtZSwhZGlzYWJsZWQsI21heExlbmd0aCwjbWluTGVuZ3RoLG5hbWUscGxhY2Vob2xkZXIsIXJlYWRPbmx5LCFyZXF1aXJlZCwjcm93cyxzZWxlY3Rpb25EaXJlY3Rpb24sI3NlbGVjdGlvbkVuZCwjc2VsZWN0aW9uU3RhcnQsdmFsdWUsd3JhcCcsXG4gICAgJ3RpdGxlXltIVE1MRWxlbWVudF18dGV4dCcsXG4gICAgJ3RyYWNrXltIVE1MRWxlbWVudF18IWRlZmF1bHQsa2luZCxsYWJlbCxzcmMsc3JjbGFuZycsXG4gICAgJ3VsXltIVE1MRWxlbWVudF18IWNvbXBhY3QsdHlwZScsXG4gICAgJ3Vua25vd25eW0hUTUxFbGVtZW50XXwnLFxuICAgICd2aWRlb15tZWRpYXwjaGVpZ2h0LHBvc3Rlciwjd2lkdGgnLFxuICAgICc6c3ZnOmFeOnN2ZzpncmFwaGljc3wnLFxuICAgICc6c3ZnOmFuaW1hdGVeOnN2ZzphbmltYXRpb258JyxcbiAgICAnOnN2ZzphbmltYXRlTW90aW9uXjpzdmc6YW5pbWF0aW9ufCcsXG4gICAgJzpzdmc6YW5pbWF0ZVRyYW5zZm9ybV46c3ZnOmFuaW1hdGlvbnwnLFxuICAgICc6c3ZnOmNpcmNsZV46c3ZnOmdlb21ldHJ5fCcsXG4gICAgJzpzdmc6Y2xpcFBhdGheOnN2ZzpncmFwaGljc3wnLFxuICAgICc6c3ZnOmRlZnNeOnN2ZzpncmFwaGljc3wnLFxuICAgICc6c3ZnOmRlc2NeOnN2Zzp8JyxcbiAgICAnOnN2ZzpkaXNjYXJkXjpzdmc6fCcsXG4gICAgJzpzdmc6ZWxsaXBzZV46c3ZnOmdlb21ldHJ5fCcsXG4gICAgJzpzdmc6ZmVCbGVuZF46c3ZnOnwnLFxuICAgICc6c3ZnOmZlQ29sb3JNYXRyaXheOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZUNvbXBvbmVudFRyYW5zZmVyXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVDb21wb3NpdGVeOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZUNvbnZvbHZlTWF0cml4Xjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVEaWZmdXNlTGlnaHRpbmdeOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZURpc3BsYWNlbWVudE1hcF46c3ZnOnwnLFxuICAgICc6c3ZnOmZlRGlzdGFudExpZ2h0Xjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVEcm9wU2hhZG93Xjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVGbG9vZF46c3ZnOnwnLFxuICAgICc6c3ZnOmZlRnVuY0FeOnN2Zzpjb21wb25lbnRUcmFuc2ZlckZ1bmN0aW9ufCcsXG4gICAgJzpzdmc6ZmVGdW5jQl46c3ZnOmNvbXBvbmVudFRyYW5zZmVyRnVuY3Rpb258JyxcbiAgICAnOnN2ZzpmZUZ1bmNHXjpzdmc6Y29tcG9uZW50VHJhbnNmZXJGdW5jdGlvbnwnLFxuICAgICc6c3ZnOmZlRnVuY1JeOnN2Zzpjb21wb25lbnRUcmFuc2ZlckZ1bmN0aW9ufCcsXG4gICAgJzpzdmc6ZmVHYXVzc2lhbkJsdXJeOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZUltYWdlXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVNZXJnZV46c3ZnOnwnLFxuICAgICc6c3ZnOmZlTWVyZ2VOb2RlXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVNb3JwaG9sb2d5Xjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVPZmZzZXReOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZVBvaW50TGlnaHReOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZVNwZWN1bGFyTGlnaHRpbmdeOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZVNwb3RMaWdodF46c3ZnOnwnLFxuICAgICc6c3ZnOmZlVGlsZV46c3ZnOnwnLFxuICAgICc6c3ZnOmZlVHVyYnVsZW5jZV46c3ZnOnwnLFxuICAgICc6c3ZnOmZpbHRlcl46c3ZnOnwnLFxuICAgICc6c3ZnOmZvcmVpZ25PYmplY3ReOnN2ZzpncmFwaGljc3wnLFxuICAgICc6c3ZnOmdeOnN2ZzpncmFwaGljc3wnLFxuICAgICc6c3ZnOmltYWdlXjpzdmc6Z3JhcGhpY3N8JyxcbiAgICAnOnN2ZzpsaW5lXjpzdmc6Z2VvbWV0cnl8JyxcbiAgICAnOnN2ZzpsaW5lYXJHcmFkaWVudF46c3ZnOmdyYWRpZW50fCcsXG4gICAgJzpzdmc6bXBhdGheOnN2Zzp8JyxcbiAgICAnOnN2ZzptYXJrZXJeOnN2Zzp8JyxcbiAgICAnOnN2ZzptYXNrXjpzdmc6fCcsXG4gICAgJzpzdmc6bWV0YWRhdGFeOnN2Zzp8JyxcbiAgICAnOnN2ZzpwYXRoXjpzdmc6Z2VvbWV0cnl8JyxcbiAgICAnOnN2ZzpwYXR0ZXJuXjpzdmc6fCcsXG4gICAgJzpzdmc6cG9seWdvbl46c3ZnOmdlb21ldHJ5fCcsXG4gICAgJzpzdmc6cG9seWxpbmVeOnN2ZzpnZW9tZXRyeXwnLFxuICAgICc6c3ZnOnJhZGlhbEdyYWRpZW50Xjpzdmc6Z3JhZGllbnR8JyxcbiAgICAnOnN2ZzpyZWN0Xjpzdmc6Z2VvbWV0cnl8JyxcbiAgICAnOnN2ZzpzdmdeOnN2ZzpncmFwaGljc3wjY3VycmVudFNjYWxlLCN6b29tQW5kUGFuJyxcbiAgICAnOnN2ZzpzY3JpcHReOnN2Zzp8dHlwZScsXG4gICAgJzpzdmc6c2V0Xjpzdmc6YW5pbWF0aW9ufCcsXG4gICAgJzpzdmc6c3RvcF46c3ZnOnwnLFxuICAgICc6c3ZnOnN0eWxlXjpzdmc6fCFkaXNhYmxlZCxtZWRpYSx0aXRsZSx0eXBlJyxcbiAgICAnOnN2Zzpzd2l0Y2heOnN2ZzpncmFwaGljc3wnLFxuICAgICc6c3ZnOnN5bWJvbF46c3ZnOnwnLFxuICAgICc6c3ZnOnRzcGFuXjpzdmc6dGV4dFBvc2l0aW9uaW5nfCcsXG4gICAgJzpzdmc6dGV4dF46c3ZnOnRleHRQb3NpdGlvbmluZ3wnLFxuICAgICc6c3ZnOnRleHRQYXRoXjpzdmc6dGV4dENvbnRlbnR8JyxcbiAgICAnOnN2Zzp0aXRsZV46c3ZnOnwnLFxuICAgICc6c3ZnOnVzZV46c3ZnOmdyYXBoaWNzfCcsXG4gICAgJzpzdmc6dmlld146c3ZnOnwjem9vbUFuZFBhbicsXG4gICAgJ2RhdGFeW0hUTUxFbGVtZW50XXx2YWx1ZScsXG4gICAgJ2tleWdlbl5bSFRNTEVsZW1lbnRdfCFhdXRvZm9jdXMsY2hhbGxlbmdlLCFkaXNhYmxlZCxmb3JtLGtleXR5cGUsbmFtZScsXG4gICAgJ21lbnVpdGVtXltIVE1MRWxlbWVudF18dHlwZSxsYWJlbCxpY29uLCFkaXNhYmxlZCwhY2hlY2tlZCxyYWRpb2dyb3VwLCFkZWZhdWx0JyxcbiAgICAnc3VtbWFyeV5bSFRNTEVsZW1lbnRdfCcsXG4gICAgJ3RpbWVeW0hUTUxFbGVtZW50XXxkYXRlVGltZScsXG4gICAgJzpzdmc6Y3Vyc29yXjpzdmc6fCcsXG5dO1xudmFyIF9BVFRSX1RPX1BST1AgPSB7XG4gICAgJ2NsYXNzJzogJ2NsYXNzTmFtZScsXG4gICAgJ2Zvcic6ICdodG1sRm9yJyxcbiAgICAnZm9ybWFjdGlvbic6ICdmb3JtQWN0aW9uJyxcbiAgICAnaW5uZXJIdG1sJzogJ2lubmVySFRNTCcsXG4gICAgJ3JlYWRvbmx5JzogJ3JlYWRPbmx5JyxcbiAgICAndGFiaW5kZXgnOiAndGFiSW5kZXgnLFxufTtcbnZhciBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9zY2hlbWEgPSB7fTtcbiAgICAgICAgU0NIRU1BLmZvckVhY2goZnVuY3Rpb24gKGVuY29kZWRUeXBlKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHt9O1xuICAgICAgICAgICAgdmFyIF9hID0gZW5jb2RlZFR5cGUuc3BsaXQoJ3wnKSwgc3RyVHlwZSA9IF9hWzBdLCBzdHJQcm9wZXJ0aWVzID0gX2FbMV07XG4gICAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHN0clByb3BlcnRpZXMuc3BsaXQoJywnKTtcbiAgICAgICAgICAgIHZhciBfYiA9IHN0clR5cGUuc3BsaXQoJ14nKSwgdHlwZU5hbWVzID0gX2JbMF0sIHN1cGVyTmFtZSA9IF9iWzFdO1xuICAgICAgICAgICAgdHlwZU5hbWVzLnNwbGl0KCcsJykuZm9yRWFjaChmdW5jdGlvbiAodGFnKSB7IHJldHVybiBfdGhpcy5fc2NoZW1hW3RhZy50b0xvd2VyQ2FzZSgpXSA9IHR5cGU7IH0pO1xuICAgICAgICAgICAgdmFyIHN1cGVyVHlwZSA9IHN1cGVyTmFtZSAmJiBfdGhpcy5fc2NoZW1hW3N1cGVyTmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgICAgIGlmIChzdXBlclR5cGUpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhzdXBlclR5cGUpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHsgdHlwZVtwcm9wXSA9IHN1cGVyVHlwZVtwcm9wXTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wZXJ0eVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgeWV0IHN1cHBvcnQgZXZlbnRzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGV2ZXIgYWxsb3dpbmcgdG8gYmluZCB0byBldmVudHMsIEdPIFRIUk9VR0ggQSBTRUNVUklUWSBSRVZJRVcsIGFsbG93aW5nIGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpbGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbG1vc3QgY2VydGFpbmx5IGludHJvZHVjZSBiYWQgWFNTIHZ1bG5lcmFiaWxpdGllcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0eXBlW3Byb3BlcnR5LnN1YnN0cmluZygxKV0gPSBFVkVOVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyEnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVbcHJvcGVydHkuc3Vic3RyaW5nKDEpXSA9IEJPT0xFQU47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlW3Byb3BlcnR5LnN1YnN0cmluZygxKV0gPSBOVU1CRVI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlW3Byb3BlcnR5LnN1YnN0cmluZygxKV0gPSBPQkpFQ1Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVbcHJvcGVydHldID0gU1RSSU5HO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGFnTmFtZVxuICAgICAqIEBwYXJhbSB7P30gcHJvcE5hbWVcbiAgICAgKiBAcGFyYW0gez99IHNjaGVtYU1ldGFzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLmhhc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHRhZ05hbWUsIHByb3BOYW1lLCBzY2hlbWFNZXRhcykge1xuICAgICAgICBpZiAoc2NoZW1hTWV0YXMuc29tZShmdW5jdGlvbiAoc2NoZW1hKSB7IHJldHVybiBzY2hlbWEubmFtZSA9PT0gTk9fRVJST1JTX1NDSEVNQS5uYW1lOyB9KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZ05hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgIGlmIChpc05nQ29udGFpbmVyKHRhZ05hbWUpIHx8IGlzTmdDb250ZW50KHRhZ05hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjaGVtYU1ldGFzLnNvbWUoZnVuY3Rpb24gKHNjaGVtYSkgeyByZXR1cm4gc2NoZW1hLm5hbWUgPT09IENVU1RPTV9FTEVNRU5UU19TQ0hFTUEubmFtZTsgfSkpIHtcbiAgICAgICAgICAgICAgICAvLyBDYW4ndCB0ZWxsIG5vdyBhcyB3ZSBkb24ndCBrbm93IHdoaWNoIHByb3BlcnRpZXMgYSBjdXN0b20gZWxlbWVudCB3aWxsIGdldFxuICAgICAgICAgICAgICAgIC8vIG9uY2UgaXQgaXMgaW5zdGFudGlhdGVkXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudFByb3BlcnRpZXMgPSB0aGlzLl9zY2hlbWFbdGFnTmFtZS50b0xvd2VyQ2FzZSgpXSB8fCB0aGlzLl9zY2hlbWFbJ3Vua25vd24nXTtcbiAgICAgICAgcmV0dXJuICEhZWxlbWVudFByb3BlcnRpZXNbcHJvcE5hbWVdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0YWdOYW1lXG4gICAgICogQHBhcmFtIHs/fSBzY2hlbWFNZXRhc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5oYXNFbGVtZW50ID0gZnVuY3Rpb24gKHRhZ05hbWUsIHNjaGVtYU1ldGFzKSB7XG4gICAgICAgIGlmIChzY2hlbWFNZXRhcy5zb21lKGZ1bmN0aW9uIChzY2hlbWEpIHsgcmV0dXJuIHNjaGVtYS5uYW1lID09PSBOT19FUlJPUlNfU0NIRU1BLm5hbWU7IH0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnTmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgICAgICAgaWYgKGlzTmdDb250YWluZXIodGFnTmFtZSkgfHwgaXNOZ0NvbnRlbnQodGFnTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY2hlbWFNZXRhcy5zb21lKGZ1bmN0aW9uIChzY2hlbWEpIHsgcmV0dXJuIHNjaGVtYS5uYW1lID09PSBDVVNUT01fRUxFTUVOVFNfU0NIRU1BLm5hbWU7IH0pKSB7XG4gICAgICAgICAgICAgICAgLy8gQWxsb3cgYW55IGN1c3RvbSBlbGVtZW50c1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhIXRoaXMuX3NjaGVtYVt0YWdOYW1lLnRvTG93ZXJDYXNlKCldO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogc2VjdXJpdHlDb250ZXh0IHJldHVybnMgdGhlIHNlY3VyaXR5IGNvbnRleHQgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eSBvbiB0aGUgZ2l2ZW4gRE9NIHRhZy5cbiAgICAgKlxuICAgICAqIFRhZyBhbmQgcHJvcGVydHkgbmFtZSBhcmUgc3RhdGljYWxseSBrbm93biBhbmQgY2Fubm90IGNoYW5nZSBhdCBydW50aW1lLCBpLmUuIGl0IGlzIG5vdFxuICAgICAqIHBvc3NpYmxlIHRvIGJpbmQgYSB2YWx1ZSBpbnRvIGEgY2hhbmdpbmcgYXR0cmlidXRlIG9yIHRhZyBuYW1lLlxuICAgICAqXG4gICAgICogVGhlIGZpbHRlcmluZyBpcyB3aGl0ZSBsaXN0IGJhc2VkLiBBbGwgYXR0cmlidXRlcyBpbiB0aGUgc2NoZW1hIGFib3ZlIGFyZSBhc3N1bWVkIHRvIGhhdmUgdGhlXG4gICAgICogJ05PTkUnIHNlY3VyaXR5IGNvbnRleHQsIGkuZS4gdGhhdCB0aGV5IGFyZSBzYWZlIGluZXJ0IHN0cmluZyB2YWx1ZXMuIE9ubHkgc3BlY2lmaWMgd2VsbCBrbm93blxuICAgICAqIGF0dGFjayB2ZWN0b3JzIGFyZSBhc3NpZ25lZCB0aGVpciBhcHByb3ByaWF0ZSBjb250ZXh0LlxuICAgICAqIEBwYXJhbSB7P30gdGFnTmFtZVxuICAgICAqIEBwYXJhbSB7P30gcHJvcE5hbWVcbiAgICAgKiBAcGFyYW0gez99IGlzQXR0cmlidXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLnNlY3VyaXR5Q29udGV4dCA9IGZ1bmN0aW9uICh0YWdOYW1lLCBwcm9wTmFtZSwgaXNBdHRyaWJ1dGUpIHtcbiAgICAgICAgaWYgKGlzQXR0cmlidXRlKSB7XG4gICAgICAgICAgICAvLyBOQjogRm9yIHNlY3VyaXR5IHB1cnBvc2VzLCB1c2UgdGhlIG1hcHBlZCBwcm9wZXJ0eSBuYW1lLCBub3QgdGhlIGF0dHJpYnV0ZSBuYW1lLlxuICAgICAgICAgICAgcHJvcE5hbWUgPSB0aGlzLmdldE1hcHBlZFByb3BOYW1lKHByb3BOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgY29tcGFyaXNvbnMgYXJlIGNhc2UgaW5zZW5zaXRpdmUsIHNvIHRoYXQgY2FzZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGF0dHJpYnV0ZSBhbmRcbiAgICAgICAgLy8gcHJvcGVydHkgbmFtZXMgZG8gbm90IGhhdmUgYSBzZWN1cml0eSBpbXBhY3QuXG4gICAgICAgIHRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHByb3BOYW1lID0gcHJvcE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3R4ID0gU0VDVVJJVFlfU0NIRU1BW3RhZ05hbWUgKyAnfCcgKyBwcm9wTmFtZV07XG4gICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIHJldHVybiBjdHg7XG4gICAgICAgIH1cbiAgICAgICAgY3R4ID0gU0VDVVJJVFlfU0NIRU1BWycqfCcgKyBwcm9wTmFtZV07XG4gICAgICAgIHJldHVybiBjdHggPyBjdHggOiBTZWN1cml0eUNvbnRleHQuTk9ORTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJvcE5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUuZ2V0TWFwcGVkUHJvcE5hbWUgPSBmdW5jdGlvbiAocHJvcE5hbWUpIHsgcmV0dXJuIF9BVFRSX1RPX1BST1BbcHJvcE5hbWVdIHx8IHByb3BOYW1lOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5nZXREZWZhdWx0Q29tcG9uZW50RWxlbWVudE5hbWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnbmctY29tcG9uZW50JzsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUudmFsaWRhdGVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnb24nKSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbXNnID0gXCJCaW5kaW5nIHRvIGV2ZW50IHByb3BlcnR5ICdcIiArIG5hbWUgKyBcIicgaXMgZGlzYWxsb3dlZCBmb3Igc2VjdXJpdHkgcmVhc29ucywgXCIgK1xuICAgICAgICAgICAgICAgIChcInBsZWFzZSB1c2UgKFwiICsgbmFtZS5zbGljZSgyKSArIFwiKT0uLi5cIikgK1xuICAgICAgICAgICAgICAgIChcIlxcbklmICdcIiArIG5hbWUgKyBcIicgaXMgYSBkaXJlY3RpdmUgaW5wdXQsIG1ha2Ugc3VyZSB0aGUgZGlyZWN0aXZlIGlzIGltcG9ydGVkIGJ5IHRoZVwiKSArXG4gICAgICAgICAgICAgICAgXCIgY3VycmVudCBtb2R1bGUuXCI7XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcjogdHJ1ZSwgbXNnOiBtc2cgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUudmFsaWRhdGVBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAobmFtZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ29uJykpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1zZyA9IFwiQmluZGluZyB0byBldmVudCBhdHRyaWJ1dGUgJ1wiICsgbmFtZSArIFwiJyBpcyBkaXNhbGxvd2VkIGZvciBzZWN1cml0eSByZWFzb25zLCBcIiArXG4gICAgICAgICAgICAgICAgKFwicGxlYXNlIHVzZSAoXCIgKyBuYW1lLnNsaWNlKDIpICsgXCIpPS4uLlwiKTtcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiB0cnVlLCBtc2c6IG1zZyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5hbGxLbm93bkVsZW1lbnROYW1lcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3NjaGVtYSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcm9wTmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5ub3JtYWxpemVBbmltYXRpb25TdHlsZVByb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgIHJldHVybiBkYXNoQ2FzZVRvQ2FtZWxDYXNlKHByb3BOYW1lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY2FtZWxDYXNlUHJvcFxuICAgICAqIEBwYXJhbSB7P30gdXNlclByb3ZpZGVkUHJvcFxuICAgICAqIEBwYXJhbSB7P30gdmFsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLm5vcm1hbGl6ZUFuaW1hdGlvblN0eWxlVmFsdWUgPSBmdW5jdGlvbiAoY2FtZWxDYXNlUHJvcCwgdXNlclByb3ZpZGVkUHJvcCwgdmFsKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVuaXQgPSAnJztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RyVmFsID0gdmFsLnRvU3RyaW5nKCkudHJpbSgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvck1zZyA9ICgobnVsbCkpO1xuICAgICAgICBpZiAoX2lzUGl4ZWxEaW1lbnNpb25TdHlsZShjYW1lbENhc2VQcm9wKSAmJiB2YWwgIT09IDAgJiYgdmFsICE9PSAnMCcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHVuaXQgPSAncHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsQW5kU3VmZml4TWF0Y2ggPSB2YWwubWF0Y2goL15bKy1dP1tcXGRcXC5dKyhbYS16XSopJC8pO1xuICAgICAgICAgICAgICAgIGlmICh2YWxBbmRTdWZmaXhNYXRjaCAmJiB2YWxBbmRTdWZmaXhNYXRjaFsxXS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvck1zZyA9IFwiUGxlYXNlIHByb3ZpZGUgYSBDU1MgdW5pdCB2YWx1ZSBmb3IgXCIgKyB1c2VyUHJvdmlkZWRQcm9wICsgXCI6XCIgKyB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGVycm9yOiBlcnJvck1zZywgdmFsdWU6IHN0clZhbCArIHVuaXQgfTtcbiAgICB9O1xuICAgIHJldHVybiBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnk7XG59KEVsZW1lbnRTY2hlbWFSZWdpc3RyeSkpO1xuRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21waWxlckluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkRvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBAcGFyYW0gez99IHByb3BcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9pc1BpeGVsRGltZW5zaW9uU3R5bGUocHJvcCkge1xuICAgIHN3aXRjaCAocHJvcCkge1xuICAgICAgICBjYXNlICd3aWR0aCc6XG4gICAgICAgIGNhc2UgJ2hlaWdodCc6XG4gICAgICAgIGNhc2UgJ21pbldpZHRoJzpcbiAgICAgICAgY2FzZSAnbWluSGVpZ2h0JzpcbiAgICAgICAgY2FzZSAnbWF4V2lkdGgnOlxuICAgICAgICBjYXNlICdtYXhIZWlnaHQnOlxuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICBjYXNlICdmb250U2l6ZSc6XG4gICAgICAgIGNhc2UgJ291dGxpbmVXaWR0aCc6XG4gICAgICAgIGNhc2UgJ291dGxpbmVPZmZzZXQnOlxuICAgICAgICBjYXNlICdwYWRkaW5nVG9wJzpcbiAgICAgICAgY2FzZSAncGFkZGluZ0xlZnQnOlxuICAgICAgICBjYXNlICdwYWRkaW5nQm90dG9tJzpcbiAgICAgICAgY2FzZSAncGFkZGluZ1JpZ2h0JzpcbiAgICAgICAgY2FzZSAnbWFyZ2luVG9wJzpcbiAgICAgICAgY2FzZSAnbWFyZ2luTGVmdCc6XG4gICAgICAgIGNhc2UgJ21hcmdpbkJvdHRvbSc6XG4gICAgICAgIGNhc2UgJ21hcmdpblJpZ2h0JzpcbiAgICAgICAgY2FzZSAnYm9yZGVyUmFkaXVzJzpcbiAgICAgICAgY2FzZSAnYm9yZGVyV2lkdGgnOlxuICAgICAgICBjYXNlICdib3JkZXJUb3BXaWR0aCc6XG4gICAgICAgIGNhc2UgJ2JvcmRlckxlZnRXaWR0aCc6XG4gICAgICAgIGNhc2UgJ2JvcmRlclJpZ2h0V2lkdGgnOlxuICAgICAgICBjYXNlICdib3JkZXJCb3R0b21XaWR0aCc6XG4gICAgICAgIGNhc2UgJ3RleHRJbmRlbnQnOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxudmFyIFNoYWRvd0NzcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2hhZG93Q3NzKCkge1xuICAgICAgICB0aGlzLnN0cmljdFN0eWxpbmcgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNzc1RleHRcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/PX0gaG9zdFNlbGVjdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLnNoaW1Dc3NUZXh0ID0gZnVuY3Rpb24gKGNzc1RleHQsIHNlbGVjdG9yLCBob3N0U2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKGhvc3RTZWxlY3RvciA9PT0gdm9pZCAwKSB7IGhvc3RTZWxlY3RvciA9ICcnOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvdXJjZU1hcHBpbmdVcmwgPSBleHRyYWN0U291cmNlTWFwcGluZ1VybChjc3NUZXh0KTtcbiAgICAgICAgY3NzVGV4dCA9IHN0cmlwQ29tbWVudHMoY3NzVGV4dCk7XG4gICAgICAgIGNzc1RleHQgPSB0aGlzLl9pbnNlcnREaXJlY3RpdmVzKGNzc1RleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NvcGVDc3NUZXh0KGNzc1RleHQsIHNlbGVjdG9yLCBob3N0U2VsZWN0b3IpICsgc291cmNlTWFwcGluZ1VybDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY3NzVGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5faW5zZXJ0RGlyZWN0aXZlcyA9IGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gICAgICAgIGNzc1RleHQgPSB0aGlzLl9pbnNlcnRQb2x5ZmlsbERpcmVjdGl2ZXNJbkNzc1RleHQoY3NzVGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnRQb2x5ZmlsbFJ1bGVzSW5Dc3NUZXh0KGNzc1RleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjc3NUZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9pbnNlcnRQb2x5ZmlsbERpcmVjdGl2ZXNJbkNzc1RleHQgPSBmdW5jdGlvbiAoY3NzVGV4dCkge1xuICAgICAgICAvLyBEaWZmZXJlbmNlIHdpdGggd2ViY29tcG9uZW50cy5qczogZG9lcyBub3QgaGFuZGxlIGNvbW1lbnRzXG4gICAgICAgIHJldHVybiBjc3NUZXh0LnJlcGxhY2UoX2Nzc0NvbnRlbnROZXh0U2VsZWN0b3JSZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG0gPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgbVtfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1bMl0gKyAneyc7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjc3NUZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9pbnNlcnRQb2x5ZmlsbFJ1bGVzSW5Dc3NUZXh0ID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICAgICAgLy8gRGlmZmVyZW5jZSB3aXRoIHdlYmNvbXBvbmVudHMuanM6IGRvZXMgbm90IGhhbmRsZSBjb21tZW50c1xuICAgICAgICByZXR1cm4gY3NzVGV4dC5yZXBsYWNlKF9jc3NDb250ZW50UnVsZVJlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBtW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBydWxlID0gbVswXS5yZXBsYWNlKG1bMV0sICcnKS5yZXBsYWNlKG1bMl0sICcnKTtcbiAgICAgICAgICAgIHJldHVybiBtWzRdICsgcnVsZTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNzc1RleHRcbiAgICAgKiBAcGFyYW0gez99IHNjb3BlU2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IGhvc3RTZWxlY3RvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fc2NvcGVDc3NUZXh0ID0gZnVuY3Rpb24gKGNzc1RleHQsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1bnNjb3BlZFJ1bGVzID0gdGhpcy5fZXh0cmFjdFVuc2NvcGVkUnVsZXNGcm9tQ3NzVGV4dChjc3NUZXh0KTtcbiAgICAgICAgLy8gcmVwbGFjZSA6aG9zdCBhbmQgOmhvc3QtY29udGV4dCAtc2hhZG93Y3NzaG9zdCBhbmQgLXNoYWRvd2Nzc2hvc3QgcmVzcGVjdGl2ZWx5XG4gICAgICAgIGNzc1RleHQgPSB0aGlzLl9pbnNlcnRQb2x5ZmlsbEhvc3RJbkNzc1RleHQoY3NzVGV4dCk7XG4gICAgICAgIGNzc1RleHQgPSB0aGlzLl9jb252ZXJ0Q29sb25Ib3N0KGNzc1RleHQpO1xuICAgICAgICBjc3NUZXh0ID0gdGhpcy5fY29udmVydENvbG9uSG9zdENvbnRleHQoY3NzVGV4dCk7XG4gICAgICAgIGNzc1RleHQgPSB0aGlzLl9jb252ZXJ0U2hhZG93RE9NU2VsZWN0b3JzKGNzc1RleHQpO1xuICAgICAgICBpZiAoc2NvcGVTZWxlY3Rvcikge1xuICAgICAgICAgICAgY3NzVGV4dCA9IHRoaXMuX3Njb3BlU2VsZWN0b3JzKGNzc1RleHQsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgY3NzVGV4dCA9IGNzc1RleHQgKyAnXFxuJyArIHVuc2NvcGVkUnVsZXM7XG4gICAgICAgIHJldHVybiBjc3NUZXh0LnRyaW0oKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY3NzVGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fZXh0cmFjdFVuc2NvcGVkUnVsZXNGcm9tQ3NzVGV4dCA9IGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gICAgICAgIC8vIERpZmZlcmVuY2Ugd2l0aCB3ZWJjb21wb25lbnRzLmpzOiBkb2VzIG5vdCBoYW5kbGUgY29tbWVudHNcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gciA9ICcnO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtO1xuICAgICAgICBfY3NzQ29udGVudFVuc2NvcGVkUnVsZVJlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlICgobSA9IF9jc3NDb250ZW50VW5zY29wZWRSdWxlUmUuZXhlYyhjc3NUZXh0KSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJ1bGUgPSBtWzBdLnJlcGxhY2UobVsyXSwgJycpLnJlcGxhY2UobVsxXSwgbVs0XSk7XG4gICAgICAgICAgICByICs9IHJ1bGUgKyAnXFxuXFxuJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY3NzVGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fY29udmVydENvbG9uSG9zdCA9IGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb252ZXJ0Q29sb25SdWxlKGNzc1RleHQsIF9jc3NDb2xvbkhvc3RSZSwgdGhpcy5fY29sb25Ib3N0UGFydFJlcGxhY2VyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY3NzVGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fY29udmVydENvbG9uSG9zdENvbnRleHQgPSBmdW5jdGlvbiAoY3NzVGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udmVydENvbG9uUnVsZShjc3NUZXh0LCBfY3NzQ29sb25Ib3N0Q29udGV4dFJlLCB0aGlzLl9jb2xvbkhvc3RDb250ZXh0UGFydFJlcGxhY2VyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY3NzVGV4dFxuICAgICAqIEBwYXJhbSB7P30gcmVnRXhwXG4gICAgICogQHBhcmFtIHs/fSBwYXJ0UmVwbGFjZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2NvbnZlcnRDb2xvblJ1bGUgPSBmdW5jdGlvbiAoY3NzVGV4dCwgcmVnRXhwLCBwYXJ0UmVwbGFjZXIpIHtcbiAgICAgICAgLy8gbVsxXSA9IDpob3N0KC1jb250ZXh0KSwgbVsyXSA9IGNvbnRlbnRzIG9mICgpLCBtWzNdIHJlc3Qgb2YgcnVsZVxuICAgICAgICByZXR1cm4gY3NzVGV4dC5yZXBsYWNlKHJlZ0V4cCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG0gPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgbVtfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1bMl0pIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJ0cyA9IG1bMl0uc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHAgPSBwYXJ0c1tpXS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICByLnB1c2gocGFydFJlcGxhY2VyKF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IsIHAsIG1bM10pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIuam9pbignLCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IgKyBtWzNdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaG9zdFxuICAgICAqIEBwYXJhbSB7P30gcGFydFxuICAgICAqIEBwYXJhbSB7P30gc3VmZml4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9jb2xvbkhvc3RDb250ZXh0UGFydFJlcGxhY2VyID0gZnVuY3Rpb24gKGhvc3QsIHBhcnQsIHN1ZmZpeCkge1xuICAgICAgICBpZiAocGFydC5pbmRleE9mKF9wb2x5ZmlsbEhvc3QpID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2xvbkhvc3RQYXJ0UmVwbGFjZXIoaG9zdCwgcGFydCwgc3VmZml4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBob3N0ICsgcGFydCArIHN1ZmZpeCArICcsICcgKyBwYXJ0ICsgJyAnICsgaG9zdCArIHN1ZmZpeDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBob3N0XG4gICAgICogQHBhcmFtIHs/fSBwYXJ0XG4gICAgICogQHBhcmFtIHs/fSBzdWZmaXhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2NvbG9uSG9zdFBhcnRSZXBsYWNlciA9IGZ1bmN0aW9uIChob3N0LCBwYXJ0LCBzdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIGhvc3QgKyBwYXJ0LnJlcGxhY2UoX3BvbHlmaWxsSG9zdCwgJycpICsgc3VmZml4O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjc3NUZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9jb252ZXJ0U2hhZG93RE9NU2VsZWN0b3JzID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICAgICAgcmV0dXJuIF9zaGFkb3dET01TZWxlY3RvcnNSZS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgcGF0dGVybikgeyByZXR1cm4gcmVzdWx0LnJlcGxhY2UocGF0dGVybiwgJyAnKTsgfSwgY3NzVGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNzc1RleHRcbiAgICAgKiBAcGFyYW0gez99IHNjb3BlU2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IGhvc3RTZWxlY3RvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fc2NvcGVTZWxlY3RvcnMgPSBmdW5jdGlvbiAoY3NzVGV4dCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBwcm9jZXNzUnVsZXMoY3NzVGV4dCwgZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlbGVjdG9yID0gcnVsZS5zZWxlY3RvcjtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRlbnQgPSBydWxlLmNvbnRlbnQ7XG4gICAgICAgICAgICBpZiAocnVsZS5zZWxlY3RvclswXSAhPSAnQCcpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvciA9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zY29wZVNlbGVjdG9yKHJ1bGUuc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3RvciwgX3RoaXMuc3RyaWN0U3R5bGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChydWxlLnNlbGVjdG9yLnN0YXJ0c1dpdGgoJ0BtZWRpYScpIHx8IHJ1bGUuc2VsZWN0b3Iuc3RhcnRzV2l0aCgnQHN1cHBvcnRzJykgfHxcbiAgICAgICAgICAgICAgICBydWxlLnNlbGVjdG9yLnN0YXJ0c1dpdGgoJ0BwYWdlJykgfHwgcnVsZS5zZWxlY3Rvci5zdGFydHNXaXRoKCdAZG9jdW1lbnQnKSkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBfdGhpcy5fc2NvcGVTZWxlY3RvcnMocnVsZS5jb250ZW50LCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDc3NSdWxlKHNlbGVjdG9yLCBjb250ZW50KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBzY29wZVNlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBob3N0U2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IHN0cmljdFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fc2NvcGVTZWxlY3RvciA9IGZ1bmN0aW9uIChzZWxlY3Rvciwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yLCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yLnNwbGl0KCcsJylcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHBhcnQpIHsgcmV0dXJuIHBhcnQudHJpbSgpLnNwbGl0KF9zaGFkb3dEZWVwU2VsZWN0b3JzKTsgfSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGRlZXBQYXJ0cykge1xuICAgICAgICAgICAgdmFyIHNoYWxsb3dQYXJ0ID0gZGVlcFBhcnRzWzBdLCBvdGhlclBhcnRzID0gZGVlcFBhcnRzLnNsaWNlKDEpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXBwbHlTY29wZSA9IGZ1bmN0aW9uIChzaGFsbG93UGFydCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fc2VsZWN0b3JOZWVkc1Njb3Bpbmcoc2hhbGxvd1BhcnQsIHNjb3BlU2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpY3QgP1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FwcGx5U3RyaWN0U2VsZWN0b3JTY29wZShzaGFsbG93UGFydCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYXBwbHlTZWxlY3RvclNjb3BlKHNoYWxsb3dQYXJ0LCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNoYWxsb3dQYXJ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gW2FwcGx5U2NvcGUoc2hhbGxvd1BhcnQpXS5jb25jYXQob3RoZXJQYXJ0cykuam9pbignICcpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBzY29wZVNlbGVjdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9zZWxlY3Rvck5lZWRzU2NvcGluZyA9IGZ1bmN0aW9uIChzZWxlY3Rvciwgc2NvcGVTZWxlY3Rvcikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZSA9IHRoaXMuX21ha2VTY29wZU1hdGNoZXIoc2NvcGVTZWxlY3Rvcik7XG4gICAgICAgIHJldHVybiAhcmUudGVzdChzZWxlY3Rvcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNjb3BlU2VsZWN0b3JcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX21ha2VTY29wZU1hdGNoZXIgPSBmdW5jdGlvbiAoc2NvcGVTZWxlY3Rvcikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBscmUgPSAvXFxbL2c7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJyZSA9IC9cXF0vZztcbiAgICAgICAgc2NvcGVTZWxlY3RvciA9IHNjb3BlU2VsZWN0b3IucmVwbGFjZShscmUsICdcXFxcWycpLnJlcGxhY2UocnJlLCAnXFxcXF0nKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoJ14oJyArIHNjb3BlU2VsZWN0b3IgKyAnKScgKyBfc2VsZWN0b3JSZVN1ZmZpeCwgJ20nKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IHNjb3BlU2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IGhvc3RTZWxlY3RvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fYXBwbHlTZWxlY3RvclNjb3BlID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpIHtcbiAgICAgICAgLy8gRGlmZmVyZW5jZSBmcm9tIHdlYmNvbXBvbmVudHMuanM6IHNjb3BlU2VsZWN0b3IgY291bGQgbm90IGJlIGFuIGFycmF5XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseVNpbXBsZVNlbGVjdG9yU2NvcGUoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBzY29wZVNlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBob3N0U2VsZWN0b3JcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2FwcGx5U2ltcGxlU2VsZWN0b3JTY29wZSA9IGZ1bmN0aW9uIChzZWxlY3Rvciwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKSB7XG4gICAgICAgIC8vIEluIEFuZHJvaWQgYnJvd3NlciwgdGhlIGxhc3RJbmRleCBpcyBub3QgcmVzZXQgd2hlbiB0aGUgcmVnZXggaXMgdXNlZCBpbiBTdHJpbmcucmVwbGFjZSgpXG4gICAgICAgIF9wb2x5ZmlsbEhvc3RSZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICBpZiAoX3BvbHlmaWxsSG9zdFJlLnRlc3Qoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXBsYWNlQnlfMSA9IHRoaXMuc3RyaWN0U3R5bGluZyA/IFwiW1wiICsgaG9zdFNlbGVjdG9yICsgXCJdXCIgOiBzY29wZVNlbGVjdG9yO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvclJlLCBmdW5jdGlvbiAoaG5jLCBzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3Rvci5yZXBsYWNlKC8oW146XSopKDoqKSguKikvLCBmdW5jdGlvbiAoXywgYmVmb3JlLCBjb2xvbiwgYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlZm9yZSArIHJlcGxhY2VCeV8xICsgY29sb24gKyBhZnRlcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoX3BvbHlmaWxsSG9zdFJlLCByZXBsYWNlQnlfMSArICcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjb3BlU2VsZWN0b3IgKyAnICcgKyBzZWxlY3RvcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IHNjb3BlU2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IGhvc3RTZWxlY3RvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fYXBwbHlTdHJpY3RTZWxlY3RvclNjb3BlID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNSZSA9IC9cXFtpcz0oW15cXF1dKilcXF0vZztcbiAgICAgICAgc2NvcGVTZWxlY3RvciA9IHNjb3BlU2VsZWN0b3IucmVwbGFjZShpc1JlLCBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHBhcnRzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcnRzWzBdO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXR0ck5hbWUgPSAnWycgKyBzY29wZVNlbGVjdG9yICsgJ10nO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBfc2NvcGVTZWxlY3RvclBhcnQgPSBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2NvcGVkUCA9IHAudHJpbSgpO1xuICAgICAgICAgICAgaWYgKCFzY29wZWRQKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHAuaW5kZXhPZihfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgc2NvcGVkUCA9IF90aGlzLl9hcHBseVNpbXBsZVNlbGVjdG9yU2NvcGUocCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSA6aG9zdCBzaW5jZSBpdCBzaG91bGQgYmUgdW5uZWNlc3NhcnlcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ID0gcC5yZXBsYWNlKF9wb2x5ZmlsbEhvc3RSZSwgJycpO1xuICAgICAgICAgICAgICAgIGlmICh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWF0Y2hlcyA9IHQubWF0Y2goLyhbXjpdKikoOiopKC4qKS8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVkUCA9IG1hdGNoZXNbMV0gKyBhdHRyTmFtZSArIG1hdGNoZXNbMl0gKyBtYXRjaGVzWzNdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNjb3BlZFA7XG4gICAgICAgIH07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNhZmVDb250ZW50ID0gbmV3IFNhZmVTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgIHNlbGVjdG9yID0gc2FmZUNvbnRlbnQuY29udGVudCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzY29wZWRTZWxlY3RvciA9ICcnO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydEluZGV4ID0gMDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZXAgPSAvKCB8PnxcXCt8fig/IT0pKVxccyovZztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2NvcGVBZnRlciA9IHNlbGVjdG9yLmluZGV4T2YoX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvcik7XG4gICAgICAgIHdoaWxlICgocmVzID0gc2VwLmV4ZWMoc2VsZWN0b3IpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VwYXJhdG9yID0gcmVzWzFdO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFydCA9IHNlbGVjdG9yLnNsaWNlKHN0YXJ0SW5kZXgsIHJlcy5pbmRleCkudHJpbSgpO1xuICAgICAgICAgICAgLy8gaWYgYSBzZWxlY3RvciBhcHBlYXJzIGJlZm9yZSA6aG9zdC1jb250ZXh0IGl0IHNob3VsZCBub3QgYmUgc2hpbW1lZCBhcyBpdFxuICAgICAgICAgICAgLy8gbWF0Y2hlcyBvbiBhbmNlc3RvciBlbGVtZW50cyBhbmQgbm90IG9uIGVsZW1lbnRzIGluIHRoZSBob3N0J3Mgc2hhZG93XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzY29wZWRQYXJ0ID0gc3RhcnRJbmRleCA+PSBzY29wZUFmdGVyID8gX3Njb3BlU2VsZWN0b3JQYXJ0KHBhcnQpIDogcGFydDtcbiAgICAgICAgICAgIHNjb3BlZFNlbGVjdG9yICs9IHNjb3BlZFBhcnQgKyBcIiBcIiArIHNlcGFyYXRvciArIFwiIFwiO1xuICAgICAgICAgICAgc3RhcnRJbmRleCA9IHNlcC5sYXN0SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgc2NvcGVkU2VsZWN0b3IgKz0gX3Njb3BlU2VsZWN0b3JQYXJ0KHNlbGVjdG9yLnN1YnN0cmluZyhzdGFydEluZGV4KSk7XG4gICAgICAgIC8vIHJlcGxhY2UgdGhlIHBsYWNlaG9sZGVycyB3aXRoIHRoZWlyIG9yaWdpbmFsIHZhbHVlc1xuICAgICAgICByZXR1cm4gc2FmZUNvbnRlbnQucmVzdG9yZShzY29wZWRTZWxlY3Rvcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9pbnNlcnRQb2x5ZmlsbEhvc3RJbkNzc1RleHQgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yLnJlcGxhY2UoX2NvbG9uSG9zdENvbnRleHRSZSwgX3BvbHlmaWxsSG9zdENvbnRleHQpXG4gICAgICAgICAgICAucmVwbGFjZShfY29sb25Ib3N0UmUsIF9wb2x5ZmlsbEhvc3QpO1xuICAgIH07XG4gICAgcmV0dXJuIFNoYWRvd0Nzcztcbn0oKSk7XG52YXIgU2FmZVNlbGVjdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2FmZVNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXJzID0gW107XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICAvLyBSZXBsYWNlcyBhdHRyaWJ1dGUgc2VsZWN0b3JzIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAgICAvLyBUaGUgV1MgaW4gW2F0dHI9XCJ2YSBsdWVcIl0gd291bGQgb3RoZXJ3aXNlIGJlIGludGVycHJldGVkIGFzIGEgc2VsZWN0b3Igc2VwYXJhdG9yLlxuICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoLyhcXFtbXlxcXV0qXFxdKS9nLCBmdW5jdGlvbiAoXywga2VlcCkge1xuICAgICAgICAgICAgdmFyIHJlcGxhY2VCeSA9IFwiX19waC1cIiArIF90aGlzLmluZGV4ICsgXCJfX1wiO1xuICAgICAgICAgICAgX3RoaXMucGxhY2Vob2xkZXJzLnB1c2goa2VlcCk7XG4gICAgICAgICAgICBfdGhpcy5pbmRleCsrO1xuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VCeTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJlcGxhY2VzIHRoZSBleHByZXNzaW9uIGluIGA6bnRoLWNoaWxkKDJuICsgMSlgIHdpdGggYSBwbGFjZWhvbGRlci5cbiAgICAgICAgLy8gV1MgYW5kIFwiK1wiIHdvdWxkIG90aGVyd2lzZSBiZSBpbnRlcnByZXRlZCBhcyBzZWxlY3RvciBzZXBhcmF0b3JzLlxuICAgICAgICB0aGlzLl9jb250ZW50ID0gc2VsZWN0b3IucmVwbGFjZSgvKDpudGgtWy1cXHddKykoXFwoW14pXStcXCkpL2csIGZ1bmN0aW9uIChfLCBwc2V1ZG8sIGV4cCkge1xuICAgICAgICAgICAgdmFyIHJlcGxhY2VCeSA9IFwiX19waC1cIiArIF90aGlzLmluZGV4ICsgXCJfX1wiO1xuICAgICAgICAgICAgX3RoaXMucGxhY2Vob2xkZXJzLnB1c2goZXhwKTtcbiAgICAgICAgICAgIF90aGlzLmluZGV4Kys7XG4gICAgICAgICAgICByZXR1cm4gcHNldWRvICsgcmVwbGFjZUJ5O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29udGVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2FmZVNlbGVjdG9yLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZSgvX19waC0oXFxkKylfXy9nLCBmdW5jdGlvbiAocGgsIGluZGV4KSB7IHJldHVybiBfdGhpcy5wbGFjZWhvbGRlcnNbK2luZGV4XTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNhZmVTZWxlY3Rvci5wcm90b3R5cGUuY29udGVudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbnRlbnQ7IH07XG4gICAgcmV0dXJuIFNhZmVTZWxlY3Rvcjtcbn0oKSk7XG52YXIgX2Nzc0NvbnRlbnROZXh0U2VsZWN0b3JSZSA9IC9wb2x5ZmlsbC1uZXh0LXNlbGVjdG9yW159XSpjb250ZW50OltcXHNdKj8oWydcIl0pKC4qPylcXDFbO1xcc10qfShbXntdKj8pey9naW07XG52YXIgX2Nzc0NvbnRlbnRSdWxlUmUgPSAvKHBvbHlmaWxsLXJ1bGUpW159XSooY29udGVudDpbXFxzXSooWydcIl0pKC4qPylcXDMpWztcXHNdKltefV0qfS9naW07XG52YXIgX2Nzc0NvbnRlbnRVbnNjb3BlZFJ1bGVSZSA9IC8ocG9seWZpbGwtdW5zY29wZWQtcnVsZSlbXn1dKihjb250ZW50OltcXHNdKihbJ1wiXSkoLio/KVxcMylbO1xcc10qW159XSp9L2dpbTtcbnZhciBfcG9seWZpbGxIb3N0ID0gJy1zaGFkb3djc3Nob3N0Jztcbi8vIG5vdGU6IDpob3N0LWNvbnRleHQgcHJlLXByb2Nlc3NlZCB0byAtc2hhZG93Y3NzaG9zdGNvbnRleHQuXG52YXIgX3BvbHlmaWxsSG9zdENvbnRleHQgPSAnLXNoYWRvd2Nzc2NvbnRleHQnO1xudmFyIF9wYXJlblN1ZmZpeCA9ICcpKD86XFxcXCgoJyArXG4gICAgJyg/OlxcXFwoW14pKF0qXFxcXCl8W14pKF0qKSs/JyArXG4gICAgJylcXFxcKSk/KFteLHtdKiknO1xudmFyIF9jc3NDb2xvbkhvc3RSZSA9IG5ldyBSZWdFeHAoJygnICsgX3BvbHlmaWxsSG9zdCArIF9wYXJlblN1ZmZpeCwgJ2dpbScpO1xudmFyIF9jc3NDb2xvbkhvc3RDb250ZXh0UmUgPSBuZXcgUmVnRXhwKCcoJyArIF9wb2x5ZmlsbEhvc3RDb250ZXh0ICsgX3BhcmVuU3VmZml4LCAnZ2ltJyk7XG52YXIgX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvciA9IF9wb2x5ZmlsbEhvc3QgKyAnLW5vLWNvbWJpbmF0b3InO1xudmFyIF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3JSZSA9IC8tc2hhZG93Y3NzaG9zdC1uby1jb21iaW5hdG9yKFteXFxzXSopLztcbnZhciBfc2hhZG93RE9NU2VsZWN0b3JzUmUgPSBbXG4gICAgLzo6c2hhZG93L2csXG4gICAgLzo6Y29udGVudC9nLFxuICAgIC8vIERlcHJlY2F0ZWQgc2VsZWN0b3JzXG4gICAgL1xcL3NoYWRvdy1kZWVwXFwvL2csXG4gICAgL1xcL3NoYWRvd1xcLy9nLFxuXTtcbi8vIFRoZSBkZWVwIGNvbWJpbmF0b3IgaXMgZGVwcmVjYXRlZCBpbiB0aGUgQ1NTIHNwZWNcbi8vIFN1cHBvcnQgZm9yIGA+Pj5gLCBgZGVlcGAsIGA6Om5nLWRlZXBgIGlzIHRoZW4gYWxzbyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS5cbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL3B1bGwvMTc2NzdcbnZhciBfc2hhZG93RGVlcFNlbGVjdG9ycyA9IC8oPzo+Pj4pfCg/OlxcL2RlZXBcXC8pfCg/Ojo6bmctZGVlcCkvZztcbnZhciBfc2VsZWN0b3JSZVN1ZmZpeCA9ICcoWz5cXFxcc34rXFxbLix7Ol1bXFxcXHNcXFxcU10qKT8kJztcbnZhciBfcG9seWZpbGxIb3N0UmUgPSAvLXNoYWRvd2Nzc2hvc3QvZ2ltO1xudmFyIF9jb2xvbkhvc3RSZSA9IC86aG9zdC9naW07XG52YXIgX2NvbG9uSG9zdENvbnRleHRSZSA9IC86aG9zdC1jb250ZXh0L2dpbTtcbnZhciBfY29tbWVudFJlID0gL1xcL1xcKlxccypbXFxzXFxTXSo/XFwqXFwvL2c7XG4vKipcbiAqIEBwYXJhbSB7P30gaW5wdXRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHN0cmlwQ29tbWVudHMoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQucmVwbGFjZShfY29tbWVudFJlLCAnJyk7XG59XG4vLyBhbGwgY29tbWVudHMgZXhjZXB0IGlubGluZSBzb3VyY2UgbWFwcGluZ1xudmFyIF9zb3VyY2VNYXBwaW5nVXJsUmUgPSAvXFwvXFwqXFxzKiNcXHMqc291cmNlTWFwcGluZ1VSTD1bXFxzXFxTXSs/XFwqXFwvLztcbi8qKlxuICogQHBhcmFtIHs/fSBpbnB1dFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFNvdXJjZU1hcHBpbmdVcmwoaW5wdXQpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXRjaGVyID0gaW5wdXQubWF0Y2goX3NvdXJjZU1hcHBpbmdVcmxSZSk7XG4gICAgcmV0dXJuIG1hdGNoZXIgPyBtYXRjaGVyWzBdIDogJyc7XG59XG52YXIgX3J1bGVSZSA9IC8oXFxzKikoW147XFx7XFx9XSs/KShcXHMqKSgoPzp7JUJMT0NLJX0/XFxzKjs/KXwoPzpcXHMqOykpL2c7XG52YXIgX2N1cmx5UmUgPSAvKFt7fV0pL2c7XG52YXIgT1BFTl9DVVJMWSA9ICd7JztcbnZhciBDTE9TRV9DVVJMWSA9ICd9JztcbnZhciBCTE9DS19QTEFDRUhPTERFUiA9ICclQkxPQ0slJztcbnZhciBDc3NSdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gQ3NzUnVsZShzZWxlY3RvciwgY29udGVudCkge1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgfVxuICAgIHJldHVybiBDc3NSdWxlO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBpbnB1dFxuICogQHBhcmFtIHs/fSBydWxlQ2FsbGJhY2tcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NSdWxlcyhpbnB1dCwgcnVsZUNhbGxiYWNrKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5wdXRXaXRoRXNjYXBlZEJsb2NrcyA9IGVzY2FwZUJsb2NrcyhpbnB1dCk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmV4dEJsb2NrSW5kZXggPSAwO1xuICAgIHJldHVybiBpbnB1dFdpdGhFc2NhcGVkQmxvY2tzLmVzY2FwZWRTdHJpbmcucmVwbGFjZShfcnVsZVJlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBtW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VsZWN0b3IgPSBtWzJdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250ZW50ID0gJyc7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN1ZmZpeCA9IG1bNF07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRlbnRQcmVmaXggPSAnJztcbiAgICAgICAgaWYgKHN1ZmZpeCAmJiBzdWZmaXguc3RhcnRzV2l0aCgneycgKyBCTE9DS19QTEFDRUhPTERFUikpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBpbnB1dFdpdGhFc2NhcGVkQmxvY2tzLmJsb2Nrc1tuZXh0QmxvY2tJbmRleCsrXTtcbiAgICAgICAgICAgIHN1ZmZpeCA9IHN1ZmZpeC5zdWJzdHJpbmcoQkxPQ0tfUExBQ0VIT0xERVIubGVuZ3RoICsgMSk7XG4gICAgICAgICAgICBjb250ZW50UHJlZml4ID0gJ3snO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJ1bGUgPSBydWxlQ2FsbGJhY2sobmV3IENzc1J1bGUoc2VsZWN0b3IsIGNvbnRlbnQpKTtcbiAgICAgICAgcmV0dXJuIFwiXCIgKyBtWzFdICsgcnVsZS5zZWxlY3RvciArIG1bM10gKyBjb250ZW50UHJlZml4ICsgcnVsZS5jb250ZW50ICsgc3VmZml4O1xuICAgIH0pO1xufVxudmFyIFN0cmluZ1dpdGhFc2NhcGVkQmxvY2tzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVzY2FwZWRTdHJpbmdcbiAgICAgKiBAcGFyYW0gez99IGJsb2Nrc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN0cmluZ1dpdGhFc2NhcGVkQmxvY2tzKGVzY2FwZWRTdHJpbmcsIGJsb2Nrcykge1xuICAgICAgICB0aGlzLmVzY2FwZWRTdHJpbmcgPSBlc2NhcGVkU3RyaW5nO1xuICAgICAgICB0aGlzLmJsb2NrcyA9IGJsb2NrcztcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZ1dpdGhFc2NhcGVkQmxvY2tzO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBpbnB1dFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlQmxvY2tzKGlucHV0KSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5wdXRQYXJ0cyA9IGlucHV0LnNwbGl0KF9jdXJseVJlKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHRQYXJ0cyA9IFtdO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGVzY2FwZWRCbG9ja3MgPSBbXTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBicmFja2V0Q291bnQgPSAwO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGN1cnJlbnRCbG9ja1BhcnRzID0gW107XG4gICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJ0SW5kZXggPSAwOyBwYXJ0SW5kZXggPCBpbnB1dFBhcnRzLmxlbmd0aDsgcGFydEluZGV4KyspIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFydCA9IGlucHV0UGFydHNbcGFydEluZGV4XTtcbiAgICAgICAgaWYgKHBhcnQgPT0gQ0xPU0VfQ1VSTFkpIHtcbiAgICAgICAgICAgIGJyYWNrZXRDb3VudC0tO1xuICAgICAgICB9XG4gICAgICAgIGlmIChicmFja2V0Q291bnQgPiAwKSB7XG4gICAgICAgICAgICBjdXJyZW50QmxvY2tQYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRCbG9ja1BhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBlc2NhcGVkQmxvY2tzLnB1c2goY3VycmVudEJsb2NrUGFydHMuam9pbignJykpO1xuICAgICAgICAgICAgICAgIHJlc3VsdFBhcnRzLnB1c2goQkxPQ0tfUExBQ0VIT0xERVIpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCbG9ja1BhcnRzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRQYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0ID09IE9QRU5fQ1VSTFkpIHtcbiAgICAgICAgICAgIGJyYWNrZXRDb3VudCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjdXJyZW50QmxvY2tQYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGVzY2FwZWRCbG9ja3MucHVzaChjdXJyZW50QmxvY2tQYXJ0cy5qb2luKCcnKSk7XG4gICAgICAgIHJlc3VsdFBhcnRzLnB1c2goQkxPQ0tfUExBQ0VIT0xERVIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFN0cmluZ1dpdGhFc2NhcGVkQmxvY2tzKHJlc3VsdFBhcnRzLmpvaW4oJycpLCBlc2NhcGVkQmxvY2tzKTtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBDT01QT05FTlRfVkFSSUFCTEUgPSAnJUNPTVAlJztcbnZhciBIT1NUX0FUVFIgPSBcIl9uZ2hvc3QtXCIgKyBDT01QT05FTlRfVkFSSUFCTEU7XG52YXIgQ09OVEVOVF9BVFRSID0gXCJfbmdjb250ZW50LVwiICsgQ09NUE9ORU5UX1ZBUklBQkxFO1xudmFyIFN0eWxlc0NvbXBpbGVEZXBlbmRlbmN5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IG1vZHVsZVVybFxuICAgICAqIEBwYXJhbSB7P30gc2V0VmFsdWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdHlsZXNDb21waWxlRGVwZW5kZW5jeShuYW1lLCBtb2R1bGVVcmwsIHNldFZhbHVlKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMubW9kdWxlVXJsID0gbW9kdWxlVXJsO1xuICAgICAgICB0aGlzLnNldFZhbHVlID0gc2V0VmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBTdHlsZXNDb21waWxlRGVwZW5kZW5jeTtcbn0oKSk7XG52YXIgQ29tcGlsZWRTdHlsZXNoZWV0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG91dHB1dEN0eFxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVzVmFyXG4gICAgICogQHBhcmFtIHs/fSBkZXBlbmRlbmNpZXNcbiAgICAgKiBAcGFyYW0gez99IGlzU2hpbW1lZFxuICAgICAqIEBwYXJhbSB7P30gbWV0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbXBpbGVkU3R5bGVzaGVldChvdXRwdXRDdHgsIHN0eWxlc1ZhciwgZGVwZW5kZW5jaWVzLCBpc1NoaW1tZWQsIG1ldGEpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRDdHggPSBvdXRwdXRDdHg7XG4gICAgICAgIHRoaXMuc3R5bGVzVmFyID0gc3R5bGVzVmFyO1xuICAgICAgICB0aGlzLmRlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llcztcbiAgICAgICAgdGhpcy5pc1NoaW1tZWQgPSBpc1NoaW1tZWQ7XG4gICAgICAgIHRoaXMubWV0YSA9IG1ldGE7XG4gICAgfVxuICAgIHJldHVybiBDb21waWxlZFN0eWxlc2hlZXQ7XG59KCkpO1xudmFyIFN0eWxlQ29tcGlsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX3VybFJlc29sdmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3R5bGVDb21waWxlcihfdXJsUmVzb2x2ZXIpIHtcbiAgICAgICAgdGhpcy5fdXJsUmVzb2x2ZXIgPSBfdXJsUmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuX3NoYWRvd0NzcyA9IG5ldyBTaGFkb3dDc3MoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBvdXRwdXRDdHhcbiAgICAgKiBAcGFyYW0gez99IGNvbXBcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0eWxlQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVDb21wb25lbnQgPSBmdW5jdGlvbiAob3V0cHV0Q3R4LCBjb21wKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlbXBsYXRlID0gKChjb21wLnRlbXBsYXRlKSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb21waWxlU3R5bGVzKG91dHB1dEN0eCwgY29tcCwgbmV3IENvbXBpbGVTdHlsZXNoZWV0TWV0YWRhdGEoe1xuICAgICAgICAgICAgc3R5bGVzOiB0ZW1wbGF0ZS5zdHlsZXMsXG4gICAgICAgICAgICBzdHlsZVVybHM6IHRlbXBsYXRlLnN0eWxlVXJscyxcbiAgICAgICAgICAgIG1vZHVsZVVybDogaWRlbnRpZmllck1vZHVsZVVybChjb21wLnR5cGUpXG4gICAgICAgIH0pLCB0cnVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gb3V0cHV0Q3R4XG4gICAgICogQHBhcmFtIHs/fSBjb21wXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZXNoZWV0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdHlsZUNvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlU3R5bGVzID0gZnVuY3Rpb24gKG91dHB1dEN0eCwgY29tcCwgc3R5bGVzaGVldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29tcGlsZVN0eWxlcyhvdXRwdXRDdHgsIGNvbXAsIHN0eWxlc2hlZXQsIGZhbHNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29tcFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3R5bGVDb21waWxlci5wcm90b3R5cGUubmVlZHNTdHlsZVNoaW0gPSBmdW5jdGlvbiAoY29tcCkge1xuICAgICAgICByZXR1cm4gKChjb21wLnRlbXBsYXRlKSkuZW5jYXBzdWxhdGlvbiA9PT0gVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG91dHB1dEN0eFxuICAgICAqIEBwYXJhbSB7P30gY29tcFxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVzaGVldFxuICAgICAqIEBwYXJhbSB7P30gaXNDb21wb25lbnRTdHlsZXNoZWV0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdHlsZUNvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZVN0eWxlcyA9IGZ1bmN0aW9uIChvdXRwdXRDdHgsIGNvbXAsIHN0eWxlc2hlZXQsIGlzQ29tcG9uZW50U3R5bGVzaGVldCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzaGltID0gdGhpcy5uZWVkc1N0eWxlU2hpbShjb21wKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVFeHByZXNzaW9ucyA9IHN0eWxlc2hlZXQuc3R5bGVzLm1hcChmdW5jdGlvbiAocGxhaW5TdHlsZSkgeyByZXR1cm4gbGl0ZXJhbChfdGhpcy5fc2hpbUlmTmVlZGVkKHBsYWluU3R5bGUsIHNoaW0pKTsgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlcGVuZGVuY2llcyA9IFtdO1xuICAgICAgICBzdHlsZXNoZWV0LnN0eWxlVXJscy5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZVVybCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwckluZGV4ID0gc3R5bGVFeHByZXNzaW9ucy5sZW5ndGg7XG4gICAgICAgICAgICAvLyBOb3RlOiBUaGlzIHBsYWNlaG9sZGVyIHdpbGwgYmUgZmlsbGVkIGxhdGVyLlxuICAgICAgICAgICAgc3R5bGVFeHByZXNzaW9ucy5wdXNoKC8qKiBAdHlwZSB7P30gKi8gKChudWxsKSkpO1xuICAgICAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2gobmV3IFN0eWxlc0NvbXBpbGVEZXBlbmRlbmN5KGdldFN0eWxlc1Zhck5hbWUobnVsbCksIHN0eWxlVXJsLCBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHN0eWxlRXhwcmVzc2lvbnNbZXhwckluZGV4XSA9IG91dHB1dEN0eC5pbXBvcnRFeHByKHZhbHVlKTsgfSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gc3R5bGVzIHZhcmlhYmxlIGNvbnRhaW5zIHBsYWluIHN0cmluZ3MgYW5kIGFycmF5cyBvZiBvdGhlciBzdHlsZXMgYXJyYXlzIChyZWN1cnNpdmUpLFxuICAgICAgICAvLyBzbyB3ZSBzZXQgaXRzIHR5cGUgdG8gZHluYW1pYy5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVzVmFyID0gZ2V0U3R5bGVzVmFyTmFtZShpc0NvbXBvbmVudFN0eWxlc2hlZXQgPyBjb21wIDogbnVsbCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0bXQgPSB2YXJpYWJsZShzdHlsZXNWYXIpXG4gICAgICAgICAgICAuc2V0KGxpdGVyYWxBcnIoc3R5bGVFeHByZXNzaW9ucywgbmV3IEFycmF5VHlwZShEWU5BTUlDX1RZUEUsIFtUeXBlTW9kaWZpZXIuQ29uc3RdKSkpXG4gICAgICAgICAgICAudG9EZWNsU3RtdChudWxsLCBpc0NvbXBvbmVudFN0eWxlc2hlZXQgPyBbU3RtdE1vZGlmaWVyLkZpbmFsXSA6IFtcbiAgICAgICAgICAgIFN0bXRNb2RpZmllci5GaW5hbCwgU3RtdE1vZGlmaWVyLkV4cG9ydGVkXG4gICAgICAgIF0pO1xuICAgICAgICBvdXRwdXRDdHguc3RhdGVtZW50cy5wdXNoKHN0bXQpO1xuICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVkU3R5bGVzaGVldChvdXRwdXRDdHgsIHN0eWxlc1ZhciwgZGVwZW5kZW5jaWVzLCBzaGltLCBzdHlsZXNoZWV0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVcbiAgICAgKiBAcGFyYW0gez99IHNoaW1cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0eWxlQ29tcGlsZXIucHJvdG90eXBlLl9zaGltSWZOZWVkZWQgPSBmdW5jdGlvbiAoc3R5bGUkJDEsIHNoaW0pIHtcbiAgICAgICAgcmV0dXJuIHNoaW0gPyB0aGlzLl9zaGFkb3dDc3Muc2hpbUNzc1RleHQoc3R5bGUkJDEsIENPTlRFTlRfQVRUUiwgSE9TVF9BVFRSKSA6IHN0eWxlJCQxO1xuICAgIH07XG4gICAgcmV0dXJuIFN0eWxlQ29tcGlsZXI7XG59KCkpO1xuU3R5bGVDb21waWxlci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcGlsZXJJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5TdHlsZUNvbXBpbGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogVXJsUmVzb2x2ZXIsIH0sXG5dOyB9O1xuLyoqXG4gKiBAcGFyYW0gez99IGNvbXBvbmVudFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGVzVmFyTmFtZShjb21wb25lbnQpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSBcInN0eWxlc1wiO1xuICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgcmVzdWx0ICs9IFwiX1wiICsgaWRlbnRpZmllck5hbWUoY29tcG9uZW50LnR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEV2ZW50SGFuZGxlclZhcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV2ZW50SGFuZGxlclZhcnMoKSB7XG4gICAgfVxuICAgIHJldHVybiBFdmVudEhhbmRsZXJWYXJzO1xufSgpKTtcbkV2ZW50SGFuZGxlclZhcnMuZXZlbnQgPSB2YXJpYWJsZSgnJGV2ZW50Jyk7XG52YXIgQ29udmVydEFjdGlvbkJpbmRpbmdSZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdHNcbiAgICAgKiBAcGFyYW0gez99IGFsbG93RGVmYXVsdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbnZlcnRBY3Rpb25CaW5kaW5nUmVzdWx0KHN0bXRzLCBhbGxvd0RlZmF1bHQpIHtcbiAgICAgICAgdGhpcy5zdG10cyA9IHN0bXRzO1xuICAgICAgICB0aGlzLmFsbG93RGVmYXVsdCA9IGFsbG93RGVmYXVsdDtcbiAgICB9XG4gICAgcmV0dXJuIENvbnZlcnRBY3Rpb25CaW5kaW5nUmVzdWx0O1xufSgpKTtcbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIGV4cHJlc3Npb24gQVNUIGludG8gYW4gZXhlY3V0YWJsZSBvdXRwdXQgQVNULCBhc3N1bWluZyB0aGUgZXhwcmVzc2lvbiBpc1xuICogdXNlZCBpbiBhbiBhY3Rpb24gYmluZGluZyAoZS5nLiBhbiBldmVudCBoYW5kbGVyKS5cbiAqIEBwYXJhbSB7P30gbG9jYWxSZXNvbHZlclxuICogQHBhcmFtIHs/fSBpbXBsaWNpdFJlY2VpdmVyXG4gKiBAcGFyYW0gez99IGFjdGlvblxuICogQHBhcmFtIHs/fSBiaW5kaW5nSWRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRBY3Rpb25CaW5kaW5nKGxvY2FsUmVzb2x2ZXIsIGltcGxpY2l0UmVjZWl2ZXIsIGFjdGlvbiwgYmluZGluZ0lkKSB7XG4gICAgaWYgKCFsb2NhbFJlc29sdmVyKSB7XG4gICAgICAgIGxvY2FsUmVzb2x2ZXIgPSBuZXcgRGVmYXVsdExvY2FsUmVzb2x2ZXIoKTtcbiAgICB9XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWN0aW9uV2l0aG91dEJ1aWx0aW5zID0gY29udmVydFByb3BlcnR5QmluZGluZ0J1aWx0aW5zKHtcbiAgICAgICAgY3JlYXRlTGl0ZXJhbEFycmF5Q29udmVydGVyOiBmdW5jdGlvbiAoYXJnQ291bnQpIHtcbiAgICAgICAgICAgIC8vIE5vdGU6IG5vIGNhY2hpbmcgZm9yIGxpdGVyYWwgYXJyYXlzIGluIGFjdGlvbnMuXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFyZ3MpIHsgcmV0dXJuIGxpdGVyYWxBcnIoYXJncyk7IH07XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZUxpdGVyYWxNYXBDb252ZXJ0ZXI6IGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgICAgICAvLyBOb3RlOiBubyBjYWNoaW5nIGZvciBsaXRlcmFsIG1hcHMgaW4gYWN0aW9ucy5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW50cmllcyA9IGtleXMubWFwKGZ1bmN0aW9uIChrLCBpKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgICAgICAgICBrZXk6IGsua2V5LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVzW2ldLFxuICAgICAgICAgICAgICAgICAgICBxdW90ZWQ6IGsucXVvdGVkLFxuICAgICAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGl0ZXJhbE1hcChlbnRyaWVzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZVBpcGVDb252ZXJ0ZXI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIFN0YXRlOiBBY3Rpb25zIGFyZSBub3QgYWxsb3dlZCB0byBjb250YWluIHBpcGVzLiBQaXBlOiBcIiArIG5hbWUpO1xuICAgICAgICB9XG4gICAgfSwgYWN0aW9uKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aXNpdG9yID0gbmV3IF9Bc3RUb0lyVmlzaXRvcihsb2NhbFJlc29sdmVyLCBpbXBsaWNpdFJlY2VpdmVyLCBiaW5kaW5nSWQpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGFjdGlvblN0bXRzID0gW107XG4gICAgZmxhdHRlblN0YXRlbWVudHMoYWN0aW9uV2l0aG91dEJ1aWx0aW5zLnZpc2l0KHZpc2l0b3IsIF9Nb2RlLlN0YXRlbWVudCksIGFjdGlvblN0bXRzKTtcbiAgICBwcmVwZW5kVGVtcG9yYXJ5RGVjbHModmlzaXRvci50ZW1wb3JhcnlDb3VudCwgYmluZGluZ0lkLCBhY3Rpb25TdG10cyk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGFzdEluZGV4ID0gYWN0aW9uU3RtdHMubGVuZ3RoIC0gMTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmV2ZW50RGVmYXVsdFZhciA9ICgobnVsbCkpO1xuICAgIGlmIChsYXN0SW5kZXggPj0gMCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsYXN0U3RhdGVtZW50ID0gYWN0aW9uU3RtdHNbbGFzdEluZGV4XTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmV0dXJuRXhwciA9IGNvbnZlcnRTdG10SW50b0V4cHJlc3Npb24obGFzdFN0YXRlbWVudCk7XG4gICAgICAgIGlmIChyZXR1cm5FeHByKSB7XG4gICAgICAgICAgICAvLyBOb3RlOiBXZSBuZWVkIHRvIGNhc3QgdGhlIHJlc3VsdCBvZiB0aGUgbWV0aG9kIGNhbGwgdG8gZHluYW1pYyxcbiAgICAgICAgICAgIC8vIGFzIGl0IG1pZ2h0IGJlIGEgdm9pZCBtZXRob2QhXG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdFZhciA9IGNyZWF0ZVByZXZlbnREZWZhdWx0VmFyKGJpbmRpbmdJZCk7XG4gICAgICAgICAgICBhY3Rpb25TdG10c1tsYXN0SW5kZXhdID1cbiAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdFZhci5zZXQocmV0dXJuRXhwci5jYXN0KERZTkFNSUNfVFlQRSkubm90SWRlbnRpY2FsKGxpdGVyYWwoZmFsc2UpKSlcbiAgICAgICAgICAgICAgICAgICAgLnRvRGVjbFN0bXQobnVsbCwgW1N0bXRNb2RpZmllci5GaW5hbF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ29udmVydEFjdGlvbkJpbmRpbmdSZXN1bHQoYWN0aW9uU3RtdHMsIHByZXZlbnREZWZhdWx0VmFyKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBjb252ZXJ0ZXJGYWN0b3J5XG4gKiBAcGFyYW0gez99IGFzdFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY29udmVydFByb3BlcnR5QmluZGluZ0J1aWx0aW5zKGNvbnZlcnRlckZhY3RvcnksIGFzdCkge1xuICAgIHJldHVybiBjb252ZXJ0QnVpbHRpbnMoY29udmVydGVyRmFjdG9yeSwgYXN0KTtcbn1cbnZhciBDb252ZXJ0UHJvcGVydHlCaW5kaW5nUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRzXG4gICAgICogQHBhcmFtIHs/fSBjdXJyVmFsRXhwclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbnZlcnRQcm9wZXJ0eUJpbmRpbmdSZXN1bHQoc3RtdHMsIGN1cnJWYWxFeHByKSB7XG4gICAgICAgIHRoaXMuc3RtdHMgPSBzdG10cztcbiAgICAgICAgdGhpcy5jdXJyVmFsRXhwciA9IGN1cnJWYWxFeHByO1xuICAgIH1cbiAgICByZXR1cm4gQ29udmVydFByb3BlcnR5QmluZGluZ1Jlc3VsdDtcbn0oKSk7XG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBleHByZXNzaW9uIEFTVCBpbnRvIGFuIGV4ZWN1dGFibGUgb3V0cHV0IEFTVCwgYXNzdW1pbmcgdGhlIGV4cHJlc3Npb25cbiAqIGlzIHVzZWQgaW4gcHJvcGVydHkgYmluZGluZy4gVGhlIGV4cHJlc3Npb24gaGFzIHRvIGJlIHByZXByb2Nlc3NlZCB2aWFcbiAqIGBjb252ZXJ0UHJvcGVydHlCaW5kaW5nQnVpbHRpbnNgLlxuICogQHBhcmFtIHs/fSBsb2NhbFJlc29sdmVyXG4gKiBAcGFyYW0gez99IGltcGxpY2l0UmVjZWl2ZXJcbiAqIEBwYXJhbSB7P30gZXhwcmVzc2lvbldpdGhvdXRCdWlsdGluc1xuICogQHBhcmFtIHs/fSBiaW5kaW5nSWRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRQcm9wZXJ0eUJpbmRpbmcobG9jYWxSZXNvbHZlciwgaW1wbGljaXRSZWNlaXZlciwgZXhwcmVzc2lvbldpdGhvdXRCdWlsdGlucywgYmluZGluZ0lkKSB7XG4gICAgaWYgKCFsb2NhbFJlc29sdmVyKSB7XG4gICAgICAgIGxvY2FsUmVzb2x2ZXIgPSBuZXcgRGVmYXVsdExvY2FsUmVzb2x2ZXIoKTtcbiAgICB9XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3VyclZhbEV4cHIgPSBjcmVhdGVDdXJyVmFsdWVFeHByKGJpbmRpbmdJZCk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RtdHMgPSBbXTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aXNpdG9yID0gbmV3IF9Bc3RUb0lyVmlzaXRvcihsb2NhbFJlc29sdmVyLCBpbXBsaWNpdFJlY2VpdmVyLCBiaW5kaW5nSWQpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG91dHB1dEV4cHIgPSBleHByZXNzaW9uV2l0aG91dEJ1aWx0aW5zLnZpc2l0KHZpc2l0b3IsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgIGlmICh2aXNpdG9yLnRlbXBvcmFyeUNvdW50KSB7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCB2aXNpdG9yLnRlbXBvcmFyeUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHN0bXRzLnB1c2godGVtcG9yYXJ5RGVjbGFyYXRpb24oYmluZGluZ0lkLCBpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RtdHMucHVzaChjdXJyVmFsRXhwci5zZXQob3V0cHV0RXhwcikudG9EZWNsU3RtdChudWxsLCBbU3RtdE1vZGlmaWVyLkZpbmFsXSkpO1xuICAgIHJldHVybiBuZXcgQ29udmVydFByb3BlcnR5QmluZGluZ1Jlc3VsdChzdG10cywgY3VyclZhbEV4cHIpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGNvbnZlcnRlckZhY3RvcnlcbiAqIEBwYXJhbSB7P30gYXN0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjb252ZXJ0QnVpbHRpbnMoY29udmVydGVyRmFjdG9yeSwgYXN0KSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlzaXRvciA9IG5ldyBfQnVpbHRpbkFzdENvbnZlcnRlcihjb252ZXJ0ZXJGYWN0b3J5KTtcbiAgICByZXR1cm4gYXN0LnZpc2l0KHZpc2l0b3IpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGJpbmRpbmdJZFxuICogQHBhcmFtIHs/fSB0ZW1wb3JhcnlOdW1iZXJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHRlbXBvcmFyeU5hbWUoYmluZGluZ0lkLCB0ZW1wb3JhcnlOdW1iZXIpIHtcbiAgICByZXR1cm4gXCJ0bXBfXCIgKyBiaW5kaW5nSWQgKyBcIl9cIiArIHRlbXBvcmFyeU51bWJlcjtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBiaW5kaW5nSWRcbiAqIEBwYXJhbSB7P30gdGVtcG9yYXJ5TnVtYmVyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB0ZW1wb3JhcnlEZWNsYXJhdGlvbihiaW5kaW5nSWQsIHRlbXBvcmFyeU51bWJlcikge1xuICAgIHJldHVybiBuZXcgRGVjbGFyZVZhclN0bXQodGVtcG9yYXJ5TmFtZShiaW5kaW5nSWQsIHRlbXBvcmFyeU51bWJlciksIE5VTExfRVhQUik7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdGVtcG9yYXJ5Q291bnRcbiAqIEBwYXJhbSB7P30gYmluZGluZ0lkXG4gKiBAcGFyYW0gez99IHN0YXRlbWVudHNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHByZXBlbmRUZW1wb3JhcnlEZWNscyh0ZW1wb3JhcnlDb3VudCwgYmluZGluZ0lkLCBzdGF0ZW1lbnRzKSB7XG4gICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gdGVtcG9yYXJ5Q291bnQgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBzdGF0ZW1lbnRzLnVuc2hpZnQodGVtcG9yYXJ5RGVjbGFyYXRpb24oYmluZGluZ0lkLCBpKSk7XG4gICAgfVxufVxudmFyIF9Nb2RlID0ge307XG5fTW9kZS5TdGF0ZW1lbnQgPSAwO1xuX01vZGUuRXhwcmVzc2lvbiA9IDE7XG5fTW9kZVtfTW9kZS5TdGF0ZW1lbnRdID0gXCJTdGF0ZW1lbnRcIjtcbl9Nb2RlW19Nb2RlLkV4cHJlc3Npb25dID0gXCJFeHByZXNzaW9uXCI7XG4vKipcbiAqIEBwYXJhbSB7P30gbW9kZVxuICogQHBhcmFtIHs/fSBhc3RcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGVuc3VyZVN0YXRlbWVudE1vZGUobW9kZSwgYXN0KSB7XG4gICAgaWYgKG1vZGUgIT09IF9Nb2RlLlN0YXRlbWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBhIHN0YXRlbWVudCwgYnV0IHNhdyBcIiArIGFzdCk7XG4gICAgfVxufVxuLyoqXG4gKiBAcGFyYW0gez99IG1vZGVcbiAqIEBwYXJhbSB7P30gYXN0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBlbnN1cmVFeHByZXNzaW9uTW9kZShtb2RlLCBhc3QpIHtcbiAgICBpZiAobW9kZSAhPT0gX01vZGUuRXhwcmVzc2lvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBhbiBleHByZXNzaW9uLCBidXQgc2F3IFwiICsgYXN0KTtcbiAgICB9XG59XG4vKipcbiAqIEBwYXJhbSB7P30gbW9kZVxuICogQHBhcmFtIHs/fSBleHByXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCBleHByKSB7XG4gICAgaWYgKG1vZGUgPT09IF9Nb2RlLlN0YXRlbWVudCkge1xuICAgICAgICByZXR1cm4gZXhwci50b1N0bXQoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cbn1cbnZhciBfQnVpbHRpbkFzdENvbnZlcnRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoX0J1aWx0aW5Bc3RDb252ZXJ0ZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfY29udmVydGVyRmFjdG9yeVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9CdWlsdGluQXN0Q29udmVydGVyKF9jb252ZXJ0ZXJGYWN0b3J5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9jb252ZXJ0ZXJGYWN0b3J5ID0gX2NvbnZlcnRlckZhY3Rvcnk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9CdWlsdGluQXN0Q29udmVydGVyLnByb3RvdHlwZS52aXNpdFBpcGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFyZ3MgPSBbYXN0LmV4cF0uY29uY2F0KGFzdC5hcmdzKS5tYXAoZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gYXN0LnZpc2l0KF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICAgIHJldHVybiBuZXcgQnVpbHRpbkZ1bmN0aW9uQ2FsbChhc3Quc3BhbiwgYXJncywgdGhpcy5fY29udmVydGVyRmFjdG9yeS5jcmVhdGVQaXBlQ29udmVydGVyKGFzdC5uYW1lLCBhcmdzLmxlbmd0aCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9CdWlsdGluQXN0Q29udmVydGVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXJncyA9IGFzdC5leHByZXNzaW9ucy5tYXAoZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gYXN0LnZpc2l0KF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICAgIHJldHVybiBuZXcgQnVpbHRpbkZ1bmN0aW9uQ2FsbChhc3Quc3BhbiwgYXJncywgdGhpcy5fY29udmVydGVyRmFjdG9yeS5jcmVhdGVMaXRlcmFsQXJyYXlDb252ZXJ0ZXIoYXN0LmV4cHJlc3Npb25zLmxlbmd0aCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9CdWlsdGluQXN0Q29udmVydGVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXAgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFyZ3MgPSBhc3QudmFsdWVzLm1hcChmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBhc3QudmlzaXQoX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWlsdGluRnVuY3Rpb25DYWxsKGFzdC5zcGFuLCBhcmdzLCB0aGlzLl9jb252ZXJ0ZXJGYWN0b3J5LmNyZWF0ZUxpdGVyYWxNYXBDb252ZXJ0ZXIoYXN0LmtleXMpKTtcbiAgICB9O1xuICAgIHJldHVybiBfQnVpbHRpbkFzdENvbnZlcnRlcjtcbn0oQXN0VHJhbnNmb3JtZXIpKTtcbnZhciBfQXN0VG9JclZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2xvY2FsUmVzb2x2ZXJcbiAgICAgKiBAcGFyYW0gez99IF9pbXBsaWNpdFJlY2VpdmVyXG4gICAgICogQHBhcmFtIHs/fSBiaW5kaW5nSWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfQXN0VG9JclZpc2l0b3IoX2xvY2FsUmVzb2x2ZXIsIF9pbXBsaWNpdFJlY2VpdmVyLCBiaW5kaW5nSWQpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxSZXNvbHZlciA9IF9sb2NhbFJlc29sdmVyO1xuICAgICAgICB0aGlzLl9pbXBsaWNpdFJlY2VpdmVyID0gX2ltcGxpY2l0UmVjZWl2ZXI7XG4gICAgICAgIHRoaXMuYmluZGluZ0lkID0gYmluZGluZ0lkO1xuICAgICAgICB0aGlzLl9ub2RlTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9yZXN1bHRNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUZW1wb3JhcnkgPSAwO1xuICAgICAgICB0aGlzLnRlbXBvcmFyeUNvdW50ID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IG1vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRCaW5hcnkgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9wO1xuICAgICAgICBzd2l0Y2ggKGFzdC5vcGVyYXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuUGx1cztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuTWludXM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLk11bHRpcGx5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5EaXZpZGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLk1vZHVsbztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJyYmJzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLkFuZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3x8JzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLk9yO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnPT0nOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuRXF1YWxzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnIT0nOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuTm90RXF1YWxzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnPT09JzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLklkZW50aWNhbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJyE9PSc6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5Ob3RJZGVudGljYWw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLkxvd2VyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5CaWdnZXI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5Mb3dlckVxdWFscztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLkJpZ2dlckVxdWFscztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgb3BlcmF0aW9uIFwiICsgYXN0Lm9wZXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIob3AsIHRoaXMuX3Zpc2l0KGFzdC5sZWZ0LCBfTW9kZS5FeHByZXNzaW9uKSwgdGhpcy5fdmlzaXQoYXN0LnJpZ2h0LCBfTW9kZS5FeHByZXNzaW9uKSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IG1vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRDaGFpbiA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgZW5zdXJlU3RhdGVtZW50TW9kZShtb2RlLCBhc3QpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMsIG1vZGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IG1vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb25kaXRpb25hbCA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSB0aGlzLl92aXNpdChhc3QuY29uZGl0aW9uLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIHZhbHVlLmNvbmRpdGlvbmFsKHRoaXMuX3Zpc2l0KGFzdC50cnVlRXhwLCBfTW9kZS5FeHByZXNzaW9uKSwgdGhpcy5fdmlzaXQoYXN0LmZhbHNlRXhwLCBfTW9kZS5FeHByZXNzaW9uKSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IG1vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRQaXBlID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIHN0YXRlOiBQaXBlcyBzaG91bGQgaGF2ZSBiZWVuIGNvbnZlcnRlZCBpbnRvIGZ1bmN0aW9ucy4gUGlwZTogXCIgKyBhc3QubmFtZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gbW9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEZ1bmN0aW9uQ2FsbCA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udmVydGVkQXJncyA9IHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmblJlc3VsdDtcbiAgICAgICAgaWYgKGFzdCBpbnN0YW5jZW9mIEJ1aWx0aW5GdW5jdGlvbkNhbGwpIHtcbiAgICAgICAgICAgIGZuUmVzdWx0ID0gYXN0LmNvbnZlcnRlcihjb252ZXJ0ZWRBcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZuUmVzdWx0ID0gdGhpcy5fdmlzaXQoLyoqIEB0eXBlIHs/fSAqLyAoKGFzdC50YXJnZXQpKSwgX01vZGUuRXhwcmVzc2lvbikuY2FsbEZuKGNvbnZlcnRlZEFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCBmblJlc3VsdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gbW9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEltcGxpY2l0UmVjZWl2ZXIgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIGVuc3VyZUV4cHJlc3Npb25Nb2RlKG1vZGUsIGFzdCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbXBsaWNpdFJlY2VpdmVyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IG1vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICBlbnN1cmVFeHByZXNzaW9uTW9kZShtb2RlLCBhc3QpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhcmdzID0gW2xpdGVyYWwoYXN0LmV4cHJlc3Npb25zLmxlbmd0aCldO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgYXN0LnN0cmluZ3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzLnB1c2gobGl0ZXJhbChhc3Quc3RyaW5nc1tpXSkpO1xuICAgICAgICAgICAgYXJncy5wdXNoKHRoaXMuX3Zpc2l0KGFzdC5leHByZXNzaW9uc1tpXSwgX01vZGUuRXhwcmVzc2lvbikpO1xuICAgICAgICB9XG4gICAgICAgIGFyZ3MucHVzaChsaXRlcmFsKGFzdC5zdHJpbmdzW2FzdC5zdHJpbmdzLmxlbmd0aCAtIDFdKSk7XG4gICAgICAgIHJldHVybiBhc3QuZXhwcmVzc2lvbnMubGVuZ3RoIDw9IDkgP1xuICAgICAgICAgICAgaW1wb3J0RXhwcihJZGVudGlmaWVycy5pbmxpbmVJbnRlcnBvbGF0ZSkuY2FsbEZuKGFyZ3MpIDpcbiAgICAgICAgICAgIGltcG9ydEV4cHIoSWRlbnRpZmllcnMuaW50ZXJwb2xhdGUpLmNhbGxGbihbYXJnc1swXSwgbGl0ZXJhbEFycihhcmdzLnNsaWNlKDEpKV0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IG1vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRLZXllZFJlYWQgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxlZnRNb3N0U2FmZSA9IHRoaXMubGVmdE1vc3RTYWZlTm9kZShhc3QpO1xuICAgICAgICBpZiAobGVmdE1vc3RTYWZlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0U2FmZUFjY2Vzcyhhc3QsIGxlZnRNb3N0U2FmZSwgbW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgdGhpcy5fdmlzaXQoYXN0Lm9iaiwgX01vZGUuRXhwcmVzc2lvbikua2V5KHRoaXMuX3Zpc2l0KGFzdC5rZXksIF9Nb2RlLkV4cHJlc3Npb24pKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBtb2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0S2V5ZWRXcml0ZSA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2JqID0gdGhpcy5fdmlzaXQoYXN0Lm9iaiwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGtleSA9IHRoaXMuX3Zpc2l0KGFzdC5rZXksIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IHRoaXMuX3Zpc2l0KGFzdC52YWx1ZSwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCBvYmoua2V5KGtleSkuc2V0KHZhbHVlKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gbW9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheSA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBTdGF0ZTogbGl0ZXJhbCBhcnJheXMgc2hvdWxkIGhhdmUgYmVlbiBjb252ZXJ0ZWQgaW50byBmdW5jdGlvbnNcIik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gbW9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXAgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgU3RhdGU6IGxpdGVyYWwgbWFwcyBzaG91bGQgaGF2ZSBiZWVuIGNvbnZlcnRlZCBpbnRvIGZ1bmN0aW9uc1wiKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBtb2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbFByaW1pdGl2ZSA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIGxpdGVyYWwoYXN0LnZhbHVlKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUuX2dldExvY2FsID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIHRoaXMuX2xvY2FsUmVzb2x2ZXIuZ2V0TG9jYWwobmFtZSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IG1vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsZWZ0TW9zdFNhZmUgPSB0aGlzLmxlZnRNb3N0U2FmZU5vZGUoYXN0KTtcbiAgICAgICAgaWYgKGxlZnRNb3N0U2FmZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydFNhZmVBY2Nlc3MoYXN0LCBsZWZ0TW9zdFNhZmUsIG1vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXJncyA9IHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlY2VpdmVyID0gdGhpcy5fdmlzaXQoYXN0LnJlY2VpdmVyLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgICAgIGlmIChyZWNlaXZlciA9PT0gdGhpcy5faW1wbGljaXRSZWNlaXZlcikge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhckV4cHIgPSB0aGlzLl9nZXRMb2NhbChhc3QubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhckV4cHIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFyRXhwci5jYWxsRm4oYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVjZWl2ZXIuY2FsbE1ldGhvZChhc3QubmFtZSwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IG1vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRQcmVmaXhOb3QgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCBub3QodGhpcy5fdmlzaXQoYXN0LmV4cHJlc3Npb24sIF9Nb2RlLkV4cHJlc3Npb24pKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gbW9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdE5vbk51bGxBc3NlcnQgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCBhc3NlcnROb3ROdWxsKHRoaXMuX3Zpc2l0KGFzdC5leHByZXNzaW9uLCBfTW9kZS5FeHByZXNzaW9uKSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IG1vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxlZnRNb3N0U2FmZSA9IHRoaXMubGVmdE1vc3RTYWZlTm9kZShhc3QpO1xuICAgICAgICBpZiAobGVmdE1vc3RTYWZlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0U2FmZUFjY2Vzcyhhc3QsIGxlZnRNb3N0U2FmZSwgbW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVjZWl2ZXIgPSB0aGlzLl92aXNpdChhc3QucmVjZWl2ZXIsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICAgICAgaWYgKHJlY2VpdmVyID09PSB0aGlzLl9pbXBsaWNpdFJlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fZ2V0TG9jYWwoYXN0Lm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVjZWl2ZXIucHJvcChhc3QubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IG1vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVdyaXRlID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWNlaXZlciA9IHRoaXMuX3Zpc2l0KGFzdC5yZWNlaXZlciwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgIGlmIChyZWNlaXZlciA9PT0gdGhpcy5faW1wbGljaXRSZWNlaXZlcikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFyRXhwciA9IHRoaXMuX2dldExvY2FsKGFzdC5uYW1lKTtcbiAgICAgICAgICAgIGlmICh2YXJFeHByKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYXNzaWduIHRvIGEgcmVmZXJlbmNlIG9yIHZhcmlhYmxlIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCByZWNlaXZlci5wcm9wKGFzdC5uYW1lKS5zZXQodGhpcy5fdmlzaXQoYXN0LnZhbHVlLCBfTW9kZS5FeHByZXNzaW9uKSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IG1vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRTYWZlUHJvcGVydHlSZWFkID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0U2FmZUFjY2Vzcyhhc3QsIHRoaXMubGVmdE1vc3RTYWZlTm9kZShhc3QpLCBtb2RlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBtb2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0U2FmZU1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRTYWZlQWNjZXNzKGFzdCwgdGhpcy5sZWZ0TW9zdFNhZmVOb2RlKGFzdCksIG1vZGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RzXG4gICAgICogQHBhcmFtIHs/fSBtb2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0QWxsID0gZnVuY3Rpb24gKGFzdHMsIG1vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGFzdHMubWFwKGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIF90aGlzLl92aXNpdChhc3QsIG1vZGUpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBtb2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UXVvdGUgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlF1b3RlcyBhcmUgbm90IHN1cHBvcnRlZCBmb3IgZXZhbHVhdGlvbiFcXG4gICAgICAgIFN0YXRlbWVudDogXCIgKyBhc3QudW5pbnRlcnByZXRlZEV4cHJlc3Npb24gKyBcIiBsb2NhdGVkIGF0IFwiICsgYXN0LmxvY2F0aW9uKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBtb2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLl92aXNpdCA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gdGhpcy5fcmVzdWx0TWFwLmdldChhc3QpO1xuICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9ub2RlTWFwLmdldChhc3QpIHx8IGFzdCkudmlzaXQodGhpcywgbW9kZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gbGVmdE1vc3RTYWZlXG4gICAgICogQHBhcmFtIHs/fSBtb2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLmNvbnZlcnRTYWZlQWNjZXNzID0gZnVuY3Rpb24gKGFzdCwgbGVmdE1vc3RTYWZlLCBtb2RlKSB7XG4gICAgICAgIC8vIElmIHRoZSBleHByZXNzaW9uIGNvbnRhaW5zIGEgc2FmZSBhY2Nlc3Mgbm9kZSBvbiB0aGUgbGVmdCBpdCBuZWVkcyB0byBiZSBjb252ZXJ0ZWQgdG9cbiAgICAgICAgLy8gYW4gZXhwcmVzc2lvbiB0aGF0IGd1YXJkcyB0aGUgYWNjZXNzIHRvIHRoZSBtZW1iZXIgYnkgY2hlY2tpbmcgdGhlIHJlY2VpdmVyIGZvciBibGFuay4gQXNcbiAgICAgICAgLy8gZXhlY3V0aW9uIHByb2NlZWRzIGZyb20gbGVmdCB0byByaWdodCwgdGhlIGxlZnQgbW9zdCBwYXJ0IG9mIHRoZSBleHByZXNzaW9uIG11c3QgYmUgZ3VhcmRlZFxuICAgICAgICAvLyBmaXJzdCBidXQsIGJlY2F1c2UgbWVtYmVyIGFjY2VzcyBpcyBsZWZ0IGFzc29jaWF0aXZlLCB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgZXhwcmVzc2lvbiBpcyBhdFxuICAgICAgICAvLyB0aGUgdG9wIG9mIHRoZSBBU1QuIFRoZSBkZXNpcmVkIHJlc3VsdCByZXF1aXJlcyBsaWZ0aW5nIGEgY29weSBvZiB0aGUgdGhlIGxlZnQgcGFydCBvZiB0aGVcbiAgICAgICAgLy8gZXhwcmVzc2lvbiB1cCB0byB0ZXN0IGl0IGZvciBibGFuayBiZWZvcmUgZ2VuZXJhdGluZyB0aGUgdW5ndWFyZGVkIHZlcnNpb24uXG4gICAgICAgIC8vIENvbnNpZGVyLCBmb3IgZXhhbXBsZSB0aGUgZm9sbG93aW5nIGV4cHJlc3Npb246IGE/LmIuYz8uZC5lXG4gICAgICAgIC8vIFRoaXMgcmVzdWx0cyBpbiB0aGUgYXN0OlxuICAgICAgICAvLyAgICAgICAgIC5cbiAgICAgICAgLy8gICAgICAgIC8gXFxcbiAgICAgICAgLy8gICAgICAgPy4gICBlXG4gICAgICAgIC8vICAgICAgLyAgXFxcbiAgICAgICAgLy8gICAgIC4gICAgZFxuICAgICAgICAvLyAgICAvIFxcXG4gICAgICAgIC8vICAgPy4gIGNcbiAgICAgICAgLy8gIC8gIFxcXG4gICAgICAgIC8vIGEgICAgYlxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIHRyZWUgc2hvdWxkIGJlIGdlbmVyYXRlZDpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgICAgIC8tLS0tID8gLS0tLVxcXG4gICAgICAgIC8vICAgICAgIC8gICAgICB8ICAgICAgXFxcbiAgICAgICAgLy8gICAgIGEgICAvLS0tID8gLS0tXFwgIG51bGxcbiAgICAgICAgLy8gICAgICAgIC8gICAgIHwgICAgIFxcXG4gICAgICAgIC8vICAgICAgIC4gICAgICAuICAgICBudWxsXG4gICAgICAgIC8vICAgICAgLyBcXCAgICAvIFxcXG4gICAgICAgIC8vICAgICAuICBjICAgLiAgIGVcbiAgICAgICAgLy8gICAgLyBcXCAgICAvIFxcXG4gICAgICAgIC8vICAgYSAgIGIgICwgICBkXG4gICAgICAgIC8vICAgICAgICAgLyBcXFxuICAgICAgICAvLyAgICAgICAgLiAgIGNcbiAgICAgICAgLy8gICAgICAgLyBcXFxuICAgICAgICAvLyAgICAgIGEgICBiXG4gICAgICAgIC8vXG4gICAgICAgIC8vIE5vdGljZSB0aGF0IHRoZSBmaXJzdCBndWFyZCBjb25kaXRpb24gaXMgdGhlIGxlZnQgaGFuZCBvZiB0aGUgbGVmdCBtb3N0IHNhZmUgYWNjZXNzIG5vZGVcbiAgICAgICAgLy8gd2hpY2ggY29tZXMgaW4gYXMgbGVmdE1vc3RTYWZlIHRvIHRoaXMgcm91dGluZS5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZ3VhcmRlZEV4cHJlc3Npb24gPSB0aGlzLl92aXNpdChsZWZ0TW9zdFNhZmUucmVjZWl2ZXIsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wb3JhcnkgPSAoKHVuZGVmaW5lZCkpO1xuICAgICAgICBpZiAodGhpcy5uZWVkc1RlbXBvcmFyeShsZWZ0TW9zdFNhZmUucmVjZWl2ZXIpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZXhwcmVzc2lvbiBoYXMgbWV0aG9kIGNhbGxzIG9yIHBpcGVzIHRoZW4gd2UgbmVlZCB0byBzYXZlIHRoZSByZXN1bHQgaW50byBhXG4gICAgICAgICAgICAvLyB0ZW1wb3JhcnkgdmFyaWFibGUgdG8gYXZvaWQgY2FsbGluZyBzdGF0ZWZ1bCBvciBpbXB1cmUgY29kZSBtb3JlIHRoYW4gb25jZS5cbiAgICAgICAgICAgIHRlbXBvcmFyeSA9IHRoaXMuYWxsb2NhdGVUZW1wb3JhcnkoKTtcbiAgICAgICAgICAgIC8vIFByZXNlcnZlIHRoZSByZXN1bHQgaW4gdGhlIHRlbXBvcmFyeSB2YXJpYWJsZVxuICAgICAgICAgICAgZ3VhcmRlZEV4cHJlc3Npb24gPSB0ZW1wb3Jhcnkuc2V0KGd1YXJkZWRFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIC8vIEVuc3VyZSBhbGwgZnVydGhlciByZWZlcmVuY2VzIHRvIHRoZSBndWFyZGVkIGV4cHJlc3Npb24gcmVmZXIgdG8gdGhlIHRlbXBvcmFyeSBpbnN0ZWFkLlxuICAgICAgICAgICAgdGhpcy5fcmVzdWx0TWFwLnNldChsZWZ0TW9zdFNhZmUucmVjZWl2ZXIsIHRlbXBvcmFyeSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29uZGl0aW9uID0gZ3VhcmRlZEV4cHJlc3Npb24uaXNCbGFuaygpO1xuICAgICAgICAvLyBDb252ZXJ0IHRoZSBhc3QgdG8gYW4gdW5ndWFyZGVkIGFjY2VzcyB0byB0aGUgcmVjZWl2ZXIncyBtZW1iZXIuIFRoZSBtYXAgd2lsbCBzdWJzdGl0dXRlXG4gICAgICAgIC8vIGxlZnRNb3N0Tm9kZSB3aXRoIGl0cyB1bmd1YXJkZWQgdmVyc2lvbiBpbiB0aGUgY2FsbCB0byBgdGhpcy52aXNpdCgpYC5cbiAgICAgICAgaWYgKGxlZnRNb3N0U2FmZSBpbnN0YW5jZW9mIFNhZmVNZXRob2RDYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9ub2RlTWFwLnNldChsZWZ0TW9zdFNhZmUsIG5ldyBNZXRob2RDYWxsKGxlZnRNb3N0U2FmZS5zcGFuLCBsZWZ0TW9zdFNhZmUucmVjZWl2ZXIsIGxlZnRNb3N0U2FmZS5uYW1lLCBsZWZ0TW9zdFNhZmUuYXJncykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbm9kZU1hcC5zZXQobGVmdE1vc3RTYWZlLCBuZXcgUHJvcGVydHlSZWFkKGxlZnRNb3N0U2FmZS5zcGFuLCBsZWZ0TW9zdFNhZmUucmVjZWl2ZXIsIGxlZnRNb3N0U2FmZS5uYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB0aGUgbm9kZSBub3cgd2l0aG91dCB0aGUgZ3VhcmRlZCBtZW1iZXIgYWNjZXNzLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhY2Nlc3MgPSB0aGlzLl92aXNpdChhc3QsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICAvLyBSZW1vdmUgdGhlIG1hcHBpbmcuIFRoaXMgaXMgbm90IHN0cmljdGx5IHJlcXVpcmVkIGFzIHRoZSBjb252ZXJ0ZXIgb25seSB0cmF2ZXJzZXMgZWFjaCBub2RlXG4gICAgICAgIC8vIG9uY2UgYnV0IGlzIHNhZmVyIGlmIHRoZSBjb252ZXJzaW9uIGlzIGNoYW5nZWQgdG8gdHJhdmVyc2UgdGhlIG5vZGVzIG1vcmUgdGhhbiBvbmNlLlxuICAgICAgICB0aGlzLl9ub2RlTWFwLmRlbGV0ZShsZWZ0TW9zdFNhZmUpO1xuICAgICAgICAvLyBJZiB3ZSBhbGxvY2F0ZWQgYSB0ZW1wb3JhcnksIHJlbGVhc2UgaXQuXG4gICAgICAgIGlmICh0ZW1wb3JhcnkpIHtcbiAgICAgICAgICAgIHRoaXMucmVsZWFzZVRlbXBvcmFyeSh0ZW1wb3JhcnkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByb2R1Y2UgdGhlIGNvbmRpdGlvbmFsXG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCBjb25kaXRpb24uY29uZGl0aW9uYWwobGl0ZXJhbChudWxsKSwgYWNjZXNzKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS5sZWZ0TW9zdFNhZmVOb2RlID0gZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBhc3QpIHtcbiAgICAgICAgICAgIHJldHVybiAoX3RoaXMuX25vZGVNYXAuZ2V0KGFzdCkgfHwgYXN0KS52aXNpdCh2aXNpdG9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGFzdC52aXNpdCh7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdEJpbmFyeTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0Q2hhaW46IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdENvbmRpdGlvbmFsOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRGdW5jdGlvbkNhbGw6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdEltcGxpY2l0UmVjZWl2ZXI6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdEludGVycG9sYXRpb246IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdEtleWVkUmVhZDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdmlzaXQodGhpcywgYXN0Lm9iaik7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdEtleWVkV3JpdGU6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdExpdGVyYWxBcnJheTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0TGl0ZXJhbE1hcDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0TGl0ZXJhbFByaW1pdGl2ZTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0TWV0aG9kQ2FsbDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdmlzaXQodGhpcywgYXN0LnJlY2VpdmVyKTsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0UGlwZTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0UHJlZml4Tm90OiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXROb25OdWxsQXNzZXJ0OiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRQcm9wZXJ0eVJlYWQ6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5yZWNlaXZlcik7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdFByb3BlcnR5V3JpdGU6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdFF1b3RlOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRTYWZlTWV0aG9kQ2FsbDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdmlzaXQodGhpcywgYXN0LnJlY2VpdmVyKSB8fCBhc3Q7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdFNhZmVQcm9wZXJ0eVJlYWQ6IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXQodGhpcywgYXN0LnJlY2VpdmVyKSB8fCBhc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUubmVlZHNUZW1wb3JhcnkgPSBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGFzdCkge1xuICAgICAgICAgICAgcmV0dXJuIGFzdCAmJiAoX3RoaXMuX25vZGVNYXAuZ2V0KGFzdCkgfHwgYXN0KS52aXNpdCh2aXNpdG9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlzaXRTb21lID0gZnVuY3Rpb24gKHZpc2l0b3IsIGFzdCkge1xuICAgICAgICAgICAgcmV0dXJuIGFzdC5zb21lKGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHZpc2l0KHZpc2l0b3IsIGFzdCk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXN0LnZpc2l0KHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0QmluYXJ5OiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB2aXNpdCh0aGlzLCBhc3QubGVmdCkgfHwgdmlzaXQodGhpcywgYXN0LnJpZ2h0KTsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0Q2hhaW46IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGZhbHNlOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRDb25kaXRpb25hbDogZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdCh0aGlzLCBhc3QuY29uZGl0aW9uKSB8fCB2aXNpdCh0aGlzLCBhc3QudHJ1ZUV4cCkgfHxcbiAgICAgICAgICAgICAgICAgICAgdmlzaXQodGhpcywgYXN0LmZhbHNlRXhwKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdEZ1bmN0aW9uQ2FsbDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0SW1wbGljaXRSZWNlaXZlcjogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdEludGVycG9sYXRpb246IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHZpc2l0U29tZSh0aGlzLCBhc3QuZXhwcmVzc2lvbnMpOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRLZXllZFJlYWQ6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGZhbHNlOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRLZXllZFdyaXRlOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBmYWxzZTsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0TGl0ZXJhbEFycmF5OiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRMaXRlcmFsTWFwOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRMaXRlcmFsUHJpbWl0aXZlOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBmYWxzZTsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0TWV0aG9kQ2FsbDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0UGlwZTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0UHJlZml4Tm90OiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB2aXNpdCh0aGlzLCBhc3QuZXhwcmVzc2lvbik7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdE5vbk51bGxBc3NlcnQ6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5leHByZXNzaW9uKTsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0UHJvcGVydHlSZWFkOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBmYWxzZTsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0UHJvcGVydHlXcml0ZTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdFF1b3RlOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBmYWxzZTsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0U2FmZU1ldGhvZENhbGw6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHRydWU7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdFNhZmVQcm9wZXJ0eVJlYWQ6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLmFsbG9jYXRlVGVtcG9yYXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wTnVtYmVyID0gdGhpcy5fY3VycmVudFRlbXBvcmFyeSsrO1xuICAgICAgICB0aGlzLnRlbXBvcmFyeUNvdW50ID0gTWF0aC5tYXgodGhpcy5fY3VycmVudFRlbXBvcmFyeSwgdGhpcy50ZW1wb3JhcnlDb3VudCk7XG4gICAgICAgIHJldHVybiBuZXcgUmVhZFZhckV4cHIodGVtcG9yYXJ5TmFtZSh0aGlzLmJpbmRpbmdJZCwgdGVtcE51bWJlcikpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZW1wb3JhcnlcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUucmVsZWFzZVRlbXBvcmFyeSA9IGZ1bmN0aW9uICh0ZW1wb3JhcnkpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudFRlbXBvcmFyeS0tO1xuICAgICAgICBpZiAodGVtcG9yYXJ5Lm5hbWUgIT0gdGVtcG9yYXJ5TmFtZSh0aGlzLmJpbmRpbmdJZCwgdGhpcy5fY3VycmVudFRlbXBvcmFyeSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRlbXBvcmFyeSBcIiArIHRlbXBvcmFyeS5uYW1lICsgXCIgcmVsZWFzZWQgb3V0IG9mIG9yZGVyXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gX0FzdFRvSXJWaXNpdG9yO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBhcmdcbiAqIEBwYXJhbSB7P30gb3V0cHV0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBmbGF0dGVuU3RhdGVtZW50cyhhcmcsIG91dHB1dCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgKChhcmcpKS5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gZmxhdHRlblN0YXRlbWVudHMoZW50cnksIG91dHB1dCk7IH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb3V0cHV0LnB1c2goYXJnKTtcbiAgICB9XG59XG52YXIgRGVmYXVsdExvY2FsUmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlZmF1bHRMb2NhbFJlc29sdmVyKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERlZmF1bHRMb2NhbFJlc29sdmVyLnByb3RvdHlwZS5nZXRMb2NhbCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lID09PSBFdmVudEhhbmRsZXJWYXJzLmV2ZW50Lm5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBFdmVudEhhbmRsZXJWYXJzLmV2ZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIERlZmF1bHRMb2NhbFJlc29sdmVyO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBiaW5kaW5nSWRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUN1cnJWYWx1ZUV4cHIoYmluZGluZ0lkKSB7XG4gICAgcmV0dXJuIHZhcmlhYmxlKFwiY3VyclZhbF9cIiArIGJpbmRpbmdJZCk7IC8vIGZpeCBzeW50YXggaGlnaGxpZ2h0aW5nOiBgXG59XG4vKipcbiAqIEBwYXJhbSB7P30gYmluZGluZ0lkXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjcmVhdGVQcmV2ZW50RGVmYXVsdFZhcihiaW5kaW5nSWQpIHtcbiAgICByZXR1cm4gdmFyaWFibGUoXCJwZF9cIiArIGJpbmRpbmdJZCk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gc3RtdFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY29udmVydFN0bXRJbnRvRXhwcmVzc2lvbihzdG10KSB7XG4gICAgaWYgKHN0bXQgaW5zdGFuY2VvZiBFeHByZXNzaW9uU3RhdGVtZW50KSB7XG4gICAgICAgIHJldHVybiBzdG10LmV4cHI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0bXQgaW5zdGFuY2VvZiBSZXR1cm5TdGF0ZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHN0bXQudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxudmFyIEJ1aWx0aW5GdW5jdGlvbkNhbGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEJ1aWx0aW5GdW5jdGlvbkNhbGwsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcGFuXG4gICAgICogQHBhcmFtIHs/fSBhcmdzXG4gICAgICogQHBhcmFtIHs/fSBjb252ZXJ0ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCdWlsdGluRnVuY3Rpb25DYWxsKHNwYW4sIGFyZ3MsIGNvbnZlcnRlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuLCBudWxsLCBhcmdzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgX3RoaXMuY29udmVydGVyID0gY29udmVydGVyO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBCdWlsdGluRnVuY3Rpb25DYWxsO1xufShGdW5jdGlvbkNhbGwpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBDTEFTU19BVFRSJDEgPSAnY2xhc3MnO1xudmFyIFNUWUxFX0FUVFIgPSAnc3R5bGUnO1xudmFyIElNUExJQ0lUX1RFTVBMQVRFX1ZBUiA9ICdcXCRpbXBsaWNpdCc7XG52YXIgVmlld0NvbXBpbGVSZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlld0NsYXNzVmFyXG4gICAgICogQHBhcmFtIHs/fSByZW5kZXJlclR5cGVWYXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBWaWV3Q29tcGlsZVJlc3VsdCh2aWV3Q2xhc3NWYXIsIHJlbmRlcmVyVHlwZVZhcikge1xuICAgICAgICB0aGlzLnZpZXdDbGFzc1ZhciA9IHZpZXdDbGFzc1ZhcjtcbiAgICAgICAgdGhpcy5yZW5kZXJlclR5cGVWYXIgPSByZW5kZXJlclR5cGVWYXI7XG4gICAgfVxuICAgIHJldHVybiBWaWV3Q29tcGlsZVJlc3VsdDtcbn0oKSk7XG52YXIgVmlld0NvbXBpbGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9jb25maWdcbiAgICAgKiBAcGFyYW0gez99IF9yZWZsZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IF9zY2hlbWFSZWdpc3RyeVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFZpZXdDb21waWxlcihfY29uZmlnLCBfcmVmbGVjdG9yLCBfc2NoZW1hUmVnaXN0cnkpIHtcbiAgICAgICAgdGhpcy5fY29uZmlnID0gX2NvbmZpZztcbiAgICAgICAgdGhpcy5fcmVmbGVjdG9yID0gX3JlZmxlY3RvcjtcbiAgICAgICAgdGhpcy5fc2NoZW1hUmVnaXN0cnkgPSBfc2NoZW1hUmVnaXN0cnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gb3V0cHV0Q3R4XG4gICAgICogQHBhcmFtIHs/fSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0gez99IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZXNcbiAgICAgKiBAcGFyYW0gez99IHVzZWRQaXBlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0NvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlQ29tcG9uZW50ID0gZnVuY3Rpb24gKG91dHB1dEN0eCwgY29tcG9uZW50LCB0ZW1wbGF0ZSwgc3R5bGVzLCB1c2VkUGlwZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW1iZWRkZWRWaWV3Q291bnQgPSAwO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGF0aWNRdWVyeUlkcyA9IGZpbmRTdGF0aWNRdWVyeUlkcyh0ZW1wbGF0ZSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlbmRlckNvbXBvbmVudFZhck5hbWUgPSAoKHVuZGVmaW5lZCkpO1xuICAgICAgICBpZiAoIWNvbXBvbmVudC5pc0hvc3QpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlbXBsYXRlXzEgPSAoKGNvbXBvbmVudC50ZW1wbGF0ZSkpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3VzdG9tUmVuZGVyRGF0YSA9IFtdO1xuICAgICAgICAgICAgaWYgKHRlbXBsYXRlXzEuYW5pbWF0aW9ucyAmJiB0ZW1wbGF0ZV8xLmFuaW1hdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tUmVuZGVyRGF0YS5wdXNoKG5ldyBMaXRlcmFsTWFwRW50cnkoJ2FuaW1hdGlvbicsIGNvbnZlcnRWYWx1ZVRvT3V0cHV0QXN0KG91dHB1dEN0eCwgdGVtcGxhdGVfMS5hbmltYXRpb25zKSwgdHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVuZGVyQ29tcG9uZW50VmFyID0gdmFyaWFibGUocmVuZGVyZXJUeXBlTmFtZShjb21wb25lbnQudHlwZS5yZWZlcmVuY2UpKTtcbiAgICAgICAgICAgIHJlbmRlckNvbXBvbmVudFZhck5hbWUgPSAoKHJlbmRlckNvbXBvbmVudFZhci5uYW1lKSk7XG4gICAgICAgICAgICBvdXRwdXRDdHguc3RhdGVtZW50cy5wdXNoKHJlbmRlckNvbXBvbmVudFZhclxuICAgICAgICAgICAgICAgIC5zZXQoaW1wb3J0RXhwcihJZGVudGlmaWVycy5jcmVhdGVSZW5kZXJlclR5cGUyKS5jYWxsRm4oW25ldyBMaXRlcmFsTWFwRXhwcihbXG4gICAgICAgICAgICAgICAgICAgIG5ldyBMaXRlcmFsTWFwRW50cnkoJ2VuY2Fwc3VsYXRpb24nLCBsaXRlcmFsKHRlbXBsYXRlXzEuZW5jYXBzdWxhdGlvbiksIGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IExpdGVyYWxNYXBFbnRyeSgnc3R5bGVzJywgc3R5bGVzLCBmYWxzZSksXG4gICAgICAgICAgICAgICAgICAgIG5ldyBMaXRlcmFsTWFwRW50cnkoJ2RhdGEnLCBuZXcgTGl0ZXJhbE1hcEV4cHIoY3VzdG9tUmVuZGVyRGF0YSksIGZhbHNlKVxuICAgICAgICAgICAgICAgIF0pXSkpXG4gICAgICAgICAgICAgICAgLnRvRGVjbFN0bXQoaW1wb3J0VHlwZShJZGVudGlmaWVycy5SZW5kZXJlclR5cGUyKSwgW1N0bXRNb2RpZmllci5GaW5hbCwgU3RtdE1vZGlmaWVyLkV4cG9ydGVkXSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpZXdCdWlsZGVyRmFjdG9yeSA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVtYmVkZGVkVmlld0luZGV4ID0gZW1iZWRkZWRWaWV3Q291bnQrKztcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmlld0J1aWxkZXIoX3RoaXMuX3JlZmxlY3Rvciwgb3V0cHV0Q3R4LCBwYXJlbnQsIGNvbXBvbmVudCwgZW1iZWRkZWRWaWV3SW5kZXgsIHVzZWRQaXBlcywgc3RhdGljUXVlcnlJZHMsIHZpZXdCdWlsZGVyRmFjdG9yeSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0b3IgPSB2aWV3QnVpbGRlckZhY3RvcnkobnVsbCk7XG4gICAgICAgIHZpc2l0b3IudmlzaXRBbGwoW10sIHRlbXBsYXRlKTtcbiAgICAgICAgKF9hID0gb3V0cHV0Q3R4LnN0YXRlbWVudHMpLnB1c2guYXBwbHkoX2EsIHZpc2l0b3IuYnVpbGQoKSk7XG4gICAgICAgIHJldHVybiBuZXcgVmlld0NvbXBpbGVSZXN1bHQodmlzaXRvci52aWV3TmFtZSwgcmVuZGVyQ29tcG9uZW50VmFyTmFtZSk7XG4gICAgICAgIHZhciBfYTtcbiAgICB9O1xuICAgIHJldHVybiBWaWV3Q29tcGlsZXI7XG59KCkpO1xuVmlld0NvbXBpbGVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21waWxlckluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cblZpZXdDb21waWxlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IENvbXBpbGVyQ29uZmlnLCB9LFxuICAgIHsgdHlwZTogQ29tcGlsZVJlZmxlY3RvciwgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRTY2hlbWFSZWdpc3RyeSwgfSxcbl07IH07XG52YXIgTE9HX1ZBUiQxID0gdmFyaWFibGUoJ19sJyk7XG52YXIgVklFV19WQVIgPSB2YXJpYWJsZSgnX3YnKTtcbnZhciBDSEVDS19WQVIgPSB2YXJpYWJsZSgnX2NrJyk7XG52YXIgQ09NUF9WQVIgPSB2YXJpYWJsZSgnX2NvJyk7XG52YXIgRVZFTlRfTkFNRV9WQVIgPSB2YXJpYWJsZSgnZW4nKTtcbnZhciBBTExPV19ERUZBVUxUX1ZBUiA9IHZhcmlhYmxlKFwiYWRcIik7XG52YXIgVmlld0J1aWxkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVmbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBvdXRwdXRDdHhcbiAgICAgKiBAcGFyYW0gez99IHBhcmVudFxuICAgICAqIEBwYXJhbSB7P30gY29tcG9uZW50XG4gICAgICogQHBhcmFtIHs/fSBlbWJlZGRlZFZpZXdJbmRleFxuICAgICAqIEBwYXJhbSB7P30gdXNlZFBpcGVzXG4gICAgICogQHBhcmFtIHs/fSBzdGF0aWNRdWVyeUlkc1xuICAgICAqIEBwYXJhbSB7P30gdmlld0J1aWxkZXJGYWN0b3J5XG4gICAgICovXG4gICAgZnVuY3Rpb24gVmlld0J1aWxkZXIocmVmbGVjdG9yLCBvdXRwdXRDdHgsIHBhcmVudCwgY29tcG9uZW50LCBlbWJlZGRlZFZpZXdJbmRleCwgdXNlZFBpcGVzLCBzdGF0aWNRdWVyeUlkcywgdmlld0J1aWxkZXJGYWN0b3J5KSB7XG4gICAgICAgIHRoaXMucmVmbGVjdG9yID0gcmVmbGVjdG9yO1xuICAgICAgICB0aGlzLm91dHB1dEN0eCA9IG91dHB1dEN0eDtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICB0aGlzLmVtYmVkZGVkVmlld0luZGV4ID0gZW1iZWRkZWRWaWV3SW5kZXg7XG4gICAgICAgIHRoaXMudXNlZFBpcGVzID0gdXNlZFBpcGVzO1xuICAgICAgICB0aGlzLnN0YXRpY1F1ZXJ5SWRzID0gc3RhdGljUXVlcnlJZHM7XG4gICAgICAgIHRoaXMudmlld0J1aWxkZXJGYWN0b3J5ID0gdmlld0J1aWxkZXJGYWN0b3J5O1xuICAgICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgICAgIHRoaXMucHVyZVBpcGVOb2RlSW5kaWNlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMucmVmTm9kZUluZGljZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLnZhcmlhYmxlcyA9IFtdO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAgIC8vIFRPRE8odGJvc2NoKTogVGhlIG9sZCB2aWV3IGNvbXBpbGVyIHVzZWQgdG8gdXNlIGFuIGBhbnlgIHR5cGVcbiAgICAgICAgLy8gZm9yIHRoZSBjb250ZXh0IGluIGFueSBlbWJlZGRlZCB2aWV3LiBXZSBrZWVwIHRoaXMgYmVoYWl2b3IgZm9yIG5vd1xuICAgICAgICAvLyB0byBiZSBhYmxlIHRvIGludHJvZHVjZSB0aGUgbmV3IHZpZXcgY29tcGlsZXIgd2l0aG91dCB0b28gbWFueSBlcnJvcnMuXG4gICAgICAgIHRoaXMuY29tcFR5cGUgPSB0aGlzLmVtYmVkZGVkVmlld0luZGV4ID4gMCA/XG4gICAgICAgICAgICBEWU5BTUlDX1RZUEUgOlxuICAgICAgICAgICAgZXhwcmVzc2lvblR5cGUob3V0cHV0Q3R4LmltcG9ydEV4cHIodGhpcy5jb21wb25lbnQudHlwZS5yZWZlcmVuY2UpKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdCdWlsZGVyLnByb3RvdHlwZSwgXCJ2aWV3TmFtZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlld0NsYXNzTmFtZSh0aGlzLmNvbXBvbmVudC50eXBlLnJlZmVyZW5jZSwgdGhpcy5lbWJlZGRlZFZpZXdJbmRleCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFyaWFibGVzXG4gICAgICogQHBhcmFtIHs/fSBhc3ROb2Rlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0QWxsID0gZnVuY3Rpb24gKHZhcmlhYmxlcywgYXN0Tm9kZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy52YXJpYWJsZXMgPSB2YXJpYWJsZXM7XG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgcGlwZXMgZm9yIHRoZSBwdXJlIHBpcGVzIGltbWVkaWF0ZWx5LCBzbyB0aGF0IHdlIGtub3cgdGhlaXIgaW5kaWNlcy5cbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy51c2VkUGlwZXMuZm9yRWFjaChmdW5jdGlvbiAocGlwZSkge1xuICAgICAgICAgICAgICAgIGlmIChwaXBlLnB1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucHVyZVBpcGVOb2RlSW5kaWNlc1twaXBlLm5hbWVdID0gX3RoaXMuX2NyZWF0ZVBpcGUobnVsbCwgcGlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVlcnlJZHNfMSA9IHN0YXRpY1ZpZXdRdWVyeUlkcyh0aGlzLnN0YXRpY1F1ZXJ5SWRzKTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LnZpZXdRdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5LCBxdWVyeUluZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gTm90ZTogcXVlcmllcyBzdGFydCB3aXRoIGlkIDEgc28gd2UgY2FuIHVzZSB0aGUgbnVtYmVyIGluIGEgQmxvb20gZmlsdGVyIVxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1ZXJ5SWQgPSBxdWVyeUluZGV4ICsgMTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiaW5kaW5nVHlwZSA9IHF1ZXJ5LmZpcnN0ID8gMCAvKiBGaXJzdCAqLyA6IDE7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmxhZ3MgPSAxMzQyMTc3MjggLyogVHlwZVZpZXdRdWVyeSAqLyB8IGNhbGNTdGF0aWNEeW5hbWljUXVlcnlGbGFncyhxdWVyeUlkc18xLCBxdWVyeUlkLCBxdWVyeS5maXJzdCk7XG4gICAgICAgICAgICAgICAgX3RoaXMubm9kZXMucHVzaChmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2VTcGFuOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBub2RlRmxhZ3M6IGZsYWdzLFxuICAgICAgICAgICAgICAgICAgICBub2RlRGVmOiBpbXBvcnRFeHByKElkZW50aWZpZXJzLnF1ZXJ5RGVmKS5jYWxsRm4oW1xuICAgICAgICAgICAgICAgICAgICAgICAgbGl0ZXJhbChmbGFncyksIGxpdGVyYWwocXVlcnlJZCksXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgTGl0ZXJhbE1hcEV4cHIoW25ldyBMaXRlcmFsTWFwRW50cnkocXVlcnkucHJvcGVydHlOYW1lLCBsaXRlcmFsKGJpbmRpbmdUeXBlKSwgZmFsc2UpXSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICB9KTsgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0ZW1wbGF0ZVZpc2l0QWxsKHRoaXMsIGFzdE5vZGVzKTtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50ICYmIChhc3ROb2Rlcy5sZW5ndGggPT09IDAgfHwgbmVlZHNBZGRpdGlvbmFsUm9vdE5vZGUoYXN0Tm9kZXMpKSkge1xuICAgICAgICAgICAgLy8gaWYgdGhlIHZpZXcgaXMgYW4gZW1iZWRkZWQgdmlldywgdGhlbiB3ZSBuZWVkIHRvIGFkZCBhbiBhZGRpdGlvbmFsIHJvb3Qgbm9kZSBpbiBzb21lIGNhc2VzXG4gICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2goZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICBzb3VyY2VTcGFuOiBudWxsLFxuICAgICAgICAgICAgICAgIG5vZGVGbGFnczogMSAvKiBUeXBlRWxlbWVudCAqLyxcbiAgICAgICAgICAgICAgICBub2RlRGVmOiBpbXBvcnRFeHByKElkZW50aWZpZXJzLmFuY2hvckRlZikuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICAgICAgbGl0ZXJhbCgwIC8qIE5vbmUgKi8pLCBOVUxMX0VYUFIsIE5VTExfRVhQUiwgbGl0ZXJhbCgwKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICB9KTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IHRhcmdldFN0YXRlbWVudHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uICh0YXJnZXRTdGF0ZW1lbnRzKSB7XG4gICAgICAgIGlmICh0YXJnZXRTdGF0ZW1lbnRzID09PSB2b2lkIDApIHsgdGFyZ2V0U3RhdGVtZW50cyA9IFtdOyB9XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkLmJ1aWxkKHRhcmdldFN0YXRlbWVudHMpOyB9KTtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5fY3JlYXRlTm9kZUV4cHJlc3Npb25zKCksIHVwZGF0ZVJlbmRlcmVyU3RtdHMgPSBfYS51cGRhdGVSZW5kZXJlclN0bXRzLCB1cGRhdGVEaXJlY3RpdmVzU3RtdHMgPSBfYS51cGRhdGVEaXJlY3RpdmVzU3RtdHMsIG5vZGVEZWZFeHBycyA9IF9hLm5vZGVEZWZFeHBycztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXBkYXRlUmVuZGVyZXJGbiA9IHRoaXMuX2NyZWF0ZVVwZGF0ZUZuKHVwZGF0ZVJlbmRlcmVyU3RtdHMpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1cGRhdGVEaXJlY3RpdmVzRm4gPSB0aGlzLl9jcmVhdGVVcGRhdGVGbih1cGRhdGVEaXJlY3RpdmVzU3RtdHMpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aWV3RmxhZ3MgPSAwO1xuICAgICAgICBpZiAoIXRoaXMucGFyZW50ICYmIHRoaXMuY29tcG9uZW50LmNoYW5nZURldGVjdGlvbiA9PT0gQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoKSB7XG4gICAgICAgICAgICB2aWV3RmxhZ3MgfD0gMiAvKiBPblB1c2ggKi87XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlld0ZhY3RvcnkgPSBuZXcgRGVjbGFyZUZ1bmN0aW9uU3RtdCh0aGlzLnZpZXdOYW1lLCBbbmV3IEZuUGFyYW0oLyoqIEB0eXBlIHs/fSAqLyAoKExPR19WQVIkMS5uYW1lKSkpXSwgW25ldyBSZXR1cm5TdGF0ZW1lbnQoaW1wb3J0RXhwcihJZGVudGlmaWVycy52aWV3RGVmKS5jYWxsRm4oW1xuICAgICAgICAgICAgICAgIGxpdGVyYWwodmlld0ZsYWdzKSxcbiAgICAgICAgICAgICAgICBsaXRlcmFsQXJyKG5vZGVEZWZFeHBycyksXG4gICAgICAgICAgICAgICAgdXBkYXRlRGlyZWN0aXZlc0ZuLFxuICAgICAgICAgICAgICAgIHVwZGF0ZVJlbmRlcmVyRm4sXG4gICAgICAgICAgICBdKSldLCBpbXBvcnRUeXBlKElkZW50aWZpZXJzLlZpZXdEZWZpbml0aW9uKSwgdGhpcy5lbWJlZGRlZFZpZXdJbmRleCA9PT0gMCA/IFtTdG10TW9kaWZpZXIuRXhwb3J0ZWRdIDogW10pO1xuICAgICAgICB0YXJnZXRTdGF0ZW1lbnRzLnB1c2godmlld0ZhY3RvcnkpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0U3RhdGVtZW50cztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdXBkYXRlU3RtdHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS5fY3JlYXRlVXBkYXRlRm4gPSBmdW5jdGlvbiAodXBkYXRlU3RtdHMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXBkYXRlRm47XG4gICAgICAgIGlmICh1cGRhdGVTdG10cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmVTdG10cyA9IFtdO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbXBvbmVudC5pc0hvc3QgJiYgZmluZFJlYWRWYXJOYW1lcyh1cGRhdGVTdG10cykuaGFzKC8qKiBAdHlwZSB7P30gKi8gKChDT01QX1ZBUi5uYW1lKSkpKSB7XG4gICAgICAgICAgICAgICAgcHJlU3RtdHMucHVzaChDT01QX1ZBUi5zZXQoVklFV19WQVIucHJvcCgnY29tcG9uZW50JykpLnRvRGVjbFN0bXQodGhpcy5jb21wVHlwZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlRm4gPSBmbihbXG4gICAgICAgICAgICAgICAgbmV3IEZuUGFyYW0oLyoqIEB0eXBlIHs/fSAqLyAoKENIRUNLX1ZBUi5uYW1lKSksIElORkVSUkVEX1RZUEUpLFxuICAgICAgICAgICAgICAgIG5ldyBGblBhcmFtKC8qKiBAdHlwZSB7P30gKi8gKChWSUVXX1ZBUi5uYW1lKSksIElORkVSUkVEX1RZUEUpXG4gICAgICAgICAgICBdLCBwcmVTdG10cy5jb25jYXQodXBkYXRlU3RtdHMpLCBJTkZFUlJFRF9UWVBFKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVwZGF0ZUZuID0gTlVMTF9FWFBSO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cGRhdGVGbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUudmlzaXROZ0NvbnRlbnQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIC8vIG5nQ29udGVudERlZihuZ0NvbnRlbnRJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyKTogTm9kZURlZjtcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICBzb3VyY2VTcGFuOiBhc3Quc291cmNlU3BhbixcbiAgICAgICAgICAgIG5vZGVGbGFnczogOCAvKiBUeXBlTmdDb250ZW50ICovLFxuICAgICAgICAgICAgbm9kZURlZjogaW1wb3J0RXhwcihJZGVudGlmaWVycy5uZ0NvbnRlbnREZWYpLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgbGl0ZXJhbChhc3QubmdDb250ZW50SW5kZXgpLCBsaXRlcmFsKGFzdC5pbmRleClcbiAgICAgICAgICAgIF0pXG4gICAgICAgIH0pOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAvLyB0ZXh0RGVmKG5nQ29udGVudEluZGV4OiBudW1iZXIsIGNvbnN0YW50czogc3RyaW5nW10pOiBOb2RlRGVmO1xuICAgICAgICB0aGlzLm5vZGVzLnB1c2goZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIHNvdXJjZVNwYW46IGFzdC5zb3VyY2VTcGFuLFxuICAgICAgICAgICAgbm9kZUZsYWdzOiAyIC8qIFR5cGVUZXh0ICovLFxuICAgICAgICAgICAgbm9kZURlZjogaW1wb3J0RXhwcihJZGVudGlmaWVycy50ZXh0RGVmKS5jYWxsRm4oW1xuICAgICAgICAgICAgICAgIGxpdGVyYWwoYXN0Lm5nQ29udGVudEluZGV4KSwgbGl0ZXJhbEFycihbbGl0ZXJhbChhc3QudmFsdWUpXSlcbiAgICAgICAgICAgIF0pXG4gICAgICAgIH0pOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUudmlzaXRCb3VuZFRleHQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVJbmRleCA9IHRoaXMubm9kZXMubGVuZ3RoO1xuICAgICAgICAvLyByZXNlcnZlIHRoZSBzcGFjZSBpbiB0aGUgbm9kZURlZnMgYXJyYXlcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKC8qKiBAdHlwZSB7P30gKi8gKChudWxsKSkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3RXaXRoU291cmNlID0gKGFzdC52YWx1ZSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGludGVyID0gKGFzdFdpdGhTb3VyY2UuYXN0KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXBkYXRlUmVuZGVyZXJFeHByZXNzaW9ucyA9IGludGVyLmV4cHJlc3Npb25zLm1hcChmdW5jdGlvbiAoZXhwciwgYmluZGluZ0luZGV4KSB7IHJldHVybiBfdGhpcy5fcHJlcHJvY2Vzc1VwZGF0ZUV4cHJlc3Npb24oeyBub2RlSW5kZXg6IG5vZGVJbmRleCwgYmluZGluZ0luZGV4OiBiaW5kaW5nSW5kZXgsIHNvdXJjZVNwYW46IGFzdC5zb3VyY2VTcGFuLCBjb250ZXh0OiBDT01QX1ZBUiwgdmFsdWU6IGV4cHIgfSk7IH0pO1xuICAgICAgICAvLyB0ZXh0RGVmKG5nQ29udGVudEluZGV4OiBudW1iZXIsIGNvbnN0YW50czogc3RyaW5nW10pOiBOb2RlRGVmO1xuICAgICAgICB0aGlzLm5vZGVzW25vZGVJbmRleF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgc291cmNlU3BhbjogYXN0LnNvdXJjZVNwYW4sXG4gICAgICAgICAgICBub2RlRmxhZ3M6IDIgLyogVHlwZVRleHQgKi8sXG4gICAgICAgICAgICBub2RlRGVmOiBpbXBvcnRFeHByKElkZW50aWZpZXJzLnRleHREZWYpLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgbGl0ZXJhbChhc3QubmdDb250ZW50SW5kZXgpLCBsaXRlcmFsQXJyKGludGVyLnN0cmluZ3MubWFwKGZ1bmN0aW9uIChzKSB7IHJldHVybiBsaXRlcmFsKHMpOyB9KSlcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgdXBkYXRlUmVuZGVyZXI6IHVwZGF0ZVJlbmRlcmVyRXhwcmVzc2lvbnNcbiAgICAgICAgfSk7IH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0RW1iZWRkZWRUZW1wbGF0ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZUluZGV4ID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gICAgICAgIC8vIHJlc2VydmUgdGhlIHNwYWNlIGluIHRoZSBub2RlRGVmcyBhcnJheVxuICAgICAgICB0aGlzLm5vZGVzLnB1c2goLyoqIEB0eXBlIHs/fSAqLyAoKG51bGwpKSk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuX3Zpc2l0RWxlbWVudE9yVGVtcGxhdGUobm9kZUluZGV4LCBhc3QpLCBmbGFncyA9IF9hLmZsYWdzLCBxdWVyeU1hdGNoZXNFeHByID0gX2EucXVlcnlNYXRjaGVzRXhwciwgaG9zdEV2ZW50cyA9IF9hLmhvc3RFdmVudHM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNoaWxkVmlzaXRvciA9IHRoaXMudmlld0J1aWxkZXJGYWN0b3J5KHRoaXMpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGRWaXNpdG9yKTtcbiAgICAgICAgY2hpbGRWaXNpdG9yLnZpc2l0QWxsKGFzdC52YXJpYWJsZXMsIGFzdC5jaGlsZHJlbik7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNoaWxkQ291bnQgPSB0aGlzLm5vZGVzLmxlbmd0aCAtIG5vZGVJbmRleCAtIDE7XG4gICAgICAgIC8vIGFuY2hvckRlZihcbiAgICAgICAgLy8gICBmbGFnczogTm9kZUZsYWdzLCBtYXRjaGVkUXVlcmllczogW3N0cmluZywgUXVlcnlWYWx1ZVR5cGVdW10sIG5nQ29udGVudEluZGV4OiBudW1iZXIsXG4gICAgICAgIC8vICAgY2hpbGRDb3VudDogbnVtYmVyLCBoYW5kbGVFdmVudEZuPzogRWxlbWVudEhhbmRsZUV2ZW50Rm4sIHRlbXBsYXRlRmFjdG9yeT86XG4gICAgICAgIC8vICAgVmlld0RlZmluaXRpb25GYWN0b3J5KTogTm9kZURlZjtcbiAgICAgICAgdGhpcy5ub2Rlc1tub2RlSW5kZXhdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIHNvdXJjZVNwYW46IGFzdC5zb3VyY2VTcGFuLFxuICAgICAgICAgICAgbm9kZUZsYWdzOiAxIC8qIFR5cGVFbGVtZW50ICovIHwgZmxhZ3MsXG4gICAgICAgICAgICBub2RlRGVmOiBpbXBvcnRFeHByKElkZW50aWZpZXJzLmFuY2hvckRlZikuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICBsaXRlcmFsKGZsYWdzKSxcbiAgICAgICAgICAgICAgICBxdWVyeU1hdGNoZXNFeHByLFxuICAgICAgICAgICAgICAgIGxpdGVyYWwoYXN0Lm5nQ29udGVudEluZGV4KSxcbiAgICAgICAgICAgICAgICBsaXRlcmFsKGNoaWxkQ291bnQpLFxuICAgICAgICAgICAgICAgIF90aGlzLl9jcmVhdGVFbGVtZW50SGFuZGxlRXZlbnRGbihub2RlSW5kZXgsIGhvc3RFdmVudHMpLFxuICAgICAgICAgICAgICAgIHZhcmlhYmxlKGNoaWxkVmlzaXRvci52aWV3TmFtZSksXG4gICAgICAgICAgICBdKVxuICAgICAgICB9KTsgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlSW5kZXggPSB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgICAgICAgLy8gcmVzZXJ2ZSB0aGUgc3BhY2UgaW4gdGhlIG5vZGVEZWZzIGFycmF5IHNvIHdlIGNhbiBhZGQgY2hpbGRyZW5cbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKC8qKiBAdHlwZSB7P30gKi8gKChudWxsKSkpO1xuICAgICAgICAvLyBVc2luZyBhIG51bGwgZWxlbWVudCBuYW1lIGNyZWF0ZXMgYW4gYW5jaG9yLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbE5hbWUgPSBpc05nQ29udGFpbmVyKGFzdC5uYW1lKSA/IG51bGwgOiBhc3QubmFtZTtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5fdmlzaXRFbGVtZW50T3JUZW1wbGF0ZShub2RlSW5kZXgsIGFzdCksIGZsYWdzID0gX2EuZmxhZ3MsIHVzZWRFdmVudHMgPSBfYS51c2VkRXZlbnRzLCBxdWVyeU1hdGNoZXNFeHByID0gX2EucXVlcnlNYXRjaGVzRXhwciwgZGlySG9zdEJpbmRpbmdzID0gX2EuaG9zdEJpbmRpbmdzLCBob3N0RXZlbnRzID0gX2EuaG9zdEV2ZW50cztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5wdXREZWZzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVwZGF0ZVJlbmRlcmVyRXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3V0cHV0RGVmcyA9IFtdO1xuICAgICAgICBpZiAoZWxOYW1lKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBob3N0QmluZGluZ3MgPSBhc3QuaW5wdXRzXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaW5wdXRBc3QpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgY29udGV4dDogLyoqIEB0eXBlIHs/fSAqLyAoQ09NUF9WQVIpLFxuICAgICAgICAgICAgICAgIGlucHV0QXN0OiBpbnB1dEFzdCxcbiAgICAgICAgICAgICAgICBkaXJBc3Q6IC8qKiBAdHlwZSB7P30gKi8gKG51bGwpLFxuICAgICAgICAgICAgfSk7IH0pXG4gICAgICAgICAgICAgICAgLmNvbmNhdChkaXJIb3N0QmluZGluZ3MpO1xuICAgICAgICAgICAgaWYgKGhvc3RCaW5kaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVSZW5kZXJlckV4cHJlc3Npb25zID1cbiAgICAgICAgICAgICAgICAgICAgaG9zdEJpbmRpbmdzLm1hcChmdW5jdGlvbiAoaG9zdEJpbmRpbmcsIGJpbmRpbmdJbmRleCkgeyByZXR1cm4gX3RoaXMuX3ByZXByb2Nlc3NVcGRhdGVFeHByZXNzaW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGhvc3RCaW5kaW5nLmNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlSW5kZXg6IG5vZGVJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpbmRpbmdJbmRleDogYmluZGluZ0luZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlU3BhbjogaG9zdEJpbmRpbmcuaW5wdXRBc3Quc291cmNlU3BhbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBob3N0QmluZGluZy5pbnB1dEFzdC52YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9KTsgfSk7XG4gICAgICAgICAgICAgICAgaW5wdXREZWZzID0gaG9zdEJpbmRpbmdzLm1hcChmdW5jdGlvbiAoaG9zdEJpbmRpbmcpIHsgcmV0dXJuIGVsZW1lbnRCaW5kaW5nRGVmKGhvc3RCaW5kaW5nLmlucHV0QXN0LCBob3N0QmluZGluZy5kaXJBc3QpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dERlZnMgPSB1c2VkRXZlbnRzLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gX2FbMF0sIGV2ZW50TmFtZSA9IF9hWzFdO1xuICAgICAgICAgICAgICAgIHJldHVybiBsaXRlcmFsQXJyKFtsaXRlcmFsKHRhcmdldCksIGxpdGVyYWwoZXZlbnROYW1lKV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcGxhdGVWaXNpdEFsbCh0aGlzLCBhc3QuY2hpbGRyZW4pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlsZENvdW50ID0gdGhpcy5ub2Rlcy5sZW5ndGggLSBub2RlSW5kZXggLSAxO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wQXN0ID0gYXN0LmRpcmVjdGl2ZXMuZmluZChmdW5jdGlvbiAoZGlyQXN0KSB7IHJldHVybiBkaXJBc3QuZGlyZWN0aXZlLmlzQ29tcG9uZW50OyB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcFJlbmRlcmVyVHlwZSA9IChOVUxMX0VYUFIpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wVmlldyA9IChOVUxMX0VYUFIpO1xuICAgICAgICBpZiAoY29tcEFzdCkge1xuICAgICAgICAgICAgY29tcFZpZXcgPSB0aGlzLm91dHB1dEN0eC5pbXBvcnRFeHByKGNvbXBBc3QuZGlyZWN0aXZlLmNvbXBvbmVudFZpZXdUeXBlKTtcbiAgICAgICAgICAgIGNvbXBSZW5kZXJlclR5cGUgPSB0aGlzLm91dHB1dEN0eC5pbXBvcnRFeHByKGNvbXBBc3QuZGlyZWN0aXZlLnJlbmRlcmVyVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZWxlbWVudERlZihcbiAgICAgICAgLy8gICBmbGFnczogTm9kZUZsYWdzLCBtYXRjaGVkUXVlcmllc0RzbDogW3N0cmluZyB8IG51bWJlciwgUXVlcnlWYWx1ZVR5cGVdW10sXG4gICAgICAgIC8vICAgbmdDb250ZW50SW5kZXg6IG51bWJlciwgY2hpbGRDb3VudDogbnVtYmVyLCBuYW1lc3BhY2VBbmROYW1lOiBzdHJpbmcsXG4gICAgICAgIC8vICAgZml4ZWRBdHRyczogW3N0cmluZywgc3RyaW5nXVtdID0gW10sXG4gICAgICAgIC8vICAgYmluZGluZ3M/OiBbQmluZGluZ0ZsYWdzLCBzdHJpbmcsIHN0cmluZyB8IFNlY3VyaXR5Q29udGV4dF1bXSxcbiAgICAgICAgLy8gICBvdXRwdXRzPzogKFtPdXRwdXRUeXBlLkVsZW1lbnRPdXRwdXQgfCBPdXRwdXRUeXBlLkRpcmVjdGl2ZUhvc3RPdXRwdXQsIHN0cmluZywgc3RyaW5nXSlbXSxcbiAgICAgICAgLy8gICBoYW5kbGVFdmVudD86IEVsZW1lbnRIYW5kbGVFdmVudEZuLFxuICAgICAgICAvLyAgIGNvbXBvbmVudFZpZXc/OiAoKSA9PiBWaWV3RGVmaW5pdGlvbiwgY29tcG9uZW50UmVuZGVyZXJUeXBlPzogUmVuZGVyZXJUeXBlMik6IE5vZGVEZWY7XG4gICAgICAgIHRoaXMubm9kZXNbbm9kZUluZGV4XSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICBzb3VyY2VTcGFuOiBhc3Quc291cmNlU3BhbixcbiAgICAgICAgICAgIG5vZGVGbGFnczogMSAvKiBUeXBlRWxlbWVudCAqLyB8IGZsYWdzLFxuICAgICAgICAgICAgbm9kZURlZjogaW1wb3J0RXhwcihJZGVudGlmaWVycy5lbGVtZW50RGVmKS5jYWxsRm4oW1xuICAgICAgICAgICAgICAgIGxpdGVyYWwoZmxhZ3MpLFxuICAgICAgICAgICAgICAgIHF1ZXJ5TWF0Y2hlc0V4cHIsXG4gICAgICAgICAgICAgICAgbGl0ZXJhbChhc3QubmdDb250ZW50SW5kZXgpLFxuICAgICAgICAgICAgICAgIGxpdGVyYWwoY2hpbGRDb3VudCksXG4gICAgICAgICAgICAgICAgbGl0ZXJhbChlbE5hbWUpLFxuICAgICAgICAgICAgICAgIGVsTmFtZSA/IGZpeGVkQXR0cnNEZWYoYXN0KSA6IE5VTExfRVhQUixcbiAgICAgICAgICAgICAgICBpbnB1dERlZnMubGVuZ3RoID8gbGl0ZXJhbEFycihpbnB1dERlZnMpIDogTlVMTF9FWFBSLFxuICAgICAgICAgICAgICAgIG91dHB1dERlZnMubGVuZ3RoID8gbGl0ZXJhbEFycihvdXRwdXREZWZzKSA6IE5VTExfRVhQUixcbiAgICAgICAgICAgICAgICBfdGhpcy5fY3JlYXRlRWxlbWVudEhhbmRsZUV2ZW50Rm4obm9kZUluZGV4LCBob3N0RXZlbnRzKSxcbiAgICAgICAgICAgICAgICBjb21wVmlldyxcbiAgICAgICAgICAgICAgICBjb21wUmVuZGVyZXJUeXBlLFxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICB1cGRhdGVSZW5kZXJlcjogdXBkYXRlUmVuZGVyZXJFeHByZXNzaW9uc1xuICAgICAgICB9KTsgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZUluZGV4XG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS5fdmlzaXRFbGVtZW50T3JUZW1wbGF0ZSA9IGZ1bmN0aW9uIChub2RlSW5kZXgsIGFzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmbGFncyA9IDA7XG4gICAgICAgIGlmIChhc3QuaGFzVmlld0NvbnRhaW5lcikge1xuICAgICAgICAgICAgZmxhZ3MgfD0gMTY3NzcyMTYgLyogRW1iZWRkZWRWaWV3cyAqLztcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1c2VkRXZlbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICBhc3Qub3V0cHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIF9hID0gZWxlbWVudEV2ZW50TmFtZUFuZFRhcmdldChldmVudCwgbnVsbCksIG5hbWUgPSBfYS5uYW1lLCB0YXJnZXQgPSBfYS50YXJnZXQ7XG4gICAgICAgICAgICB1c2VkRXZlbnRzLnNldCjJtWVsZW1lbnRFdmVudEZ1bGxOYW1lKHRhcmdldCwgbmFtZSksIFt0YXJnZXQsIG5hbWVdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFzdC5kaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpckFzdCkge1xuICAgICAgICAgICAgZGlyQXN0Lmhvc3RFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBlbGVtZW50RXZlbnROYW1lQW5kVGFyZ2V0KGV2ZW50LCBkaXJBc3QpLCBuYW1lID0gX2EubmFtZSwgdGFyZ2V0ID0gX2EudGFyZ2V0O1xuICAgICAgICAgICAgICAgIHVzZWRFdmVudHMuc2V0KMm1ZWxlbWVudEV2ZW50RnVsbE5hbWUodGFyZ2V0LCBuYW1lKSwgW3RhcmdldCwgbmFtZV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBob3N0QmluZGluZ3MgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaG9zdEV2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLl92aXNpdENvbXBvbmVudEZhY3RvcnlSZXNvbHZlclByb3ZpZGVyKGFzdC5kaXJlY3RpdmVzKTtcbiAgICAgICAgYXN0LnByb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlckFzdCwgcHJvdmlkZXJJbmRleCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlyQXN0ID0gKCh1bmRlZmluZWQpKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpckluZGV4ID0gKCh1bmRlZmluZWQpKTtcbiAgICAgICAgICAgIGFzdC5kaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGxvY2FsRGlyQXN0LCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsRGlyQXN0LmRpcmVjdGl2ZS50eXBlLnJlZmVyZW5jZSA9PT0gdG9rZW5SZWZlcmVuY2UocHJvdmlkZXJBc3QudG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpckFzdCA9IGxvY2FsRGlyQXN0O1xuICAgICAgICAgICAgICAgICAgICBkaXJJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZGlyQXN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMuX3Zpc2l0RGlyZWN0aXZlKHByb3ZpZGVyQXN0LCBkaXJBc3QsIGRpckluZGV4LCBub2RlSW5kZXgsIGFzdC5yZWZlcmVuY2VzLCBhc3QucXVlcnlNYXRjaGVzLCB1c2VkRXZlbnRzLCAvKiogQHR5cGUgez99ICovICgoX3RoaXMuc3RhdGljUXVlcnlJZHMuZ2V0KC8qKiBAdHlwZSB7P30gKi8gKGFzdCkpKSkpLCBkaXJIb3N0QmluZGluZ3MgPSBfYS5ob3N0QmluZGluZ3MsIGRpckhvc3RFdmVudHMgPSBfYS5ob3N0RXZlbnRzO1xuICAgICAgICAgICAgICAgIGhvc3RCaW5kaW5ncy5wdXNoLmFwcGx5KGhvc3RCaW5kaW5ncywgZGlySG9zdEJpbmRpbmdzKTtcbiAgICAgICAgICAgICAgICBob3N0RXZlbnRzLnB1c2guYXBwbHkoaG9zdEV2ZW50cywgZGlySG9zdEV2ZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdmlzaXRQcm92aWRlcihwcm92aWRlckFzdCwgYXN0LnF1ZXJ5TWF0Y2hlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdWVyeU1hdGNoRXhwcnMgPSBbXTtcbiAgICAgICAgYXN0LnF1ZXJ5TWF0Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWVUeXBlID0gKCh1bmRlZmluZWQpKTtcbiAgICAgICAgICAgIGlmICh0b2tlblJlZmVyZW5jZShtYXRjaC52YWx1ZSkgPT09XG4gICAgICAgICAgICAgICAgX3RoaXMucmVmbGVjdG9yLnJlc29sdmVFeHRlcm5hbFJlZmVyZW5jZShJZGVudGlmaWVycy5FbGVtZW50UmVmKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlVHlwZSA9IDAgLyogRWxlbWVudFJlZiAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuUmVmZXJlbmNlKG1hdGNoLnZhbHVlKSA9PT1cbiAgICAgICAgICAgICAgICBfdGhpcy5yZWZsZWN0b3IucmVzb2x2ZUV4dGVybmFsUmVmZXJlbmNlKElkZW50aWZpZXJzLlZpZXdDb250YWluZXJSZWYpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlID0gMyAvKiBWaWV3Q29udGFpbmVyUmVmICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG9rZW5SZWZlcmVuY2UobWF0Y2gudmFsdWUpID09PVxuICAgICAgICAgICAgICAgIF90aGlzLnJlZmxlY3Rvci5yZXNvbHZlRXh0ZXJuYWxSZWZlcmVuY2UoSWRlbnRpZmllcnMuVGVtcGxhdGVSZWYpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlID0gMiAvKiBUZW1wbGF0ZVJlZiAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5TWF0Y2hFeHBycy5wdXNoKGxpdGVyYWxBcnIoW2xpdGVyYWwobWF0Y2gucXVlcnlJZCksIGxpdGVyYWwodmFsdWVUeXBlKV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGFzdC5yZWZlcmVuY2VzLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWVUeXBlID0gKCh1bmRlZmluZWQpKTtcbiAgICAgICAgICAgIGlmICghcmVmLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlID0gMSAvKiBSZW5kZXJFbGVtZW50ICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG9rZW5SZWZlcmVuY2UocmVmLnZhbHVlKSA9PT1cbiAgICAgICAgICAgICAgICBfdGhpcy5yZWZsZWN0b3IucmVzb2x2ZUV4dGVybmFsUmVmZXJlbmNlKElkZW50aWZpZXJzLlRlbXBsYXRlUmVmKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlVHlwZSA9IDIgLyogVGVtcGxhdGVSZWYgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZWZOb2RlSW5kaWNlc1tyZWYubmFtZV0gPSBub2RlSW5kZXg7XG4gICAgICAgICAgICAgICAgcXVlcnlNYXRjaEV4cHJzLnB1c2gobGl0ZXJhbEFycihbbGl0ZXJhbChyZWYubmFtZSksIGxpdGVyYWwodmFsdWVUeXBlKV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGFzdC5vdXRwdXRzLmZvckVhY2goZnVuY3Rpb24gKG91dHB1dEFzdCkge1xuICAgICAgICAgICAgaG9zdEV2ZW50cy5wdXNoKHsgY29udGV4dDogQ09NUF9WQVIsIGV2ZW50QXN0OiBvdXRwdXRBc3QsIGRpckFzdDogLyoqIEB0eXBlIHs/fSAqLyAoKG51bGwpKSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmbGFnczogZmxhZ3MsXG4gICAgICAgICAgICB1c2VkRXZlbnRzOiBBcnJheS5mcm9tKHVzZWRFdmVudHMudmFsdWVzKCkpLFxuICAgICAgICAgICAgcXVlcnlNYXRjaGVzRXhwcjogcXVlcnlNYXRjaEV4cHJzLmxlbmd0aCA/IGxpdGVyYWxBcnIocXVlcnlNYXRjaEV4cHJzKSA6IE5VTExfRVhQUixcbiAgICAgICAgICAgIGhvc3RCaW5kaW5nczogaG9zdEJpbmRpbmdzLFxuICAgICAgICAgICAgaG9zdEV2ZW50czogaG9zdEV2ZW50c1xuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcm92aWRlckFzdFxuICAgICAqIEBwYXJhbSB7P30gZGlyQXN0XG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3RpdmVJbmRleFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudE5vZGVJbmRleFxuICAgICAqIEBwYXJhbSB7P30gcmVmc1xuICAgICAqIEBwYXJhbSB7P30gcXVlcnlNYXRjaGVzXG4gICAgICogQHBhcmFtIHs/fSB1c2VkRXZlbnRzXG4gICAgICogQHBhcmFtIHs/fSBxdWVyeUlkc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLl92aXNpdERpcmVjdGl2ZSA9IGZ1bmN0aW9uIChwcm92aWRlckFzdCwgZGlyQXN0LCBkaXJlY3RpdmVJbmRleCwgZWxlbWVudE5vZGVJbmRleCwgcmVmcywgcXVlcnlNYXRjaGVzLCB1c2VkRXZlbnRzLCBxdWVyeUlkcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlSW5kZXggPSB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgICAgICAgLy8gcmVzZXJ2ZSB0aGUgc3BhY2UgaW4gdGhlIG5vZGVEZWZzIGFycmF5IHNvIHdlIGNhbiBhZGQgY2hpbGRyZW5cbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKC8qKiBAdHlwZSB7P30gKi8gKChudWxsKSkpO1xuICAgICAgICBkaXJBc3QuZGlyZWN0aXZlLnF1ZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAocXVlcnksIHF1ZXJ5SW5kZXgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1ZXJ5SWQgPSBkaXJBc3QuY29udGVudFF1ZXJ5U3RhcnRJZCArIHF1ZXJ5SW5kZXg7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmbGFncyA9IDY3MTA4ODY0IC8qIFR5cGVDb250ZW50UXVlcnkgKi8gfCBjYWxjU3RhdGljRHluYW1pY1F1ZXJ5RmxhZ3MocXVlcnlJZHMsIHF1ZXJ5SWQsIHF1ZXJ5LmZpcnN0KTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJpbmRpbmdUeXBlID0gcXVlcnkuZmlyc3QgPyAwIC8qIEZpcnN0ICovIDogMTtcbiAgICAgICAgICAgIF90aGlzLm5vZGVzLnB1c2goZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICBzb3VyY2VTcGFuOiBkaXJBc3Quc291cmNlU3BhbixcbiAgICAgICAgICAgICAgICBub2RlRmxhZ3M6IGZsYWdzLFxuICAgICAgICAgICAgICAgIG5vZGVEZWY6IGltcG9ydEV4cHIoSWRlbnRpZmllcnMucXVlcnlEZWYpLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgICAgIGxpdGVyYWwoZmxhZ3MpLCBsaXRlcmFsKHF1ZXJ5SWQpLFxuICAgICAgICAgICAgICAgICAgICBuZXcgTGl0ZXJhbE1hcEV4cHIoW25ldyBMaXRlcmFsTWFwRW50cnkocXVlcnkucHJvcGVydHlOYW1lLCBsaXRlcmFsKGJpbmRpbmdUeXBlKSwgZmFsc2UpXSlcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE5vdGU6IHRoZSBvcGVyYXRpb24gYmVsb3cgbWlnaHQgYWxzbyBjcmVhdGUgbmV3IG5vZGVEZWZzLFxuICAgICAgICAvLyBidXQgd2UgZG9uJ3Qgd2FudCB0aGVtIHRvIGJlIGEgY2hpbGQgb2YgYSBkaXJlY3RpdmUsXG4gICAgICAgIC8vIGFzIHRoZXkgbWlnaHQgYmUgYSBwcm92aWRlci9waXBlIG9uIHRoZWlyIG93bi5cbiAgICAgICAgLy8gSS5lLiB3ZSBvbmx5IGFsbG93IHF1ZXJpZXMgYXMgY2hpbGRyZW4gb2YgZGlyZWN0aXZlcyBub2Rlcy5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hpbGRDb3VudCA9IHRoaXMubm9kZXMubGVuZ3RoIC0gbm9kZUluZGV4IC0gMTtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5fdmlzaXRQcm92aWRlck9yRGlyZWN0aXZlKHByb3ZpZGVyQXN0LCBxdWVyeU1hdGNoZXMpLCBmbGFncyA9IF9hLmZsYWdzLCBxdWVyeU1hdGNoRXhwcnMgPSBfYS5xdWVyeU1hdGNoRXhwcnMsIHByb3ZpZGVyRXhwciA9IF9hLnByb3ZpZGVyRXhwciwgZGVwc0V4cHIgPSBfYS5kZXBzRXhwcjtcbiAgICAgICAgcmVmcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgIGlmIChyZWYudmFsdWUgJiYgdG9rZW5SZWZlcmVuY2UocmVmLnZhbHVlKSA9PT0gdG9rZW5SZWZlcmVuY2UocHJvdmlkZXJBc3QudG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVmTm9kZUluZGljZXNbcmVmLm5hbWVdID0gbm9kZUluZGV4O1xuICAgICAgICAgICAgICAgIHF1ZXJ5TWF0Y2hFeHBycy5wdXNoKGxpdGVyYWxBcnIoW2xpdGVyYWwocmVmLm5hbWUpLCBsaXRlcmFsKDQgLyogUHJvdmlkZXIgKi8pXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRpckFzdC5kaXJlY3RpdmUuaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgIGZsYWdzIHw9IDMyNzY4IC8qIENvbXBvbmVudCAqLztcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnB1dERlZnMgPSBkaXJBc3QuaW5wdXRzLm1hcChmdW5jdGlvbiAoaW5wdXRBc3QsIGlucHV0SW5kZXgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hcFZhbHVlID0gbGl0ZXJhbEFycihbbGl0ZXJhbChpbnB1dEluZGV4KSwgbGl0ZXJhbChpbnB1dEFzdC5kaXJlY3RpdmVOYW1lKV0pO1xuICAgICAgICAgICAgLy8gTm90ZTogaXQncyBpbXBvcnRhbnQgdG8gbm90IHF1b3RlIHRoZSBrZXkgc28gdGhhdCB3ZSBjYW4gY2FwdHVyZSByZW5hbWVzIGJ5IG1pbmlmaWVycyFcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbE1hcEVudHJ5KGlucHV0QXN0LmRpcmVjdGl2ZU5hbWUsIG1hcFZhbHVlLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvdXRwdXREZWZzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpck1ldGEgPSBkaXJBc3QuZGlyZWN0aXZlO1xuICAgICAgICBPYmplY3Qua2V5cyhkaXJNZXRhLm91dHB1dHMpLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBldmVudE5hbWUgPSBkaXJNZXRhLm91dHB1dHNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgaWYgKHVzZWRFdmVudHMuaGFzKGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3RlOiBpdCdzIGltcG9ydGFudCB0byBub3QgcXVvdGUgdGhlIGtleSBzbyB0aGF0IHdlIGNhbiBjYXB0dXJlIHJlbmFtZXMgYnkgbWluaWZpZXJzIVxuICAgICAgICAgICAgICAgIG91dHB1dERlZnMucHVzaChuZXcgTGl0ZXJhbE1hcEVudHJ5KHByb3BOYW1lLCBsaXRlcmFsKGV2ZW50TmFtZSksIGZhbHNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1cGRhdGVEaXJlY3RpdmVFeHByZXNzaW9ucyA9IFtdO1xuICAgICAgICBpZiAoZGlyQXN0LmlucHV0cy5sZW5ndGggfHwgKGZsYWdzICYgKDI2MjE0NCAvKiBEb0NoZWNrICovIHwgNjU1MzYgLyogT25Jbml0ICovKSkgPiAwKSB7XG4gICAgICAgICAgICB1cGRhdGVEaXJlY3RpdmVFeHByZXNzaW9ucyA9XG4gICAgICAgICAgICAgICAgZGlyQXN0LmlucHV0cy5tYXAoZnVuY3Rpb24gKGlucHV0LCBiaW5kaW5nSW5kZXgpIHsgcmV0dXJuIF90aGlzLl9wcmVwcm9jZXNzVXBkYXRlRXhwcmVzc2lvbih7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJbmRleDogbm9kZUluZGV4LFxuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nSW5kZXg6IGJpbmRpbmdJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlU3BhbjogaW5wdXQuc291cmNlU3BhbixcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogQ09NUF9WQVIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpbnB1dC52YWx1ZVxuICAgICAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXJDb250ZXh0RXhwciA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMubm9kZVZhbHVlKS5jYWxsRm4oW1ZJRVdfVkFSLCBsaXRlcmFsKG5vZGVJbmRleCldKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaG9zdEJpbmRpbmdzID0gZGlyQXN0Lmhvc3RQcm9wZXJ0aWVzLm1hcChmdW5jdGlvbiAoaW5wdXRBc3QpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICBjb250ZXh0OiBkaXJDb250ZXh0RXhwcixcbiAgICAgICAgICAgIGRpckFzdDogZGlyQXN0LFxuICAgICAgICAgICAgaW5wdXRBc3Q6IGlucHV0QXN0LFxuICAgICAgICB9KTsgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhvc3RFdmVudHMgPSBkaXJBc3QuaG9zdEV2ZW50cy5tYXAoZnVuY3Rpb24gKGhvc3RFdmVudEFzdCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIGNvbnRleHQ6IGRpckNvbnRleHRFeHByLFxuICAgICAgICAgICAgZXZlbnRBc3Q6IGhvc3RFdmVudEFzdCwgZGlyQXN0OiBkaXJBc3QsXG4gICAgICAgIH0pOyB9KTtcbiAgICAgICAgLy8gZGlyZWN0aXZlRGVmKFxuICAgICAgICAvLyAgIGZsYWdzOiBOb2RlRmxhZ3MsIG1hdGNoZWRRdWVyaWVzOiBbc3RyaW5nLCBRdWVyeVZhbHVlVHlwZV1bXSwgY2hpbGRDb3VudDogbnVtYmVyLCBjdG9yOlxuICAgICAgICAvLyAgIGFueSxcbiAgICAgICAgLy8gICBkZXBzOiAoW0RlcEZsYWdzLCBhbnldIHwgYW55KVtdLCBwcm9wcz86IHtbbmFtZTogc3RyaW5nXTogW251bWJlciwgc3RyaW5nXX0sXG4gICAgICAgIC8vICAgb3V0cHV0cz86IHtbbmFtZTogc3RyaW5nXTogc3RyaW5nfSwgY29tcG9uZW50PzogKCkgPT4gVmlld0RlZmluaXRpb24pOiBOb2RlRGVmO1xuICAgICAgICB0aGlzLm5vZGVzW25vZGVJbmRleF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgc291cmNlU3BhbjogZGlyQXN0LnNvdXJjZVNwYW4sXG4gICAgICAgICAgICBub2RlRmxhZ3M6IDE2Mzg0IC8qIFR5cGVEaXJlY3RpdmUgKi8gfCBmbGFncyxcbiAgICAgICAgICAgIG5vZGVEZWY6IGltcG9ydEV4cHIoSWRlbnRpZmllcnMuZGlyZWN0aXZlRGVmKS5jYWxsRm4oW1xuICAgICAgICAgICAgICAgIGxpdGVyYWwoZmxhZ3MpLCBxdWVyeU1hdGNoRXhwcnMubGVuZ3RoID8gbGl0ZXJhbEFycihxdWVyeU1hdGNoRXhwcnMpIDogTlVMTF9FWFBSLFxuICAgICAgICAgICAgICAgIGxpdGVyYWwoY2hpbGRDb3VudCksIHByb3ZpZGVyRXhwciwgZGVwc0V4cHIsXG4gICAgICAgICAgICAgICAgaW5wdXREZWZzLmxlbmd0aCA/IG5ldyBMaXRlcmFsTWFwRXhwcihpbnB1dERlZnMpIDogTlVMTF9FWFBSLFxuICAgICAgICAgICAgICAgIG91dHB1dERlZnMubGVuZ3RoID8gbmV3IExpdGVyYWxNYXBFeHByKG91dHB1dERlZnMpIDogTlVMTF9FWFBSXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIHVwZGF0ZURpcmVjdGl2ZXM6IHVwZGF0ZURpcmVjdGl2ZUV4cHJlc3Npb25zLFxuICAgICAgICAgICAgZGlyZWN0aXZlOiBkaXJBc3QuZGlyZWN0aXZlLnR5cGUsXG4gICAgICAgIH0pOyB9O1xuICAgICAgICByZXR1cm4geyBob3N0QmluZGluZ3M6IGhvc3RCaW5kaW5ncywgaG9zdEV2ZW50czogaG9zdEV2ZW50cyB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcm92aWRlckFzdFxuICAgICAqIEBwYXJhbSB7P30gcXVlcnlNYXRjaGVzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUuX3Zpc2l0UHJvdmlkZXIgPSBmdW5jdGlvbiAocHJvdmlkZXJBc3QsIHF1ZXJ5TWF0Y2hlcykge1xuICAgICAgICB0aGlzLl9hZGRQcm92aWRlck5vZGUodGhpcy5fdmlzaXRQcm92aWRlck9yRGlyZWN0aXZlKHByb3ZpZGVyQXN0LCBxdWVyeU1hdGNoZXMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLl92aXNpdENvbXBvbmVudEZhY3RvcnlSZXNvbHZlclByb3ZpZGVyID0gZnVuY3Rpb24gKGRpcmVjdGl2ZXMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcG9uZW50RGlyTWV0YSA9IGRpcmVjdGl2ZXMuZmluZChmdW5jdGlvbiAoZGlyQXN0KSB7IHJldHVybiBkaXJBc3QuZGlyZWN0aXZlLmlzQ29tcG9uZW50OyB9KTtcbiAgICAgICAgaWYgKGNvbXBvbmVudERpck1ldGEgJiYgY29tcG9uZW50RGlyTWV0YS5kaXJlY3RpdmUuZW50cnlDb21wb25lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIF9hID0gY29tcG9uZW50RmFjdG9yeVJlc29sdmVyUHJvdmlkZXJEZWYodGhpcy5yZWZsZWN0b3IsIHRoaXMub3V0cHV0Q3R4LCA4MTkyIC8qIFByaXZhdGVQcm92aWRlciAqLywgY29tcG9uZW50RGlyTWV0YS5kaXJlY3RpdmUuZW50cnlDb21wb25lbnRzKSwgcHJvdmlkZXJFeHByID0gX2EucHJvdmlkZXJFeHByLCBkZXBzRXhwciA9IF9hLmRlcHNFeHByLCBmbGFncyA9IF9hLmZsYWdzLCB0b2tlbkV4cHJfMSA9IF9hLnRva2VuRXhwcjtcbiAgICAgICAgICAgIHRoaXMuX2FkZFByb3ZpZGVyTm9kZSh7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJFeHByOiBwcm92aWRlckV4cHIsXG4gICAgICAgICAgICAgICAgZGVwc0V4cHI6IGRlcHNFeHByLFxuICAgICAgICAgICAgICAgIGZsYWdzOiBmbGFncyxcbiAgICAgICAgICAgICAgICB0b2tlbkV4cHI6IHRva2VuRXhwcl8xLFxuICAgICAgICAgICAgICAgIHF1ZXJ5TWF0Y2hFeHByczogW10sXG4gICAgICAgICAgICAgICAgc291cmNlU3BhbjogY29tcG9uZW50RGlyTWV0YS5zb3VyY2VTcGFuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkYXRhXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUuX2FkZFByb3ZpZGVyTm9kZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVJbmRleCA9IHRoaXMubm9kZXMubGVuZ3RoO1xuICAgICAgICAvLyBwcm92aWRlckRlZihcbiAgICAgICAgLy8gICBmbGFnczogTm9kZUZsYWdzLCBtYXRjaGVkUXVlcmllczogW3N0cmluZywgUXVlcnlWYWx1ZVR5cGVdW10sIHRva2VuOmFueSxcbiAgICAgICAgLy8gICB2YWx1ZTogYW55LCBkZXBzOiAoW0RlcEZsYWdzLCBhbnldIHwgYW55KVtdKTogTm9kZURlZjtcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICBzb3VyY2VTcGFuOiBkYXRhLnNvdXJjZVNwYW4sXG4gICAgICAgICAgICBub2RlRmxhZ3M6IGRhdGEuZmxhZ3MsXG4gICAgICAgICAgICBub2RlRGVmOiBpbXBvcnRFeHByKElkZW50aWZpZXJzLnByb3ZpZGVyRGVmKS5jYWxsRm4oW1xuICAgICAgICAgICAgICAgIGxpdGVyYWwoZGF0YS5mbGFncyksXG4gICAgICAgICAgICAgICAgZGF0YS5xdWVyeU1hdGNoRXhwcnMubGVuZ3RoID8gbGl0ZXJhbEFycihkYXRhLnF1ZXJ5TWF0Y2hFeHBycykgOiBOVUxMX0VYUFIsXG4gICAgICAgICAgICAgICAgZGF0YS50b2tlbkV4cHIsIGRhdGEucHJvdmlkZXJFeHByLCBkYXRhLmRlcHNFeHByXG4gICAgICAgICAgICBdKVxuICAgICAgICB9KTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHByb3ZpZGVyQXN0XG4gICAgICogQHBhcmFtIHs/fSBxdWVyeU1hdGNoZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS5fdmlzaXRQcm92aWRlck9yRGlyZWN0aXZlID0gZnVuY3Rpb24gKHByb3ZpZGVyQXN0LCBxdWVyeU1hdGNoZXMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmxhZ3MgPSAwO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdWVyeU1hdGNoRXhwcnMgPSBbXTtcbiAgICAgICAgcXVlcnlNYXRjaGVzLmZvckVhY2goZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICBpZiAodG9rZW5SZWZlcmVuY2UobWF0Y2gudmFsdWUpID09PSB0b2tlblJlZmVyZW5jZShwcm92aWRlckFzdC50b2tlbikpIHtcbiAgICAgICAgICAgICAgICBxdWVyeU1hdGNoRXhwcnMucHVzaChsaXRlcmFsQXJyKFtsaXRlcmFsKG1hdGNoLnF1ZXJ5SWQpLCBsaXRlcmFsKDQgLyogUHJvdmlkZXIgKi8pXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIF9hID0gcHJvdmlkZXJEZWYodGhpcy5vdXRwdXRDdHgsIHByb3ZpZGVyQXN0KSwgcHJvdmlkZXJFeHByID0gX2EucHJvdmlkZXJFeHByLCBkZXBzRXhwciA9IF9hLmRlcHNFeHByLCBwcm92aWRlckZsYWdzID0gX2EuZmxhZ3MsIHRva2VuRXhwciA9IF9hLnRva2VuRXhwcjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZsYWdzOiBmbGFncyB8IHByb3ZpZGVyRmxhZ3MsXG4gICAgICAgICAgICBxdWVyeU1hdGNoRXhwcnM6IHF1ZXJ5TWF0Y2hFeHBycyxcbiAgICAgICAgICAgIHByb3ZpZGVyRXhwcjogcHJvdmlkZXJFeHByLFxuICAgICAgICAgICAgZGVwc0V4cHI6IGRlcHNFeHByLFxuICAgICAgICAgICAgdG9rZW5FeHByOiB0b2tlbkV4cHIsXG4gICAgICAgICAgICBzb3VyY2VTcGFuOiBwcm92aWRlckFzdC5zb3VyY2VTcGFuXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS5nZXRMb2NhbCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lID09IEV2ZW50SGFuZGxlclZhcnMuZXZlbnQubmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIEV2ZW50SGFuZGxlclZhcnMuZXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3VyclZpZXdFeHByID0gVklFV19WQVI7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gY3VyckJ1aWxkZXIgPSB0aGlzOyBjdXJyQnVpbGRlcjsgY3VyckJ1aWxkZXIgPSBjdXJyQnVpbGRlci5wYXJlbnQsXG4gICAgICAgICAgICBjdXJyVmlld0V4cHIgPSBjdXJyVmlld0V4cHIucHJvcCgncGFyZW50JykuY2FzdChEWU5BTUlDX1RZUEUpKSB7XG4gICAgICAgICAgICAvLyBjaGVjayByZWZlcmVuY2VzXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWZOb2RlSW5kZXggPSBjdXJyQnVpbGRlci5yZWZOb2RlSW5kaWNlc1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChyZWZOb2RlSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKElkZW50aWZpZXJzLm5vZGVWYWx1ZSkuY2FsbEZuKFtjdXJyVmlld0V4cHIsIGxpdGVyYWwocmVmTm9kZUluZGV4KV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2hlY2sgdmFyaWFibGVzXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YXJBc3QgPSBjdXJyQnVpbGRlci52YXJpYWJsZXMuZmluZChmdW5jdGlvbiAodmFyQXN0KSB7IHJldHVybiB2YXJBc3QubmFtZSA9PT0gbmFtZTsgfSk7XG4gICAgICAgICAgICBpZiAodmFyQXN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFyVmFsdWUgPSB2YXJBc3QudmFsdWUgfHwgSU1QTElDSVRfVEVNUExBVEVfVkFSO1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyVmlld0V4cHIucHJvcCgnY29udGV4dCcpLnByb3AodmFyVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHBhcmFtIHs/fSBhcmdDb3VudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLmNyZWF0ZUxpdGVyYWxBcnJheUNvbnZlcnRlciA9IGZ1bmN0aW9uIChzb3VyY2VTcGFuLCBhcmdDb3VudCkge1xuICAgICAgICBpZiAoYXJnQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlRXhwcl8xID0gaW1wb3J0RXhwcihJZGVudGlmaWVycy5FTVBUWV9BUlJBWSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWVFeHByXzE7IH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZUluZGV4ID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gICAgICAgIC8vIHB1cmVBcnJheURlZihhcmdDb3VudDogbnVtYmVyKTogTm9kZURlZjtcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICBzb3VyY2VTcGFuOiBzb3VyY2VTcGFuLFxuICAgICAgICAgICAgbm9kZUZsYWdzOiAzMiAvKiBUeXBlUHVyZUFycmF5ICovLFxuICAgICAgICAgICAgbm9kZURlZjogaW1wb3J0RXhwcihJZGVudGlmaWVycy5wdXJlQXJyYXlEZWYpLmNhbGxGbihbbGl0ZXJhbChhcmdDb3VudCldKVxuICAgICAgICB9KTsgfSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYXJncykgeyByZXR1cm4gY2FsbENoZWNrU3RtdChub2RlSW5kZXgsIGFyZ3MpOyB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHBhcmFtIHs/fSBrZXlzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUuY3JlYXRlTGl0ZXJhbE1hcENvbnZlcnRlciA9IGZ1bmN0aW9uIChzb3VyY2VTcGFuLCBrZXlzKSB7XG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWVFeHByXzIgPSBpbXBvcnRFeHByKElkZW50aWZpZXJzLkVNUFRZX01BUCk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWVFeHByXzI7IH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gZnVuY3Rpb24gcHVyZU9iamVjdERlZihwcm9wVG9JbmRleDoge1twOiBzdHJpbmddOiBudW1iZXJ9KTogTm9kZURlZlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXAgPSBsaXRlcmFsTWFwKGtleXMubWFwKGZ1bmN0aW9uIChlLCBpKSB7IHJldHVybiAoT2JqZWN0LmFzc2lnbih7fSwgZSwgeyB2YWx1ZTogbGl0ZXJhbChpKSB9KSk7IH0pKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZUluZGV4ID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gICAgICAgIHRoaXMubm9kZXMucHVzaChmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgc291cmNlU3Bhbjogc291cmNlU3BhbixcbiAgICAgICAgICAgIG5vZGVGbGFnczogNjQgLyogVHlwZVB1cmVPYmplY3QgKi8sXG4gICAgICAgICAgICBub2RlRGVmOiBpbXBvcnRFeHByKElkZW50aWZpZXJzLnB1cmVPYmplY3REZWYpLmNhbGxGbihbbWFwXSlcbiAgICAgICAgfSk7IH0pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFyZ3MpIHsgcmV0dXJuIGNhbGxDaGVja1N0bXQobm9kZUluZGV4LCBhcmdzKTsgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gYXJnQ291bnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS5jcmVhdGVQaXBlQ29udmVydGVyID0gZnVuY3Rpb24gKGV4cHJlc3Npb24sIG5hbWUsIGFyZ0NvdW50KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBpcGUgPSAoKHRoaXMudXNlZFBpcGVzLmZpbmQoZnVuY3Rpb24gKHBpcGVTdW1tYXJ5KSB7IHJldHVybiBwaXBlU3VtbWFyeS5uYW1lID09PSBuYW1lOyB9KSkpO1xuICAgICAgICBpZiAocGlwZS5wdXJlKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlSW5kZXhfMSA9IHRoaXMubm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgLy8gZnVuY3Rpb24gcHVyZVBpcGVEZWYoYXJnQ291bnQ6IG51bWJlcik6IE5vZGVEZWY7XG4gICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2goZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICBzb3VyY2VTcGFuOiBleHByZXNzaW9uLnNvdXJjZVNwYW4sXG4gICAgICAgICAgICAgICAgbm9kZUZsYWdzOiAxMjggLyogVHlwZVB1cmVQaXBlICovLFxuICAgICAgICAgICAgICAgIG5vZGVEZWY6IGltcG9ydEV4cHIoSWRlbnRpZmllcnMucHVyZVBpcGVEZWYpLmNhbGxGbihbbGl0ZXJhbChhcmdDb3VudCldKVxuICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICAgICAgLy8gZmluZCB1bmRlcmx5aW5nIHBpcGUgaW4gdGhlIGNvbXBvbmVudCB2aWV3XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wVmlld0V4cHIgPSBWSUVXX1ZBUjtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBCdWlsZGVyID0gdGhpcztcbiAgICAgICAgICAgIHdoaWxlIChjb21wQnVpbGRlci5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBjb21wQnVpbGRlciA9IGNvbXBCdWlsZGVyLnBhcmVudDtcbiAgICAgICAgICAgICAgICBjb21wVmlld0V4cHIgPSBjb21wVmlld0V4cHIucHJvcCgncGFyZW50JykuY2FzdChEWU5BTUlDX1RZUEUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGlwZU5vZGVJbmRleCA9IGNvbXBCdWlsZGVyLnB1cmVQaXBlTm9kZUluZGljZXNbbmFtZV07XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwaXBlVmFsdWVFeHByXzEgPSBpbXBvcnRFeHByKElkZW50aWZpZXJzLm5vZGVWYWx1ZSkuY2FsbEZuKFtjb21wVmlld0V4cHIsIGxpdGVyYWwocGlwZU5vZGVJbmRleCldKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYXJncykgeyByZXR1cm4gY2FsbFVud3JhcFZhbHVlKGV4cHJlc3Npb24ubm9kZUluZGV4LCBleHByZXNzaW9uLmJpbmRpbmdJbmRleCwgY2FsbENoZWNrU3RtdChub2RlSW5kZXhfMSwgW3BpcGVWYWx1ZUV4cHJfMV0uY29uY2F0KGFyZ3MpKSk7IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlSW5kZXggPSB0aGlzLl9jcmVhdGVQaXBlKGV4cHJlc3Npb24uc291cmNlU3BhbiwgcGlwZSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlVmFsdWVFeHByXzEgPSBpbXBvcnRFeHByKElkZW50aWZpZXJzLm5vZGVWYWx1ZSkuY2FsbEZuKFtWSUVXX1ZBUiwgbGl0ZXJhbChub2RlSW5kZXgpXSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFyZ3MpIHsgcmV0dXJuIGNhbGxVbndyYXBWYWx1ZShleHByZXNzaW9uLm5vZGVJbmRleCwgZXhwcmVzc2lvbi5iaW5kaW5nSW5kZXgsIG5vZGVWYWx1ZUV4cHJfMS5jYWxsTWV0aG9kKCd0cmFuc2Zvcm0nLCBhcmdzKSk7IH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7P30gcGlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLl9jcmVhdGVQaXBlID0gZnVuY3Rpb24gKHNvdXJjZVNwYW4sIHBpcGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZUluZGV4ID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZsYWdzID0gMDtcbiAgICAgICAgcGlwZS50eXBlLmxpZmVjeWNsZUhvb2tzLmZvckVhY2goZnVuY3Rpb24gKGxpZmVjeWNsZUhvb2spIHtcbiAgICAgICAgICAgIC8vIGZvciBwaXBlcywgd2Ugb25seSBzdXBwb3J0IG5nT25EZXN0cm95XG4gICAgICAgICAgICBpZiAobGlmZWN5Y2xlSG9vayA9PT0gTGlmZWN5Y2xlSG9va3MuT25EZXN0cm95KSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MgfD0gbGlmZWN5Y2xlSG9va1RvTm9kZUZsYWcobGlmZWN5Y2xlSG9vayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXBFeHBycyA9IHBpcGUudHlwZS5kaURlcHMubWFwKGZ1bmN0aW9uIChkaURlcCkgeyByZXR1cm4gZGVwRGVmKF90aGlzLm91dHB1dEN0eCwgZGlEZXApOyB9KTtcbiAgICAgICAgLy8gZnVuY3Rpb24gcGlwZURlZihcbiAgICAgICAgLy8gICBmbGFnczogTm9kZUZsYWdzLCBjdG9yOiBhbnksIGRlcHM6IChbRGVwRmxhZ3MsIGFueV0gfCBhbnkpW10pOiBOb2RlRGVmXG4gICAgICAgIHRoaXMubm9kZXMucHVzaChmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgc291cmNlU3Bhbjogc291cmNlU3BhbixcbiAgICAgICAgICAgIG5vZGVGbGFnczogMTYgLyogVHlwZVBpcGUgKi8sXG4gICAgICAgICAgICBub2RlRGVmOiBpbXBvcnRFeHByKElkZW50aWZpZXJzLnBpcGVEZWYpLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgbGl0ZXJhbChmbGFncyksIF90aGlzLm91dHB1dEN0eC5pbXBvcnRFeHByKHBpcGUudHlwZS5yZWZlcmVuY2UpLCBsaXRlcmFsQXJyKGRlcEV4cHJzKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgfSk7IH0pO1xuICAgICAgICByZXR1cm4gbm9kZUluZGV4O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHByZXNzaW9uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUuX3ByZXByb2Nlc3NVcGRhdGVFeHByZXNzaW9uID0gZnVuY3Rpb24gKGV4cHJlc3Npb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5vZGVJbmRleDogZXhwcmVzc2lvbi5ub2RlSW5kZXgsXG4gICAgICAgICAgICBiaW5kaW5nSW5kZXg6IGV4cHJlc3Npb24uYmluZGluZ0luZGV4LFxuICAgICAgICAgICAgc291cmNlU3BhbjogZXhwcmVzc2lvbi5zb3VyY2VTcGFuLFxuICAgICAgICAgICAgY29udGV4dDogZXhwcmVzc2lvbi5jb250ZXh0LFxuICAgICAgICAgICAgdmFsdWU6IGNvbnZlcnRQcm9wZXJ0eUJpbmRpbmdCdWlsdGlucyh7XG4gICAgICAgICAgICAgICAgY3JlYXRlTGl0ZXJhbEFycmF5Q29udmVydGVyOiBmdW5jdGlvbiAoYXJnQ291bnQpIHsgcmV0dXJuIF90aGlzLmNyZWF0ZUxpdGVyYWxBcnJheUNvbnZlcnRlcihleHByZXNzaW9uLnNvdXJjZVNwYW4sIGFyZ0NvdW50KTsgfSxcbiAgICAgICAgICAgICAgICBjcmVhdGVMaXRlcmFsTWFwQ29udmVydGVyOiBmdW5jdGlvbiAoa2V5cykgeyByZXR1cm4gX3RoaXMuY3JlYXRlTGl0ZXJhbE1hcENvbnZlcnRlcihleHByZXNzaW9uLnNvdXJjZVNwYW4sIGtleXMpOyB9LFxuICAgICAgICAgICAgICAgIGNyZWF0ZVBpcGVDb252ZXJ0ZXI6IGZ1bmN0aW9uIChuYW1lLCBhcmdDb3VudCkgeyByZXR1cm4gX3RoaXMuY3JlYXRlUGlwZUNvbnZlcnRlcihleHByZXNzaW9uLCBuYW1lLCBhcmdDb3VudCk7IH1cbiAgICAgICAgICAgIH0sIGV4cHJlc3Npb24udmFsdWUpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS5fY3JlYXRlTm9kZUV4cHJlc3Npb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXBkYXRlQmluZGluZ0NvdW50ID0gMDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXBkYXRlUmVuZGVyZXJTdG10cyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1cGRhdGVEaXJlY3RpdmVzU3RtdHMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZURlZkV4cHJzID0gdGhpcy5ub2Rlcy5tYXAoZnVuY3Rpb24gKGZhY3RvcnksIG5vZGVJbmRleCkge1xuICAgICAgICAgICAgdmFyIF9hID0gZmFjdG9yeSgpLCBub2RlRGVmID0gX2Eubm9kZURlZiwgbm9kZUZsYWdzID0gX2Eubm9kZUZsYWdzLCB1cGRhdGVEaXJlY3RpdmVzID0gX2EudXBkYXRlRGlyZWN0aXZlcywgdXBkYXRlUmVuZGVyZXIgPSBfYS51cGRhdGVSZW5kZXJlciwgc291cmNlU3BhbiA9IF9hLnNvdXJjZVNwYW47XG4gICAgICAgICAgICBpZiAodXBkYXRlUmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVSZW5kZXJlclN0bXRzLnB1c2guYXBwbHkodXBkYXRlUmVuZGVyZXJTdG10cywgY3JlYXRlVXBkYXRlU3RhdGVtZW50cyhub2RlSW5kZXgsIHNvdXJjZVNwYW4sIHVwZGF0ZVJlbmRlcmVyLCBmYWxzZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVwZGF0ZURpcmVjdGl2ZXMpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVEaXJlY3RpdmVzU3RtdHMucHVzaC5hcHBseSh1cGRhdGVEaXJlY3RpdmVzU3RtdHMsIGNyZWF0ZVVwZGF0ZVN0YXRlbWVudHMobm9kZUluZGV4LCBzb3VyY2VTcGFuLCB1cGRhdGVEaXJlY3RpdmVzLCAobm9kZUZsYWdzICYgKDI2MjE0NCAvKiBEb0NoZWNrICovIHwgNjU1MzYgLyogT25Jbml0ICovKSkgPiAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSB1c2UgYSBjb21tYSBleHByZXNzaW9uIHRvIGNhbGwgdGhlIGxvZyBmdW5jdGlvbiBiZWZvcmVcbiAgICAgICAgICAgIC8vIHRoZSBub2RlRGVmIGZ1bmN0aW9uLCBidXQgc3RpbGwgdXNlIHRoZSByZXN1bHQgb2YgdGhlIG5vZGVEZWYgZnVuY3Rpb25cbiAgICAgICAgICAgIC8vIGFzIHRoZSB2YWx1ZS5cbiAgICAgICAgICAgIC8vIE5vdGU6IFdlIG9ubHkgYWRkIHRoZSBsb2dnZXIgdG8gZWxlbWVudHMgLyB0ZXh0IG5vZGVzLFxuICAgICAgICAgICAgLy8gc28gd2UgZG9uJ3QgZ2VuZXJhdGUgdG9vIG11Y2ggY29kZS5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxvZ1dpdGhOb2RlRGVmID0gbm9kZUZsYWdzICYgMyAvKiBDYXRSZW5kZXJOb2RlICovID9cbiAgICAgICAgICAgICAgICBuZXcgQ29tbWFFeHByKFtMT0dfVkFSJDEuY2FsbEZuKFtdKS5jYWxsRm4oW10pLCBub2RlRGVmXSkgOlxuICAgICAgICAgICAgICAgIG5vZGVEZWY7XG4gICAgICAgICAgICByZXR1cm4gYXBwbHlTb3VyY2VTcGFuVG9FeHByZXNzaW9uSWZOZWVkZWQobG9nV2l0aE5vZGVEZWYsIHNvdXJjZVNwYW4pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgdXBkYXRlUmVuZGVyZXJTdG10czogdXBkYXRlUmVuZGVyZXJTdG10cywgdXBkYXRlRGlyZWN0aXZlc1N0bXRzOiB1cGRhdGVEaXJlY3RpdmVzU3RtdHMsIG5vZGVEZWZFeHByczogbm9kZURlZkV4cHJzIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IG5vZGVJbmRleFxuICAgICAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgICAgICogQHBhcmFtIHs/fSBleHByZXNzaW9uc1xuICAgICAgICAgKiBAcGFyYW0gez99IGFsbG93RW1wdHlFeHByc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlVXBkYXRlU3RhdGVtZW50cyhub2RlSW5kZXgsIHNvdXJjZVNwYW4sIGV4cHJlc3Npb25zLCBhbGxvd0VtcHR5RXhwcnMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVwZGF0ZVN0bXRzID0gW107XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHBycyA9IGV4cHJlc3Npb25zLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlU3BhbiA9IF9hLnNvdXJjZVNwYW4sIGNvbnRleHQgPSBfYS5jb250ZXh0LCB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJpbmRpbmdJZCA9IFwiXCIgKyB1cGRhdGVCaW5kaW5nQ291bnQrKztcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lUmVzb2x2ZXIgPSBjb250ZXh0ID09PSBDT01QX1ZBUiA/IHNlbGYgOiBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBfYiA9IGNvbnZlcnRQcm9wZXJ0eUJpbmRpbmcobmFtZVJlc29sdmVyLCBjb250ZXh0LCB2YWx1ZSwgYmluZGluZ0lkKSwgc3RtdHMgPSBfYi5zdG10cywgY3VyclZhbEV4cHIgPSBfYi5jdXJyVmFsRXhwcjtcbiAgICAgICAgICAgICAgICB1cGRhdGVTdG10cy5wdXNoLmFwcGx5KHVwZGF0ZVN0bXRzLCBzdG10cy5tYXAoZnVuY3Rpb24gKHN0bXQpIHsgcmV0dXJuIGFwcGx5U291cmNlU3BhblRvU3RhdGVtZW50SWZOZWVkZWQoc3RtdCwgc291cmNlU3Bhbik7IH0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwbHlTb3VyY2VTcGFuVG9FeHByZXNzaW9uSWZOZWVkZWQoY3VyclZhbEV4cHIsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZXhwcmVzc2lvbnMubGVuZ3RoIHx8IGFsbG93RW1wdHlFeHBycykge1xuICAgICAgICAgICAgICAgIHVwZGF0ZVN0bXRzLnB1c2goYXBwbHlTb3VyY2VTcGFuVG9TdGF0ZW1lbnRJZk5lZWRlZChjYWxsQ2hlY2tTdG10KG5vZGVJbmRleCwgZXhwcnMpLnRvU3RtdCgpLCBzb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlU3RtdHM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZUluZGV4XG4gICAgICogQHBhcmFtIHs/fSBoYW5kbGVyc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLl9jcmVhdGVFbGVtZW50SGFuZGxlRXZlbnRGbiA9IGZ1bmN0aW9uIChub2RlSW5kZXgsIGhhbmRsZXJzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhhbmRsZUV2ZW50U3RtdHMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaGFuZGxlRXZlbnRCaW5kaW5nQ291bnQgPSAwO1xuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBfYS5jb250ZXh0LCBldmVudEFzdCA9IF9hLmV2ZW50QXN0LCBkaXJBc3QgPSBfYS5kaXJBc3Q7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiaW5kaW5nSWQgPSBcIlwiICsgaGFuZGxlRXZlbnRCaW5kaW5nQ291bnQrKztcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWVSZXNvbHZlciA9IGNvbnRleHQgPT09IENPTVBfVkFSID8gX3RoaXMgOiBudWxsO1xuICAgICAgICAgICAgdmFyIF9iID0gY29udmVydEFjdGlvbkJpbmRpbmcobmFtZVJlc29sdmVyLCBjb250ZXh0LCBldmVudEFzdC5oYW5kbGVyLCBiaW5kaW5nSWQpLCBzdG10cyA9IF9iLnN0bXRzLCBhbGxvd0RlZmF1bHQgPSBfYi5hbGxvd0RlZmF1bHQ7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cnVlU3RtdHMgPSBzdG10cztcbiAgICAgICAgICAgIGlmIChhbGxvd0RlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICB0cnVlU3RtdHMucHVzaChBTExPV19ERUZBVUxUX1ZBUi5zZXQoYWxsb3dEZWZhdWx0LmFuZChBTExPV19ERUZBVUxUX1ZBUikpLnRvU3RtdCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfYyA9IGVsZW1lbnRFdmVudE5hbWVBbmRUYXJnZXQoZXZlbnRBc3QsIGRpckFzdCksIGV2ZW50VGFyZ2V0ID0gX2MudGFyZ2V0LCBldmVudE5hbWUgPSBfYy5uYW1lO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZnVsbEV2ZW50TmFtZSA9IMm1ZWxlbWVudEV2ZW50RnVsbE5hbWUoZXZlbnRUYXJnZXQsIGV2ZW50TmFtZSk7XG4gICAgICAgICAgICBoYW5kbGVFdmVudFN0bXRzLnB1c2goYXBwbHlTb3VyY2VTcGFuVG9TdGF0ZW1lbnRJZk5lZWRlZChuZXcgSWZTdG10KGxpdGVyYWwoZnVsbEV2ZW50TmFtZSkuaWRlbnRpY2FsKEVWRU5UX05BTUVfVkFSKSwgdHJ1ZVN0bXRzKSwgZXZlbnRBc3Quc291cmNlU3BhbikpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaGFuZGxlRXZlbnRGbjtcbiAgICAgICAgaWYgKGhhbmRsZUV2ZW50U3RtdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlU3RtdHMgPSBbQUxMT1dfREVGQVVMVF9WQVIuc2V0KGxpdGVyYWwodHJ1ZSkpLnRvRGVjbFN0bXQoQk9PTF9UWVBFKV07XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29tcG9uZW50LmlzSG9zdCAmJiBmaW5kUmVhZFZhck5hbWVzKGhhbmRsZUV2ZW50U3RtdHMpLmhhcygvKiogQHR5cGUgez99ICovICgoQ09NUF9WQVIubmFtZSkpKSkge1xuICAgICAgICAgICAgICAgIHByZVN0bXRzLnB1c2goQ09NUF9WQVIuc2V0KFZJRVdfVkFSLnByb3AoJ2NvbXBvbmVudCcpKS50b0RlY2xTdG10KHRoaXMuY29tcFR5cGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZUV2ZW50Rm4gPSBmbihbXG4gICAgICAgICAgICAgICAgbmV3IEZuUGFyYW0oLyoqIEB0eXBlIHs/fSAqLyAoKFZJRVdfVkFSLm5hbWUpKSwgSU5GRVJSRURfVFlQRSksXG4gICAgICAgICAgICAgICAgbmV3IEZuUGFyYW0oLyoqIEB0eXBlIHs/fSAqLyAoKEVWRU5UX05BTUVfVkFSLm5hbWUpKSwgSU5GRVJSRURfVFlQRSksXG4gICAgICAgICAgICAgICAgbmV3IEZuUGFyYW0oLyoqIEB0eXBlIHs/fSAqLyAoKEV2ZW50SGFuZGxlclZhcnMuZXZlbnQubmFtZSkpLCBJTkZFUlJFRF9UWVBFKVxuICAgICAgICAgICAgXSwgcHJlU3RtdHMuY29uY2F0KGhhbmRsZUV2ZW50U3RtdHMsIFtuZXcgUmV0dXJuU3RhdGVtZW50KEFMTE9XX0RFRkFVTFRfVkFSKV0pLCBJTkZFUlJFRF9UWVBFKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZUV2ZW50Rm4gPSBOVUxMX0VYUFI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhbmRsZUV2ZW50Rm47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0RGlyZWN0aXZlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUudmlzaXREaXJlY3RpdmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0UmVmZXJlbmNlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUudmlzaXRWYXJpYWJsZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0RXZlbnQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS52aXNpdEVsZW1lbnRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0QXR0ciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICByZXR1cm4gVmlld0J1aWxkZXI7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IGFzdE5vZGVzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBuZWVkc0FkZGl0aW9uYWxSb290Tm9kZShhc3ROb2Rlcykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGxhc3RBc3ROb2RlID0gYXN0Tm9kZXNbYXN0Tm9kZXMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGxhc3RBc3ROb2RlIGluc3RhbmNlb2YgRW1iZWRkZWRUZW1wbGF0ZUFzdCkge1xuICAgICAgICByZXR1cm4gbGFzdEFzdE5vZGUuaGFzVmlld0NvbnRhaW5lcjtcbiAgICB9XG4gICAgaWYgKGxhc3RBc3ROb2RlIGluc3RhbmNlb2YgRWxlbWVudEFzdCkge1xuICAgICAgICBpZiAoaXNOZ0NvbnRhaW5lcihsYXN0QXN0Tm9kZS5uYW1lKSAmJiBsYXN0QXN0Tm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZWVkc0FkZGl0aW9uYWxSb290Tm9kZShsYXN0QXN0Tm9kZS5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhc3RBc3ROb2RlLmhhc1ZpZXdDb250YWluZXI7XG4gICAgfVxuICAgIHJldHVybiBsYXN0QXN0Tm9kZSBpbnN0YW5jZW9mIE5nQ29udGVudEFzdDtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBpbnB1dEFzdFxuICogQHBhcmFtIHs/fSBkaXJBc3RcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGVsZW1lbnRCaW5kaW5nRGVmKGlucHV0QXN0LCBkaXJBc3QpIHtcbiAgICBzd2l0Y2ggKGlucHV0QXN0LnR5cGUpIHtcbiAgICAgICAgY2FzZSBQcm9wZXJ0eUJpbmRpbmdUeXBlLkF0dHJpYnV0ZTpcbiAgICAgICAgICAgIHJldHVybiBsaXRlcmFsQXJyKFtcbiAgICAgICAgICAgICAgICBsaXRlcmFsKDEgLyogVHlwZUVsZW1lbnRBdHRyaWJ1dGUgKi8pLCBsaXRlcmFsKGlucHV0QXN0Lm5hbWUpLFxuICAgICAgICAgICAgICAgIGxpdGVyYWwoaW5wdXRBc3Quc2VjdXJpdHlDb250ZXh0KVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIGNhc2UgUHJvcGVydHlCaW5kaW5nVHlwZS5Qcm9wZXJ0eTpcbiAgICAgICAgICAgIHJldHVybiBsaXRlcmFsQXJyKFtcbiAgICAgICAgICAgICAgICBsaXRlcmFsKDggLyogVHlwZVByb3BlcnR5ICovKSwgbGl0ZXJhbChpbnB1dEFzdC5uYW1lKSxcbiAgICAgICAgICAgICAgICBsaXRlcmFsKGlucHV0QXN0LnNlY3VyaXR5Q29udGV4dClcbiAgICAgICAgICAgIF0pO1xuICAgICAgICBjYXNlIFByb3BlcnR5QmluZGluZ1R5cGUuQW5pbWF0aW9uOlxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmluZGluZ1R5cGUgPSA4IC8qIFR5cGVQcm9wZXJ0eSAqLyB8XG4gICAgICAgICAgICAgICAgKGRpckFzdCAmJiBkaXJBc3QuZGlyZWN0aXZlLmlzQ29tcG9uZW50ID8gMzIgLyogU3ludGhldGljSG9zdFByb3BlcnR5ICovIDpcbiAgICAgICAgICAgICAgICAgICAgMTYgLyogU3ludGhldGljUHJvcGVydHkgKi8pO1xuICAgICAgICAgICAgcmV0dXJuIGxpdGVyYWxBcnIoW1xuICAgICAgICAgICAgICAgIGxpdGVyYWwoYmluZGluZ1R5cGUpLCBsaXRlcmFsKCdAJyArIGlucHV0QXN0Lm5hbWUpLCBsaXRlcmFsKGlucHV0QXN0LnNlY3VyaXR5Q29udGV4dClcbiAgICAgICAgICAgIF0pO1xuICAgICAgICBjYXNlIFByb3BlcnR5QmluZGluZ1R5cGUuQ2xhc3M6XG4gICAgICAgICAgICByZXR1cm4gbGl0ZXJhbEFycihbbGl0ZXJhbCgyIC8qIFR5cGVFbGVtZW50Q2xhc3MgKi8pLCBsaXRlcmFsKGlucHV0QXN0Lm5hbWUpLCBOVUxMX0VYUFJdKTtcbiAgICAgICAgY2FzZSBQcm9wZXJ0eUJpbmRpbmdUeXBlLlN0eWxlOlxuICAgICAgICAgICAgcmV0dXJuIGxpdGVyYWxBcnIoW1xuICAgICAgICAgICAgICAgIGxpdGVyYWwoNCAvKiBUeXBlRWxlbWVudFN0eWxlICovKSwgbGl0ZXJhbChpbnB1dEFzdC5uYW1lKSwgbGl0ZXJhbChpbnB1dEFzdC51bml0KVxuICAgICAgICAgICAgXSk7XG4gICAgfVxufVxuLyoqXG4gKiBAcGFyYW0gez99IGVsZW1lbnRBc3RcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGZpeGVkQXR0cnNEZWYoZWxlbWVudEFzdCkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hcFJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZWxlbWVudEFzdC5hdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyQXN0KSB7IG1hcFJlc3VsdFthdHRyQXN0Lm5hbWVdID0gYXR0ckFzdC52YWx1ZTsgfSk7XG4gICAgZWxlbWVudEFzdC5kaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpckFzdCkge1xuICAgICAgICBPYmplY3Qua2V5cyhkaXJBc3QuZGlyZWN0aXZlLmhvc3RBdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IGRpckFzdC5kaXJlY3RpdmUuaG9zdEF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmV2VmFsdWUgPSBtYXBSZXN1bHRbbmFtZV07XG4gICAgICAgICAgICBtYXBSZXN1bHRbbmFtZV0gPSBwcmV2VmFsdWUgIT0gbnVsbCA/IG1lcmdlQXR0cmlidXRlVmFsdWUobmFtZSwgcHJldlZhbHVlLCB2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgLy8gTm90ZTogV2UgbmVlZCB0byBzb3J0IHRvIGdldCBhIGRlZmluZWQgb3V0cHV0IG9yZGVyXG4gICAgLy8gZm9yIHRlc3RzIGFuZCBmb3IgY2FjaGluZyBnZW5lcmF0ZWQgYXJ0aWZhY3RzLi4uXG4gICAgcmV0dXJuIGxpdGVyYWxBcnIoT2JqZWN0LmtleXMobWFwUmVzdWx0KS5zb3J0KCkubWFwKGZ1bmN0aW9uIChhdHRyTmFtZSkgeyByZXR1cm4gbGl0ZXJhbEFycihbbGl0ZXJhbChhdHRyTmFtZSksIGxpdGVyYWwobWFwUmVzdWx0W2F0dHJOYW1lXSldKTsgfSkpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGF0dHJOYW1lXG4gKiBAcGFyYW0gez99IGF0dHJWYWx1ZTFcbiAqIEBwYXJhbSB7P30gYXR0clZhbHVlMlxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gbWVyZ2VBdHRyaWJ1dGVWYWx1ZShhdHRyTmFtZSwgYXR0clZhbHVlMSwgYXR0clZhbHVlMikge1xuICAgIGlmIChhdHRyTmFtZSA9PSBDTEFTU19BVFRSJDEgfHwgYXR0ck5hbWUgPT0gU1RZTEVfQVRUUikge1xuICAgICAgICByZXR1cm4gYXR0clZhbHVlMSArIFwiIFwiICsgYXR0clZhbHVlMjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBhdHRyVmFsdWUyO1xuICAgIH1cbn1cbi8qKlxuICogQHBhcmFtIHs/fSBub2RlSW5kZXhcbiAqIEBwYXJhbSB7P30gZXhwcnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNhbGxDaGVja1N0bXQobm9kZUluZGV4LCBleHBycykge1xuICAgIGlmIChleHBycy5sZW5ndGggPiAxMCkge1xuICAgICAgICByZXR1cm4gQ0hFQ0tfVkFSLmNhbGxGbihbVklFV19WQVIsIGxpdGVyYWwobm9kZUluZGV4KSwgbGl0ZXJhbCgxIC8qIER5bmFtaWMgKi8pLCBsaXRlcmFsQXJyKGV4cHJzKV0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIENIRUNLX1ZBUi5jYWxsRm4oW1ZJRVdfVkFSLCBsaXRlcmFsKG5vZGVJbmRleCksIGxpdGVyYWwoMCAvKiBJbmxpbmUgKi8pXS5jb25jYXQoZXhwcnMpKTtcbiAgICB9XG59XG4vKipcbiAqIEBwYXJhbSB7P30gbm9kZUluZGV4XG4gKiBAcGFyYW0gez99IGJpbmRpbmdJZHhcbiAqIEBwYXJhbSB7P30gZXhwclxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY2FsbFVud3JhcFZhbHVlKG5vZGVJbmRleCwgYmluZGluZ0lkeCwgZXhwcikge1xuICAgIHJldHVybiBpbXBvcnRFeHByKElkZW50aWZpZXJzLnVud3JhcFZhbHVlKS5jYWxsRm4oW1xuICAgICAgICBWSUVXX1ZBUiwgbGl0ZXJhbChub2RlSW5kZXgpLCBsaXRlcmFsKGJpbmRpbmdJZHgpLCBleHByXG4gICAgXSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gbm9kZXNcbiAqIEBwYXJhbSB7Pz19IHJlc3VsdFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZmluZFN0YXRpY1F1ZXJ5SWRzKG5vZGVzLCByZXN1bHQpIHtcbiAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHsgcmVzdWx0ID0gbmV3IE1hcCgpOyB9XG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGF0aWNRdWVyeUlkcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZHluYW1pY1F1ZXJ5SWRzID0gbmV3IFNldCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdWVyeU1hdGNoZXMgPSAoKHVuZGVmaW5lZCkpO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEVsZW1lbnRBc3QpIHtcbiAgICAgICAgICAgIGZpbmRTdGF0aWNRdWVyeUlkcyhub2RlLmNoaWxkcmVuLCByZXN1bHQpO1xuICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNoaWxkRGF0YSA9ICgocmVzdWx0LmdldChjaGlsZCkpKTtcbiAgICAgICAgICAgICAgICBjaGlsZERhdGEuc3RhdGljUXVlcnlJZHMuZm9yRWFjaChmdW5jdGlvbiAocXVlcnlJZCkgeyByZXR1cm4gc3RhdGljUXVlcnlJZHMuYWRkKHF1ZXJ5SWQpOyB9KTtcbiAgICAgICAgICAgICAgICBjaGlsZERhdGEuZHluYW1pY1F1ZXJ5SWRzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5SWQpIHsgcmV0dXJuIGR5bmFtaWNRdWVyeUlkcy5hZGQocXVlcnlJZCk7IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBxdWVyeU1hdGNoZXMgPSBub2RlLnF1ZXJ5TWF0Y2hlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgRW1iZWRkZWRUZW1wbGF0ZUFzdCkge1xuICAgICAgICAgICAgZmluZFN0YXRpY1F1ZXJ5SWRzKG5vZGUuY2hpbGRyZW4sIHJlc3VsdCk7XG4gICAgICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hpbGREYXRhID0gKChyZXN1bHQuZ2V0KGNoaWxkKSkpO1xuICAgICAgICAgICAgICAgIGNoaWxkRGF0YS5zdGF0aWNRdWVyeUlkcy5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyeUlkKSB7IHJldHVybiBkeW5hbWljUXVlcnlJZHMuYWRkKHF1ZXJ5SWQpOyB9KTtcbiAgICAgICAgICAgICAgICBjaGlsZERhdGEuZHluYW1pY1F1ZXJ5SWRzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5SWQpIHsgcmV0dXJuIGR5bmFtaWNRdWVyeUlkcy5hZGQocXVlcnlJZCk7IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBxdWVyeU1hdGNoZXMgPSBub2RlLnF1ZXJ5TWF0Y2hlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAocXVlcnlNYXRjaGVzKSB7XG4gICAgICAgICAgICBxdWVyeU1hdGNoZXMuZm9yRWFjaChmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIHN0YXRpY1F1ZXJ5SWRzLmFkZChtYXRjaC5xdWVyeUlkKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZHluYW1pY1F1ZXJ5SWRzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5SWQpIHsgcmV0dXJuIHN0YXRpY1F1ZXJ5SWRzLmRlbGV0ZShxdWVyeUlkKTsgfSk7XG4gICAgICAgIHJlc3VsdC5zZXQobm9kZSwgeyBzdGF0aWNRdWVyeUlkczogc3RhdGljUXVlcnlJZHMsIGR5bmFtaWNRdWVyeUlkczogZHluYW1pY1F1ZXJ5SWRzIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gbm9kZVN0YXRpY1F1ZXJ5SWRzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzdGF0aWNWaWV3UXVlcnlJZHMobm9kZVN0YXRpY1F1ZXJ5SWRzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhdGljUXVlcnlJZHMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZHluYW1pY1F1ZXJ5SWRzID0gbmV3IFNldCgpO1xuICAgIEFycmF5LmZyb20obm9kZVN0YXRpY1F1ZXJ5SWRzLnZhbHVlcygpKS5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICBlbnRyeS5zdGF0aWNRdWVyeUlkcy5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyeUlkKSB7IHJldHVybiBzdGF0aWNRdWVyeUlkcy5hZGQocXVlcnlJZCk7IH0pO1xuICAgICAgICBlbnRyeS5keW5hbWljUXVlcnlJZHMuZm9yRWFjaChmdW5jdGlvbiAocXVlcnlJZCkgeyByZXR1cm4gZHluYW1pY1F1ZXJ5SWRzLmFkZChxdWVyeUlkKTsgfSk7XG4gICAgfSk7XG4gICAgZHluYW1pY1F1ZXJ5SWRzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5SWQpIHsgcmV0dXJuIHN0YXRpY1F1ZXJ5SWRzLmRlbGV0ZShxdWVyeUlkKTsgfSk7XG4gICAgcmV0dXJuIHsgc3RhdGljUXVlcnlJZHM6IHN0YXRpY1F1ZXJ5SWRzLCBkeW5hbWljUXVlcnlJZHM6IGR5bmFtaWNRdWVyeUlkcyB9O1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGV2ZW50QXN0XG4gKiBAcGFyYW0gez99IGRpckFzdFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZWxlbWVudEV2ZW50TmFtZUFuZFRhcmdldChldmVudEFzdCwgZGlyQXN0KSB7XG4gICAgaWYgKGV2ZW50QXN0LmlzQW5pbWF0aW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBcIkBcIiArIGV2ZW50QXN0Lm5hbWUgKyBcIi5cIiArIGV2ZW50QXN0LnBoYXNlLFxuICAgICAgICAgICAgdGFyZ2V0OiBkaXJBc3QgJiYgZGlyQXN0LmRpcmVjdGl2ZS5pc0NvbXBvbmVudCA/ICdjb21wb25lbnQnIDogbnVsbFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50QXN0O1xuICAgIH1cbn1cbi8qKlxuICogQHBhcmFtIHs/fSBxdWVyeUlkc1xuICogQHBhcmFtIHs/fSBxdWVyeUlkXG4gKiBAcGFyYW0gez99IGlzRmlyc3RcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNhbGNTdGF0aWNEeW5hbWljUXVlcnlGbGFncyhxdWVyeUlkcywgcXVlcnlJZCwgaXNGaXJzdCkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGZsYWdzID0gMDtcbiAgICAvLyBOb3RlOiBXZSBvbmx5IG1ha2UgcXVlcmllcyBzdGF0aWMgdGhhdCBxdWVyeSBmb3IgYSBzaW5nbGUgaXRlbS5cbiAgICAvLyBUaGlzIGlzIGJlY2F1c2Ugb2YgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCB0aGUgb2xkIHZpZXcgY29tcGlsZXIuLi5cbiAgICBpZiAoaXNGaXJzdCAmJiAocXVlcnlJZHMuc3RhdGljUXVlcnlJZHMuaGFzKHF1ZXJ5SWQpIHx8ICFxdWVyeUlkcy5keW5hbWljUXVlcnlJZHMuaGFzKHF1ZXJ5SWQpKSkge1xuICAgICAgICBmbGFncyB8PSAyNjg0MzU0NTYgLyogU3RhdGljUXVlcnkgKi87XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmbGFncyB8PSA1MzY4NzA5MTIgLyogRHluYW1pY1F1ZXJ5ICovO1xuICAgIH1cbiAgICByZXR1cm4gZmxhZ3M7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgR2VuZXJhdGVkRmlsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcmNGaWxlVXJsXG4gICAgICogQHBhcmFtIHs/fSBnZW5GaWxlVXJsXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VPclN0bXRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gR2VuZXJhdGVkRmlsZShzcmNGaWxlVXJsLCBnZW5GaWxlVXJsLCBzb3VyY2VPclN0bXRzKSB7XG4gICAgICAgIHRoaXMuc3JjRmlsZVVybCA9IHNyY0ZpbGVVcmw7XG4gICAgICAgIHRoaXMuZ2VuRmlsZVVybCA9IGdlbkZpbGVVcmw7XG4gICAgICAgIGlmICh0eXBlb2Ygc291cmNlT3JTdG10cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlID0gc291cmNlT3JTdG10cztcbiAgICAgICAgICAgIHRoaXMuc3RtdHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zb3VyY2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5zdG10cyA9IHNvdXJjZU9yU3RtdHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEdlbmVyYXRlZEZpbGU7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IGZpbGVcbiAqIEBwYXJhbSB7Pz19IHByZWFtYmxlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB0b1R5cGVTY3JpcHQoZmlsZSwgcHJlYW1ibGUpIHtcbiAgICBpZiAocHJlYW1ibGUgPT09IHZvaWQgMCkgeyBwcmVhbWJsZSA9ICcnOyB9XG4gICAgaWYgKCFmaWxlLnN0bXRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgc3RhdGU6IE5vIHN0bXRzIHByZXNlbnQgb24gR2VuZXJhdGVkRmlsZSBcIiArIGZpbGUuZ2VuRmlsZVVybCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHlwZVNjcmlwdEVtaXR0ZXIoKS5lbWl0U3RhdGVtZW50cyhzb3VyY2VVcmwoZmlsZS5zcmNGaWxlVXJsKSwgZmlsZS5nZW5GaWxlVXJsLCBmaWxlLnN0bXRzLCBwcmVhbWJsZSk7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEBwYXJhbSB7P30gZm9ySml0Q3R4XG4gKiBAcGFyYW0gez99IHN1bW1hcnlSZXNvbHZlclxuICogQHBhcmFtIHs/fSBzeW1ib2xSZXNvbHZlclxuICogQHBhcmFtIHs/fSBzeW1ib2xzXG4gKiBAcGFyYW0gez99IHR5cGVzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzZXJpYWxpemVTdW1tYXJpZXMoZm9ySml0Q3R4LCBzdW1tYXJ5UmVzb2x2ZXIsIHN5bWJvbFJlc29sdmVyLCBzeW1ib2xzLCB0eXBlcykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHRvSnNvblNlcmlhbGl6ZXIgPSBuZXcgVG9Kc29uU2VyaWFsaXplcihzeW1ib2xSZXNvbHZlciwgc3VtbWFyeVJlc29sdmVyKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmb3JKaXRTZXJpYWxpemVyID0gbmV3IEZvckppdFNlcmlhbGl6ZXIoZm9ySml0Q3R4LCBzeW1ib2xSZXNvbHZlcik7XG4gICAgLy8gZm9yIHN5bWJvbHMsIHdlIHVzZSBldmVyeXRoaW5nIGV4Y2VwdCBmb3IgdGhlIGNsYXNzIG1ldGFkYXRhIGl0c2VsZlxuICAgIC8vICh3ZSBrZWVwIHRoZSBzdGF0aWNzIHRob3VnaCksIGFzIHRoZSBjbGFzcyBtZXRhZGF0YSBpcyBjb250YWluZWQgaW4gdGhlXG4gICAgLy8gQ29tcGlsZVR5cGVTdW1tYXJ5LlxuICAgIHN5bWJvbHMuZm9yRWFjaChmdW5jdGlvbiAocmVzb2x2ZWRTeW1ib2wpIHsgcmV0dXJuIHRvSnNvblNlcmlhbGl6ZXIuYWRkT3JNZXJnZVN1bW1hcnkoeyBzeW1ib2w6IHJlc29sdmVkU3ltYm9sLnN5bWJvbCwgbWV0YWRhdGE6IHJlc29sdmVkU3ltYm9sLm1ldGFkYXRhIH0pOyB9KTtcbiAgICAvLyBBZGQgc3VtbWFyaWVzIHRoYXQgYXJlIHJlZmVyZW5jZWQgYnkgdGhlIGdpdmVuIHN5bWJvbHMgKHRyYW5zaXRpdmVseSlcbiAgICAvLyBOb3RlOiB0aGUgc2VyaWFsaXplci5zeW1ib2xzIGFycmF5IG1pZ2h0IGJlIGdyb3dpbmcgd2hpbGVcbiAgICAvLyB3ZSBleGVjdXRlIHRoZSBsb29wIVxuICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvY2Vzc2VkSW5kZXggPSAwOyBwcm9jZXNzZWRJbmRleCA8IHRvSnNvblNlcmlhbGl6ZXIuc3ltYm9scy5sZW5ndGg7IHByb2Nlc3NlZEluZGV4KyspIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ltYm9sID0gdG9Kc29uU2VyaWFsaXplci5zeW1ib2xzW3Byb2Nlc3NlZEluZGV4XTtcbiAgICAgICAgaWYgKHN1bW1hcnlSZXNvbHZlci5pc0xpYnJhcnlGaWxlKHN5bWJvbC5maWxlUGF0aCkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN1bW1hcnkgPSBzdW1tYXJ5UmVzb2x2ZXIucmVzb2x2ZVN1bW1hcnkoc3ltYm9sKTtcbiAgICAgICAgICAgIGlmICghc3VtbWFyeSkge1xuICAgICAgICAgICAgICAgIC8vIHNvbWUgc3ltYm9scyBtaWdodCBvcmlnaW5hdGUgZnJvbSBhIHBsYWluIHR5cGVzY3JpcHQgbGlicmFyeVxuICAgICAgICAgICAgICAgIC8vIHRoYXQganVzdCBleHBvcnRlZCAuZC50cyBhbmQgLm1ldGFkYXRhLmpzb24gZmlsZXMsIGkuZS4gd2hlcmUgbm8gc3VtbWFyeVxuICAgICAgICAgICAgICAgIC8vIGZpbGVzIHdlcmUgY3JlYXRlZC5cbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXNvbHZlZFN5bWJvbCA9IHN5bWJvbFJlc29sdmVyLnJlc29sdmVTeW1ib2woc3ltYm9sKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWRTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtbWFyeSA9IHsgc3ltYm9sOiByZXNvbHZlZFN5bWJvbC5zeW1ib2wsIG1ldGFkYXRhOiByZXNvbHZlZFN5bWJvbC5tZXRhZGF0YSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdW1tYXJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1bW1hcnkudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3JKaXRTZXJpYWxpemVyLmFkZExpYlR5cGUoc3VtbWFyeS50eXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9Kc29uU2VyaWFsaXplci5hZGRPck1lcmdlU3VtbWFyeShzdW1tYXJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBZGQgdHlwZSBzdW1tYXJpZXMuXG4gICAgLy8gTm90ZTogV2UgZG9uJ3QgYWRkIHRoZSBzdW1tYXJpZXMgb2YgYWxsIHJlZmVyZW5jZWQgc3ltYm9scyBhcyBmb3IgdGhlIFJlc29sdmVkU3ltYm9scyxcbiAgICAvLyBhcyB0aGUgdHlwZSBzdW1tYXJpZXMgYWxyZWFkeSBjb250YWluIHRoZSB0cmFuc2l0aXZlIGRhdGEgdGhhdCB0aGV5IHJlcXVpcmVcbiAgICAvLyAoaW4gYSBtaW5pbWFsIHdheSkuXG4gICAgdHlwZXMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHN1bW1hcnkgPSBfYS5zdW1tYXJ5LCBtZXRhZGF0YSA9IF9hLm1ldGFkYXRhO1xuICAgICAgICBmb3JKaXRTZXJpYWxpemVyLmFkZFNvdXJjZVR5cGUoc3VtbWFyeSwgbWV0YWRhdGEpO1xuICAgICAgICB0b0pzb25TZXJpYWxpemVyLmFkZE9yTWVyZ2VTdW1tYXJ5KHsgc3ltYm9sOiBzdW1tYXJ5LnR5cGUucmVmZXJlbmNlLCBtZXRhZGF0YTogbnVsbCwgdHlwZTogc3VtbWFyeSB9KTtcbiAgICAgICAgaWYgKHN1bW1hcnkuc3VtbWFyeUtpbmQgPT09IENvbXBpbGVTdW1tYXJ5S2luZC5OZ01vZHVsZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmdNb2R1bGVTdW1tYXJ5ID0gKHN1bW1hcnkpO1xuICAgICAgICAgICAgbmdNb2R1bGVTdW1tYXJ5LmV4cG9ydGVkRGlyZWN0aXZlcy5jb25jYXQobmdNb2R1bGVTdW1tYXJ5LmV4cG9ydGVkUGlwZXMpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ltYm9sID0gaWQucmVmZXJlbmNlO1xuICAgICAgICAgICAgICAgIGlmIChzdW1tYXJ5UmVzb2x2ZXIuaXNMaWJyYXJ5RmlsZShzeW1ib2wuZmlsZVBhdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN1bW1hcnlfMSA9IHN1bW1hcnlSZXNvbHZlci5yZXNvbHZlU3VtbWFyeShzeW1ib2wpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3VtbWFyeV8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b0pzb25TZXJpYWxpemVyLmFkZE9yTWVyZ2VTdW1tYXJ5KHN1bW1hcnlfMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBfYSA9IHRvSnNvblNlcmlhbGl6ZXIuc2VyaWFsaXplKCksIGpzb24gPSBfYS5qc29uLCBleHBvcnRBcyA9IF9hLmV4cG9ydEFzO1xuICAgIGZvckppdFNlcmlhbGl6ZXIuc2VyaWFsaXplKGV4cG9ydEFzKTtcbiAgICByZXR1cm4geyBqc29uOiBqc29uLCBleHBvcnRBczogZXhwb3J0QXMgfTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBzeW1ib2xDYWNoZVxuICogQHBhcmFtIHs/fSBqc29uXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZVN1bW1hcmllcyhzeW1ib2xDYWNoZSwganNvbikge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlc2VyaWFsaXplciA9IG5ldyBGcm9tSnNvbkRlc2VyaWFsaXplcihzeW1ib2xDYWNoZSk7XG4gICAgcmV0dXJuIGRlc2VyaWFsaXplci5kZXNlcmlhbGl6ZShqc29uKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBvdXRwdXRDdHhcbiAqIEBwYXJhbSB7P30gcmVmZXJlbmNlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjcmVhdGVGb3JKaXRTdHViKG91dHB1dEN0eCwgcmVmZXJlbmNlKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVN1bW1hcnlGb3JKaXRGdW5jdGlvbihvdXRwdXRDdHgsIHJlZmVyZW5jZSwgTlVMTF9FWFBSKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBvdXRwdXRDdHhcbiAqIEBwYXJhbSB7P30gcmVmZXJlbmNlXG4gKiBAcGFyYW0gez99IHZhbHVlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjcmVhdGVTdW1tYXJ5Rm9ySml0RnVuY3Rpb24ob3V0cHV0Q3R4LCByZWZlcmVuY2UsIHZhbHVlKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZm5OYW1lID0gc3VtbWFyeUZvckppdE5hbWUocmVmZXJlbmNlLm5hbWUpO1xuICAgIG91dHB1dEN0eC5zdGF0ZW1lbnRzLnB1c2goZm4oW10sIFtuZXcgUmV0dXJuU3RhdGVtZW50KHZhbHVlKV0sIG5ldyBBcnJheVR5cGUoRFlOQU1JQ19UWVBFKSkudG9EZWNsU3RtdChmbk5hbWUsIFtcbiAgICAgICAgU3RtdE1vZGlmaWVyLkZpbmFsLCBTdG10TW9kaWZpZXIuRXhwb3J0ZWRcbiAgICBdKSk7XG59XG52YXIgVG9Kc29uU2VyaWFsaXplciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoVG9Kc29uU2VyaWFsaXplciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN5bWJvbFJlc29sdmVyXG4gICAgICogQHBhcmFtIHs/fSBzdW1tYXJ5UmVzb2x2ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUb0pzb25TZXJpYWxpemVyKHN5bWJvbFJlc29sdmVyLCBzdW1tYXJ5UmVzb2x2ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3ltYm9sUmVzb2x2ZXIgPSBzeW1ib2xSZXNvbHZlcjtcbiAgICAgICAgX3RoaXMuc3VtbWFyeVJlc29sdmVyID0gc3VtbWFyeVJlc29sdmVyO1xuICAgICAgICAvLyBOb3RlOiBUaGlzIG9ubHkgY29udGFpbnMgc3ltYm9scyB3aXRob3V0IG1lbWJlcnMuXG4gICAgICAgIF90aGlzLnN5bWJvbHMgPSBbXTtcbiAgICAgICAgX3RoaXMuaW5kZXhCeVN5bWJvbCA9IG5ldyBNYXAoKTtcbiAgICAgICAgX3RoaXMucHJvY2Vzc2VkU3VtbWFyeUJ5U3ltYm9sID0gbmV3IE1hcCgpO1xuICAgICAgICBfdGhpcy5wcm9jZXNzZWRTdW1tYXJpZXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN1bW1hcnlcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRvSnNvblNlcmlhbGl6ZXIucHJvdG90eXBlLmFkZE9yTWVyZ2VTdW1tYXJ5ID0gZnVuY3Rpb24gKHN1bW1hcnkpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ltYm9sTWV0YSA9IHN1bW1hcnkubWV0YWRhdGE7XG4gICAgICAgIGlmIChzeW1ib2xNZXRhICYmIHN5bWJvbE1ldGEuX19zeW1ib2xpYyA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgLy8gRm9yIGNsYXNzZXMsIHdlIGtlZXAgZXZlcnl0aGluZyBleGNlcHQgdGhlaXIgY2xhc3MgZGVjb3JhdG9ycy5cbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8ga2VlcCBlLmcuIHRoZSBjdG9yIGFyZ3MsIG1ldGhvZCBuYW1lcywgbWV0aG9kIGRlY29yYXRvcnNcbiAgICAgICAgICAgIC8vIHNvIHRoYXQgdGhlIGNsYXNzIGNhbiBiZSBleHRlbmRlZCBpbiBhbm90aGVyIGNvbXBpbGF0aW9uIHVuaXQuXG4gICAgICAgICAgICAvLyBXZSBkb24ndCBrZWVwIHRoZSBjbGFzcyBkZWNvcmF0b3JzIGFzXG4gICAgICAgICAgICAvLyAxKSB0aGV5IHJlZmVyIHRvIGRhdGFcbiAgICAgICAgICAgIC8vICAgdGhhdCBzaG91bGQgbm90IGNhdXNlIGEgcmVidWlsZCBvZiBkb3duc3RyZWFtIGNvbXBpbGF0aW9uIHVuaXRzXG4gICAgICAgICAgICAvLyAgIChlLmcuIGlubGluZSB0ZW1wbGF0ZXMgb2YgQENvbXBvbmVudCwgb3IgQE5nTW9kdWxlLmRlY2xhcmF0aW9ucylcbiAgICAgICAgICAgIC8vIDIpIHRoZWlyIGRhdGEgaXMgYWxyZWFkeSBjYXB0dXJlZCBpbiBUeXBlU3VtbWFyaWVzLCBlLmcuIERpcmVjdGl2ZVN1bW1hcnkuXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbG9uZV8xID0ge307XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzeW1ib2xNZXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wTmFtZSAhPT0gJ2RlY29yYXRvcnMnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lXzFbcHJvcE5hbWVdID0gc3ltYm9sTWV0YVtwcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzeW1ib2xNZXRhID0gY2xvbmVfMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9jZXNzZWRTdW1tYXJ5ID0gdGhpcy5wcm9jZXNzZWRTdW1tYXJ5QnlTeW1ib2wuZ2V0KHN1bW1hcnkuc3ltYm9sKTtcbiAgICAgICAgaWYgKCFwcm9jZXNzZWRTdW1tYXJ5KSB7XG4gICAgICAgICAgICBwcm9jZXNzZWRTdW1tYXJ5ID0gdGhpcy5wcm9jZXNzVmFsdWUoeyBzeW1ib2w6IHN1bW1hcnkuc3ltYm9sIH0pO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzZWRTdW1tYXJpZXMucHVzaChwcm9jZXNzZWRTdW1tYXJ5KTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2VkU3VtbWFyeUJ5U3ltYm9sLnNldChzdW1tYXJ5LnN5bWJvbCwgcHJvY2Vzc2VkU3VtbWFyeSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZTogPT0gb24gcHVycG9zZSB0byBjb21wYXJlIHdpdGggdW5kZWZpbmVkIVxuICAgICAgICBpZiAocHJvY2Vzc2VkU3VtbWFyeS5tZXRhZGF0YSA9PSBudWxsICYmIHN5bWJvbE1ldGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvY2Vzc2VkU3VtbWFyeS5tZXRhZGF0YSA9IHRoaXMucHJvY2Vzc1ZhbHVlKHN5bWJvbE1ldGEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGU6ID09IG9uIHB1cnBvc2UgdG8gY29tcGFyZSB3aXRoIHVuZGVmaW5lZCFcbiAgICAgICAgaWYgKHByb2Nlc3NlZFN1bW1hcnkudHlwZSA9PSBudWxsICYmIHN1bW1hcnkudHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBwcm9jZXNzZWRTdW1tYXJ5LnR5cGUgPSB0aGlzLnByb2Nlc3NWYWx1ZShzdW1tYXJ5LnR5cGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRvSnNvblNlcmlhbGl6ZXIucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwb3J0QXMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ganNvbiA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHN1bW1hcmllczogdGhpcy5wcm9jZXNzZWRTdW1tYXJpZXMsXG4gICAgICAgICAgICBzeW1ib2xzOiB0aGlzLnN5bWJvbHMubWFwKGZ1bmN0aW9uIChzeW1ib2wsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgc3ltYm9sLmFzc2VydE5vTWVtYmVycygpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGltcG9ydEFzID0gKCh1bmRlZmluZWQpKTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc3VtbWFyeVJlc29sdmVyLmlzTGlicmFyeUZpbGUoc3ltYm9sLmZpbGVQYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICBpbXBvcnRBcyA9IHN5bWJvbC5uYW1lICsgXCJfXCIgKyBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXMucHVzaCh7IHN5bWJvbDogc3ltYm9sLCBleHBvcnRBczogaW1wb3J0QXMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIF9fc3ltYm9sOiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogc3ltYm9sLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGNvbnZlcnQgdGhlIHNvdXJjZSBmaWxlbmFtZXMgdGludG8gb3V0cHV0IGZpbGVuYW1lcyxcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgdGhlIGdlbmVyYXRlZCBzdW1tYXJ5IGZpbGUgd2lsbCBiZSB1c2VkIHdoZW4gdGhlIGN1cnJlbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gY29tcGlsYXRpb24gdW5pdCBpcyB1c2VkIGFzIGEgbGlicmFyeVxuICAgICAgICAgICAgICAgICAgICBmaWxlUGF0aDogX3RoaXMuc3VtbWFyeVJlc29sdmVyLmdldExpYnJhcnlGaWxlTmFtZShzeW1ib2wuZmlsZVBhdGgpLFxuICAgICAgICAgICAgICAgICAgICBpbXBvcnRBczogaW1wb3J0QXNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IGpzb246IGpzb24sIGV4cG9ydEFzOiBleHBvcnRBcyB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVG9Kc29uU2VyaWFsaXplci5wcm90b3R5cGUucHJvY2Vzc1ZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2aXNpdFZhbHVlKHZhbHVlLCB0aGlzLCBudWxsKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUb0pzb25TZXJpYWxpemVyLnByb3RvdHlwZS52aXNpdE90aGVyID0gZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmFzZVN5bWJvbCA9IHRoaXMuc3ltYm9sUmVzb2x2ZXIuZ2V0U3RhdGljU3ltYm9sKHZhbHVlLmZpbGVQYXRoLCB2YWx1ZS5uYW1lKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluZGV4ID0gdGhpcy5pbmRleEJ5U3ltYm9sLmdldChiYXNlU3ltYm9sKTtcbiAgICAgICAgICAgIC8vIE5vdGU6ID09IG9uIHB1cnBvc2UgdG8gY29tcGFyZSB3aXRoIHVuZGVmaW5lZCFcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLmluZGV4QnlTeW1ib2wuc2l6ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4QnlTeW1ib2wuc2V0KGJhc2VTeW1ib2wsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLnN5bWJvbHMucHVzaChiYXNlU3ltYm9sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IF9fc3ltYm9sOiBpbmRleCwgbWVtYmVyczogdmFsdWUubWVtYmVycyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVG9Kc29uU2VyaWFsaXplcjtcbn0oVmFsdWVUcmFuc2Zvcm1lcikpO1xudmFyIEZvckppdFNlcmlhbGl6ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gb3V0cHV0Q3R4XG4gICAgICogQHBhcmFtIHs/fSBzeW1ib2xSZXNvbHZlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEZvckppdFNlcmlhbGl6ZXIob3V0cHV0Q3R4LCBzeW1ib2xSZXNvbHZlcikge1xuICAgICAgICB0aGlzLm91dHB1dEN0eCA9IG91dHB1dEN0eDtcbiAgICAgICAgdGhpcy5zeW1ib2xSZXNvbHZlciA9IHN5bWJvbFJlc29sdmVyO1xuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3VtbWFyeVxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEZvckppdFNlcmlhbGl6ZXIucHJvdG90eXBlLmFkZFNvdXJjZVR5cGUgPSBmdW5jdGlvbiAoc3VtbWFyeSwgbWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5kYXRhLnNldChzdW1tYXJ5LnR5cGUucmVmZXJlbmNlLCB7IHN1bW1hcnk6IHN1bW1hcnksIG1ldGFkYXRhOiBtZXRhZGF0YSwgaXNMaWJyYXJ5OiBmYWxzZSB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3VtbWFyeVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRm9ySml0U2VyaWFsaXplci5wcm90b3R5cGUuYWRkTGliVHlwZSA9IGZ1bmN0aW9uIChzdW1tYXJ5KSB7XG4gICAgICAgIHRoaXMuZGF0YS5zZXQoc3VtbWFyeS50eXBlLnJlZmVyZW5jZSwgeyBzdW1tYXJ5OiBzdW1tYXJ5LCBtZXRhZGF0YTogbnVsbCwgaXNMaWJyYXJ5OiB0cnVlIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHBvcnRBc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRm9ySml0U2VyaWFsaXplci5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKGV4cG9ydEFzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nTW9kdWxlU3ltYm9scyA9IG5ldyBTZXQoKTtcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLmRhdGEudmFsdWVzKCkpLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgc3VtbWFyeSA9IF9hLnN1bW1hcnksIG1ldGFkYXRhID0gX2EubWV0YWRhdGEsIGlzTGlicmFyeSA9IF9hLmlzTGlicmFyeTtcbiAgICAgICAgICAgIGlmIChzdW1tYXJ5LnN1bW1hcnlLaW5kID09PSBDb21waWxlU3VtbWFyeUtpbmQuTmdNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAvLyBjb2xsZWN0IHRoZSBzeW1ib2xzIHRoYXQgcmVmZXIgdG8gTmdNb2R1bGUgY2xhc3Nlcy5cbiAgICAgICAgICAgICAgICAvLyBOb3RlOiB3ZSBjYW4ndCBqdXN0IHJlbHkgb24gYHN1bW1hcnkudHlwZS5zdW1tYXJ5S2luZGAgdG8gZGV0ZXJtaW5lIHRoaXMgYXNcbiAgICAgICAgICAgICAgICAvLyB3ZSBkb24ndCBhZGQgdGhlIHN1bW1hcmllcyBvZiBhbGwgcmVmZXJlbmNlZCBzeW1ib2xzIHdoZW4gd2Ugc2VyaWFsaXplIHR5cGUgc3VtbWFyaWVzLlxuICAgICAgICAgICAgICAgIC8vIFNlZSBzZXJpYWxpemVTdW1tYXJpZXMgZm9yIGRldGFpbHMuXG4gICAgICAgICAgICAgICAgbmdNb2R1bGVTeW1ib2xzLmFkZChzdW1tYXJ5LnR5cGUucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtb2RTdW1tYXJ5ID0gKHN1bW1hcnkpO1xuICAgICAgICAgICAgICAgIG1vZFN1bW1hcnkubW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2QpIHsgbmdNb2R1bGVTeW1ib2xzLmFkZChtb2QucmVmZXJlbmNlKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzTGlicmFyeSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZuTmFtZSA9IHN1bW1hcnlGb3JKaXROYW1lKHN1bW1hcnkudHlwZS5yZWZlcmVuY2UubmFtZSk7XG4gICAgICAgICAgICAgICAgY3JlYXRlU3VtbWFyeUZvckppdEZ1bmN0aW9uKF90aGlzLm91dHB1dEN0eCwgc3VtbWFyeS50eXBlLnJlZmVyZW5jZSwgX3RoaXMuc2VyaWFsaXplU3VtbWFyeVdpdGhEZXBzKHN1bW1hcnksIC8qKiBAdHlwZSB7P30gKi8gKChtZXRhZGF0YSkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBleHBvcnRBcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ltYm9sID0gZW50cnkuc3ltYm9sO1xuICAgICAgICAgICAgaWYgKG5nTW9kdWxlU3ltYm9scy5oYXMoc3ltYm9sKSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGppdEV4cG9ydEFzTmFtZSA9IHN1bW1hcnlGb3JKaXROYW1lKGVudHJ5LmV4cG9ydEFzKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5vdXRwdXRDdHguc3RhdGVtZW50cy5wdXNoKHZhcmlhYmxlKGppdEV4cG9ydEFzTmFtZSkuc2V0KF90aGlzLnNlcmlhbGl6ZVN1bW1hcnlSZWYoc3ltYm9sKSkudG9EZWNsU3RtdChudWxsLCBbXG4gICAgICAgICAgICAgICAgICAgIFN0bXRNb2RpZmllci5FeHBvcnRlZFxuICAgICAgICAgICAgICAgIF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN1bW1hcnlcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBGb3JKaXRTZXJpYWxpemVyLnByb3RvdHlwZS5zZXJpYWxpemVTdW1tYXJ5V2l0aERlcHMgPSBmdW5jdGlvbiAoc3VtbWFyeSwgbWV0YWRhdGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwcmVzc2lvbnMgPSBbdGhpcy5zZXJpYWxpemVTdW1tYXJ5KHN1bW1hcnkpXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvdmlkZXJzID0gW107XG4gICAgICAgIGlmIChtZXRhZGF0YSBpbnN0YW5jZW9mIENvbXBpbGVOZ01vZHVsZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoLmFwcGx5KGV4cHJlc3Npb25zLCBcbiAgICAgICAgICAgIC8vIEZvciBkaXJlY3RpdmVzIC8gcGlwZXMsIHdlIG9ubHkgYWRkIHRoZSBkZWNsYXJlZCBvbmVzLFxuICAgICAgICAgICAgLy8gYW5kIHJlbHkgb24gdHJhbnNpdGl2ZWx5IGltcG9ydGluZyBOZ01vZHVsZXMgdG8gZ2V0IHRoZSB0cmFuc2l0aXZlXG4gICAgICAgICAgICAvLyBzdW1tYXJpZXMuXG4gICAgICAgICAgICBtZXRhZGF0YS5kZWNsYXJlZERpcmVjdGl2ZXMuY29uY2F0KG1ldGFkYXRhLmRlY2xhcmVkUGlwZXMpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdHlwZS5yZWZlcmVuY2U7IH0pXG4gICAgICAgICAgICAgICAgLmNvbmNhdChtZXRhZGF0YS50cmFuc2l0aXZlTW9kdWxlLm1vZHVsZXMubWFwKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0eXBlLnJlZmVyZW5jZTsgfSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChyZWYpIHsgcmV0dXJuIHJlZiAhPT0gbWV0YWRhdGEudHlwZS5yZWZlcmVuY2U7IH0pKVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHJlZikgeyByZXR1cm4gX3RoaXMuc2VyaWFsaXplU3VtbWFyeVJlZihyZWYpOyB9KSk7XG4gICAgICAgICAgICAvLyBOb3RlOiBXZSBkb24ndCB1c2UgYE5nTW9kdWxlU3VtbWFyeS5wcm92aWRlcnNgLCBhcyB0aGF0IG9uZSBpcyB0cmFuc2l0aXZlLFxuICAgICAgICAgICAgLy8gYW5kIHdlIGFscmVhZHkgaGF2ZSB0cmFuc2l0aXZlIG1vZHVsZXMuXG4gICAgICAgICAgICBwcm92aWRlcnMgPSBtZXRhZGF0YS5wcm92aWRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3VtbWFyeS5zdW1tYXJ5S2luZCA9PT0gQ29tcGlsZVN1bW1hcnlLaW5kLkRpcmVjdGl2ZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlyU3VtbWFyeSA9IChzdW1tYXJ5KTtcbiAgICAgICAgICAgIHByb3ZpZGVycyA9IGRpclN1bW1hcnkucHJvdmlkZXJzLmNvbmNhdChkaXJTdW1tYXJ5LnZpZXdQcm92aWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGU6IFdlIGNhbid0IGp1c3QgcmVmZXIgdG8gdGhlIGBuZ3N1bW1hcnkudHNgIGZpbGVzIGZvciBgdXNlQ2xhc3NgIHByb3ZpZGVycyAoYXMgd2UgZG8gZm9yXG4gICAgICAgIC8vIGRlY2xhcmVkRGlyZWN0aXZlcyAvIGRlY2xhcmVkUGlwZXMpLCBhcyB3ZSBhbGxvd1xuICAgICAgICAvLyBwcm92aWRlcnMgd2l0aG91dCBjdG9yIGFyZ3VtZW50cyB0byBza2lwIHRoZSBgQEluamVjdGFibGVgIGRlY29yYXRvcixcbiAgICAgICAgLy8gaS5lLiB3ZSBkaWRuJ3QgZ2VuZXJhdGUgLm5nc3VtbWFyeS50cyBmaWxlcyBmb3IgdGhlc2UuXG4gICAgICAgIGV4cHJlc3Npb25zLnB1c2guYXBwbHkoZXhwcmVzc2lvbnMsIHByb3ZpZGVycy5maWx0ZXIoZnVuY3Rpb24gKHByb3ZpZGVyKSB7IHJldHVybiAhIXByb3ZpZGVyLnVzZUNsYXNzOyB9KS5tYXAoZnVuY3Rpb24gKHByb3ZpZGVyKSB7IHJldHVybiBfdGhpcy5zZXJpYWxpemVTdW1tYXJ5KC8qKiBAdHlwZSB7P30gKi8gKHtcbiAgICAgICAgICAgIHN1bW1hcnlLaW5kOiBDb21waWxlU3VtbWFyeUtpbmQuSW5qZWN0YWJsZSwgdHlwZTogcHJvdmlkZXIudXNlQ2xhc3NcbiAgICAgICAgfSkpOyB9KSk7XG4gICAgICAgIHJldHVybiBsaXRlcmFsQXJyKGV4cHJlc3Npb25zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVN5bWJvbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRm9ySml0U2VyaWFsaXplci5wcm90b3R5cGUuc2VyaWFsaXplU3VtbWFyeVJlZiA9IGZ1bmN0aW9uICh0eXBlU3ltYm9sKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGppdEltcG9ydGVkU3ltYm9sID0gdGhpcy5zeW1ib2xSZXNvbHZlci5nZXRTdGF0aWNTeW1ib2woc3VtbWFyeUZvckppdEZpbGVOYW1lKHR5cGVTeW1ib2wuZmlsZVBhdGgpLCBzdW1tYXJ5Rm9ySml0TmFtZSh0eXBlU3ltYm9sLm5hbWUpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0cHV0Q3R4LmltcG9ydEV4cHIoaml0SW1wb3J0ZWRTeW1ib2wpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkYXRhXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBGb3JKaXRTZXJpYWxpemVyLnByb3RvdHlwZS5zZXJpYWxpemVTdW1tYXJ5ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3V0cHV0Q3R4ID0gdGhpcy5vdXRwdXRDdHg7XG4gICAgICAgIHZhciBUcmFuc2Zvcm1lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBUcmFuc2Zvcm1lcigpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhcnJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0QXJyYXkgPSBmdW5jdGlvbiAoYXJyLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gbGl0ZXJhbEFycihhcnIubWFwKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gdmlzaXRWYWx1ZShlbnRyeSwgX3RoaXMsIGNvbnRleHQpOyB9KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IG1hcFxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRTdHJpbmdNYXAgPSBmdW5jdGlvbiAobWFwLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxNYXBFeHByKE9iamVjdC5rZXlzKG1hcCkubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIG5ldyBMaXRlcmFsTWFwRW50cnkoa2V5LCB2aXNpdFZhbHVlKG1hcFtrZXldLCBfdGhpcywgY29udGV4dCksIGZhbHNlKTsgfSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRQcmltaXRpdmUgPSBmdW5jdGlvbiAodmFsdWUsIGNvbnRleHQpIHsgcmV0dXJuIGxpdGVyYWwodmFsdWUpOyB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdE90aGVyID0gZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXRDdHguaW1wb3J0RXhwcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIFN0YXRlOiBFbmNvdW50ZXJlZCB2YWx1ZSBcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIFRyYW5zZm9ybWVyO1xuICAgICAgICB9KCkpO1xuICAgICAgICByZXR1cm4gdmlzaXRWYWx1ZShkYXRhLCBuZXcgVHJhbnNmb3JtZXIoKSwgbnVsbCk7XG4gICAgfTtcbiAgICByZXR1cm4gRm9ySml0U2VyaWFsaXplcjtcbn0oKSk7XG52YXIgRnJvbUpzb25EZXNlcmlhbGl6ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEZyb21Kc29uRGVzZXJpYWxpemVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3ltYm9sQ2FjaGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBGcm9tSnNvbkRlc2VyaWFsaXplcihzeW1ib2xDYWNoZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zeW1ib2xDYWNoZSA9IHN5bWJvbENhY2hlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30ganNvblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRnJvbUpzb25EZXNlcmlhbGl6ZXIucHJvdG90eXBlLmRlc2VyaWFsaXplID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGF0YSA9IEpTT04ucGFyc2UoanNvbik7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGltcG9ydEFzID0gW107XG4gICAgICAgIHRoaXMuc3ltYm9scyA9IFtdO1xuICAgICAgICBkYXRhLnN5bWJvbHMuZm9yRWFjaChmdW5jdGlvbiAoc2VyaWFsaXplZFN5bWJvbCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ltYm9sID0gX3RoaXMuc3ltYm9sQ2FjaGUuZ2V0KHNlcmlhbGl6ZWRTeW1ib2wuZmlsZVBhdGgsIHNlcmlhbGl6ZWRTeW1ib2wubmFtZSk7XG4gICAgICAgICAgICBfdGhpcy5zeW1ib2xzLnB1c2goc3ltYm9sKTtcbiAgICAgICAgICAgIGlmIChzZXJpYWxpemVkU3ltYm9sLmltcG9ydEFzKSB7XG4gICAgICAgICAgICAgICAgaW1wb3J0QXMucHVzaCh7IHN5bWJvbDogc3ltYm9sLCBpbXBvcnRBczogc2VyaWFsaXplZFN5bWJvbC5pbXBvcnRBcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN1bW1hcmllcyA9IHZpc2l0VmFsdWUoZGF0YS5zdW1tYXJpZXMsIHRoaXMsIG51bGwpO1xuICAgICAgICByZXR1cm4geyBzdW1tYXJpZXM6IHN1bW1hcmllcywgaW1wb3J0QXM6IGltcG9ydEFzIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1hcFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRnJvbUpzb25EZXNlcmlhbGl6ZXIucHJvdG90eXBlLnZpc2l0U3RyaW5nTWFwID0gZnVuY3Rpb24gKG1hcCwgY29udGV4dCkge1xuICAgICAgICBpZiAoJ19fc3ltYm9sJyBpbiBtYXApIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJhc2VTeW1ib2wgPSB0aGlzLnN5bWJvbHNbbWFwWydfX3N5bWJvbCddXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lbWJlcnMgPSBtYXBbJ21lbWJlcnMnXTtcbiAgICAgICAgICAgIHJldHVybiBtZW1iZXJzLmxlbmd0aCA/IHRoaXMuc3ltYm9sQ2FjaGUuZ2V0KGJhc2VTeW1ib2wuZmlsZVBhdGgsIGJhc2VTeW1ib2wubmFtZSwgbWVtYmVycykgOlxuICAgICAgICAgICAgICAgIGJhc2VTeW1ib2w7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS52aXNpdFN0cmluZ01hcC5jYWxsKHRoaXMsIG1hcCwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBGcm9tSnNvbkRlc2VyaWFsaXplcjtcbn0oVmFsdWVUcmFuc2Zvcm1lcikpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEFvdENvbXBpbGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9jb25maWdcbiAgICAgKiBAcGFyYW0gez99IF9ob3N0XG4gICAgICogQHBhcmFtIHs/fSBfcmVmbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBfbWV0YWRhdGFSZXNvbHZlclxuICAgICAqIEBwYXJhbSB7P30gX3RlbXBsYXRlUGFyc2VyXG4gICAgICogQHBhcmFtIHs/fSBfc3R5bGVDb21waWxlclxuICAgICAqIEBwYXJhbSB7P30gX3ZpZXdDb21waWxlclxuICAgICAqIEBwYXJhbSB7P30gX25nTW9kdWxlQ29tcGlsZXJcbiAgICAgKiBAcGFyYW0gez99IF9vdXRwdXRFbWl0dGVyXG4gICAgICogQHBhcmFtIHs/fSBfc3VtbWFyeVJlc29sdmVyXG4gICAgICogQHBhcmFtIHs/fSBfbG9jYWxlSWRcbiAgICAgKiBAcGFyYW0gez99IF90cmFuc2xhdGlvbkZvcm1hdFxuICAgICAqIEBwYXJhbSB7P30gX2VuYWJsZVN1bW1hcmllc0ZvckppdFxuICAgICAqIEBwYXJhbSB7P30gX3N5bWJvbFJlc29sdmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gQW90Q29tcGlsZXIoX2NvbmZpZywgX2hvc3QsIF9yZWZsZWN0b3IsIF9tZXRhZGF0YVJlc29sdmVyLCBfdGVtcGxhdGVQYXJzZXIsIF9zdHlsZUNvbXBpbGVyLCBfdmlld0NvbXBpbGVyLCBfbmdNb2R1bGVDb21waWxlciwgX291dHB1dEVtaXR0ZXIsIF9zdW1tYXJ5UmVzb2x2ZXIsIF9sb2NhbGVJZCwgX3RyYW5zbGF0aW9uRm9ybWF0LCBfZW5hYmxlU3VtbWFyaWVzRm9ySml0LCBfc3ltYm9sUmVzb2x2ZXIpIHtcbiAgICAgICAgdGhpcy5fY29uZmlnID0gX2NvbmZpZztcbiAgICAgICAgdGhpcy5faG9zdCA9IF9ob3N0O1xuICAgICAgICB0aGlzLl9yZWZsZWN0b3IgPSBfcmVmbGVjdG9yO1xuICAgICAgICB0aGlzLl9tZXRhZGF0YVJlc29sdmVyID0gX21ldGFkYXRhUmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlUGFyc2VyID0gX3RlbXBsYXRlUGFyc2VyO1xuICAgICAgICB0aGlzLl9zdHlsZUNvbXBpbGVyID0gX3N0eWxlQ29tcGlsZXI7XG4gICAgICAgIHRoaXMuX3ZpZXdDb21waWxlciA9IF92aWV3Q29tcGlsZXI7XG4gICAgICAgIHRoaXMuX25nTW9kdWxlQ29tcGlsZXIgPSBfbmdNb2R1bGVDb21waWxlcjtcbiAgICAgICAgdGhpcy5fb3V0cHV0RW1pdHRlciA9IF9vdXRwdXRFbWl0dGVyO1xuICAgICAgICB0aGlzLl9zdW1tYXJ5UmVzb2x2ZXIgPSBfc3VtbWFyeVJlc29sdmVyO1xuICAgICAgICB0aGlzLl9sb2NhbGVJZCA9IF9sb2NhbGVJZDtcbiAgICAgICAgdGhpcy5fdHJhbnNsYXRpb25Gb3JtYXQgPSBfdHJhbnNsYXRpb25Gb3JtYXQ7XG4gICAgICAgIHRoaXMuX2VuYWJsZVN1bW1hcmllc0ZvckppdCA9IF9lbmFibGVTdW1tYXJpZXNGb3JKaXQ7XG4gICAgICAgIHRoaXMuX3N5bWJvbFJlc29sdmVyID0gX3N5bWJvbFJlc29sdmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFvdENvbXBpbGVyLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmNsZWFyQ2FjaGUoKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJvb3RGaWxlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW90Q29tcGlsZXIucHJvdG90eXBlLmFuYWx5emVNb2R1bGVzU3luYyA9IGZ1bmN0aW9uIChyb290RmlsZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvZ3JhbVN5bWJvbHMgPSBleHRyYWN0UHJvZ3JhbVN5bWJvbHModGhpcy5fc3ltYm9sUmVzb2x2ZXIsIHJvb3RGaWxlcywgdGhpcy5faG9zdCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFuYWx5emVSZXN1bHQgPSBhbmFseXplQW5kVmFsaWRhdGVOZ01vZHVsZXMocHJvZ3JhbVN5bWJvbHMsIHRoaXMuX2hvc3QsIHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIpO1xuICAgICAgICBhbmFseXplUmVzdWx0Lm5nTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChuZ01vZHVsZSkgeyByZXR1cm4gX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIubG9hZE5nTW9kdWxlRGlyZWN0aXZlQW5kUGlwZU1ldGFkYXRhKG5nTW9kdWxlLnR5cGUucmVmZXJlbmNlLCB0cnVlKTsgfSk7XG4gICAgICAgIHJldHVybiBhbmFseXplUmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByb290RmlsZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFvdENvbXBpbGVyLnByb3RvdHlwZS5hbmFseXplTW9kdWxlc0FzeW5jID0gZnVuY3Rpb24gKHJvb3RGaWxlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9ncmFtU3ltYm9scyA9IGV4dHJhY3RQcm9ncmFtU3ltYm9scyh0aGlzLl9zeW1ib2xSZXNvbHZlciwgcm9vdEZpbGVzLCB0aGlzLl9ob3N0KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYW5hbHl6ZVJlc3VsdCA9IGFuYWx5emVBbmRWYWxpZGF0ZU5nTW9kdWxlcyhwcm9ncmFtU3ltYm9scywgdGhpcy5faG9zdCwgdGhpcy5fbWV0YWRhdGFSZXNvbHZlcik7XG4gICAgICAgIHJldHVybiBQcm9taXNlXG4gICAgICAgICAgICAuYWxsKGFuYWx5emVSZXN1bHQubmdNb2R1bGVzLm1hcChmdW5jdGlvbiAobmdNb2R1bGUpIHsgcmV0dXJuIF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmxvYWROZ01vZHVsZURpcmVjdGl2ZUFuZFBpcGVNZXRhZGF0YShuZ01vZHVsZS50eXBlLnJlZmVyZW5jZSwgZmFsc2UpOyB9KSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFuYWx5emVSZXN1bHQ7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhbmFseXplUmVzdWx0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBb3RDb21waWxlci5wcm90b3R5cGUuZW1pdEFsbFN0dWJzID0gZnVuY3Rpb24gKGFuYWx5emVSZXN1bHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGZpbGVzID0gYW5hbHl6ZVJlc3VsdC5maWxlcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlTW9kdWxlcyA9IGZpbGVzLm1hcChmdW5jdGlvbiAoZmlsZSkgeyByZXR1cm4gX3RoaXMuX2NvbXBpbGVTdHViRmlsZShmaWxlLnNyY1VybCwgZmlsZS5kaXJlY3RpdmVzLCBmaWxlLnBpcGVzLCBmaWxlLm5nTW9kdWxlcywgZmFsc2UpOyB9KTtcbiAgICAgICAgcmV0dXJuIGZsYXR0ZW4oc291cmNlTW9kdWxlcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFuYWx5emVSZXN1bHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFvdENvbXBpbGVyLnByb3RvdHlwZS5lbWl0UGFydGlhbFN0dWJzID0gZnVuY3Rpb24gKGFuYWx5emVSZXN1bHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGZpbGVzID0gYW5hbHl6ZVJlc3VsdC5maWxlcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlTW9kdWxlcyA9IGZpbGVzLm1hcChmdW5jdGlvbiAoZmlsZSkgeyByZXR1cm4gX3RoaXMuX2NvbXBpbGVTdHViRmlsZShmaWxlLnNyY1VybCwgZmlsZS5kaXJlY3RpdmVzLCBmaWxlLnBpcGVzLCBmaWxlLm5nTW9kdWxlcywgdHJ1ZSk7IH0pO1xuICAgICAgICByZXR1cm4gZmxhdHRlbihzb3VyY2VNb2R1bGVzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYW5hbHl6ZVJlc3VsdFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW90Q29tcGlsZXIucHJvdG90eXBlLmVtaXRBbGxJbXBscyA9IGZ1bmN0aW9uIChhbmFseXplUmVzdWx0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBuZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlID0gYW5hbHl6ZVJlc3VsdC5uZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlLCBmaWxlcyA9IGFuYWx5emVSZXN1bHQuZmlsZXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvdXJjZU1vZHVsZXMgPSBmaWxlcy5tYXAoZnVuY3Rpb24gKGZpbGUpIHsgcmV0dXJuIF90aGlzLl9jb21waWxlSW1wbEZpbGUoZmlsZS5zcmNVcmwsIG5nTW9kdWxlQnlQaXBlT3JEaXJlY3RpdmUsIGZpbGUuZGlyZWN0aXZlcywgZmlsZS5waXBlcywgZmlsZS5uZ01vZHVsZXMsIGZpbGUuaW5qZWN0YWJsZXMpOyB9KTtcbiAgICAgICAgcmV0dXJuIGZsYXR0ZW4oc291cmNlTW9kdWxlcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNyY0ZpbGVVcmxcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZXNcbiAgICAgKiBAcGFyYW0gez99IHBpcGVzXG4gICAgICogQHBhcmFtIHs/fSBuZ01vZHVsZXNcbiAgICAgKiBAcGFyYW0gez99IHBhcnRpYWxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFvdENvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZVN0dWJGaWxlID0gZnVuY3Rpb24gKHNyY0ZpbGVVcmwsIGRpcmVjdGl2ZXMsIHBpcGVzLCBuZ01vZHVsZXMsIHBhcnRpYWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gcGFydGlhbCBpcyB0cnVlIHdoZW4gd2Ugb25seSBuZWVkIHRoZSBmaWxlcyB3ZSBhcmUgY2VydGFpbiB3aWxsIHByb2R1Y2UgYSBmYWN0b3J5IGFuZC9vclxuICAgICAgICAvLyBzdW1tYXJ5LlxuICAgICAgICAvLyBUaGlzIGlzIHRoZSBub3JtYWwgY2FzZSBmb3IgYG5nY2AgYnV0IGlmIHdlIGFzc3VtZSBsaWJyYXJ5aWVzIGFyZSBnZW5lcmF0aW5nIHRoZWlyIG93blxuICAgICAgICAvLyBmYWN0b3JpZXNcbiAgICAgICAgLy8gdGhlbiB3ZSBtaWdodCBuZWVkIGEgZmFjdG9yeSBmb3IgYSBmaWxlIHRoYXQgcmUtZXhwb3J0cyBhIG1vZHVsZSBvciBmYWN0b3J5IHdoaWNoIHdlIGNhbm5vdFxuICAgICAgICAvLyBrbm93XG4gICAgICAgIC8vIGFoZWFkIG9mIHRpbWUgc28gd2UgbmVlZCBhIHN0dWIgZ2VuZXJhdGUgZm9yIGFsbCBub24tLmQudHMgZmlsZXMuIFRoZSAuZC50cyBmaWxlcyBkbyBub3QgbmVlZFxuICAgICAgICAvLyB0b1xuICAgICAgICAvLyBiZSBleGNsdWRlZCBoZXJlIGJlY2F1c2UgdGhleSBhcmUgZXhjbHVkZWQgd2hlbiB0aGUgbW9kdWxlcyBhcmUgYW5hbHl6ZWQuIElmIGEgZmFjdG9yeSBlbmRzXG4gICAgICAgIC8vIHVwXG4gICAgICAgIC8vIG5vdCBiZWluZyBuZWVkZWQsIHRoZSBmYWN0b3J5IGZpbGUgaXMgbm90IHdyaXR0ZW4gaW4gd3JpdGVGaWxlIGNhbGxiYWNrLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmaWxlU3VmZml4ID0gc3BsaXRUeXBlc2NyaXB0U3VmZml4KHNyY0ZpbGVVcmwsIHRydWUpWzFdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBnZW5lcmF0ZWRGaWxlcyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZ0ZhY3RvcnlPdXRwdXRDdHggPSB0aGlzLl9jcmVhdGVPdXRwdXRDb250ZXh0KG5nZmFjdG9yeUZpbGVQYXRoKHNyY0ZpbGVVcmwsIHRydWUpKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaml0U3VtbWFyeU91dHB1dEN0eCA9IHRoaXMuX2NyZWF0ZU91dHB1dENvbnRleHQoc3VtbWFyeUZvckppdEZpbGVOYW1lKHNyY0ZpbGVVcmwsIHRydWUpKTtcbiAgICAgICAgLy8gY3JlYXRlIGV4cG9ydHMgdGhhdCB1c2VyIGNvZGUgY2FuIHJlZmVyZW5jZVxuICAgICAgICBuZ01vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobmdNb2R1bGVSZWZlcmVuY2UpIHtcbiAgICAgICAgICAgIF90aGlzLl9uZ01vZHVsZUNvbXBpbGVyLmNyZWF0ZVN0dWIobmdGYWN0b3J5T3V0cHV0Q3R4LCBuZ01vZHVsZVJlZmVyZW5jZSk7XG4gICAgICAgICAgICBjcmVhdGVGb3JKaXRTdHViKGppdFN1bW1hcnlPdXRwdXRDdHgsIG5nTW9kdWxlUmVmZXJlbmNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnRpYWxKaXRTdHViUmVxdWlyZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFydGlhbEZhY3RvcnlTdHViUmVxdWlyZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gY3JlYXRlIHN0dWJzIGZvciBleHRlcm5hbCBzdHlsZXNoZWV0cyAoYWx3YXlzIGVtcHR5LCBhcyB1c2VycyBzaG91bGQgbm90IGltcG9ydCBhbnl0aGluZyBmcm9tXG4gICAgICAgIC8vIHRoZSBnZW5lcmF0ZWQgY29kZSlcbiAgICAgICAgZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJUeXBlKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wTWV0YSA9IF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldERpcmVjdGl2ZU1ldGFkYXRhKC8qKiBAdHlwZSB7P30gKi8gKGRpclR5cGUpKTtcbiAgICAgICAgICAgIHBhcnRpYWxKaXRTdHViUmVxdWlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCFjb21wTWV0YS5pc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgKChcbiAgICAgICAgICAgIC8vIE5vdGU6IGNvbXBNZXRhIGlzIGEgY29tcG9uZW50IGFuZCB0aGVyZWZvcmUgdGVtcGxhdGUgaXMgbm9uIG51bGwuXG4gICAgICAgICAgICBjb21wTWV0YS50ZW1wbGF0ZSkpLmV4dGVybmFsU3R5bGVzaGVldHMuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGVzaGVldE1ldGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZUNvbnRleHQgPSBfdGhpcy5fY3JlYXRlT3V0cHV0Q29udGV4dChfc3R5bGVzTW9kdWxlVXJsKC8qKiBAdHlwZSB7P30gKi8gKChzdHlsZXNoZWV0TWV0YS5tb2R1bGVVcmwpKSwgX3RoaXMuX3N0eWxlQ29tcGlsZXIubmVlZHNTdHlsZVNoaW0oY29tcE1ldGEpLCBmaWxlU3VmZml4KSk7XG4gICAgICAgICAgICAgICAgX2NyZWF0ZVR5cGVSZWZlcmVuY2VTdHViKHN0eWxlQ29udGV4dCwgSWRlbnRpZmllcnMuQ29tcG9uZW50RmFjdG9yeSk7XG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVkRmlsZXMucHVzaChfdGhpcy5fY29kZWdlblNvdXJjZU1vZHVsZSgvKiogQHR5cGUgez99ICovICgoc3R5bGVzaGVldE1ldGEubW9kdWxlVXJsKSksIHN0eWxlQ29udGV4dCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYXJ0aWFsRmFjdG9yeVN0dWJSZXF1aXJlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBJZiB3ZSBuZWVkIGFsbCB0aGUgc3R1YnMgdG8gYmUgZ2VuZXJhdGVkIHRoZW4gaW5zZXJ0IGFuIGFyYml0cmFyeSByZWZlcmVuY2UgaW50byB0aGUgc3R1YlxuICAgICAgICBpZiAoKHBhcnRpYWxGYWN0b3J5U3R1YlJlcXVpcmVkIHx8ICFwYXJ0aWFsKSAmJiBuZ0ZhY3RvcnlPdXRwdXRDdHguc3RhdGVtZW50cy5sZW5ndGggPD0gMCkge1xuICAgICAgICAgICAgX2NyZWF0ZVR5cGVSZWZlcmVuY2VTdHViKG5nRmFjdG9yeU91dHB1dEN0eCwgSWRlbnRpZmllcnMuQ29tcG9uZW50RmFjdG9yeSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChwYXJ0aWFsSml0U3R1YlJlcXVpcmVkIHx8ICFwYXJ0aWFsIHx8IChwaXBlcyAmJiBwaXBlcy5sZW5ndGggPiAwKSkgJiZcbiAgICAgICAgICAgIGppdFN1bW1hcnlPdXRwdXRDdHguc3RhdGVtZW50cy5sZW5ndGggPD0gMCkge1xuICAgICAgICAgICAgX2NyZWF0ZVR5cGVSZWZlcmVuY2VTdHViKGppdFN1bW1hcnlPdXRwdXRDdHgsIElkZW50aWZpZXJzLkNvbXBvbmVudEZhY3RvcnkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGU6IHdlIGFyZSBjcmVhdGluZyBzdHViIG5nZmFjdG9yeS9uZ3N1bW1hcnkgZm9yIGFsbCBzb3VyY2UgZmlsZXMsXG4gICAgICAgIC8vIGFzIHRoZSByZWFsIGNhbGN1bGF0aW9uIHJlcXVpcmVzIGFsbW9zdCB0aGUgc2FtZSBsb2dpYyBhcyBwcm9kdWNpbmcgdGhlIHJlYWwgY29udGVudCBmb3JcbiAgICAgICAgLy8gdGhlbS4gT3VyIHBpcGVsaW5lIHdpbGwgZmlsdGVyIG91dCBlbXB0eSBvbmVzIGF0IHRoZSBlbmQuIEJlY2F1c2Ugb2YgdGhpcyBmaWx0ZXIsIGhvd2V2ZXIsXG4gICAgICAgIC8vIHN0dWIgcmVmZXJlbmNlcyB0byB0aGUgcmVmZXJlbmNlIHR5cGUgbmVlZHMgdG8gYmUgZ2VuZXJhdGVkIGV2ZW4gaWYgdGhlIHVzZXIgY2Fubm90XG4gICAgICAgIC8vIHJlZmVyIHRvIHR5cGUgZnJvbSB0aGUgYC5kLnRzYCBmaWxlIHRvIHByZXZlbnQgdGhlIGZpbGUgYmVpbmcgZWxpZGVkIGZyb20gdGhlIGVtaXQuXG4gICAgICAgIGdlbmVyYXRlZEZpbGVzLnB1c2godGhpcy5fY29kZWdlblNvdXJjZU1vZHVsZShzcmNGaWxlVXJsLCBuZ0ZhY3RvcnlPdXRwdXRDdHgpKTtcbiAgICAgICAgaWYgKHRoaXMuX2VuYWJsZVN1bW1hcmllc0ZvckppdCkge1xuICAgICAgICAgICAgZ2VuZXJhdGVkRmlsZXMucHVzaCh0aGlzLl9jb2RlZ2VuU291cmNlTW9kdWxlKHNyY0ZpbGVVcmwsIGppdFN1bW1hcnlPdXRwdXRDdHgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2VuZXJhdGVkRmlsZXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNyY0ZpbGVVcmxcbiAgICAgKiBAcGFyYW0gez99IG5nTW9kdWxlQnlQaXBlT3JEaXJlY3RpdmVcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZXNcbiAgICAgKiBAcGFyYW0gez99IHBpcGVzXG4gICAgICogQHBhcmFtIHs/fSBuZ01vZHVsZXNcbiAgICAgKiBAcGFyYW0gez99IGluamVjdGFibGVzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBb3RDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVJbXBsRmlsZSA9IGZ1bmN0aW9uIChzcmNGaWxlVXJsLCBuZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlLCBkaXJlY3RpdmVzLCBwaXBlcywgbmdNb2R1bGVzLCBpbmplY3RhYmxlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmaWxlU3VmZml4ID0gc3BsaXRUeXBlc2NyaXB0U3VmZml4KHNyY0ZpbGVVcmwsIHRydWUpWzFdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBnZW5lcmF0ZWRGaWxlcyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvdXRwdXRDdHggPSB0aGlzLl9jcmVhdGVPdXRwdXRDb250ZXh0KG5nZmFjdG9yeUZpbGVQYXRoKHNyY0ZpbGVVcmwsIHRydWUpKTtcbiAgICAgICAgZ2VuZXJhdGVkRmlsZXMucHVzaC5hcHBseShnZW5lcmF0ZWRGaWxlcywgdGhpcy5fY3JlYXRlU3VtbWFyeShzcmNGaWxlVXJsLCBkaXJlY3RpdmVzLCBwaXBlcywgbmdNb2R1bGVzLCBpbmplY3RhYmxlcywgb3V0cHV0Q3R4KSk7XG4gICAgICAgIC8vIGNvbXBpbGUgYWxsIG5nIG1vZHVsZXNcbiAgICAgICAgbmdNb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKG5nTW9kdWxlVHlwZSkgeyByZXR1cm4gX3RoaXMuX2NvbXBpbGVNb2R1bGUob3V0cHV0Q3R4LCBuZ01vZHVsZVR5cGUpOyB9KTtcbiAgICAgICAgLy8gY29tcGlsZSBjb21wb25lbnRzXG4gICAgICAgIGRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyVHlwZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcE1ldGEgPSBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXREaXJlY3RpdmVNZXRhZGF0YSgvKiogQHR5cGUgez99ICovIChkaXJUeXBlKSk7XG4gICAgICAgICAgICBpZiAoIWNvbXBNZXRhLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmdNb2R1bGUgPSBuZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlLmdldChkaXJUeXBlKTtcbiAgICAgICAgICAgIGlmICghbmdNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnRlcm5hbCBFcnJvcjogY2Fubm90IGRldGVybWluZSB0aGUgbW9kdWxlIGZvciBjb21wb25lbnQgXCIgKyBpZGVudGlmaWVyTmFtZShjb21wTWV0YS50eXBlKSArIFwiIVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbXBpbGUgc3R5bGVzXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wb25lbnRTdHlsZXNoZWV0ID0gX3RoaXMuX3N0eWxlQ29tcGlsZXIuY29tcGlsZUNvbXBvbmVudChvdXRwdXRDdHgsIGNvbXBNZXRhKTsgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgKChcbiAgICAgICAgICAgIC8vIE5vdGU6IGNvbXBNZXRhIGlzIGEgY29tcG9uZW50IGFuZCB0aGVyZWZvcmUgdGVtcGxhdGUgaXMgbm9uIG51bGwuXG4gICAgICAgICAgICBjb21wTWV0YS50ZW1wbGF0ZSkpLmV4dGVybmFsU3R5bGVzaGVldHMuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGVzaGVldE1ldGEpIHtcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZWRGaWxlcy5wdXNoKF90aGlzLl9jb2RlZ2VuU3R5bGVzKC8qKiBAdHlwZSB7P30gKi8gKChzdHlsZXNoZWV0TWV0YS5tb2R1bGVVcmwpKSwgY29tcE1ldGEsIHN0eWxlc2hlZXRNZXRhLCBmaWxlU3VmZml4KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGNvbXBpbGUgY29tcG9uZW50c1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcFZpZXdWYXJzID0gX3RoaXMuX2NvbXBpbGVDb21wb25lbnQob3V0cHV0Q3R4LCBjb21wTWV0YSwgbmdNb2R1bGUsIG5nTW9kdWxlLnRyYW5zaXRpdmVNb2R1bGUuZGlyZWN0aXZlcywgY29tcG9uZW50U3R5bGVzaGVldCwgZmlsZVN1ZmZpeCk7XG4gICAgICAgICAgICBfdGhpcy5fY29tcGlsZUNvbXBvbmVudEZhY3Rvcnkob3V0cHV0Q3R4LCBjb21wTWV0YSwgbmdNb2R1bGUsIGZpbGVTdWZmaXgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG91dHB1dEN0eC5zdGF0ZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNyY01vZHVsZSA9IHRoaXMuX2NvZGVnZW5Tb3VyY2VNb2R1bGUoc3JjRmlsZVVybCwgb3V0cHV0Q3R4KTtcbiAgICAgICAgICAgIGdlbmVyYXRlZEZpbGVzLnVuc2hpZnQoc3JjTW9kdWxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2VuZXJhdGVkRmlsZXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNyY0ZpbGVVcmxcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZXNcbiAgICAgKiBAcGFyYW0gez99IHBpcGVzXG4gICAgICogQHBhcmFtIHs/fSBuZ01vZHVsZXNcbiAgICAgKiBAcGFyYW0gez99IGluamVjdGFibGVzXG4gICAgICogQHBhcmFtIHs/fSBuZ0ZhY3RvcnlDdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFvdENvbXBpbGVyLnByb3RvdHlwZS5fY3JlYXRlU3VtbWFyeSA9IGZ1bmN0aW9uIChzcmNGaWxlVXJsLCBkaXJlY3RpdmVzLCBwaXBlcywgbmdNb2R1bGVzLCBpbmplY3RhYmxlcywgbmdGYWN0b3J5Q3R4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN5bWJvbFN1bW1hcmllcyA9IHRoaXMuX3N5bWJvbFJlc29sdmVyLmdldFN5bWJvbHNPZihzcmNGaWxlVXJsKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoc3ltYm9sKSB7IHJldHVybiBfdGhpcy5fc3ltYm9sUmVzb2x2ZXIucmVzb2x2ZVN5bWJvbChzeW1ib2wpOyB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHlwZURhdGEgPSBuZ01vZHVsZXMubWFwKGZ1bmN0aW9uIChyZWYpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICBzdW1tYXJ5OiAvKiogQHR5cGUgez99ICovICgoX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0TmdNb2R1bGVTdW1tYXJ5KHJlZikpKSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiAvKiogQHR5cGUgez99ICovICgoX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0TmdNb2R1bGVNZXRhZGF0YShyZWYpKSlcbiAgICAgICAgfSk7IH0pLmNvbmNhdChkaXJlY3RpdmVzLm1hcChmdW5jdGlvbiAocmVmKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgc3VtbWFyeTogLyoqIEB0eXBlIHs/fSAqLyAoKF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldERpcmVjdGl2ZVN1bW1hcnkocmVmKSkpLFxuICAgICAgICAgICAgbWV0YWRhdGE6IC8qKiBAdHlwZSB7P30gKi8gKChfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXREaXJlY3RpdmVNZXRhZGF0YShyZWYpKSlcbiAgICAgICAgfSk7IH0pLCBwaXBlcy5tYXAoZnVuY3Rpb24gKHJlZikgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIHN1bW1hcnk6IC8qKiBAdHlwZSB7P30gKi8gKChfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXRQaXBlU3VtbWFyeShyZWYpKSksXG4gICAgICAgICAgICBtZXRhZGF0YTogLyoqIEB0eXBlIHs/fSAqLyAoKF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldFBpcGVNZXRhZGF0YShyZWYpKSlcbiAgICAgICAgfSk7IH0pLCBpbmplY3RhYmxlcy5tYXAoZnVuY3Rpb24gKHJlZikgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIHN1bW1hcnk6IC8qKiBAdHlwZSB7P30gKi8gKChfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXRJbmplY3RhYmxlU3VtbWFyeShyZWYpKSksXG4gICAgICAgICAgICBtZXRhZGF0YTogLyoqIEB0eXBlIHs/fSAqLyAoKF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldEluamVjdGFibGVTdW1tYXJ5KHJlZikpKS50eXBlXG4gICAgICAgIH0pOyB9KSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZvckppdE91dHB1dEN0eCA9IHRoaXMuX2NyZWF0ZU91dHB1dENvbnRleHQoc3VtbWFyeUZvckppdEZpbGVOYW1lKHNyY0ZpbGVVcmwsIHRydWUpKTtcbiAgICAgICAgdmFyIF9hID0gc2VyaWFsaXplU3VtbWFyaWVzKGZvckppdE91dHB1dEN0eCwgdGhpcy5fc3VtbWFyeVJlc29sdmVyLCB0aGlzLl9zeW1ib2xSZXNvbHZlciwgc3ltYm9sU3VtbWFyaWVzLCB0eXBlRGF0YSksIGpzb24gPSBfYS5qc29uLCBleHBvcnRBcyA9IF9hLmV4cG9ydEFzO1xuICAgICAgICBleHBvcnRBcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgbmdGYWN0b3J5Q3R4LnN0YXRlbWVudHMucHVzaCh2YXJpYWJsZShlbnRyeS5leHBvcnRBcykuc2V0KG5nRmFjdG9yeUN0eC5pbXBvcnRFeHByKGVudHJ5LnN5bWJvbCkpLnRvRGVjbFN0bXQobnVsbCwgW1xuICAgICAgICAgICAgICAgIFN0bXRNb2RpZmllci5FeHBvcnRlZFxuICAgICAgICAgICAgXSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3VtbWFyeUpzb24gPSBuZXcgR2VuZXJhdGVkRmlsZShzcmNGaWxlVXJsLCBzdW1tYXJ5RmlsZU5hbWUoc3JjRmlsZVVybCksIGpzb24pO1xuICAgICAgICBpZiAodGhpcy5fZW5hYmxlU3VtbWFyaWVzRm9ySml0KSB7XG4gICAgICAgICAgICByZXR1cm4gW3N1bW1hcnlKc29uLCB0aGlzLl9jb2RlZ2VuU291cmNlTW9kdWxlKHNyY0ZpbGVVcmwsIGZvckppdE91dHB1dEN0eCldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbc3VtbWFyeUpzb25dO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBvdXRwdXRDdHhcbiAgICAgKiBAcGFyYW0gez99IG5nTW9kdWxlVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW90Q29tcGlsZXIucHJvdG90eXBlLl9jb21waWxlTW9kdWxlID0gZnVuY3Rpb24gKG91dHB1dEN0eCwgbmdNb2R1bGVUeXBlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nTW9kdWxlID0gKCh0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldE5nTW9kdWxlTWV0YWRhdGEobmdNb2R1bGVUeXBlKSkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm92aWRlcnMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuX2xvY2FsZUlkKSB7XG4gICAgICAgICAgICBwcm92aWRlcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdG9rZW46IGNyZWF0ZVRva2VuRm9yRXh0ZXJuYWxSZWZlcmVuY2UodGhpcy5fcmVmbGVjdG9yLCBJZGVudGlmaWVycy5MT0NBTEVfSUQpLFxuICAgICAgICAgICAgICAgIHVzZVZhbHVlOiB0aGlzLl9sb2NhbGVJZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl90cmFuc2xhdGlvbkZvcm1hdCkge1xuICAgICAgICAgICAgcHJvdmlkZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIHRva2VuOiBjcmVhdGVUb2tlbkZvckV4dGVybmFsUmVmZXJlbmNlKHRoaXMuX3JlZmxlY3RvciwgSWRlbnRpZmllcnMuVFJBTlNMQVRJT05TX0ZPUk1BVCksXG4gICAgICAgICAgICAgICAgdXNlVmFsdWU6IHRoaXMuX3RyYW5zbGF0aW9uRm9ybWF0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9uZ01vZHVsZUNvbXBpbGVyLmNvbXBpbGUob3V0cHV0Q3R4LCBuZ01vZHVsZSwgcHJvdmlkZXJzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gb3V0cHV0Q3R4XG4gICAgICogQHBhcmFtIHs/fSBjb21wTWV0YVxuICAgICAqIEBwYXJhbSB7P30gbmdNb2R1bGVcbiAgICAgKiBAcGFyYW0gez99IGZpbGVTdWZmaXhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFvdENvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZUNvbXBvbmVudEZhY3RvcnkgPSBmdW5jdGlvbiAob3V0cHV0Q3R4LCBjb21wTWV0YSwgbmdNb2R1bGUsIGZpbGVTdWZmaXgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaG9zdFR5cGUgPSB0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldEhvc3RDb21wb25lbnRUeXBlKGNvbXBNZXRhLnR5cGUucmVmZXJlbmNlKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaG9zdE1ldGEgPSBjcmVhdGVIb3N0Q29tcG9uZW50TWV0YShob3N0VHlwZSwgY29tcE1ldGEsIHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0SG9zdENvbXBvbmVudFZpZXdDbGFzcyhob3N0VHlwZSkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBob3N0Vmlld0ZhY3RvcnlWYXIgPSB0aGlzLl9jb21waWxlQ29tcG9uZW50KG91dHB1dEN0eCwgaG9zdE1ldGEsIG5nTW9kdWxlLCBbY29tcE1ldGEudHlwZV0sIG51bGwsIGZpbGVTdWZmaXgpXG4gICAgICAgICAgICAudmlld0NsYXNzVmFyO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wRmFjdG9yeVZhciA9IGNvbXBvbmVudEZhY3RvcnlOYW1lKGNvbXBNZXRhLnR5cGUucmVmZXJlbmNlKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5wdXRzRXhwcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9wTmFtZSBpbiBjb21wTWV0YS5pbnB1dHMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlbXBsYXRlTmFtZSA9IGNvbXBNZXRhLmlucHV0c1twcm9wTmFtZV07XG4gICAgICAgICAgICAvLyBEb24ndCBxdW90ZSBzbyB0aGF0IHRoZSBrZXkgZ2V0cyBtaW5pZmllZC4uLlxuICAgICAgICAgICAgaW5wdXRzRXhwcnMucHVzaChuZXcgTGl0ZXJhbE1hcEVudHJ5KHByb3BOYW1lLCBsaXRlcmFsKHRlbXBsYXRlTmFtZSksIGZhbHNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3V0cHV0c0V4cHJzID0gW107XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvcE5hbWUgaW4gY29tcE1ldGEub3V0cHV0cykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVtcGxhdGVOYW1lID0gY29tcE1ldGEub3V0cHV0c1twcm9wTmFtZV07XG4gICAgICAgICAgICAvLyBEb24ndCBxdW90ZSBzbyB0aGF0IHRoZSBrZXkgZ2V0cyBtaW5pZmllZC4uLlxuICAgICAgICAgICAgb3V0cHV0c0V4cHJzLnB1c2gobmV3IExpdGVyYWxNYXBFbnRyeShwcm9wTmFtZSwgbGl0ZXJhbCh0ZW1wbGF0ZU5hbWUpLCBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dEN0eC5zdGF0ZW1lbnRzLnB1c2godmFyaWFibGUoY29tcEZhY3RvcnlWYXIpXG4gICAgICAgICAgICAuc2V0KGltcG9ydEV4cHIoSWRlbnRpZmllcnMuY3JlYXRlQ29tcG9uZW50RmFjdG9yeSkuY2FsbEZuKFtcbiAgICAgICAgICAgIGxpdGVyYWwoY29tcE1ldGEuc2VsZWN0b3IpLCBvdXRwdXRDdHguaW1wb3J0RXhwcihjb21wTWV0YS50eXBlLnJlZmVyZW5jZSksXG4gICAgICAgICAgICB2YXJpYWJsZShob3N0Vmlld0ZhY3RvcnlWYXIpLCBuZXcgTGl0ZXJhbE1hcEV4cHIoaW5wdXRzRXhwcnMpLFxuICAgICAgICAgICAgbmV3IExpdGVyYWxNYXBFeHByKG91dHB1dHNFeHBycyksXG4gICAgICAgICAgICBsaXRlcmFsQXJyKC8qKiBAdHlwZSB7P30gKi8gKChjb21wTWV0YS50ZW1wbGF0ZSkpLm5nQ29udGVudFNlbGVjdG9ycy5tYXAoZnVuY3Rpb24gKHNlbGVjdG9yKSB7IHJldHVybiBsaXRlcmFsKHNlbGVjdG9yKTsgfSkpXG4gICAgICAgIF0pKVxuICAgICAgICAgICAgLnRvRGVjbFN0bXQoaW1wb3J0VHlwZShJZGVudGlmaWVycy5Db21wb25lbnRGYWN0b3J5LCBbLyoqIEB0eXBlIHs/fSAqLyAoKGV4cHJlc3Npb25UeXBlKG91dHB1dEN0eC5pbXBvcnRFeHByKGNvbXBNZXRhLnR5cGUucmVmZXJlbmNlKSkpKV0sIFtUeXBlTW9kaWZpZXIuQ29uc3RdKSwgW1N0bXRNb2RpZmllci5GaW5hbCwgU3RtdE1vZGlmaWVyLkV4cG9ydGVkXSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBvdXRwdXRDdHhcbiAgICAgKiBAcGFyYW0gez99IGNvbXBNZXRhXG4gICAgICogQHBhcmFtIHs/fSBuZ01vZHVsZVxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlSWRlbnRpZmllcnNcbiAgICAgKiBAcGFyYW0gez99IGNvbXBvbmVudFN0eWxlc1xuICAgICAqIEBwYXJhbSB7P30gZmlsZVN1ZmZpeFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW90Q29tcGlsZXIucHJvdG90eXBlLl9jb21waWxlQ29tcG9uZW50ID0gZnVuY3Rpb24gKG91dHB1dEN0eCwgY29tcE1ldGEsIG5nTW9kdWxlLCBkaXJlY3RpdmVJZGVudGlmaWVycywgY29tcG9uZW50U3R5bGVzLCBmaWxlU3VmZml4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVJZGVudGlmaWVycy5tYXAoZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0RGlyZWN0aXZlU3VtbWFyeShkaXIucmVmZXJlbmNlKTsgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBpcGVzID0gbmdNb2R1bGUudHJhbnNpdGl2ZU1vZHVsZS5waXBlcy5tYXAoZnVuY3Rpb24gKHBpcGUpIHsgcmV0dXJuIF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldFBpcGVTdW1tYXJ5KHBpcGUucmVmZXJlbmNlKTsgfSk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuX3RlbXBsYXRlUGFyc2VyLnBhcnNlKGNvbXBNZXRhLCAvKiogQHR5cGUgez99ICovICgoKChjb21wTWV0YS50ZW1wbGF0ZSkpLnRlbXBsYXRlKSksIGRpcmVjdGl2ZXMsIHBpcGVzLCBuZ01vZHVsZS5zY2hlbWFzLCB0ZW1wbGF0ZVNvdXJjZVVybChuZ01vZHVsZS50eXBlLCBjb21wTWV0YSwgLyoqIEB0eXBlIHs/fSAqLyAoKGNvbXBNZXRhLnRlbXBsYXRlKSkpKSwgcGFyc2VkVGVtcGxhdGUgPSBfYS50ZW1wbGF0ZSwgdXNlZFBpcGVzID0gX2EucGlwZXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlc0V4cHIgPSBjb21wb25lbnRTdHlsZXMgPyB2YXJpYWJsZShjb21wb25lbnRTdHlsZXMuc3R5bGVzVmFyKSA6IGxpdGVyYWxBcnIoW10pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aWV3UmVzdWx0ID0gdGhpcy5fdmlld0NvbXBpbGVyLmNvbXBpbGVDb21wb25lbnQob3V0cHV0Q3R4LCBjb21wTWV0YSwgcGFyc2VkVGVtcGxhdGUsIHN0eWxlc0V4cHIsIHVzZWRQaXBlcyk7XG4gICAgICAgIGlmIChjb21wb25lbnRTdHlsZXMpIHtcbiAgICAgICAgICAgIF9yZXNvbHZlU3R5bGVTdGF0ZW1lbnRzKHRoaXMuX3N5bWJvbFJlc29sdmVyLCBjb21wb25lbnRTdHlsZXMsIHRoaXMuX3N0eWxlQ29tcGlsZXIubmVlZHNTdHlsZVNoaW0oY29tcE1ldGEpLCBmaWxlU3VmZml4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlld1Jlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZ2VuRmlsZVBhdGhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFvdENvbXBpbGVyLnByb3RvdHlwZS5fY3JlYXRlT3V0cHV0Q29udGV4dCA9IGZ1bmN0aW9uIChnZW5GaWxlUGF0aCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbXBvcnRFeHByJCQxID0gZnVuY3Rpb24gKHN5bWJvbCwgdHlwZVBhcmFtcykge1xuICAgICAgICAgICAgaWYgKHR5cGVQYXJhbXMgPT09IHZvaWQgMCkgeyB0eXBlUGFyYW1zID0gbnVsbDsgfVxuICAgICAgICAgICAgaWYgKCEoc3ltYm9sIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludGVybmFsIGVycm9yOiB1bmtub3duIGlkZW50aWZpZXIgXCIgKyBKU09OLnN0cmluZ2lmeShzeW1ib2wpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFyaXR5ID0gX3RoaXMuX3N5bWJvbFJlc29sdmVyLmdldFR5cGVBcml0eShzeW1ib2wpIHx8IDA7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5fc3ltYm9sUmVzb2x2ZXIuZ2V0SW1wb3J0QXMoc3ltYm9sKSB8fCBzeW1ib2wsIGZpbGVQYXRoID0gX2EuZmlsZVBhdGgsIG5hbWUgPSBfYS5uYW1lLCBtZW1iZXJzID0gX2EubWVtYmVycztcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGltcG9ydE1vZHVsZSA9IF90aGlzLl9zeW1ib2xSZXNvbHZlci5maWxlTmFtZVRvTW9kdWxlTmFtZShmaWxlUGF0aCwgZ2VuRmlsZVBhdGgpO1xuICAgICAgICAgICAgLy8gSXQgc2hvdWxkIGJlIGdvb2QgZW5vdWdoIHRvIGNvbXBhcmUgZmlsZVBhdGggdG8gZ2VuRmlsZVBhdGggYW5kIGlmIHRoZXkgYXJlIGVxdWFsXG4gICAgICAgICAgICAvLyB0aGVyZSBpcyBhIHNlbGYgcmVmZXJlbmNlLiBIb3dldmVyLCBuZ2ZhY3RvcnkgZmlsZXMgZ2VuZXJhdGUgdG8gLnRzIGJ1dCB0aGVpclxuICAgICAgICAgICAgLy8gc3ltYm9scyBoYXZlIC5kLnRzIHNvIGEgc2ltcGxlIGNvbXBhcmUgaXMgaW5zdWZmaWNpZW50LiBUaGV5IHNob3VsZCBiZSBjYW5vbmljYWxcbiAgICAgICAgICAgIC8vIGFuZCBpcyB0cmFja2VkIGJ5ICMxNzcwNS5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlbGZSZWZlcmVuY2UgPSBfdGhpcy5fc3ltYm9sUmVzb2x2ZXIuZmlsZU5hbWVUb01vZHVsZU5hbWUoZ2VuRmlsZVBhdGgsIGdlbkZpbGVQYXRoKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1vZHVsZU5hbWUgPSBpbXBvcnRNb2R1bGUgPT09IHNlbGZSZWZlcmVuY2UgPyBudWxsIDogaW1wb3J0TW9kdWxlO1xuICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGluIGEgdHlwZSBleHByZXNzaW9uIHRoYXQgcmVmZXJzIHRvIGEgZ2VuZXJpYyB0eXBlIHRoZW4gc3VwcGx5XG4gICAgICAgICAgICAvLyB0aGUgcmVxdWlyZWQgdHlwZSBwYXJhbWV0ZXJzLiBJZiB0aGVyZSB3ZXJlIG5vdCBlbm91Z2ggdHlwZSBwYXJhbWV0ZXJzXG4gICAgICAgICAgICAvLyBzdXBwbGllZCwgc3VwcGx5IGFueSBhcyB0aGUgdHlwZS4gT3V0c2lkZSBhIHR5cGUgZXhwcmVzc2lvbiB0aGUgcmVmZXJlbmNlXG4gICAgICAgICAgICAvLyBzaG91bGQgbm90IHN1cHBseSB0eXBlIHBhcmFtZXRlcnMgYW5kIGJlIHRyZWF0ZWQgYXMgYSBzaW1wbGUgdmFsdWUgcmVmZXJlbmNlXG4gICAgICAgICAgICAvLyB0byB0aGUgY29uc3RydWN0b3IgZnVuY3Rpb24gaXRzZWxmLlxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3VwcGxpZWRUeXBlUGFyYW1zID0gdHlwZVBhcmFtcyB8fCBbXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1pc3NpbmdUeXBlUGFyYW1zQ291bnQgPSBhcml0eSAtIHN1cHBsaWVkVHlwZVBhcmFtcy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbGxUeXBlUGFyYW1zID0gc3VwcGxpZWRUeXBlUGFyYW1zLmNvbmNhdChuZXcgQXJyYXkobWlzc2luZ1R5cGVQYXJhbXNDb3VudCkuZmlsbChEWU5BTUlDX1RZUEUpKTtcbiAgICAgICAgICAgIHJldHVybiBtZW1iZXJzLnJlZHVjZShmdW5jdGlvbiAoZXhwciwgbWVtYmVyTmFtZSkgeyByZXR1cm4gZXhwci5wcm9wKG1lbWJlck5hbWUpOyB9LCAvKiogQHR5cGUgez99ICovIChpbXBvcnRFeHByKG5ldyBFeHRlcm5hbFJlZmVyZW5jZShtb2R1bGVOYW1lLCBuYW1lLCBudWxsKSwgYWxsVHlwZVBhcmFtcykpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHsgc3RhdGVtZW50czogW10sIGdlbkZpbGVQYXRoOiBnZW5GaWxlUGF0aCwgaW1wb3J0RXhwcjogaW1wb3J0RXhwciQkMSB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcmNGaWxlVXJsXG4gICAgICogQHBhcmFtIHs/fSBjb21wTWV0YVxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVzaGVldE1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBmaWxlU3VmZml4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBb3RDb21waWxlci5wcm90b3R5cGUuX2NvZGVnZW5TdHlsZXMgPSBmdW5jdGlvbiAoc3JjRmlsZVVybCwgY29tcE1ldGEsIHN0eWxlc2hlZXRNZXRhZGF0YSwgZmlsZVN1ZmZpeCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvdXRwdXRDdHggPSB0aGlzLl9jcmVhdGVPdXRwdXRDb250ZXh0KF9zdHlsZXNNb2R1bGVVcmwoLyoqIEB0eXBlIHs/fSAqLyAoKHN0eWxlc2hlZXRNZXRhZGF0YS5tb2R1bGVVcmwpKSwgdGhpcy5fc3R5bGVDb21waWxlci5uZWVkc1N0eWxlU2hpbShjb21wTWV0YSksIGZpbGVTdWZmaXgpKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcGlsZWRTdHlsZXNoZWV0ID0gdGhpcy5fc3R5bGVDb21waWxlci5jb21waWxlU3R5bGVzKG91dHB1dEN0eCwgY29tcE1ldGEsIHN0eWxlc2hlZXRNZXRhZGF0YSk7XG4gICAgICAgIF9yZXNvbHZlU3R5bGVTdGF0ZW1lbnRzKHRoaXMuX3N5bWJvbFJlc29sdmVyLCBjb21waWxlZFN0eWxlc2hlZXQsIHRoaXMuX3N0eWxlQ29tcGlsZXIubmVlZHNTdHlsZVNoaW0oY29tcE1ldGEpLCBmaWxlU3VmZml4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvZGVnZW5Tb3VyY2VNb2R1bGUoc3JjRmlsZVVybCwgb3V0cHV0Q3R4KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3JjRmlsZVVybFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBb3RDb21waWxlci5wcm90b3R5cGUuX2NvZGVnZW5Tb3VyY2VNb2R1bGUgPSBmdW5jdGlvbiAoc3JjRmlsZVVybCwgY3R4KSB7XG4gICAgICAgIHJldHVybiBuZXcgR2VuZXJhdGVkRmlsZShzcmNGaWxlVXJsLCBjdHguZ2VuRmlsZVBhdGgsIGN0eC5zdGF0ZW1lbnRzKTtcbiAgICB9O1xuICAgIHJldHVybiBBb3RDb21waWxlcjtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gb3V0cHV0Q3R4XG4gKiBAcGFyYW0gez99IHJlZmVyZW5jZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2NyZWF0ZVR5cGVSZWZlcmVuY2VTdHViKG91dHB1dEN0eCwgcmVmZXJlbmNlKSB7XG4gICAgb3V0cHV0Q3R4LnN0YXRlbWVudHMucHVzaChpbXBvcnRFeHByKHJlZmVyZW5jZSkudG9TdG10KCkpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHN5bWJvbFJlc29sdmVyXG4gKiBAcGFyYW0gez99IGNvbXBpbGVSZXN1bHRcbiAqIEBwYXJhbSB7P30gbmVlZHNTaGltXG4gKiBAcGFyYW0gez99IGZpbGVTdWZmaXhcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9yZXNvbHZlU3R5bGVTdGF0ZW1lbnRzKHN5bWJvbFJlc29sdmVyLCBjb21waWxlUmVzdWx0LCBuZWVkc1NoaW0sIGZpbGVTdWZmaXgpIHtcbiAgICBjb21waWxlUmVzdWx0LmRlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgICAgZGVwLnNldFZhbHVlKHN5bWJvbFJlc29sdmVyLmdldFN0YXRpY1N5bWJvbChfc3R5bGVzTW9kdWxlVXJsKGRlcC5tb2R1bGVVcmwsIG5lZWRzU2hpbSwgZmlsZVN1ZmZpeCksIGRlcC5uYW1lKSk7XG4gICAgfSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gc3R5bGVzaGVldFVybFxuICogQHBhcmFtIHs/fSBzaGltXG4gKiBAcGFyYW0gez99IHN1ZmZpeFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX3N0eWxlc01vZHVsZVVybChzdHlsZXNoZWV0VXJsLCBzaGltLCBzdWZmaXgpIHtcbiAgICByZXR1cm4gXCJcIiArIHN0eWxlc2hlZXRVcmwgKyAoc2hpbSA/ICcuc2hpbScgOiAnJykgKyBcIi5uZ3N0eWxlXCIgKyBzdWZmaXg7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gcHJvZ3JhbVN0YXRpY1N5bWJvbHNcbiAqIEBwYXJhbSB7P30gaG9zdFxuICogQHBhcmFtIHs/fSBtZXRhZGF0YVJlc29sdmVyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBhbmFseXplTmdNb2R1bGVzKHByb2dyYW1TdGF0aWNTeW1ib2xzLCBob3N0LCBtZXRhZGF0YVJlc29sdmVyKSB7XG4gICAgdmFyIF9hID0gX2NyZWF0ZU5nTW9kdWxlcyhwcm9ncmFtU3RhdGljU3ltYm9scywgaG9zdCwgbWV0YWRhdGFSZXNvbHZlciksIG5nTW9kdWxlcyA9IF9hLm5nTW9kdWxlcywgc3ltYm9sc01pc3NpbmdNb2R1bGUgPSBfYS5zeW1ib2xzTWlzc2luZ01vZHVsZTtcbiAgICByZXR1cm4gX2FuYWx5emVOZ01vZHVsZXMocHJvZ3JhbVN0YXRpY1N5bWJvbHMsIG5nTW9kdWxlcywgc3ltYm9sc01pc3NpbmdNb2R1bGUsIG1ldGFkYXRhUmVzb2x2ZXIpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHByb2dyYW1TdGF0aWNTeW1ib2xzXG4gKiBAcGFyYW0gez99IGhvc3RcbiAqIEBwYXJhbSB7P30gbWV0YWRhdGFSZXNvbHZlclxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gYW5hbHl6ZUFuZFZhbGlkYXRlTmdNb2R1bGVzKHByb2dyYW1TdGF0aWNTeW1ib2xzLCBob3N0LCBtZXRhZGF0YVJlc29sdmVyKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gYW5hbHl6ZU5nTW9kdWxlcyhwcm9ncmFtU3RhdGljU3ltYm9scywgaG9zdCwgbWV0YWRhdGFSZXNvbHZlcik7XG4gICAgaWYgKHJlc3VsdC5zeW1ib2xzTWlzc2luZ01vZHVsZSAmJiByZXN1bHQuc3ltYm9sc01pc3NpbmdNb2R1bGUubGVuZ3RoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lc3NhZ2VzID0gcmVzdWx0LnN5bWJvbHNNaXNzaW5nTW9kdWxlLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gXCJDYW5ub3QgZGV0ZXJtaW5lIHRoZSBtb2R1bGUgZm9yIGNsYXNzIFwiICsgcy5uYW1lICsgXCIgaW4gXCIgKyBzLmZpbGVQYXRoICsgXCIhIEFkZCBcIiArIHMubmFtZSArIFwiIHRvIHRoZSBOZ01vZHVsZSB0byBmaXggaXQuXCI7IH0pO1xuICAgICAgICB0aHJvdyBzeW50YXhFcnJvcihtZXNzYWdlcy5qb2luKCdcXG4nKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gcHJvZ3JhbVN5bWJvbHNcbiAqIEBwYXJhbSB7P30gbmdNb2R1bGVNZXRhc1xuICogQHBhcmFtIHs/fSBzeW1ib2xzTWlzc2luZ01vZHVsZVxuICogQHBhcmFtIHs/fSBtZXRhZGF0YVJlc29sdmVyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfYW5hbHl6ZU5nTW9kdWxlcyhwcm9ncmFtU3ltYm9scywgbmdNb2R1bGVNZXRhcywgc3ltYm9sc01pc3NpbmdNb2R1bGUsIG1ldGFkYXRhUmVzb2x2ZXIpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtb2R1bGVNZXRhc0J5UmVmID0gbmV3IE1hcCgpO1xuICAgIG5nTW9kdWxlTWV0YXMuZm9yRWFjaChmdW5jdGlvbiAobmdNb2R1bGUpIHsgcmV0dXJuIG1vZHVsZU1ldGFzQnlSZWYuc2V0KG5nTW9kdWxlLnR5cGUucmVmZXJlbmNlLCBuZ01vZHVsZSk7IH0pO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nTW9kdWxlQnlQaXBlT3JEaXJlY3RpdmUgPSBuZXcgTWFwKCk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmdNb2R1bGVzQnlGaWxlID0gbmV3IE1hcCgpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nRGlyZWN0aXZlc0J5RmlsZSA9IG5ldyBNYXAoKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZ1BpcGVzQnlGaWxlID0gbmV3IE1hcCgpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nSW5qZWN0YWJsZXNCeUZpbGUgPSBuZXcgTWFwKCk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmlsZVBhdGhzID0gbmV3IFNldCgpO1xuICAgIC8vIE1ha2Ugc3VyZSB3ZSBwcm9kdWNlIGFuIGFuYWx5emVkIGZpbGUgZm9yIGVhY2ggaW5wdXQgZmlsZVxuICAgIHByb2dyYW1TeW1ib2xzLmZvckVhY2goZnVuY3Rpb24gKHN5bWJvbCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmaWxlUGF0aCA9IHN5bWJvbC5maWxlUGF0aDtcbiAgICAgICAgZmlsZVBhdGhzLmFkZChmaWxlUGF0aCk7XG4gICAgICAgIGlmIChtZXRhZGF0YVJlc29sdmVyLmlzSW5qZWN0YWJsZShzeW1ib2wpKSB7XG4gICAgICAgICAgICBuZ0luamVjdGFibGVzQnlGaWxlLnNldChmaWxlUGF0aCwgKG5nSW5qZWN0YWJsZXNCeUZpbGUuZ2V0KGZpbGVQYXRoKSB8fCBbXSkuY29uY2F0KHN5bWJvbCkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gTG9vcGluZyBvdmVyIGFsbCBtb2R1bGVzIHRvIGNvbnN0cnVjdDpcbiAgICAvLyAtIGEgbWFwIGZyb20gZmlsZSB0byBtb2R1bGVzIGBuZ01vZHVsZXNCeUZpbGVgLFxuICAgIC8vIC0gYSBtYXAgZnJvbSBmaWxlIHRvIGRpcmVjdGl2ZXMgYG5nRGlyZWN0aXZlc0J5RmlsZWAsXG4gICAgLy8gLSBhIG1hcCBmcm9tIGZpbGUgdG8gcGlwZXMgYG5nUGlwZXNCeUZpbGVgLFxuICAgIC8vIC0gYSBtYXAgZnJvbSBkaXJlY3RpdmUvcGlwZSB0byBtb2R1bGUgYG5nTW9kdWxlQnlQaXBlT3JEaXJlY3RpdmVgLlxuICAgIG5nTW9kdWxlTWV0YXMuZm9yRWFjaChmdW5jdGlvbiAobmdNb2R1bGVNZXRhKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNyY0ZpbGVVcmwgPSBuZ01vZHVsZU1ldGEudHlwZS5yZWZlcmVuY2UuZmlsZVBhdGg7XG4gICAgICAgIGZpbGVQYXRocy5hZGQoc3JjRmlsZVVybCk7XG4gICAgICAgIG5nTW9kdWxlc0J5RmlsZS5zZXQoc3JjRmlsZVVybCwgKG5nTW9kdWxlc0J5RmlsZS5nZXQoc3JjRmlsZVVybCkgfHwgW10pLmNvbmNhdChuZ01vZHVsZU1ldGEudHlwZS5yZWZlcmVuY2UpKTtcbiAgICAgICAgbmdNb2R1bGVNZXRhLmRlY2xhcmVkRGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJJZGVudGlmaWVyKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmaWxlVXJsID0gZGlySWRlbnRpZmllci5yZWZlcmVuY2UuZmlsZVBhdGg7XG4gICAgICAgICAgICBmaWxlUGF0aHMuYWRkKGZpbGVVcmwpO1xuICAgICAgICAgICAgbmdEaXJlY3RpdmVzQnlGaWxlLnNldChmaWxlVXJsLCAobmdEaXJlY3RpdmVzQnlGaWxlLmdldChmaWxlVXJsKSB8fCBbXSkuY29uY2F0KGRpcklkZW50aWZpZXIucmVmZXJlbmNlKSk7XG4gICAgICAgICAgICBuZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlLnNldChkaXJJZGVudGlmaWVyLnJlZmVyZW5jZSwgbmdNb2R1bGVNZXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG5nTW9kdWxlTWV0YS5kZWNsYXJlZFBpcGVzLmZvckVhY2goZnVuY3Rpb24gKHBpcGVJZGVudGlmaWVyKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmaWxlVXJsID0gcGlwZUlkZW50aWZpZXIucmVmZXJlbmNlLmZpbGVQYXRoO1xuICAgICAgICAgICAgZmlsZVBhdGhzLmFkZChmaWxlVXJsKTtcbiAgICAgICAgICAgIG5nUGlwZXNCeUZpbGUuc2V0KGZpbGVVcmwsIChuZ1BpcGVzQnlGaWxlLmdldChmaWxlVXJsKSB8fCBbXSkuY29uY2F0KHBpcGVJZGVudGlmaWVyLnJlZmVyZW5jZSkpO1xuICAgICAgICAgICAgbmdNb2R1bGVCeVBpcGVPckRpcmVjdGl2ZS5zZXQocGlwZUlkZW50aWZpZXIucmVmZXJlbmNlLCBuZ01vZHVsZU1ldGEpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmaWxlcyA9IFtdO1xuICAgIGZpbGVQYXRocy5mb3JFYWNoKGZ1bmN0aW9uIChzcmNVcmwpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlyZWN0aXZlcyA9IG5nRGlyZWN0aXZlc0J5RmlsZS5nZXQoc3JjVXJsKSB8fCBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGlwZXMgPSBuZ1BpcGVzQnlGaWxlLmdldChzcmNVcmwpIHx8IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZ01vZHVsZXMgPSBuZ01vZHVsZXNCeUZpbGUuZ2V0KHNyY1VybCkgfHwgW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluamVjdGFibGVzID0gbmdJbmplY3RhYmxlc0J5RmlsZS5nZXQoc3JjVXJsKSB8fCBbXTtcbiAgICAgICAgZmlsZXMucHVzaCh7IHNyY1VybDogc3JjVXJsLCBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzLCBwaXBlczogcGlwZXMsIG5nTW9kdWxlczogbmdNb2R1bGVzLCBpbmplY3RhYmxlczogaW5qZWN0YWJsZXMgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLy8gbWFwIGRpcmVjdGl2ZS9waXBlIHRvIG1vZHVsZVxuICAgICAgICBuZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlOiBuZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlLFxuICAgICAgICAvLyBsaXN0IG1vZHVsZXMgYW5kIGRpcmVjdGl2ZXMgZm9yIGV2ZXJ5IHNvdXJjZSBmaWxlXG4gICAgICAgIGZpbGVzOiBmaWxlcyxcbiAgICAgICAgbmdNb2R1bGVzOiBuZ01vZHVsZU1ldGFzLCBzeW1ib2xzTWlzc2luZ01vZHVsZTogc3ltYm9sc01pc3NpbmdNb2R1bGVcbiAgICB9O1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHN0YXRpY1N5bWJvbFJlc29sdmVyXG4gKiBAcGFyYW0gez99IGZpbGVzXG4gKiBAcGFyYW0gez99IGhvc3RcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RQcm9ncmFtU3ltYm9scyhzdGF0aWNTeW1ib2xSZXNvbHZlciwgZmlsZXMsIGhvc3QpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGF0aWNTeW1ib2xzID0gW107XG4gICAgZmlsZXMuZmlsdGVyKGZ1bmN0aW9uIChmaWxlTmFtZSkgeyByZXR1cm4gaG9zdC5pc1NvdXJjZUZpbGUoZmlsZU5hbWUpOyB9KS5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICAgIHN0YXRpY1N5bWJvbFJlc29sdmVyLmdldFN5bWJvbHNPZihzb3VyY2VGaWxlKS5mb3JFYWNoKGZ1bmN0aW9uIChzeW1ib2wpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc29sdmVkU3ltYm9sID0gc3RhdGljU3ltYm9sUmVzb2x2ZXIucmVzb2x2ZVN5bWJvbChzeW1ib2wpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ltYm9sTWV0YSA9IHJlc29sdmVkU3ltYm9sLm1ldGFkYXRhO1xuICAgICAgICAgICAgaWYgKHN5bWJvbE1ldGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3ltYm9sTWV0YS5fX3N5bWJvbGljICE9ICdlcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHN5bWJvbHMgdGhhdCBhcmUgb25seSBpbmNsdWRlZCB0byByZWNvcmQgZXJyb3IgaW5mb3JtYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIHN0YXRpY1N5bWJvbHMucHVzaChyZXNvbHZlZFN5bWJvbC5zeW1ib2wpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0YXRpY1N5bWJvbHM7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gcHJvZ3JhbVN0YXRpY1N5bWJvbHNcbiAqIEBwYXJhbSB7P30gaG9zdFxuICogQHBhcmFtIHs/fSBtZXRhZGF0YVJlc29sdmVyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfY3JlYXRlTmdNb2R1bGVzKHByb2dyYW1TdGF0aWNTeW1ib2xzLCBob3N0LCBtZXRhZGF0YVJlc29sdmVyKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmdNb2R1bGVzID0gbmV3IE1hcCgpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb2dyYW1QaXBlc0FuZERpcmVjdGl2ZXMgPSBbXTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZ01vZHVsZVBpcGVzQW5kRGlyZWN0aXZlID0gbmV3IFNldCgpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGFkZE5nTW9kdWxlID0gZnVuY3Rpb24gKHN0YXRpY1N5bWJvbCkge1xuICAgICAgICBpZiAobmdNb2R1bGVzLmhhcyhzdGF0aWNTeW1ib2wpIHx8ICFob3N0LmlzU291cmNlRmlsZShzdGF0aWNTeW1ib2wuZmlsZVBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmdNb2R1bGUgPSBtZXRhZGF0YVJlc29sdmVyLmdldE5nTW9kdWxlTWV0YWRhdGEoc3RhdGljU3ltYm9sLCBmYWxzZSk7XG4gICAgICAgIGlmIChuZ01vZHVsZSkge1xuICAgICAgICAgICAgbmdNb2R1bGVzLnNldChuZ01vZHVsZS50eXBlLnJlZmVyZW5jZSwgbmdNb2R1bGUpO1xuICAgICAgICAgICAgbmdNb2R1bGUuZGVjbGFyZWREaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gbmdNb2R1bGVQaXBlc0FuZERpcmVjdGl2ZS5hZGQoZGlyLnJlZmVyZW5jZSk7IH0pO1xuICAgICAgICAgICAgbmdNb2R1bGUuZGVjbGFyZWRQaXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChwaXBlKSB7IHJldHVybiBuZ01vZHVsZVBpcGVzQW5kRGlyZWN0aXZlLmFkZChwaXBlLnJlZmVyZW5jZSk7IH0pO1xuICAgICAgICAgICAgLy8gRm9yIGV2ZXJ5IGlucHV0IG1vZHVsZSBhZGQgdGhlIGxpc3Qgb2YgdHJhbnNpdGl2ZWx5IGluY2x1ZGVkIG1vZHVsZXNcbiAgICAgICAgICAgIG5nTW9kdWxlLnRyYW5zaXRpdmVNb2R1bGUubW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RNZXRhKSB7IHJldHVybiBhZGROZ01vZHVsZShtb2RNZXRhLnJlZmVyZW5jZSk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhIW5nTW9kdWxlO1xuICAgIH07XG4gICAgcHJvZ3JhbVN0YXRpY1N5bWJvbHMuZm9yRWFjaChmdW5jdGlvbiAoc3RhdGljU3ltYm9sKSB7XG4gICAgICAgIGlmICghYWRkTmdNb2R1bGUoc3RhdGljU3ltYm9sKSAmJlxuICAgICAgICAgICAgKG1ldGFkYXRhUmVzb2x2ZXIuaXNEaXJlY3RpdmUoc3RhdGljU3ltYm9sKSB8fCBtZXRhZGF0YVJlc29sdmVyLmlzUGlwZShzdGF0aWNTeW1ib2wpKSkge1xuICAgICAgICAgICAgcHJvZ3JhbVBpcGVzQW5kRGlyZWN0aXZlcy5wdXNoKHN0YXRpY1N5bWJvbCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBUaHJvdyBhbiBlcnJvciBpZiBhbnkgb2YgdGhlIHByb2dyYW0gcGlwZSBvciBkaXJlY3RpdmVzIGlzIG5vdCBkZWNsYXJlZCBieSBhIG1vZHVsZVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIHN5bWJvbHNNaXNzaW5nTW9kdWxlID0gcHJvZ3JhbVBpcGVzQW5kRGlyZWN0aXZlcy5maWx0ZXIoZnVuY3Rpb24gKHMpIHsgcmV0dXJuICFuZ01vZHVsZVBpcGVzQW5kRGlyZWN0aXZlLmhhcyhzKTsgfSk7XG4gICAgcmV0dXJuIHsgbmdNb2R1bGVzOiBBcnJheS5mcm9tKG5nTW9kdWxlcy52YWx1ZXMoKSksIHN5bWJvbHNNaXNzaW5nTW9kdWxlOiBzeW1ib2xzTWlzc2luZ01vZHVsZSB9O1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEFOR1VMQVJfQ09SRSA9ICdAYW5ndWxhci9jb3JlJztcbnZhciBBTkdVTEFSX1JPVVRFUiA9ICdAYW5ndWxhci9yb3V0ZXInO1xudmFyIEhJRERFTl9LRVkgPSAvXlxcJC4qXFwkJC87XG52YXIgSUdOT1JFID0ge1xuICAgIF9fc3ltYm9saWM6ICdpZ25vcmUnXG59O1xudmFyIFVTRV9WQUxVRSA9ICd1c2VWYWx1ZSc7XG52YXIgUFJPVklERSA9ICdwcm92aWRlJztcbnZhciBSRUZFUkVOQ0VfU0VUID0gbmV3IFNldChbVVNFX1ZBTFVFLCAndXNlRmFjdG9yeScsICdkYXRhJ10pO1xuLyoqXG4gKiBAcGFyYW0gez99IHZhbHVlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzaG91bGRJZ25vcmUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUuX19zeW1ib2xpYyA9PSAnaWdub3JlJztcbn1cbi8qKlxuICogQSBzdGF0aWMgcmVmbGVjdG9yIGltcGxlbWVudHMgZW5vdWdoIG9mIHRoZSBSZWZsZWN0b3IgQVBJIHRoYXQgaXMgbmVjZXNzYXJ5IHRvIGNvbXBpbGVcbiAqIHRlbXBsYXRlcyBzdGF0aWNhbGx5LlxuICovXG52YXIgU3RhdGljUmVmbGVjdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN1bW1hcnlSZXNvbHZlclxuICAgICAqIEBwYXJhbSB7P30gc3ltYm9sUmVzb2x2ZXJcbiAgICAgKiBAcGFyYW0gez89fSBrbm93bk1ldGFkYXRhQ2xhc3Nlc1xuICAgICAqIEBwYXJhbSB7Pz19IGtub3duTWV0YWRhdGFGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0gez89fSBlcnJvclJlY29yZGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3RhdGljUmVmbGVjdG9yKHN1bW1hcnlSZXNvbHZlciwgc3ltYm9sUmVzb2x2ZXIsIGtub3duTWV0YWRhdGFDbGFzc2VzLCBrbm93bk1ldGFkYXRhRnVuY3Rpb25zLCBlcnJvclJlY29yZGVyKSB7XG4gICAgICAgIGlmIChrbm93bk1ldGFkYXRhQ2xhc3NlcyA9PT0gdm9pZCAwKSB7IGtub3duTWV0YWRhdGFDbGFzc2VzID0gW107IH1cbiAgICAgICAgaWYgKGtub3duTWV0YWRhdGFGdW5jdGlvbnMgPT09IHZvaWQgMCkgeyBrbm93bk1ldGFkYXRhRnVuY3Rpb25zID0gW107IH1cbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zdW1tYXJ5UmVzb2x2ZXIgPSBzdW1tYXJ5UmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuc3ltYm9sUmVzb2x2ZXIgPSBzeW1ib2xSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5lcnJvclJlY29yZGVyID0gZXJyb3JSZWNvcmRlcjtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucHJvcGVydHlDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5tZXRob2RDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5jb252ZXJzaW9uTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmFubm90YXRpb25Gb3JQYXJlbnRDbGFzc1dpdGhTdW1tYXJ5S2luZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uTmFtZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZUNvbnZlcnNpb25NYXAoKTtcbiAgICAgICAga25vd25NZXRhZGF0YUNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoa2MpIHsgcmV0dXJuIF90aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IoX3RoaXMuZ2V0U3RhdGljU3ltYm9sKGtjLmZpbGVQYXRoLCBrYy5uYW1lKSwga2MuY3Rvcik7IH0pO1xuICAgICAgICBrbm93bk1ldGFkYXRhRnVuY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGtmKSB7IHJldHVybiBfdGhpcy5fcmVnaXN0ZXJGdW5jdGlvbihfdGhpcy5nZXRTdGF0aWNTeW1ib2woa2YuZmlsZVBhdGgsIGtmLm5hbWUpLCBrZi5mbik7IH0pO1xuICAgICAgICB0aGlzLmFubm90YXRpb25Gb3JQYXJlbnRDbGFzc1dpdGhTdW1tYXJ5S2luZC5zZXQoQ29tcGlsZVN1bW1hcnlLaW5kLkRpcmVjdGl2ZSwgW0RpcmVjdGl2ZSwgQ29tcG9uZW50XSk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbkZvclBhcmVudENsYXNzV2l0aFN1bW1hcnlLaW5kLnNldChDb21waWxlU3VtbWFyeUtpbmQuUGlwZSwgW1BpcGVdKTtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uRm9yUGFyZW50Q2xhc3NXaXRoU3VtbWFyeUtpbmQuc2V0KENvbXBpbGVTdW1tYXJ5S2luZC5OZ01vZHVsZSwgW05nTW9kdWxlXSk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbkZvclBhcmVudENsYXNzV2l0aFN1bW1hcnlLaW5kLnNldChDb21waWxlU3VtbWFyeUtpbmQuSW5qZWN0YWJsZSwgW0luamVjdGFibGUsIFBpcGUsIERpcmVjdGl2ZSwgQ29tcG9uZW50LCBOZ01vZHVsZV0pO1xuICAgICAgICB0aGlzLmFubm90YXRpb25OYW1lcy5zZXQoRGlyZWN0aXZlLCAnRGlyZWN0aXZlJyk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbk5hbWVzLnNldChDb21wb25lbnQsICdDb21wb25lbnQnKTtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uTmFtZXMuc2V0KFBpcGUsICdQaXBlJyk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbk5hbWVzLnNldChOZ01vZHVsZSwgJ05nTW9kdWxlJyk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbk5hbWVzLnNldChJbmplY3RhYmxlLCAnSW5qZWN0YWJsZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVPckZ1bmNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUuY29tcG9uZW50TW9kdWxlVXJsID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhdGljU3ltYm9sID0gdGhpcy5maW5kU3ltYm9sRGVjbGFyYXRpb24odHlwZU9yRnVuYyk7XG4gICAgICAgIHJldHVybiB0aGlzLnN5bWJvbFJlc29sdmVyLmdldFJlc291cmNlUGF0aChzdGF0aWNTeW1ib2wpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByZWZcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUucmVzb2x2ZUV4dGVybmFsUmVmZXJlbmNlID0gZnVuY3Rpb24gKHJlZikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbXBvcnRTeW1ib2wgPSB0aGlzLmdldFN0YXRpY1N5bWJvbCgvKiogQHR5cGUgez99ICovICgocmVmLm1vZHVsZU5hbWUpKSwgLyoqIEB0eXBlIHs/fSAqLyAoKHJlZi5uYW1lKSkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByb290U3ltYm9sID0gdGhpcy5maW5kRGVjbGFyYXRpb24oLyoqIEB0eXBlIHs/fSAqLyAoKHJlZi5tb2R1bGVOYW1lKSksIC8qKiBAdHlwZSB7P30gKi8gKChyZWYubmFtZSkpKTtcbiAgICAgICAgaWYgKGltcG9ydFN5bWJvbCAhPSByb290U3ltYm9sKSB7XG4gICAgICAgICAgICB0aGlzLnN5bWJvbFJlc29sdmVyLnJlY29yZEltcG9ydEFzKHJvb3RTeW1ib2wsIGltcG9ydFN5bWJvbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb3RTeW1ib2w7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1vZHVsZVVybFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRhaW5pbmdGaWxlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLmZpbmREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChtb2R1bGVVcmwsIG5hbWUsIGNvbnRhaW5pbmdGaWxlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRTeW1ib2xEZWNsYXJhdGlvbih0aGlzLnN5bWJvbFJlc29sdmVyLmdldFN5bWJvbEJ5TW9kdWxlKG1vZHVsZVVybCwgbmFtZSwgY29udGFpbmluZ0ZpbGUpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbW9kdWxlVXJsXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLnRyeUZpbmREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChtb2R1bGVVcmwsIG5hbWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ltYm9sUmVzb2x2ZXIuaWdub3JlRXJyb3JzRm9yKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmZpbmREZWNsYXJhdGlvbihtb2R1bGVVcmwsIG5hbWUpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3ltYm9sXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLmZpbmRTeW1ib2xEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChzeW1ib2wpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzb2x2ZWRTeW1ib2wgPSB0aGlzLnN5bWJvbFJlc29sdmVyLnJlc29sdmVTeW1ib2woc3ltYm9sKTtcbiAgICAgICAgaWYgKHJlc29sdmVkU3ltYm9sICYmIHJlc29sdmVkU3ltYm9sLm1ldGFkYXRhIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5kU3ltYm9sRGVjbGFyYXRpb24ocmVzb2x2ZWRTeW1ib2wubWV0YWRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLmFubm90YXRpb25zID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYW5ub3RhdGlvbnMgPSB0aGlzLmFubm90YXRpb25DYWNoZS5nZXQodHlwZSk7XG4gICAgICAgIGlmICghYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICAgIGFubm90YXRpb25zID0gW107XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbGFzc01ldGFkYXRhID0gdGhpcy5nZXRUeXBlTWV0YWRhdGEodHlwZSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnRUeXBlID0gdGhpcy5maW5kUGFyZW50VHlwZSh0eXBlLCBjbGFzc01ldGFkYXRhKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyZW50QW5ub3RhdGlvbnMgPSB0aGlzLmFubm90YXRpb25zKHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgICAgIGFubm90YXRpb25zLnB1c2guYXBwbHkoYW5ub3RhdGlvbnMsIHBhcmVudEFubm90YXRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG93bkFubm90YXRpb25zXzEgPSBbXTtcbiAgICAgICAgICAgIGlmIChjbGFzc01ldGFkYXRhWydkZWNvcmF0b3JzJ10pIHtcbiAgICAgICAgICAgICAgICBvd25Bbm5vdGF0aW9uc18xID0gdGhpcy5zaW1wbGlmeSh0eXBlLCBjbGFzc01ldGFkYXRhWydkZWNvcmF0b3JzJ10pO1xuICAgICAgICAgICAgICAgIGFubm90YXRpb25zLnB1c2guYXBwbHkoYW5ub3RhdGlvbnMsIG93bkFubm90YXRpb25zXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudFR5cGUgJiYgIXRoaXMuc3VtbWFyeVJlc29sdmVyLmlzTGlicmFyeUZpbGUodHlwZS5maWxlUGF0aCkgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnN1bW1hcnlSZXNvbHZlci5pc0xpYnJhcnlGaWxlKHBhcmVudFR5cGUuZmlsZVBhdGgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3VtbWFyeSA9IHRoaXMuc3VtbWFyeVJlc29sdmVyLnJlc29sdmVTdW1tYXJ5KHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChzdW1tYXJ5ICYmIHN1bW1hcnkudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXF1aXJlZEFubm90YXRpb25UeXBlcyA9ICgodGhpcy5hbm5vdGF0aW9uRm9yUGFyZW50Q2xhc3NXaXRoU3VtbWFyeUtpbmQuZ2V0KC8qKiBAdHlwZSB7P30gKi8gKChzdW1tYXJ5LnR5cGUuc3VtbWFyeUtpbmQpKSkpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHlwZUhhc1JlcXVpcmVkQW5ub3RhdGlvbiA9IHJlcXVpcmVkQW5ub3RhdGlvblR5cGVzLnNvbWUoZnVuY3Rpb24gKHJlcXVpcmVkVHlwZSkgeyByZXR1cm4gb3duQW5ub3RhdGlvbnNfMS5zb21lKGZ1bmN0aW9uIChhbm4pIHsgcmV0dXJuIGFubiBpbnN0YW5jZW9mIHJlcXVpcmVkVHlwZTsgfSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXR5cGVIYXNSZXF1aXJlZEFubm90YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJDbGFzcyBcIiArIHR5cGUubmFtZSArIFwiIGluIFwiICsgdHlwZS5maWxlUGF0aCArIFwiIGV4dGVuZHMgZnJvbSBhIFwiICsgQ29tcGlsZVN1bW1hcnlLaW5kWygoc3VtbWFyeS50eXBlLnN1bW1hcnlLaW5kKSldICsgXCIgaW4gYW5vdGhlciBjb21waWxhdGlvbiB1bml0IHdpdGhvdXQgZHVwbGljYXRpbmcgdGhlIGRlY29yYXRvci4gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcIlBsZWFzZSBhZGQgYSBcIiArIHJlcXVpcmVkQW5ub3RhdGlvblR5cGVzLm1hcChmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gX3RoaXMuYW5ub3RhdGlvbk5hbWVzLmdldCh0eXBlKTsgfSkuam9pbignIG9yICcpICsgXCIgZGVjb3JhdG9yIHRvIHRoZSBjbGFzcy5cIikpLCB0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYW5ub3RhdGlvbkNhY2hlLnNldCh0eXBlLCBhbm5vdGF0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGFubikgeyByZXR1cm4gISFhbm47IH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYW5ub3RhdGlvbnM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUucHJvcE1ldGFkYXRhID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvcE1ldGFkYXRhID0gdGhpcy5wcm9wZXJ0eUNhY2hlLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKCFwcm9wTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsYXNzTWV0YWRhdGEgPSB0aGlzLmdldFR5cGVNZXRhZGF0YSh0eXBlKTtcbiAgICAgICAgICAgIHByb3BNZXRhZGF0YSA9IHt9O1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyZW50VHlwZSA9IHRoaXMuZmluZFBhcmVudFR5cGUodHlwZSwgY2xhc3NNZXRhZGF0YSk7XG4gICAgICAgICAgICBpZiAocGFyZW50VHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmVudFByb3BNZXRhZGF0YV8xID0gdGhpcy5wcm9wTWV0YWRhdGEocGFyZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocGFyZW50UHJvcE1ldGFkYXRhXzEpLmZvckVhY2goZnVuY3Rpb24gKHBhcmVudFByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgKChwcm9wTWV0YWRhdGEpKVtwYXJlbnRQcm9wXSA9IHBhcmVudFByb3BNZXRhZGF0YV8xW3BhcmVudFByb3BdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWVtYmVyc18xID0gY2xhc3NNZXRhZGF0YVsnbWVtYmVycyddIHx8IHt9O1xuICAgICAgICAgICAgT2JqZWN0LmtleXMobWVtYmVyc18xKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb3BEYXRhID0gbWVtYmVyc18xW3Byb3BOYW1lXTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9wID0gKChwcm9wRGF0YSkpXG4gICAgICAgICAgICAgICAgICAgIC5maW5kKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhWydfX3N5bWJvbGljJ10gPT0gJ3Byb3BlcnR5JyB8fCBhWydfX3N5bWJvbGljJ10gPT0gJ21ldGhvZCc7IH0pO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlY29yYXRvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoKChwcm9wTWV0YWRhdGEpKVtwcm9wTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjb3JhdG9ycy5wdXNoLmFwcGx5KGRlY29yYXRvcnMsICgocHJvcE1ldGFkYXRhKSlbcHJvcE5hbWVdKTtcbiAgICAgICAgICAgICAgICB9IC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgICAgICAoKHByb3BNZXRhZGF0YSkpW3Byb3BOYW1lXSA9IGRlY29yYXRvcnM7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgJiYgcHJvcFsnZGVjb3JhdG9ycyddKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY29yYXRvcnMucHVzaC5hcHBseShkZWNvcmF0b3JzLCBfdGhpcy5zaW1wbGlmeSh0eXBlLCBwcm9wWydkZWNvcmF0b3JzJ10pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydHlDYWNoZS5zZXQodHlwZSwgcHJvcE1ldGFkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvcE1ldGFkYXRhO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLnBhcmFtZXRlcnMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoISh0eXBlIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSkge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcihuZXcgRXJyb3IoXCJwYXJhbWV0ZXJzIHJlY2VpdmVkIFwiICsgSlNPTi5zdHJpbmdpZnkodHlwZSkgKyBcIiB3aGljaCBpcyBub3QgYSBTdGF0aWNTeW1ib2xcIiksIHR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJhbWV0ZXJzXzEgPSB0aGlzLnBhcmFtZXRlckNhY2hlLmdldCh0eXBlKTtcbiAgICAgICAgICAgIGlmICghcGFyYW1ldGVyc18xKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xhc3NNZXRhZGF0YSA9IHRoaXMuZ2V0VHlwZU1ldGFkYXRhKHR5cGUpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmVudFR5cGUgPSB0aGlzLmZpbmRQYXJlbnRUeXBlKHR5cGUsIGNsYXNzTWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lbWJlcnMgPSBjbGFzc01ldGFkYXRhID8gY2xhc3NNZXRhZGF0YVsnbWVtYmVycyddIDogbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdG9yRGF0YSA9IG1lbWJlcnMgPyBtZW1iZXJzWydfX2N0b3JfXyddIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoY3RvckRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3RvciA9ICgoY3RvckRhdGEpKS5maW5kKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhWydfX3N5bWJvbGljJ10gPT0gJ2NvbnN0cnVjdG9yJzsgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJhd1BhcmFtZXRlclR5cGVzID0gKGN0b3JbJ3BhcmFtZXRlcnMnXSkgfHwgW107XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmFtZXRlckRlY29yYXRvcnNfMSA9ICh0aGlzLnNpbXBsaWZ5KHR5cGUsIGN0b3JbJ3BhcmFtZXRlckRlY29yYXRvcnMnXSB8fCBbXSkpO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzXzEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgcmF3UGFyYW1ldGVyVHlwZXMuZm9yRWFjaChmdW5jdGlvbiAocmF3UGFyYW1UeXBlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmVzdGVkUmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJhbVR5cGUgPSBfdGhpcy50cnlTaW1wbGlmeSh0eXBlLCByYXdQYXJhbVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtVHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXN0ZWRSZXN1bHQucHVzaChwYXJhbVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVjb3JhdG9ycyA9IHBhcmFtZXRlckRlY29yYXRvcnNfMSA/IHBhcmFtZXRlckRlY29yYXRvcnNfMVtpbmRleF0gOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlY29yYXRvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXN0ZWRSZXN1bHQucHVzaC5hcHBseShuZXN0ZWRSZXN1bHQsIGRlY29yYXRvcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICAgICAgICAgICAgICAoKHBhcmFtZXRlcnNfMSkpLnB1c2gobmVzdGVkUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyc18xID0gdGhpcy5wYXJhbWV0ZXJzKHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXBhcmFtZXRlcnNfMSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzXzEgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXJDYWNoZS5zZXQodHlwZSwgcGFyYW1ldGVyc18xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJhbWV0ZXJzXzE7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgb24gdHlwZSBcIiArIEpTT04uc3RyaW5naWZ5KHR5cGUpICsgXCIgd2l0aCBlcnJvciBcIiArIGUpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLl9tZXRob2ROYW1lcyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1ldGhvZE5hbWVzID0gdGhpcy5tZXRob2RDYWNoZS5nZXQodHlwZSk7XG4gICAgICAgIGlmICghbWV0aG9kTmFtZXMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsYXNzTWV0YWRhdGEgPSB0aGlzLmdldFR5cGVNZXRhZGF0YSh0eXBlKTtcbiAgICAgICAgICAgIG1ldGhvZE5hbWVzID0ge307XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnRUeXBlID0gdGhpcy5maW5kUGFyZW50VHlwZSh0eXBlLCBjbGFzc01ldGFkYXRhKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyZW50TWV0aG9kTmFtZXNfMSA9IHRoaXMuX21ldGhvZE5hbWVzKHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHBhcmVudE1ldGhvZE5hbWVzXzEpLmZvckVhY2goZnVuY3Rpb24gKHBhcmVudFByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgKChtZXRob2ROYW1lcykpW3BhcmVudFByb3BdID0gcGFyZW50TWV0aG9kTmFtZXNfMVtwYXJlbnRQcm9wXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lbWJlcnNfMiA9IGNsYXNzTWV0YWRhdGFbJ21lbWJlcnMnXSB8fCB7fTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG1lbWJlcnNfMikuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9wRGF0YSA9IG1lbWJlcnNfMltwcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNNZXRob2QgPSAoKHByb3BEYXRhKSkuc29tZShmdW5jdGlvbiAoYSkgeyByZXR1cm4gYVsnX19zeW1ib2xpYyddID09ICdtZXRob2QnOyB9KTsgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgICAgICgobWV0aG9kTmFtZXMpKVtwcm9wTmFtZV0gPSAoKG1ldGhvZE5hbWVzKSlbcHJvcE5hbWVdIHx8IGlzTWV0aG9kO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLm1ldGhvZENhY2hlLnNldCh0eXBlLCBtZXRob2ROYW1lcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ldGhvZE5hbWVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHBhcmFtIHs/fSBjbGFzc01ldGFkYXRhXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLmZpbmRQYXJlbnRUeXBlID0gZnVuY3Rpb24gKHR5cGUsIGNsYXNzTWV0YWRhdGEpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyZW50VHlwZSA9IHRoaXMudHJ5U2ltcGxpZnkodHlwZSwgY2xhc3NNZXRhZGF0YVsnZXh0ZW5kcyddKTtcbiAgICAgICAgaWYgKHBhcmVudFR5cGUgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRUeXBlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez99IGxjUHJvcGVydHlcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUuaGFzTGlmZWN5Y2xlSG9vayA9IGZ1bmN0aW9uICh0eXBlLCBsY1Byb3BlcnR5KSB7XG4gICAgICAgIGlmICghKHR5cGUgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKG5ldyBFcnJvcihcImhhc0xpZmVjeWNsZUhvb2sgcmVjZWl2ZWQgXCIgKyBKU09OLnN0cmluZ2lmeSh0eXBlKSArIFwiIHdoaWNoIGlzIG5vdCBhIFN0YXRpY1N5bWJvbFwiKSwgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiAhIXRoaXMuX21ldGhvZE5hbWVzKHR5cGUpW2xjUHJvcGVydHldO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIG9uIHR5cGUgXCIgKyBKU09OLnN0cmluZ2lmeSh0eXBlKSArIFwiIHdpdGggZXJyb3IgXCIgKyBlKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7P30gY3RvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKHR5cGUsIGN0b3IpIHtcbiAgICAgICAgdGhpcy5jb252ZXJzaW9uTWFwLnNldCh0eXBlLCBmdW5jdGlvbiAoY29udGV4dCwgYXJncykgeyByZXR1cm4gbmV3IChjdG9yLmJpbmQuYXBwbHkoY3RvciwgW3ZvaWQgMF0uY29uY2F0KGFyZ3MpKSkoKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLl9yZWdpc3RlckZ1bmN0aW9uID0gZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG4gICAgICAgIHRoaXMuY29udmVyc2lvbk1hcC5zZXQodHlwZSwgZnVuY3Rpb24gKGNvbnRleHQsIGFyZ3MpIHsgcmV0dXJuIGZuLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLmluaXRpYWxpemVDb252ZXJzaW9uTWFwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmluamVjdGlvblRva2VuID0gdGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnSW5qZWN0aW9uVG9rZW4nKTtcbiAgICAgICAgdGhpcy5vcGFxdWVUb2tlbiA9IHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ09wYXF1ZVRva2VuJyk7XG4gICAgICAgIHRoaXMuUk9VVEVTID0gdGhpcy50cnlGaW5kRGVjbGFyYXRpb24oQU5HVUxBUl9ST1VURVIsICdST1VURVMnKTtcbiAgICAgICAgdGhpcy5BTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTID1cbiAgICAgICAgICAgIHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ0FOQUxZWkVfRk9SX0VOVFJZX0NPTVBPTkVOVFMnKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ0hvc3QnKSwgSG9zdCk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdJbmplY3RhYmxlJyksIEluamVjdGFibGUpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnU2VsZicpLCBTZWxmKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ1NraXBTZWxmJyksIFNraXBTZWxmKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ0luamVjdCcpLCBJbmplY3QpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnT3B0aW9uYWwnKSwgT3B0aW9uYWwpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnQXR0cmlidXRlJyksIEF0dHJpYnV0ZSk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdDb250ZW50Q2hpbGQnKSwgQ29udGVudENoaWxkKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ0NvbnRlbnRDaGlsZHJlbicpLCBDb250ZW50Q2hpbGRyZW4pO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnVmlld0NoaWxkJyksIFZpZXdDaGlsZCk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdWaWV3Q2hpbGRyZW4nKSwgVmlld0NoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ0lucHV0JyksIElucHV0KTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ091dHB1dCcpLCBPdXRwdXQpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnUGlwZScpLCBQaXBlKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ0hvc3RCaW5kaW5nJyksIEhvc3RCaW5kaW5nKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ0hvc3RMaXN0ZW5lcicpLCBIb3N0TGlzdGVuZXIpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnRGlyZWN0aXZlJyksIERpcmVjdGl2ZSk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdDb21wb25lbnQnKSwgQ29tcG9uZW50KTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ05nTW9kdWxlJyksIE5nTW9kdWxlKTtcbiAgICAgICAgLy8gTm90ZTogU29tZSBtZXRhZGF0YSBjbGFzc2VzIGNhbiBiZSB1c2VkIGRpcmVjdGx5IHdpdGggUHJvdmlkZXIuZGVwcy5cbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ0hvc3QnKSwgSG9zdCk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdTZWxmJyksIFNlbGYpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnU2tpcFNlbGYnKSwgU2tpcFNlbGYpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnT3B0aW9uYWwnKSwgT3B0aW9uYWwpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckZ1bmN0aW9uKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ3RyaWdnZXInKSwgdHJpZ2dlcik7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRnVuY3Rpb24odGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnc3RhdGUnKSwgc3RhdGUpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckZ1bmN0aW9uKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ3RyYW5zaXRpb24nKSwgdHJhbnNpdGlvbik7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRnVuY3Rpb24odGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnc3R5bGUnKSwgc3R5bGUpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckZ1bmN0aW9uKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ2FuaW1hdGUnKSwgYW5pbWF0ZSk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRnVuY3Rpb24odGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAna2V5ZnJhbWVzJyksIGtleWZyYW1lcyk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRnVuY3Rpb24odGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnc2VxdWVuY2UnKSwgc2VxdWVuY2UpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckZ1bmN0aW9uKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ2dyb3VwJyksIGdyb3VwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGdldFN0YXRpY1N5bWJvbCBwcm9kdWNlcyBhIFR5cGUgd2hvc2UgbWV0YWRhdGEgaXMga25vd24gYnV0IHdob3NlIGltcGxlbWVudGF0aW9uIGlzIG5vdCBsb2FkZWQuXG4gICAgICogQWxsIHR5cGVzIHBhc3NlZCB0byB0aGUgU3RhdGljUmVzb2x2ZXIgc2hvdWxkIGJlIHBzZXVkby10eXBlcyByZXR1cm5lZCBieSB0aGlzIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gZGVjbGFyYXRpb25GaWxlIHRoZSBhYnNvbHV0ZSBwYXRoIG9mIHRoZSBmaWxlIHdoZXJlIHRoZSBzeW1ib2wgaXMgZGVjbGFyZWRcbiAgICAgKiBAcGFyYW0gez99IG5hbWUgdGhlIG5hbWUgb2YgdGhlIHR5cGUuXG4gICAgICogQHBhcmFtIHs/PX0gbWVtYmVyc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS5nZXRTdGF0aWNTeW1ib2wgPSBmdW5jdGlvbiAoZGVjbGFyYXRpb25GaWxlLCBuYW1lLCBtZW1iZXJzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN5bWJvbFJlc29sdmVyLmdldFN0YXRpY1N5bWJvbChkZWNsYXJhdGlvbkZpbGUsIG5hbWUsIG1lbWJlcnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlcnJvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEBwYXJhbSB7Pz19IHBhdGhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUucmVwb3J0RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IsIGNvbnRleHQsIHBhdGgpIHtcbiAgICAgICAgaWYgKHRoaXMuZXJyb3JSZWNvcmRlcikge1xuICAgICAgICAgICAgdGhpcy5lcnJvclJlY29yZGVyKGVycm9yLCAoY29udGV4dCAmJiBjb250ZXh0LmZpbGVQYXRoKSB8fCBwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTaW1wbGlmeSBidXQgZGlzY2FyZCBhbnkgZXJyb3JzXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS50cnlTaW1wbGlmeSA9IGZ1bmN0aW9uIChjb250ZXh0LCB2YWx1ZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcmlnaW5hbFJlY29yZGVyID0gdGhpcy5lcnJvclJlY29yZGVyO1xuICAgICAgICB0aGlzLmVycm9yUmVjb3JkZXIgPSBmdW5jdGlvbiAoZXJyb3IsIGZpbGVOYW1lKSB7IH07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHRoaXMuc2ltcGxpZnkoY29udGV4dCwgdmFsdWUpO1xuICAgICAgICB0aGlzLmVycm9yUmVjb3JkZXIgPSBvcmlnaW5hbFJlY29yZGVyO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogXFxAaW50ZXJuYWxcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLnNpbXBsaWZ5ID0gZnVuY3Rpb24gKGNvbnRleHQsIHZhbHVlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzY29wZSA9IEJpbmRpbmdTY29wZS5lbXB0eTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2FsbGluZyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7P30gZGVwdGhcbiAgICAgICAgICogQHBhcmFtIHs/fSByZWZlcmVuY2VzXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBzaW1wbGlmeUluQ29udGV4dChjb250ZXh0LCB2YWx1ZSwgZGVwdGgsIHJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBzdGF0aWNTeW1ib2xcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlc29sdmVSZWZlcmVuY2VWYWx1ZShzdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXNvbHZlZFN5bWJvbCA9IHNlbGYuc3ltYm9sUmVzb2x2ZXIucmVzb2x2ZVN5bWJvbChzdGF0aWNTeW1ib2wpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlZFN5bWJvbCA/IHJlc29sdmVkU3ltYm9sLm1ldGFkYXRhIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBmdW5jdGlvblN5bWJvbFxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSB0YXJnZXRGdW5jdGlvblxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhcmdzXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBzaW1wbGlmeUNhbGwoZnVuY3Rpb25TeW1ib2wsIHRhcmdldEZ1bmN0aW9uLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldEZ1bmN0aW9uICYmIHRhcmdldEZ1bmN0aW9uWydfX3N5bWJvbGljJ10gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGluZy5nZXQoZnVuY3Rpb25TeW1ib2wpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlY3Vyc2lvbiBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FsbGluZy5zZXQoZnVuY3Rpb25TeW1ib2wsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWVfMSA9IHRhcmdldEZ1bmN0aW9uWyd2YWx1ZSddO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlXzEgJiYgKGRlcHRoICE9IDAgfHwgdmFsdWVfMS5fX3N5bWJvbGljICE9ICdlcnJvcicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyYW1ldGVycyA9IHRhcmdldEZ1bmN0aW9uWydwYXJhbWV0ZXJzJ107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVmYXVsdHMgPSB0YXJnZXRGdW5jdGlvbi5kZWZhdWx0cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJncy5tYXAoZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gc2ltcGxpZnlJbkNvbnRleHQoY29udGV4dCwgYXJnLCBkZXB0aCArIDEsIHJlZmVyZW5jZXMpOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIHNob3VsZElnbm9yZShhcmcpID8gdW5kZWZpbmVkIDogYXJnOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdHMgJiYgZGVmYXVsdHMubGVuZ3RoID4gYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoLmFwcGx5KGFyZ3MsIGRlZmF1bHRzLnNsaWNlKGFyZ3MubGVuZ3RoKS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBzaW1wbGlmeSh2YWx1ZSk7IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZnVuY3Rpb25TY29wZSA9IEJpbmRpbmdTY29wZS5idWlsZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBwYXJhbWV0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uU2NvcGUuZGVmaW5lKHBhcmFtZXRlcnNbaV0sIGFyZ3NbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvbGRTY29wZSA9IHNjb3BlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdF8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlID0gZnVuY3Rpb25TY29wZS5kb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdF8xID0gc2ltcGxpZnlJbkNvbnRleHQoZnVuY3Rpb25TeW1ib2wsIHZhbHVlXzEsIGRlcHRoICsgMSwgcmVmZXJlbmNlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZSA9IG9sZFNjb3BlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0XzE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsaW5nLmRlbGV0ZShmdW5jdGlvblN5bWJvbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGRlcHRoIGlzIDAgd2UgYXJlIGV2YWx1YXRpbmcgdGhlIHRvcCBsZXZlbCBleHByZXNzaW9uIHRoYXQgaXMgZGVzY3JpYmluZyBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlY29yYXRvci4gSW4gdGhpcyBjYXNlLCBpdCBpcyBhIGRlY29yYXRvciB3ZSBkb24ndCB1bmRlcnN0YW5kLCBzdWNoIGFzIGEgY3VzdG9tXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vbi1hbmd1bGFyIGRlY29yYXRvciwgYW5kIHdlIHNob3VsZCBqdXN0IGlnbm9yZSBpdC5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElHTk9SRTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpbXBsaWZ5KHsgX19zeW1ib2xpYzogJ2Vycm9yJywgbWVzc2FnZTogJ0Z1bmN0aW9uIGNhbGwgbm90IHN1cHBvcnRlZCcsIGNvbnRleHQ6IGZ1bmN0aW9uU3ltYm9sIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGV4cHJlc3Npb25cbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIHNpbXBsaWZ5KGV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmltaXRpdmUoZXhwcmVzc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9uIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0XzIgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9ICgoZXhwcmVzc2lvbikpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgYSBzcHJlYWQgZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5fX3N5bWJvbGljID09PSAnc3ByZWFkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNwcmVhZEFycmF5ID0gc2ltcGxpZnkoaXRlbS5leHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzcHJlYWRBcnJheSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBzcHJlYWRBcnJheV8xID0gc3ByZWFkQXJyYXk7IF9iIDwgc3ByZWFkQXJyYXlfMS5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcHJlYWRJdGVtID0gc3ByZWFkQXJyYXlfMVtfYl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRfMi5wdXNoKHNwcmVhZEl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlXzIgPSBzaW1wbGlmeShpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRJZ25vcmUodmFsdWVfMikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdF8yLnB1c2godmFsdWVfMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdF8yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdG9wIHNpbXBsaWZpY2F0aW9uIGF0IGJ1aWx0aW4gc3ltYm9scyBvciBpZiB3ZSBhcmUgaW4gYSByZWZlcmVuY2UgY29udGV4dFxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbiA9PT0gc2VsZi5pbmplY3Rpb25Ub2tlbiB8fCBleHByZXNzaW9uID09PSBzZWxmLm9wYXF1ZVRva2VuIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbnZlcnNpb25NYXAuaGFzKGV4cHJlc3Npb24pIHx8IHJlZmVyZW5jZXMgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXRpY1N5bWJvbCA9IGV4cHJlc3Npb247XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZWNsYXJhdGlvblZhbHVlID0gcmVzb2x2ZVJlZmVyZW5jZVZhbHVlKHN0YXRpY1N5bWJvbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVjbGFyYXRpb25WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaW1wbGlmeUluQ29udGV4dChzdGF0aWNTeW1ib2wsIGRlY2xhcmF0aW9uVmFsdWUsIGRlcHRoICsgMSwgcmVmZXJlbmNlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGljU3ltYm9sO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9uWydfX3N5bWJvbGljJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXRpY1N5bWJvbCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZXhwcmVzc2lvblsnX19zeW1ib2xpYyddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYmlub3AnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsZWZ0ID0gc2ltcGxpZnkoZXhwcmVzc2lvblsnbGVmdCddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZElnbm9yZShsZWZ0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByaWdodCA9IHNpbXBsaWZ5KGV4cHJlc3Npb25bJ3JpZ2h0J10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkSWdub3JlKHJpZ2h0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChleHByZXNzaW9uWydvcGVyYXRvciddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcmJic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgJiYgcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd8fCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgfHwgcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd8JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCB8IHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnXic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgXiByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyYnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0ICYgcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc9PSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgPT0gcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICchPSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgIT0gcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc9PT0nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0ID09PSByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyE9PSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgIT09IHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgPCByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0ID4gcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgPD0gcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgPj0gcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc8PCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgPDwgcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc+Pic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgPj4gcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCArIHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgLSByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0ICogcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcvJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCAvIHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgJSByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdpZic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbmRpdGlvbiA9IHNpbXBsaWZ5KGV4cHJlc3Npb25bJ2NvbmRpdGlvbiddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmRpdGlvbiA/IHNpbXBsaWZ5KGV4cHJlc3Npb25bJ3RoZW5FeHByZXNzaW9uJ10pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpbXBsaWZ5KGV4cHJlc3Npb25bJ2Vsc2VFeHByZXNzaW9uJ10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3ByZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9wZXJhbmQgPSBzaW1wbGlmeShleHByZXNzaW9uWydvcGVyYW5kJ10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkSWdub3JlKG9wZXJhbmQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wZXJhbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZXhwcmVzc2lvblsnb3BlcmF0b3InXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wZXJhbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLW9wZXJhbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICchJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIW9wZXJhbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd+JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gfm9wZXJhbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnaW5kZXgnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmRleFRhcmdldCA9IHNpbXBsaWZ5KGV4cHJlc3Npb25bJ2V4cHJlc3Npb24nXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluZGV4ID0gc2ltcGxpZnkoZXhwcmVzc2lvblsnaW5kZXgnXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleFRhcmdldCAmJiBpc1ByaW1pdGl2ZShpbmRleCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXhUYXJnZXRbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZW1iZXIgPSBleHByZXNzaW9uWydtZW1iZXInXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VsZWN0Q29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlbGVjdFRhcmdldCA9IHNpbXBsaWZ5KGV4cHJlc3Npb25bJ2V4cHJlc3Npb24nXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RUYXJnZXQgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lbWJlcnMgPSBzZWxlY3RUYXJnZXQubWVtYmVycy5jb25jYXQobWVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdENvbnRleHQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZ2V0U3RhdGljU3ltYm9sKHNlbGVjdFRhcmdldC5maWxlUGF0aCwgc2VsZWN0VGFyZ2V0Lm5hbWUsIG1lbWJlcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVjbGFyYXRpb25WYWx1ZSA9IHJlc29sdmVSZWZlcmVuY2VWYWx1ZShzZWxlY3RDb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWNsYXJhdGlvblZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpbXBsaWZ5SW5Db250ZXh0KHNlbGVjdENvbnRleHQsIGRlY2xhcmF0aW9uVmFsdWUsIGRlcHRoICsgMSwgcmVmZXJlbmNlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0Q29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0VGFyZ2V0ICYmIGlzUHJpbWl0aXZlKG1lbWJlcikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2ltcGxpZnlJbkNvbnRleHQoc2VsZWN0Q29udGV4dCwgc2VsZWN0VGFyZ2V0W21lbWJlcl0sIGRlcHRoICsgMSwgcmVmZXJlbmNlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JlZmVyZW5jZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IFRoaXMgb25seSBoYXMgdG8gZGVhbCB3aXRoIHZhcmlhYmxlIHJlZmVyZW5jZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzIHN5bWJvbCByZWZlcmVuY2VzIGhhdmUgYmVlbiBjb252ZXJ0ZWQgaW50byBTdGF0aWNTeW1ib2xzIGFscmVhZHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhlIFN0YXRpY1N5bWJvbFJlc29sdmVyIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lID0gZXhwcmVzc2lvblsnbmFtZSddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsb2NhbFZhbHVlID0gc2NvcGUucmVzb2x2ZShuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsVmFsdWUgIT0gQmluZGluZ1Njb3BlLm1pc3NpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICduZXcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NhbGwnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIGZ1bmN0aW9uIGlzIGEgYnVpbHQtaW4gY29udmVyc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNTeW1ib2wgPSBzaW1wbGlmeUluQ29udGV4dChjb250ZXh0LCBleHByZXNzaW9uWydleHByZXNzaW9uJ10sIGRlcHRoICsgMSwgLyogcmVmZXJlbmNlcyAqLyAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRpY1N5bWJvbCBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRpY1N5bWJvbCA9PT0gc2VsZi5pbmplY3Rpb25Ub2tlbiB8fCBzdGF0aWNTeW1ib2wgPT09IHNlbGYub3BhcXVlVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBzb21lYm9keSBjYWxscyBuZXcgSW5qZWN0aW9uVG9rZW4sIGRvbid0IGNyZWF0ZSBhbiBJbmplY3Rpb25Ub2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgcmF0aGVyIHJldHVybiB0aGUgc3ltYm9sIHRvIHdoaWNoIHRoZSBJbmplY3Rpb25Ub2tlbiBpcyBhc3NpZ25lZCB0by5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFyZ0V4cHJlc3Npb25zID0gZXhwcmVzc2lvblsnYXJndW1lbnRzJ10gfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb252ZXJ0ZXIgPSBzZWxmLmNvbnZlcnNpb25NYXAuZ2V0KHN0YXRpY1N5bWJvbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udmVydGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXJncyA9IGFyZ0V4cHJlc3Npb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gc2ltcGxpZnlJbkNvbnRleHQoY29udGV4dCwgYXJnLCBkZXB0aCArIDEsIHJlZmVyZW5jZXMpOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIHNob3VsZElnbm9yZShhcmcpID8gdW5kZWZpbmVkIDogYXJnOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udmVydGVyKGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBmdW5jdGlvbiBpcyBvbmUgd2UgY2FuIHNpbXBsaWZ5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRhcmdldEZ1bmN0aW9uID0gcmVzb2x2ZVJlZmVyZW5jZVZhbHVlKHN0YXRpY1N5bWJvbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpbXBsaWZ5Q2FsbChzdGF0aWNTeW1ib2wsIHRhcmdldEZ1bmN0aW9uLCBhcmdFeHByZXNzaW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElHTk9SRTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lc3NhZ2UgPSBwcm9kdWNlRXJyb3JNZXNzYWdlKGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvblsnbGluZSddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlICsgXCIgKHBvc2l0aW9uIFwiICsgKGV4cHJlc3Npb25bJ2xpbmUnXSArIDEpICsgXCI6XCIgKyAoZXhwcmVzc2lvblsnY2hhcmFjdGVyJ10gKyAxKSArIFwiIGluIHRoZSBvcmlnaW5hbCAudHMgZmlsZSlcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVwb3J0RXJyb3IocG9zaXRpb25hbEVycm9yKG1lc3NhZ2UsIGNvbnRleHQuZmlsZVBhdGgsIGV4cHJlc3Npb25bJ2xpbmUnXSwgZXhwcmVzc2lvblsnY2hhcmFjdGVyJ10pLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVwb3J0RXJyb3IobmV3IEVycm9yKG1lc3NhZ2UpLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSUdOT1JFO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2lnbm9yZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcFN0cmluZ01hcChleHByZXNzaW9uLCBmdW5jdGlvbiAodmFsdWUsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChSRUZFUkVOQ0VfU0VULmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSBVU0VfVkFMVUUgJiYgUFJPVklERSBpbiBleHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBwcm92aWRlciBleHByZXNzaW9uLCBjaGVjayBmb3Igc3BlY2lhbCB0b2tlbnMgdGhhdCBuZWVkIHRoZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkdXJpbmcgYW5hbHlzaXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb3ZpZGUgPSBzaW1wbGlmeShleHByZXNzaW9uLnByb3ZpZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvdmlkZSA9PT0gc2VsZi5ST1VURVMgfHwgcHJvdmlkZSA9PSBzZWxmLkFOQUxZWkVfRk9SX0VOVFJZX0NPTVBPTkVOVFMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaW1wbGlmeSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpbXBsaWZ5SW5Db250ZXh0KGNvbnRleHQsIHZhbHVlLCBkZXB0aCwgcmVmZXJlbmNlcyArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpbXBsaWZ5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBJR05PUkU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaW1wbGlmeSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lbWJlcnMgPSBjb250ZXh0Lm1lbWJlcnMubGVuZ3RoID8gXCIuXCIgKyBjb250ZXh0Lm1lbWJlcnMuam9pbignLicpIDogJyc7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWVzc2FnZSA9IGUubWVzc2FnZSArIFwiLCByZXNvbHZpbmcgc3ltYm9sIFwiICsgY29udGV4dC5uYW1lICsgbWVtYmVycyArIFwiIGluIFwiICsgY29udGV4dC5maWxlUGF0aDtcbiAgICAgICAgICAgICAgICBpZiAoZS5maWxlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBwb3NpdGlvbmFsRXJyb3IobWVzc2FnZSwgZS5maWxlTmFtZSwgZS5saW5lLCBlLmNvbHVtbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IHN5bnRheEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlY29yZGVkU2ltcGxpZnlJbkNvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpbXBsaWZ5SW5Db250ZXh0KGNvbnRleHQsIHZhbHVlLCAwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVwb3J0RXJyb3IoZSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHRoaXMuZXJyb3JSZWNvcmRlciA/IHJlY29yZGVkU2ltcGxpZnlJbkNvbnRleHQoY29udGV4dCwgdmFsdWUpIDpcbiAgICAgICAgICAgIHNpbXBsaWZ5SW5Db250ZXh0KGNvbnRleHQsIHZhbHVlLCAwLCAwKTtcbiAgICAgICAgaWYgKHNob3VsZElnbm9yZShyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUuZ2V0VHlwZU1ldGFkYXRhID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzb2x2ZWRTeW1ib2wgPSB0aGlzLnN5bWJvbFJlc29sdmVyLnJlc29sdmVTeW1ib2wodHlwZSk7XG4gICAgICAgIHJldHVybiByZXNvbHZlZFN5bWJvbCAmJiByZXNvbHZlZFN5bWJvbC5tZXRhZGF0YSA/IHJlc29sdmVkU3ltYm9sLm1ldGFkYXRhIDpcbiAgICAgICAgICAgIHsgX19zeW1ib2xpYzogJ2NsYXNzJyB9O1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRpY1JlZmxlY3Rvcjtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gZXJyb3JcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGV4cGFuZGVkTWVzc2FnZShlcnJvcikge1xuICAgIHN3aXRjaCAoZXJyb3IubWVzc2FnZSkge1xuICAgICAgICBjYXNlICdSZWZlcmVuY2UgdG8gbm9uLWV4cG9ydGVkIGNsYXNzJzpcbiAgICAgICAgICAgIGlmIChlcnJvci5jb250ZXh0ICYmIGVycm9yLmNvbnRleHQuY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiUmVmZXJlbmNlIHRvIGEgbm9uLWV4cG9ydGVkIGNsYXNzIFwiICsgZXJyb3IuY29udGV4dC5jbGFzc05hbWUgKyBcIi4gQ29uc2lkZXIgZXhwb3J0aW5nIHRoZSBjbGFzc1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1ZhcmlhYmxlIG5vdCBpbml0aWFsaXplZCc6XG4gICAgICAgICAgICByZXR1cm4gJ09ubHkgaW5pdGlhbGl6ZWQgdmFyaWFibGVzIGFuZCBjb25zdGFudHMgY2FuIGJlIHJlZmVyZW5jZWQgYmVjYXVzZSB0aGUgdmFsdWUgb2YgdGhpcyB2YXJpYWJsZSBpcyBuZWVkZWQgYnkgdGhlIHRlbXBsYXRlIGNvbXBpbGVyJztcbiAgICAgICAgY2FzZSAnRGVzdHJ1Y3R1cmluZyBub3Qgc3VwcG9ydGVkJzpcbiAgICAgICAgICAgIHJldHVybiAnUmVmZXJlbmNpbmcgYW4gZXhwb3J0ZWQgZGVzdHJ1Y3R1cmVkIHZhcmlhYmxlIG9yIGNvbnN0YW50IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIHRlbXBsYXRlIGNvbXBpbGVyLiBDb25zaWRlciBzaW1wbGlmeWluZyB0aGlzIHRvIGF2b2lkIGRlc3RydWN0dXJpbmcnO1xuICAgICAgICBjYXNlICdDb3VsZCBub3QgcmVzb2x2ZSB0eXBlJzpcbiAgICAgICAgICAgIGlmIChlcnJvci5jb250ZXh0ICYmIGVycm9yLmNvbnRleHQudHlwZU5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJDb3VsZCBub3QgcmVzb2x2ZSB0eXBlIFwiICsgZXJyb3IuY29udGV4dC50eXBlTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdGdW5jdGlvbiBjYWxsIG5vdCBzdXBwb3J0ZWQnOlxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlZml4ID0gZXJyb3IuY29udGV4dCAmJiBlcnJvci5jb250ZXh0Lm5hbWUgPyBcIkNhbGxpbmcgZnVuY3Rpb24gJ1wiICsgZXJyb3IuY29udGV4dC5uYW1lICsgXCInLCBmXCIgOiAnRic7XG4gICAgICAgICAgICByZXR1cm4gcHJlZml4ICtcbiAgICAgICAgICAgICAgICAndW5jdGlvbiBjYWxscyBhcmUgbm90IHN1cHBvcnRlZC4gQ29uc2lkZXIgcmVwbGFjaW5nIHRoZSBmdW5jdGlvbiBvciBsYW1iZGEgd2l0aCBhIHJlZmVyZW5jZSB0byBhbiBleHBvcnRlZCBmdW5jdGlvbic7XG4gICAgICAgIGNhc2UgJ1JlZmVyZW5jZSB0byBhIGxvY2FsIHN5bWJvbCc6XG4gICAgICAgICAgICBpZiAoZXJyb3IuY29udGV4dCAmJiBlcnJvci5jb250ZXh0Lm5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJSZWZlcmVuY2UgdG8gYSBsb2NhbCAobm9uLWV4cG9ydGVkKSBzeW1ib2wgJ1wiICsgZXJyb3IuY29udGV4dC5uYW1lICsgXCInLiBDb25zaWRlciBleHBvcnRpbmcgdGhlIHN5bWJvbFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBlcnJvci5tZXNzYWdlO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGVycm9yXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBwcm9kdWNlRXJyb3JNZXNzYWdlKGVycm9yKSB7XG4gICAgcmV0dXJuIFwiRXJyb3IgZW5jb3VudGVyZWQgcmVzb2x2aW5nIHN5bWJvbCB2YWx1ZXMgc3RhdGljYWxseS4gXCIgKyBleHBhbmRlZE1lc3NhZ2UoZXJyb3IpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGlucHV0XG4gKiBAcGFyYW0gez99IHRyYW5zZm9ybVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gbWFwU3RyaW5nTWFwKGlucHV0LCB0cmFuc2Zvcm0pIHtcbiAgICBpZiAoIWlucHV0KVxuICAgICAgICByZXR1cm4ge307XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0ge307XG4gICAgT2JqZWN0LmtleXMoaW5wdXQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IHRyYW5zZm9ybShpbnB1dFtrZXldLCBrZXkpO1xuICAgICAgICBpZiAoIXNob3VsZElnbm9yZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmIChISURERU5fS0VZLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsIGtleSwgeyBlbnVtZXJhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBvXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShvKSB7XG4gICAgcmV0dXJuIG8gPT09IG51bGwgfHwgKHR5cGVvZiBvICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvICE9PSAnb2JqZWN0Jyk7XG59XG4vKipcbiAqIEBhYnN0cmFjdFxuICovXG52YXIgQmluZGluZ1Njb3BlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCaW5kaW5nU2NvcGUoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmluZGluZ1Njb3BlLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKG5hbWUpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmRpbmdTY29wZS5idWlsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3VycmVudCA9IG5ldyBNYXAoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlZmluZTogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudC5zZXQobmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudC5zaXplID4gMCA/IG5ldyBQb3B1bGF0ZWRTY29wZShjdXJyZW50KSA6IEJpbmRpbmdTY29wZS5lbXB0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBCaW5kaW5nU2NvcGU7XG59KCkpO1xuQmluZGluZ1Njb3BlLm1pc3NpbmcgPSB7fTtcbkJpbmRpbmdTY29wZS5lbXB0eSA9IHsgcmVzb2x2ZTogZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIEJpbmRpbmdTY29wZS5taXNzaW5nOyB9IH07XG52YXIgUG9wdWxhdGVkU2NvcGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFBvcHVsYXRlZFNjb3BlLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYmluZGluZ3NcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQb3B1bGF0ZWRTY29wZShiaW5kaW5ncykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5iaW5kaW5ncyA9IGJpbmRpbmdzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUG9wdWxhdGVkU2NvcGUucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iaW5kaW5ncy5oYXMobmFtZSkgPyB0aGlzLmJpbmRpbmdzLmdldChuYW1lKSA6IEJpbmRpbmdTY29wZS5taXNzaW5nO1xuICAgIH07XG4gICAgcmV0dXJuIFBvcHVsYXRlZFNjb3BlO1xufShCaW5kaW5nU2NvcGUpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gKiBAcGFyYW0gez99IGZpbGVOYW1lXG4gKiBAcGFyYW0gez99IGxpbmVcbiAqIEBwYXJhbSB7P30gY29sdW1uXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBwb3NpdGlvbmFsRXJyb3IobWVzc2FnZSwgZmlsZU5hbWUsIGxpbmUsIGNvbHVtbikge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAoKHJlc3VsdCkpLmZpbGVOYW1lID0gZmlsZU5hbWU7XG4gICAgKChyZXN1bHQpKS5saW5lID0gbGluZTtcbiAgICAoKHJlc3VsdCkpLmNvbHVtbiA9IGNvbHVtbjtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIFJlc29sdmVkU3RhdGljU3ltYm9sID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN5bWJvbFxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZXNvbHZlZFN0YXRpY1N5bWJvbChzeW1ib2wsIG1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMuc3ltYm9sID0gc3ltYm9sO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgfVxuICAgIHJldHVybiBSZXNvbHZlZFN0YXRpY1N5bWJvbDtcbn0oKSk7XG52YXIgU1VQUE9SVEVEX1NDSEVNQV9WRVJTSU9OID0gMztcbi8qKlxuICogVGhpcyBjbGFzcyBpcyByZXNwb25zaWJsZSBmb3IgbG9hZGluZyBtZXRhZGF0YSBwZXIgc3ltYm9sLFxuICogYW5kIG5vcm1hbGl6aW5nIHJlZmVyZW5jZXMgYmV0d2VlbiBzeW1ib2xzLlxuICpcbiAqIEludGVybmFsbHksIGl0IG9ubHkgdXNlcyBzeW1ib2xzIHdpdGhvdXQgbWVtYmVycyxcbiAqIGFuZCBkZWR1Y2VzIHRoZSB2YWx1ZXMgZm9yIHN5bWJvbHMgd2l0aCBtZW1iZXJzIGJhc2VkXG4gKiBvbiB0aGVzZSBzeW1ib2xzLlxuICovXG52YXIgU3RhdGljU3ltYm9sUmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaG9zdFxuICAgICAqIEBwYXJhbSB7P30gc3RhdGljU3ltYm9sQ2FjaGVcbiAgICAgKiBAcGFyYW0gez99IHN1bW1hcnlSZXNvbHZlclxuICAgICAqIEBwYXJhbSB7Pz19IGVycm9yUmVjb3JkZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdGF0aWNTeW1ib2xSZXNvbHZlcihob3N0LCBzdGF0aWNTeW1ib2xDYWNoZSwgc3VtbWFyeVJlc29sdmVyLCBlcnJvclJlY29yZGVyKSB7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIHRoaXMuc3RhdGljU3ltYm9sQ2FjaGUgPSBzdGF0aWNTeW1ib2xDYWNoZTtcbiAgICAgICAgdGhpcy5zdW1tYXJ5UmVzb2x2ZXIgPSBzdW1tYXJ5UmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuZXJyb3JSZWNvcmRlciA9IGVycm9yUmVjb3JkZXI7XG4gICAgICAgIHRoaXMubWV0YWRhdGFDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5yZXNvbHZlZFN5bWJvbHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucmVzb2x2ZWRGaWxlUGF0aHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuaW1wb3J0QXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc3ltYm9sUmVzb3VyY2VQYXRocyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zeW1ib2xGcm9tRmlsZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5rbm93bkZpbGVOYW1lVG9Nb2R1bGVOYW1lcyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGF0aWNTeW1ib2xcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5yZXNvbHZlU3ltYm9sID0gZnVuY3Rpb24gKHN0YXRpY1N5bWJvbCkge1xuICAgICAgICBpZiAoc3RhdGljU3ltYm9sLm1lbWJlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuICgodGhpcy5fcmVzb2x2ZVN5bWJvbE1lbWJlcnMoc3RhdGljU3ltYm9sKSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHRoaXMucmVzb2x2ZWRTeW1ib2xzLmdldChzdGF0aWNTeW1ib2wpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9ICgodGhpcy5fcmVzb2x2ZVN5bWJvbEZyb21TdW1tYXJ5KHN0YXRpY1N5bWJvbCkpKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlOiBTb21lIHVzZXJzIHVzZSBsaWJyYXJpZXMgdGhhdCB3ZXJlIG5vdCBjb21waWxlZCB3aXRoIG5nYywgaS5lLiB0aGV5IGRvbid0XG4gICAgICAgIC8vIGhhdmUgc3VtbWFyaWVzLCBvbmx5IC5kLnRzIGZpbGVzLiBTbyB3ZSBhbHdheXMgbmVlZCB0byBjaGVjayBib3RoLCB0aGUgc3VtbWFyeVxuICAgICAgICAvLyBhbmQgbWV0YWRhdGEuXG4gICAgICAgIHRoaXMuX2NyZWF0ZVN5bWJvbHNPZihzdGF0aWNTeW1ib2wuZmlsZVBhdGgpO1xuICAgICAgICByZXN1bHQgPSAoKHRoaXMucmVzb2x2ZWRTeW1ib2xzLmdldChzdGF0aWNTeW1ib2wpKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBnZXRJbXBvcnRBcyBwcm9kdWNlcyBhIHN5bWJvbCB0aGF0IGNhbiBiZSB1c2VkIHRvIGltcG9ydCB0aGUgZ2l2ZW4gc3ltYm9sLlxuICAgICAqIFRoZSBpbXBvcnQgbWlnaHQgYmUgZGlmZmVyZW50IHRoYW4gdGhlIHN5bWJvbCBpZiB0aGUgc3ltYm9sIGlzIGV4cG9ydGVkIGZyb21cbiAgICAgKiBhIGxpYnJhcnkgd2l0aCBhIHN1bW1hcnk7IGluIHdoaWNoIGNhc2Ugd2Ugd2FudCB0byBpbXBvcnQgdGhlIHN5bWJvbCBmcm9tIHRoZVxuICAgICAqIG5nZmFjdG9yeSByZS1leHBvcnQgaW5zdGVhZCBvZiBkaXJlY3RseSB0byBhdm9pZCBpbnRyb2R1Y2luZyBhIGRpcmVjdCBkZXBlbmRlbmN5XG4gICAgICogb24gYW4gb3RoZXJ3aXNlIGluZGlyZWN0IGRlcGVuZGVuY3kuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez99IHN0YXRpY1N5bWJvbCB0aGUgc3ltYm9sIGZvciB3aGljaCB0byBnZW5lcmF0ZSBhIGltcG9ydCBzeW1ib2xcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5nZXRJbXBvcnRBcyA9IGZ1bmN0aW9uIChzdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgaWYgKHN0YXRpY1N5bWJvbC5tZW1iZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmFzZVN5bWJvbCA9IHRoaXMuZ2V0U3RhdGljU3ltYm9sKHN0YXRpY1N5bWJvbC5maWxlUGF0aCwgc3RhdGljU3ltYm9sLm5hbWUpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmFzZUltcG9ydEFzID0gdGhpcy5nZXRJbXBvcnRBcyhiYXNlU3ltYm9sKTtcbiAgICAgICAgICAgIHJldHVybiBiYXNlSW1wb3J0QXMgP1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0U3RhdGljU3ltYm9sKGJhc2VJbXBvcnRBcy5maWxlUGF0aCwgYmFzZUltcG9ydEFzLm5hbWUsIHN0YXRpY1N5bWJvbC5tZW1iZXJzKSA6XG4gICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdW1tYXJpemVkRmlsZU5hbWUgPSBzdHJpcFN1bW1hcnlGb3JKaXRGaWxlU3VmZml4KHN0YXRpY1N5bWJvbC5maWxlUGF0aCk7XG4gICAgICAgIGlmIChzdW1tYXJpemVkRmlsZU5hbWUgIT09IHN0YXRpY1N5bWJvbC5maWxlUGF0aCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3VtbWFyaXplZE5hbWUgPSBzdHJpcFN1bW1hcnlGb3JKaXROYW1lU3VmZml4KHN0YXRpY1N5bWJvbC5uYW1lKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJhc2VTeW1ib2wgPSB0aGlzLmdldFN0YXRpY1N5bWJvbChzdW1tYXJpemVkRmlsZU5hbWUsIHN1bW1hcml6ZWROYW1lLCBzdGF0aWNTeW1ib2wubWVtYmVycyk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiYXNlSW1wb3J0QXMgPSB0aGlzLmdldEltcG9ydEFzKGJhc2VTeW1ib2wpO1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VJbXBvcnRBcyA/XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRTdGF0aWNTeW1ib2woc3VtbWFyeUZvckppdEZpbGVOYW1lKGJhc2VJbXBvcnRBcy5maWxlUGF0aCksIHN1bW1hcnlGb3JKaXROYW1lKGJhc2VJbXBvcnRBcy5uYW1lKSwgYmFzZVN5bWJvbC5tZW1iZXJzKSA6XG4gICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSB0aGlzLnN1bW1hcnlSZXNvbHZlci5nZXRJbXBvcnRBcyhzdGF0aWNTeW1ib2wpO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gKCh0aGlzLmltcG9ydEFzLmdldChzdGF0aWNTeW1ib2wpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGdldFJlc291cmNlUGF0aCBwcm9kdWNlcyB0aGUgcGF0aCB0byB0aGUgb3JpZ2luYWwgbG9jYXRpb24gb2YgdGhlIHN5bWJvbCBhbmQgc2hvdWxkXG4gICAgICogYmUgdXNlZCB0byBkZXRlcm1pbmUgdGhlIHJlbGF0aXZlIGxvY2F0aW9uIG9mIHJlc291cmNlIHJlZmVyZW5jZXMgcmVjb3JkZWQgaW5cbiAgICAgKiBzeW1ib2wgbWV0YWRhdGEuXG4gICAgICogQHBhcmFtIHs/fSBzdGF0aWNTeW1ib2xcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5nZXRSZXNvdXJjZVBhdGggPSBmdW5jdGlvbiAoc3RhdGljU3ltYm9sKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN5bWJvbFJlc291cmNlUGF0aHMuZ2V0KHN0YXRpY1N5bWJvbCkgfHwgc3RhdGljU3ltYm9sLmZpbGVQYXRoO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZ2V0VHlwZUFyaXR5IHJldHVybnMgdGhlIG51bWJlciBvZiBnZW5lcmljIHR5cGUgcGFyYW1ldGVycyB0aGUgZ2l2ZW4gc3ltYm9sXG4gICAgICogaGFzLiBJZiB0aGUgc3ltYm9sIGlzIG5vdCBhIHR5cGUgdGhlIHJlc3VsdCBpcyBudWxsLlxuICAgICAqIEBwYXJhbSB7P30gc3RhdGljU3ltYm9sXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNTeW1ib2xSZXNvbHZlci5wcm90b3R5cGUuZ2V0VHlwZUFyaXR5ID0gZnVuY3Rpb24gKHN0YXRpY1N5bWJvbCkge1xuICAgICAgICAvLyBJZiB0aGUgZmlsZSBpcyBhIGZhY3RvcnkvbmdzdW1tYXJ5IGZpbGUsIGRvbid0IHJlc29sdmUgdGhlIHN5bWJvbCBhcyBkb2luZyBzbyB3b3VsZFxuICAgICAgICAvLyBjYXVzZSB0aGUgbWV0YWRhdGEgZm9yIGFuIGZhY3RvcnkvbmdzdW1tYXJ5IGZpbGUgdG8gYmUgbG9hZGVkIHdoaWNoIGRvZXNuJ3QgZXhpc3QuXG4gICAgICAgIC8vIEFsbCByZWZlcmVuY2VzIHRvIGdlbmVyYXRlZCBjbGFzc2VzIG11c3QgaW5jbHVkZSB0aGUgY29ycmVjdCBhcml0eSB3aGVuZXZlclxuICAgICAgICAvLyBnZW5lcmF0aW5nIGNvZGUuXG4gICAgICAgIGlmIChpc0dlbmVyYXRlZEZpbGUoc3RhdGljU3ltYm9sLmZpbGVQYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzb2x2ZWRTeW1ib2wgPSB0aGlzLnJlc29sdmVTeW1ib2woc3RhdGljU3ltYm9sKTtcbiAgICAgICAgd2hpbGUgKHJlc29sdmVkU3ltYm9sICYmIHJlc29sdmVkU3ltYm9sLm1ldGFkYXRhIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSB7XG4gICAgICAgICAgICByZXNvbHZlZFN5bWJvbCA9IHRoaXMucmVzb2x2ZVN5bWJvbChyZXNvbHZlZFN5bWJvbC5tZXRhZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChyZXNvbHZlZFN5bWJvbCAmJiByZXNvbHZlZFN5bWJvbC5tZXRhZGF0YSAmJiByZXNvbHZlZFN5bWJvbC5tZXRhZGF0YS5hcml0eSkgfHwgbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgZmlsZSBwYXRoIHRvIGEgbW9kdWxlIG5hbWUgdGhhdCBjYW4gYmUgdXNlZCBhcyBhbiBgaW1wb3J0YC5cbiAgICAgKiBAcGFyYW0gez99IGltcG9ydGVkRmlsZVBhdGhcbiAgICAgKiBAcGFyYW0gez99IGNvbnRhaW5pbmdGaWxlUGF0aFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLmZpbGVOYW1lVG9Nb2R1bGVOYW1lID0gZnVuY3Rpb24gKGltcG9ydGVkRmlsZVBhdGgsIGNvbnRhaW5pbmdGaWxlUGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5rbm93bkZpbGVOYW1lVG9Nb2R1bGVOYW1lcy5nZXQoaW1wb3J0ZWRGaWxlUGF0aCkgfHxcbiAgICAgICAgICAgIHRoaXMuaG9zdC5maWxlTmFtZVRvTW9kdWxlTmFtZShpbXBvcnRlZEZpbGVQYXRoLCBjb250YWluaW5nRmlsZVBhdGgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTeW1ib2xcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFN5bWJvbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLnJlY29yZEltcG9ydEFzID0gZnVuY3Rpb24gKHNvdXJjZVN5bWJvbCwgdGFyZ2V0U3ltYm9sKSB7XG4gICAgICAgIHNvdXJjZVN5bWJvbC5hc3NlcnROb01lbWJlcnMoKTtcbiAgICAgICAgdGFyZ2V0U3ltYm9sLmFzc2VydE5vTWVtYmVycygpO1xuICAgICAgICB0aGlzLmltcG9ydEFzLnNldChzb3VyY2VTeW1ib2wsIHRhcmdldFN5bWJvbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlIGFsbCBpbmZvcm1hdGlvbiBkZXJpdmVkIGZyb20gdGhlIGdpdmVuIGZpbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez99IGZpbGVOYW1lIHRoZSBmaWxlIHRvIGludmFsaWRhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5pbnZhbGlkYXRlRmlsZSA9IGZ1bmN0aW9uIChmaWxlTmFtZSkge1xuICAgICAgICB0aGlzLm1ldGFkYXRhQ2FjaGUuZGVsZXRlKGZpbGVOYW1lKTtcbiAgICAgICAgdGhpcy5yZXNvbHZlZEZpbGVQYXRocy5kZWxldGUoZmlsZU5hbWUpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzeW1ib2xzID0gdGhpcy5zeW1ib2xGcm9tRmlsZS5nZXQoZmlsZU5hbWUpO1xuICAgICAgICBpZiAoc3ltYm9scykge1xuICAgICAgICAgICAgdGhpcy5zeW1ib2xGcm9tRmlsZS5kZWxldGUoZmlsZU5hbWUpO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBzeW1ib2xzXzEgPSBzeW1ib2xzOyBfaSA8IHN5bWJvbHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ltYm9sID0gc3ltYm9sc18xW19pXTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVkU3ltYm9scy5kZWxldGUoc3ltYm9sKTtcbiAgICAgICAgICAgICAgICB0aGlzLmltcG9ydEFzLmRlbGV0ZShzeW1ib2wpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3ltYm9sUmVzb3VyY2VQYXRocy5kZWxldGUoc3ltYm9sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0gez99IGNiXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNTeW1ib2xSZXNvbHZlci5wcm90b3R5cGUuaWdub3JlRXJyb3JzRm9yID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlY29yZGVyID0gdGhpcy5lcnJvclJlY29yZGVyO1xuICAgICAgICB0aGlzLmVycm9yUmVjb3JkZXIgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gY2IoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JSZWNvcmRlciA9IHJlY29yZGVyO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXRpY1N5bWJvbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLl9yZXNvbHZlU3ltYm9sTWVtYmVycyA9IGZ1bmN0aW9uIChzdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWVtYmVycyA9IHN0YXRpY1N5bWJvbC5tZW1iZXJzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiYXNlUmVzb2x2ZWRTeW1ib2wgPSB0aGlzLnJlc29sdmVTeW1ib2wodGhpcy5nZXRTdGF0aWNTeW1ib2woc3RhdGljU3ltYm9sLmZpbGVQYXRoLCBzdGF0aWNTeW1ib2wubmFtZSkpO1xuICAgICAgICBpZiAoIWJhc2VSZXNvbHZlZFN5bWJvbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmFzZU1ldGFkYXRhID0gYmFzZVJlc29sdmVkU3ltYm9sLm1ldGFkYXRhO1xuICAgICAgICBpZiAoYmFzZU1ldGFkYXRhIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlc29sdmVkU3RhdGljU3ltYm9sKHN0YXRpY1N5bWJvbCwgdGhpcy5nZXRTdGF0aWNTeW1ib2woYmFzZU1ldGFkYXRhLmZpbGVQYXRoLCBiYXNlTWV0YWRhdGEubmFtZSwgbWVtYmVycykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJhc2VNZXRhZGF0YSAmJiBiYXNlTWV0YWRhdGEuX19zeW1ib2xpYyA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgaWYgKGJhc2VNZXRhZGF0YS5zdGF0aWNzICYmIG1lbWJlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZlZFN0YXRpY1N5bWJvbChzdGF0aWNTeW1ib2wsIGJhc2VNZXRhZGF0YS5zdGF0aWNzW21lbWJlcnNbMF1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gYmFzZU1ldGFkYXRhO1xuICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IG1lbWJlcnMubGVuZ3RoICYmIHZhbHVlOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlW21lbWJlcnNbaV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZlZFN0YXRpY1N5bWJvbChzdGF0aWNTeW1ib2wsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RhdGljU3ltYm9sXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNTeW1ib2xSZXNvbHZlci5wcm90b3R5cGUuX3Jlc29sdmVTeW1ib2xGcm9tU3VtbWFyeSA9IGZ1bmN0aW9uIChzdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3VtbWFyeSA9IHRoaXMuc3VtbWFyeVJlc29sdmVyLnJlc29sdmVTdW1tYXJ5KHN0YXRpY1N5bWJvbCk7XG4gICAgICAgIHJldHVybiBzdW1tYXJ5ID8gbmV3IFJlc29sdmVkU3RhdGljU3ltYm9sKHN0YXRpY1N5bWJvbCwgc3VtbWFyeS5tZXRhZGF0YSkgOiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZ2V0U3RhdGljU3ltYm9sIHByb2R1Y2VzIGEgVHlwZSB3aG9zZSBtZXRhZGF0YSBpcyBrbm93biBidXQgd2hvc2UgaW1wbGVtZW50YXRpb24gaXMgbm90IGxvYWRlZC5cbiAgICAgKiBBbGwgdHlwZXMgcGFzc2VkIHRvIHRoZSBTdGF0aWNSZXNvbHZlciBzaG91bGQgYmUgcHNldWRvLXR5cGVzIHJldHVybmVkIGJ5IHRoaXMgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/fSBkZWNsYXJhdGlvbkZpbGUgdGhlIGFic29sdXRlIHBhdGggb2YgdGhlIGZpbGUgd2hlcmUgdGhlIHN5bWJvbCBpcyBkZWNsYXJlZFxuICAgICAqIEBwYXJhbSB7P30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgdHlwZS5cbiAgICAgKiBAcGFyYW0gez89fSBtZW1iZXJzIGEgc3ltYm9sIGZvciBhIHN0YXRpYyBtZW1iZXIgb2YgdGhlIG5hbWVkIHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5nZXRTdGF0aWNTeW1ib2wgPSBmdW5jdGlvbiAoZGVjbGFyYXRpb25GaWxlLCBuYW1lLCBtZW1iZXJzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRpY1N5bWJvbENhY2hlLmdldChkZWNsYXJhdGlvbkZpbGUsIG5hbWUsIG1lbWJlcnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmaWxlUGF0aFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLmdldFN5bWJvbHNPZiA9IGZ1bmN0aW9uIChmaWxlUGF0aCkge1xuICAgICAgICAvLyBOb3RlOiBTb21lIHVzZXJzIHVzZSBsaWJyYXJpZXMgdGhhdCB3ZXJlIG5vdCBjb21waWxlZCB3aXRoIG5nYywgaS5lLiB0aGV5IGRvbid0XG4gICAgICAgIC8vIGhhdmUgc3VtbWFyaWVzLCBvbmx5IC5kLnRzIGZpbGVzLiBTbyB3ZSBhbHdheXMgbmVlZCB0byBjaGVjayBib3RoLCB0aGUgc3VtbWFyeVxuICAgICAgICAvLyBhbmQgbWV0YWRhdGEuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN5bWJvbHMgPSBuZXcgU2V0KHRoaXMuc3VtbWFyeVJlc29sdmVyLmdldFN5bWJvbHNPZihmaWxlUGF0aCkpO1xuICAgICAgICB0aGlzLl9jcmVhdGVTeW1ib2xzT2YoZmlsZVBhdGgpO1xuICAgICAgICB0aGlzLnJlc29sdmVkU3ltYm9scy5mb3JFYWNoKGZ1bmN0aW9uIChyZXNvbHZlZFN5bWJvbCkge1xuICAgICAgICAgICAgaWYgKHJlc29sdmVkU3ltYm9sLnN5bWJvbC5maWxlUGF0aCA9PT0gZmlsZVBhdGgpIHtcbiAgICAgICAgICAgICAgICBzeW1ib2xzLmFkZChyZXNvbHZlZFN5bWJvbC5zeW1ib2wpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oc3ltYm9scyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZpbGVQYXRoXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNTeW1ib2xSZXNvbHZlci5wcm90b3R5cGUuX2NyZWF0ZVN5bWJvbHNPZiA9IGZ1bmN0aW9uIChmaWxlUGF0aCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5yZXNvbHZlZEZpbGVQYXRocy5oYXMoZmlsZVBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNvbHZlZEZpbGVQYXRocy5hZGQoZmlsZVBhdGgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXNvbHZlZFN5bWJvbHMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWV0YWRhdGEgPSB0aGlzLmdldE1vZHVsZU1ldGFkYXRhKGZpbGVQYXRoKTtcbiAgICAgICAgaWYgKG1ldGFkYXRhWydpbXBvcnRBcyddKSB7XG4gICAgICAgICAgICAvLyBJbmRleCBidW5kbGUgaW5kaWNlcyBzaG91bGQgdXNlIHRoZSBpbXBvcnRBcyBtb2R1bGUgbmFtZSBkZWZpbmVkXG4gICAgICAgICAgICAvLyBpbiB0aGUgYnVuZGxlLlxuICAgICAgICAgICAgdGhpcy5rbm93bkZpbGVOYW1lVG9Nb2R1bGVOYW1lcy5zZXQoZmlsZVBhdGgsIG1ldGFkYXRhWydpbXBvcnRBcyddKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YWRhdGFbJ21ldGFkYXRhJ10pIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBkaXJlY3QgZGVjbGFyYXRpb25zIG9mIHRoZSBzeW1ib2xcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRvcExldmVsU3ltYm9sTmFtZXNfMSA9IG5ldyBTZXQoT2JqZWN0LmtleXMobWV0YWRhdGFbJ21ldGFkYXRhJ10pLm1hcCh1bmVzY2FwZUlkZW50aWZpZXIpKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9yaWdpbnNfMSA9IG1ldGFkYXRhWydvcmlnaW5zJ10gfHwge307XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhtZXRhZGF0YVsnbWV0YWRhdGEnXSkuZm9yRWFjaChmdW5jdGlvbiAobWV0YWRhdGFLZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzeW1ib2xNZXRhID0gbWV0YWRhdGFbJ21ldGFkYXRhJ11bbWV0YWRhdGFLZXldO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWUgPSB1bmVzY2FwZUlkZW50aWZpZXIobWV0YWRhdGFLZXkpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN5bWJvbCA9IF90aGlzLmdldFN0YXRpY1N5bWJvbChmaWxlUGF0aCwgbmFtZSk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3JpZ2luID0gb3JpZ2luc18xLmhhc093blByb3BlcnR5KG1ldGFkYXRhS2V5KSAmJiBvcmlnaW5zXzFbbWV0YWRhdGFLZXldO1xuICAgICAgICAgICAgICAgIGlmIChvcmlnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHN5bWJvbCBpcyBmcm9tIGEgYnVuZGxlZCBpbmRleCwgdXNlIHRoZSBkZWNsYXJhdGlvbiBsb2NhdGlvbiBvZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gc3ltYm9sIHNvIHJlbGF0aXZlIHJlZmVyZW5jZXMgKHN1Y2ggYXMgJy4vbXkuaHRtbCcpIHdpbGwgYmUgY2FsY3VsYXRlZFxuICAgICAgICAgICAgICAgICAgICAvLyBjb3JyZWN0bHkuXG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9yaWdpbkZpbGVQYXRoID0gX3RoaXMucmVzb2x2ZU1vZHVsZShvcmlnaW4sIGZpbGVQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcmlnaW5GaWxlUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVwb3J0RXJyb3IobmV3IEVycm9yKFwiQ291bGRuJ3QgcmVzb2x2ZSBvcmlnaW5hbCBzeW1ib2wgZm9yIFwiICsgb3JpZ2luICsgXCIgZnJvbSBcIiArIGZpbGVQYXRoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zeW1ib2xSZXNvdXJjZVBhdGhzLnNldChzeW1ib2wsIG9yaWdpbkZpbGVQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlZFN5bWJvbHMucHVzaChfdGhpcy5jcmVhdGVSZXNvbHZlZFN5bWJvbChzeW1ib2wsIGZpbGVQYXRoLCB0b3BMZXZlbFN5bWJvbE5hbWVzXzEsIHN5bWJvbE1ldGEpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsZSB0aGUgc3ltYm9scyBpbiBvbmUgb2YgdGhlIHJlLWV4cG9ydCBsb2NhdGlvblxuICAgICAgICBpZiAobWV0YWRhdGFbJ2V4cG9ydHMnXSkge1xuICAgICAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAobW9kdWxlRXhwb3J0KSB7XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIHRoZSBzeW1ib2xzIGluIHRoZSBsaXN0IG9mIGV4cGxpY2l0bHkgcmUtZXhwb3J0ZWQgc3ltYm9scy5cbiAgICAgICAgICAgICAgICBpZiAobW9kdWxlRXhwb3J0LmV4cG9ydCkge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVFeHBvcnQuZXhwb3J0LmZvckVhY2goZnVuY3Rpb24gKGV4cG9ydFN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ltYm9sTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwb3J0U3ltYm9sID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbE5hbWUgPSBleHBvcnRTeW1ib2w7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2xOYW1lID0gZXhwb3J0U3ltYm9sLmFzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sTmFtZSA9IHVuZXNjYXBlSWRlbnRpZmllcihzeW1ib2xOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN5bU5hbWUgPSBzeW1ib2xOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBleHBvcnRTeW1ib2wgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltTmFtZSA9IHVuZXNjYXBlSWRlbnRpZmllcihleHBvcnRTeW1ib2wubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXNvbHZlZE1vZHVsZSA9IF90aGlzLnJlc29sdmVNb2R1bGUobW9kdWxlRXhwb3J0LmZyb20sIGZpbGVQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZE1vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRhcmdldFN5bWJvbCA9IF90aGlzLmdldFN0YXRpY1N5bWJvbChyZXNvbHZlZE1vZHVsZSwgc3ltTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlU3ltYm9sID0gX3RoaXMuZ2V0U3RhdGljU3ltYm9sKGZpbGVQYXRoLCBzeW1ib2xOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFN5bWJvbHMucHVzaChfdGhpcy5jcmVhdGVFeHBvcnQoc291cmNlU3ltYm9sLCB0YXJnZXRTeW1ib2wpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgdGhlIHN5bWJvbHMgdmlhIGV4cG9ydCAqIGRpcmVjdGl2ZXMuXG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc29sdmVkTW9kdWxlID0gdGhpc18xLnJlc29sdmVNb2R1bGUobW9kdWxlRXhwb3J0LmZyb20sIGZpbGVQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkTW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZXN0ZWRFeHBvcnRzID0gdGhpc18xLmdldFN5bWJvbHNPZihyZXNvbHZlZE1vZHVsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXN0ZWRFeHBvcnRzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldFN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvdXJjZVN5bWJvbCA9IF90aGlzLmdldFN0YXRpY1N5bWJvbChmaWxlUGF0aCwgdGFyZ2V0U3ltYm9sLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkU3ltYm9scy5wdXNoKF90aGlzLmNyZWF0ZUV4cG9ydChzb3VyY2VTeW1ib2wsIHRhcmdldFN5bWJvbCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gbWV0YWRhdGFbJ2V4cG9ydHMnXTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbW9kdWxlRXhwb3J0ID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIF9sb29wXzEoLyoqIEB0eXBlIHs/fSAqLyBtb2R1bGVFeHBvcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc29sdmVkU3ltYm9scy5mb3JFYWNoKGZ1bmN0aW9uIChyZXNvbHZlZFN5bWJvbCkgeyByZXR1cm4gX3RoaXMucmVzb2x2ZWRTeW1ib2xzLnNldChyZXNvbHZlZFN5bWJvbC5zeW1ib2wsIHJlc29sdmVkU3ltYm9sKTsgfSk7XG4gICAgICAgIHRoaXMuc3ltYm9sRnJvbUZpbGUuc2V0KGZpbGVQYXRoLCByZXNvbHZlZFN5bWJvbHMubWFwKGZ1bmN0aW9uIChyZXNvbHZlZFN5bWJvbCkgeyByZXR1cm4gcmVzb2x2ZWRTeW1ib2wuc3ltYm9sOyB9KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVN5bWJvbFxuICAgICAqIEBwYXJhbSB7P30gdG9wTGV2ZWxQYXRoXG4gICAgICogQHBhcmFtIHs/fSB0b3BMZXZlbFN5bWJvbE5hbWVzXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLmNyZWF0ZVJlc29sdmVkU3ltYm9sID0gZnVuY3Rpb24gKHNvdXJjZVN5bWJvbCwgdG9wTGV2ZWxQYXRoLCB0b3BMZXZlbFN5bWJvbE5hbWVzLCBtZXRhZGF0YSkge1xuICAgICAgICAvLyBGb3IgY2xhc3NlcyB0aGF0IGRvbid0IGhhdmUgQW5ndWxhciBzdW1tYXJpZXMgLyBtZXRhZGF0YSxcbiAgICAgICAgLy8gd2Ugb25seSBrZWVwIHRoZWlyIGFyaXR5LCBidXQgbm90aGluZyBlbHNlXG4gICAgICAgIC8vIChlLmcuIHRoZWlyIGNvbnN0cnVjdG9yIHBhcmFtZXRlcnMpLlxuICAgICAgICAvLyBXZSBkbyB0aGlzIHRvIHByZXZlbnQgaW50cm9kdWNpbmcgZGVlcCBpbXBvcnRzXG4gICAgICAgIC8vIGFzIHdlIGRpZG4ndCBnZW5lcmF0ZSAubmdmYWN0b3J5LnRzIGZpbGVzIHdpdGggcHJvcGVyIHJlZXhwb3J0cy5cbiAgICAgICAgaWYgKHRoaXMuc3VtbWFyeVJlc29sdmVyLmlzTGlicmFyeUZpbGUoc291cmNlU3ltYm9sLmZpbGVQYXRoKSAmJiBtZXRhZGF0YSAmJlxuICAgICAgICAgICAgbWV0YWRhdGFbJ19fc3ltYm9saWMnXSA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNmb3JtZWRNZXRhXzEgPSB7IF9fc3ltYm9saWM6ICdjbGFzcycsIGFyaXR5OiBtZXRhZGF0YS5hcml0eSB9O1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZlZFN0YXRpY1N5bWJvbChzb3VyY2VTeW1ib2wsIHRyYW5zZm9ybWVkTWV0YV8xKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIFJlZmVyZW5jZVRyYW5zZm9ybWVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgICAgIHRzbGliXzEuX19leHRlbmRzKFJlZmVyZW5jZVRyYW5zZm9ybWVyLCBfc3VwZXIpO1xuICAgICAgICAgICAgZnVuY3Rpb24gUmVmZXJlbmNlVHJhbnNmb3JtZXIoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IG1hcFxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBmdW5jdGlvblBhcmFtc1xuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgUmVmZXJlbmNlVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0U3RyaW5nTWFwID0gZnVuY3Rpb24gKG1hcCwgZnVuY3Rpb25QYXJhbXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzeW1ib2xpYyA9IG1hcFsnX19zeW1ib2xpYyddO1xuICAgICAgICAgICAgICAgIGlmIChzeW1ib2xpYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvbGRMZW4gPSBmdW5jdGlvblBhcmFtcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uUGFyYW1zLnB1c2guYXBwbHkoZnVuY3Rpb25QYXJhbXMsIChtYXBbJ3BhcmFtZXRlcnMnXSB8fCBbXSkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSBfc3VwZXIucHJvdG90eXBlLnZpc2l0U3RyaW5nTWFwLmNhbGwodGhpcywgbWFwLCBmdW5jdGlvblBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uUGFyYW1zLmxlbmd0aCA9IG9sZExlbjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3ltYm9saWMgPT09ICdyZWZlcmVuY2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1vZHVsZV8xID0gbWFwWydtb2R1bGUnXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZSA9IG1hcFsnbmFtZSddID8gdW5lc2NhcGVJZGVudGlmaWVyKG1hcFsnbmFtZSddKSA6IG1hcFsnbmFtZSddO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZpbGVQYXRoID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kdWxlXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVQYXRoID0gKChzZWxmLnJlc29sdmVNb2R1bGUobW9kdWxlXzEsIHNvdXJjZVN5bWJvbC5maWxlUGF0aCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmlsZVBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3N5bWJvbGljOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkNvdWxkIG5vdCByZXNvbHZlIFwiICsgbW9kdWxlXzEgKyBcIiByZWxhdGl2ZSB0byBcIiArIHNvdXJjZVN5bWJvbC5maWxlUGF0aCArIFwiLlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmdldFN0YXRpY1N5bWJvbChmaWxlUGF0aCwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZnVuY3Rpb25QYXJhbXMuaW5kZXhPZihuYW1lKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWZlcmVuY2UgdG8gYSBmdW5jdGlvbiBwYXJhbWV0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IF9fc3ltYm9saWM6ICdyZWZlcmVuY2UnLCBuYW1lOiBuYW1lIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9wTGV2ZWxTeW1ib2xOYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5nZXRTdGF0aWNTeW1ib2wodG9wTGV2ZWxQYXRoLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFtYmllbnQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnZpc2l0U3RyaW5nTWFwLmNhbGwodGhpcywgbWFwLCBmdW5jdGlvblBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBSZWZlcmVuY2VUcmFuc2Zvcm1lcjtcbiAgICAgICAgfShWYWx1ZVRyYW5zZm9ybWVyKSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zZm9ybWVkTWV0YSA9IHZpc2l0VmFsdWUobWV0YWRhdGEsIG5ldyBSZWZlcmVuY2VUcmFuc2Zvcm1lcigpLCBbXSk7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1lZE1ldGEgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUV4cG9ydChzb3VyY2VTeW1ib2wsIHRyYW5zZm9ybWVkTWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZlZFN0YXRpY1N5bWJvbChzb3VyY2VTeW1ib2wsIHRyYW5zZm9ybWVkTWV0YSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVN5bWJvbFxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0U3ltYm9sXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNTeW1ib2xSZXNvbHZlci5wcm90b3R5cGUuY3JlYXRlRXhwb3J0ID0gZnVuY3Rpb24gKHNvdXJjZVN5bWJvbCwgdGFyZ2V0U3ltYm9sKSB7XG4gICAgICAgIHNvdXJjZVN5bWJvbC5hc3NlcnROb01lbWJlcnMoKTtcbiAgICAgICAgdGFyZ2V0U3ltYm9sLmFzc2VydE5vTWVtYmVycygpO1xuICAgICAgICBpZiAodGhpcy5zdW1tYXJ5UmVzb2x2ZXIuaXNMaWJyYXJ5RmlsZShzb3VyY2VTeW1ib2wuZmlsZVBhdGgpKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGNhc2UgaXMgZm9yIGFuIG5nIGxpYnJhcnkgaW1wb3J0aW5nIHN5bWJvbHMgZnJvbSBhIHBsYWluIHRzIGxpYnJhcnlcbiAgICAgICAgICAgIC8vIHRyYW5zaXRpdmVseS5cbiAgICAgICAgICAgIC8vIE5vdGU6IFdlIHJlbHkgb24gdGhlIGZhY3QgdGhhdCB3ZSBkaXNjb3ZlciBzeW1ib2xzIGluIHRoZSBkaXJlY3Rpb25cbiAgICAgICAgICAgIC8vIGZyb20gc291cmNlIGZpbGVzIHRvIGxpYnJhcnkgZmlsZXNcbiAgICAgICAgICAgIHRoaXMuaW1wb3J0QXMuc2V0KHRhcmdldFN5bWJvbCwgdGhpcy5nZXRJbXBvcnRBcyhzb3VyY2VTeW1ib2wpIHx8IHNvdXJjZVN5bWJvbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZlZFN0YXRpY1N5bWJvbChzb3VyY2VTeW1ib2wsIHRhcmdldFN5bWJvbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVycm9yXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEBwYXJhbSB7Pz19IHBhdGhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5yZXBvcnRFcnJvciA9IGZ1bmN0aW9uIChlcnJvciwgY29udGV4dCwgcGF0aCkge1xuICAgICAgICBpZiAodGhpcy5lcnJvclJlY29yZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yUmVjb3JkZXIoZXJyb3IsIChjb250ZXh0ICYmIGNvbnRleHQuZmlsZVBhdGgpIHx8IHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbW9kdWxlIGFuIGFic29sdXRlIHBhdGggdG8gYSBtb2R1bGUgZmlsZS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5nZXRNb2R1bGVNZXRhZGF0YSA9IGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbW9kdWxlTWV0YWRhdGEgPSB0aGlzLm1ldGFkYXRhQ2FjaGUuZ2V0KG1vZHVsZSk7XG4gICAgICAgIGlmICghbW9kdWxlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1vZHVsZU1ldGFkYXRhcyA9IHRoaXMuaG9zdC5nZXRNZXRhZGF0YUZvcihtb2R1bGUpO1xuICAgICAgICAgICAgaWYgKG1vZHVsZU1ldGFkYXRhcykge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1heFZlcnNpb25fMSA9IC0xO1xuICAgICAgICAgICAgICAgIG1vZHVsZU1ldGFkYXRhcy5mb3JFYWNoKGZ1bmN0aW9uIChtZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWRbJ3ZlcnNpb24nXSA+IG1heFZlcnNpb25fMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4VmVyc2lvbl8xID0gbWRbJ3ZlcnNpb24nXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZU1ldGFkYXRhID0gbWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbW9kdWxlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVNZXRhZGF0YSA9XG4gICAgICAgICAgICAgICAgICAgIHsgX19zeW1ib2xpYzogJ21vZHVsZScsIHZlcnNpb246IFNVUFBPUlRFRF9TQ0hFTUFfVkVSU0lPTiwgbW9kdWxlOiBtb2R1bGUsIG1ldGFkYXRhOiB7fSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vZHVsZU1ldGFkYXRhWyd2ZXJzaW9uJ10gIT0gU1VQUE9SVEVEX1NDSEVNQV9WRVJTSU9OKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3JNZXNzYWdlID0gbW9kdWxlTWV0YWRhdGFbJ3ZlcnNpb24nXSA9PSAyID9cbiAgICAgICAgICAgICAgICAgICAgXCJVbnN1cHBvcnRlZCBtZXRhZGF0YSB2ZXJzaW9uIFwiICsgbW9kdWxlTWV0YWRhdGFbJ3ZlcnNpb24nXSArIFwiIGZvciBtb2R1bGUgXCIgKyBtb2R1bGUgKyBcIi4gVGhpcyBtb2R1bGUgc2hvdWxkIGJlIGNvbXBpbGVkIHdpdGggYSBuZXdlciB2ZXJzaW9uIG9mIG5nY1wiIDpcbiAgICAgICAgICAgICAgICAgICAgXCJNZXRhZGF0YSB2ZXJzaW9uIG1pc21hdGNoIGZvciBtb2R1bGUgXCIgKyBtb2R1bGUgKyBcIiwgZm91bmQgdmVyc2lvbiBcIiArIG1vZHVsZU1ldGFkYXRhWyd2ZXJzaW9uJ10gKyBcIiwgZXhwZWN0ZWQgXCIgKyBTVVBQT1JURURfU0NIRU1BX1ZFUlNJT047XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcihuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhQ2FjaGUuc2V0KG1vZHVsZSwgbW9kdWxlTWV0YWRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2R1bGVNZXRhZGF0YTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbW9kdWxlXG4gICAgICogQHBhcmFtIHs/fSBzeW1ib2xOYW1lXG4gICAgICogQHBhcmFtIHs/PX0gY29udGFpbmluZ0ZpbGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5nZXRTeW1ib2xCeU1vZHVsZSA9IGZ1bmN0aW9uIChtb2R1bGUsIHN5bWJvbE5hbWUsIGNvbnRhaW5pbmdGaWxlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZpbGVQYXRoID0gdGhpcy5yZXNvbHZlTW9kdWxlKG1vZHVsZSwgY29udGFpbmluZ0ZpbGUpO1xuICAgICAgICBpZiAoIWZpbGVQYXRoKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKG5ldyBFcnJvcihcIkNvdWxkIG5vdCByZXNvbHZlIG1vZHVsZSBcIiArIG1vZHVsZSArIChjb250YWluaW5nRmlsZSA/IFwiIHJlbGF0aXZlIHRvICQge1xcbiAgICAgICAgICAgIGNvbnRhaW5pbmdGaWxlXFxuICAgICAgICAgIH0gXCIgOiAnJykpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFN0YXRpY1N5bWJvbChcIkVSUk9SOlwiICsgbW9kdWxlLCBzeW1ib2xOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGF0aWNTeW1ib2woZmlsZVBhdGgsIHN5bWJvbE5hbWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtb2R1bGVcbiAgICAgKiBAcGFyYW0gez89fSBjb250YWluaW5nRmlsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLnJlc29sdmVNb2R1bGUgPSBmdW5jdGlvbiAobW9kdWxlLCBjb250YWluaW5nRmlsZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaG9zdC5tb2R1bGVOYW1lVG9GaWxlTmFtZShtb2R1bGUsIGNvbnRhaW5pbmdGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkNvdWxkIG5vdCByZXNvbHZlIG1vZHVsZSAnXCIgKyBtb2R1bGUgKyBcIicgcmVsYXRpdmUgdG8gZmlsZSBcIiArIGNvbnRhaW5pbmdGaWxlKTtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoZSwgdW5kZWZpbmVkLCBjb250YWluaW5nRmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGljU3ltYm9sUmVzb2x2ZXI7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IGlkZW50aWZpZXJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHVuZXNjYXBlSWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIGlkZW50aWZpZXIuc3RhcnRzV2l0aCgnX19fJykgPyBpZGVudGlmaWVyLnN1YnN0cigxKSA6IGlkZW50aWZpZXI7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgQW90U3VtbWFyeVJlc29sdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGhvc3RcbiAgICAgKiBAcGFyYW0gez99IHN0YXRpY1N5bWJvbENhY2hlXG4gICAgICovXG4gICAgZnVuY3Rpb24gQW90U3VtbWFyeVJlc29sdmVyKGhvc3QsIHN0YXRpY1N5bWJvbENhY2hlKSB7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIHRoaXMuc3RhdGljU3ltYm9sQ2FjaGUgPSBzdGF0aWNTeW1ib2xDYWNoZTtcbiAgICAgICAgdGhpcy5zdW1tYXJ5Q2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubG9hZGVkRmlsZVBhdGhzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmltcG9ydEFzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZpbGVQYXRoXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBb3RTdW1tYXJ5UmVzb2x2ZXIucHJvdG90eXBlLmlzTGlicmFyeUZpbGUgPSBmdW5jdGlvbiAoZmlsZVBhdGgpIHtcbiAgICAgICAgLy8gTm90ZTogV2UgbmVlZCB0byBzdHJpcCB0aGUgLm5nZmFjdG9yeS4gZmlsZSBwYXRoLFxuICAgICAgICAvLyBzbyB0aGlzIG1ldGhvZCBhbHNvIHdvcmtzIGZvciBnZW5lcmF0ZWQgZmlsZXNcbiAgICAgICAgLy8gKGZvciB3aGljaCBob3N0LmlzU291cmNlRmlsZSB3aWxsIGFsd2F5cyByZXR1cm4gZmFsc2UpLlxuICAgICAgICByZXR1cm4gIXRoaXMuaG9zdC5pc1NvdXJjZUZpbGUoc3RyaXBHZW5lcmF0ZWRGaWxlU3VmZml4KGZpbGVQYXRoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZpbGVQYXRoXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBb3RTdW1tYXJ5UmVzb2x2ZXIucHJvdG90eXBlLmdldExpYnJhcnlGaWxlTmFtZSA9IGZ1bmN0aW9uIChmaWxlUGF0aCkgeyByZXR1cm4gdGhpcy5ob3N0LmdldE91dHB1dEZpbGVOYW1lKGZpbGVQYXRoKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXRpY1N5bWJvbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW90U3VtbWFyeVJlc29sdmVyLnByb3RvdHlwZS5yZXNvbHZlU3VtbWFyeSA9IGZ1bmN0aW9uIChzdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgc3RhdGljU3ltYm9sLmFzc2VydE5vTWVtYmVycygpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdW1tYXJ5ID0gdGhpcy5zdW1tYXJ5Q2FjaGUuZ2V0KHN0YXRpY1N5bWJvbCk7XG4gICAgICAgIGlmICghc3VtbWFyeSkge1xuICAgICAgICAgICAgdGhpcy5fbG9hZFN1bW1hcnlGaWxlKHN0YXRpY1N5bWJvbC5maWxlUGF0aCk7XG4gICAgICAgICAgICBzdW1tYXJ5ID0gKCh0aGlzLnN1bW1hcnlDYWNoZS5nZXQoc3RhdGljU3ltYm9sKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW1tYXJ5O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmaWxlUGF0aFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW90U3VtbWFyeVJlc29sdmVyLnByb3RvdHlwZS5nZXRTeW1ib2xzT2YgPSBmdW5jdGlvbiAoZmlsZVBhdGgpIHtcbiAgICAgICAgdGhpcy5fbG9hZFN1bW1hcnlGaWxlKGZpbGVQYXRoKTtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5zdW1tYXJ5Q2FjaGUua2V5cygpKS5maWx0ZXIoZnVuY3Rpb24gKHN5bWJvbCkgeyByZXR1cm4gc3ltYm9sLmZpbGVQYXRoID09PSBmaWxlUGF0aDsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXRpY1N5bWJvbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW90U3VtbWFyeVJlc29sdmVyLnByb3RvdHlwZS5nZXRJbXBvcnRBcyA9IGZ1bmN0aW9uIChzdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgc3RhdGljU3ltYm9sLmFzc2VydE5vTWVtYmVycygpO1xuICAgICAgICByZXR1cm4gKCh0aGlzLmltcG9ydEFzLmdldChzdGF0aWNTeW1ib2wpKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN1bW1hcnlcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFvdFN1bW1hcnlSZXNvbHZlci5wcm90b3R5cGUuYWRkU3VtbWFyeSA9IGZ1bmN0aW9uIChzdW1tYXJ5KSB7IHRoaXMuc3VtbWFyeUNhY2hlLnNldChzdW1tYXJ5LnN5bWJvbCwgc3VtbWFyeSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmaWxlUGF0aFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW90U3VtbWFyeVJlc29sdmVyLnByb3RvdHlwZS5fbG9hZFN1bW1hcnlGaWxlID0gZnVuY3Rpb24gKGZpbGVQYXRoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmxvYWRlZEZpbGVQYXRocy5oYXMoZmlsZVBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2FkZWRGaWxlUGF0aHMuYWRkKGZpbGVQYXRoKTtcbiAgICAgICAgaWYgKHRoaXMuaXNMaWJyYXJ5RmlsZShmaWxlUGF0aCkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN1bW1hcnlGaWxlUGF0aCA9IHN1bW1hcnlGaWxlTmFtZShmaWxlUGF0aCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBqc29uID0gdm9pZCAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBqc29uID0gdGhpcy5ob3N0LmxvYWRTdW1tYXJ5KHN1bW1hcnlGaWxlUGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsb2FkaW5nIHN1bW1hcnkgZmlsZSBcIiArIHN1bW1hcnlGaWxlUGF0aCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqc29uKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gZGVzZXJpYWxpemVTdW1tYXJpZXModGhpcy5zdGF0aWNTeW1ib2xDYWNoZSwganNvbiksIHN1bW1hcmllcyA9IF9hLnN1bW1hcmllcywgaW1wb3J0QXMgPSBfYS5pbXBvcnRBcztcbiAgICAgICAgICAgICAgICBzdW1tYXJpZXMuZm9yRWFjaChmdW5jdGlvbiAoc3VtbWFyeSkgeyByZXR1cm4gX3RoaXMuc3VtbWFyeUNhY2hlLnNldChzdW1tYXJ5LnN5bWJvbCwgc3VtbWFyeSk7IH0pO1xuICAgICAgICAgICAgICAgIGltcG9ydEFzLmZvckVhY2goZnVuY3Rpb24gKGltcG9ydEFzKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmltcG9ydEFzLnNldChpbXBvcnRBcy5zeW1ib2wsIF90aGlzLnN0YXRpY1N5bWJvbENhY2hlLmdldChuZ2ZhY3RvcnlGaWxlUGF0aChmaWxlUGF0aCksIGltcG9ydEFzLmltcG9ydEFzKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBb3RTdW1tYXJ5UmVzb2x2ZXI7XG59KCkpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IEFvdENvbXBpbGVyIGJhc2VkIG9uIG9wdGlvbnMgYW5kIGEgaG9zdC5cbiAqIEBwYXJhbSB7P30gY29tcGlsZXJIb3N0XG4gKiBAcGFyYW0gez99IG9wdGlvbnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFvdENvbXBpbGVyKGNvbXBpbGVySG9zdCwgb3B0aW9ucykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zbGF0aW9ucyA9IG9wdGlvbnMudHJhbnNsYXRpb25zIHx8ICcnO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHVybFJlc29sdmVyID0gY3JlYXRlT2ZmbGluZUNvbXBpbGVVcmxSZXNvbHZlcigpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHN5bWJvbENhY2hlID0gbmV3IFN0YXRpY1N5bWJvbENhY2hlKCk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3VtbWFyeVJlc29sdmVyID0gbmV3IEFvdFN1bW1hcnlSZXNvbHZlcihjb21waWxlckhvc3QsIHN5bWJvbENhY2hlKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzeW1ib2xSZXNvbHZlciA9IG5ldyBTdGF0aWNTeW1ib2xSZXNvbHZlcihjb21waWxlckhvc3QsIHN5bWJvbENhY2hlLCBzdW1tYXJ5UmVzb2x2ZXIpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXRpY1JlZmxlY3RvciA9IG5ldyBTdGF0aWNSZWZsZWN0b3Ioc3VtbWFyeVJlc29sdmVyLCBzeW1ib2xSZXNvbHZlcik7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29uc29sZSA9IG5ldyDJtUNvbnNvbGUoKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBodG1sUGFyc2VyID0gbmV3IEkxOE5IdG1sUGFyc2VyKG5ldyBIdG1sUGFyc2VyKCksIHRyYW5zbGF0aW9ucywgb3B0aW9ucy5pMThuRm9ybWF0LCBvcHRpb25zLm1pc3NpbmdUcmFuc2xhdGlvbiwgY29uc29sZSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29uZmlnID0gbmV3IENvbXBpbGVyQ29uZmlnKHtcbiAgICAgICAgZGVmYXVsdEVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLkVtdWxhdGVkLFxuICAgICAgICB1c2VKaXQ6IGZhbHNlLFxuICAgICAgICBlbmFibGVMZWdhY3lUZW1wbGF0ZTogb3B0aW9ucy5lbmFibGVMZWdhY3lUZW1wbGF0ZSAhPT0gZmFsc2UsXG4gICAgICAgIG1pc3NpbmdUcmFuc2xhdGlvbjogb3B0aW9ucy5taXNzaW5nVHJhbnNsYXRpb24sXG4gICAgfSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9ybWFsaXplciA9IG5ldyBEaXJlY3RpdmVOb3JtYWxpemVyKHsgZ2V0OiBmdW5jdGlvbiAodXJsKSB7IHJldHVybiBjb21waWxlckhvc3QubG9hZFJlc291cmNlKHVybCk7IH0gfSwgdXJsUmVzb2x2ZXIsIGh0bWxQYXJzZXIsIGNvbmZpZyk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwcmVzc2lvblBhcnNlciA9IG5ldyBQYXJzZXIobmV3IExleGVyKCkpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsZW1lbnRTY2hlbWFSZWdpc3RyeSA9IG5ldyBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkoKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0bXBsUGFyc2VyID0gbmV3IFRlbXBsYXRlUGFyc2VyKGNvbmZpZywgc3RhdGljUmVmbGVjdG9yLCBleHByZXNzaW9uUGFyc2VyLCBlbGVtZW50U2NoZW1hUmVnaXN0cnksIGh0bWxQYXJzZXIsIGNvbnNvbGUsIFtdKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXNvbHZlciA9IG5ldyBDb21waWxlTWV0YWRhdGFSZXNvbHZlcihjb25maWcsIG5ldyBOZ01vZHVsZVJlc29sdmVyKHN0YXRpY1JlZmxlY3RvciksIG5ldyBEaXJlY3RpdmVSZXNvbHZlcihzdGF0aWNSZWZsZWN0b3IpLCBuZXcgUGlwZVJlc29sdmVyKHN0YXRpY1JlZmxlY3RvciksIHN1bW1hcnlSZXNvbHZlciwgZWxlbWVudFNjaGVtYVJlZ2lzdHJ5LCBub3JtYWxpemVyLCBjb25zb2xlLCBzeW1ib2xDYWNoZSwgc3RhdGljUmVmbGVjdG9yKTtcbiAgICAvLyBUT0RPKHZpY2IpOiBkbyBub3QgcGFzcyBvcHRpb25zLmkxOG5Gb3JtYXQgaGVyZVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpZXdDb21waWxlciA9IG5ldyBWaWV3Q29tcGlsZXIoY29uZmlnLCBzdGF0aWNSZWZsZWN0b3IsIGVsZW1lbnRTY2hlbWFSZWdpc3RyeSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcGlsZXIgPSBuZXcgQW90Q29tcGlsZXIoY29uZmlnLCBjb21waWxlckhvc3QsIHN0YXRpY1JlZmxlY3RvciwgcmVzb2x2ZXIsIHRtcGxQYXJzZXIsIG5ldyBTdHlsZUNvbXBpbGVyKHVybFJlc29sdmVyKSwgdmlld0NvbXBpbGVyLCBuZXcgTmdNb2R1bGVDb21waWxlcihzdGF0aWNSZWZsZWN0b3IpLCBuZXcgVHlwZVNjcmlwdEVtaXR0ZXIoKSwgc3VtbWFyeVJlc29sdmVyLCBvcHRpb25zLmxvY2FsZSB8fCBudWxsLCBvcHRpb25zLmkxOG5Gb3JtYXQgfHwgbnVsbCwgb3B0aW9ucy5lbmFibGVTdW1tYXJpZXNGb3JKaXQgfHwgbnVsbCwgc3ltYm9sUmVzb2x2ZXIpO1xuICAgIHJldHVybiB7IGNvbXBpbGVyOiBjb21waWxlciwgcmVmbGVjdG9yOiBzdGF0aWNSZWZsZWN0b3IgfTtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQHBhcmFtIHs/fSBzdGF0ZW1lbnRzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpbnRlcnByZXRTdGF0ZW1lbnRzKHN0YXRlbWVudHMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdHggPSBuZXcgX0V4ZWN1dGlvbkNvbnRleHQobnVsbCwgbnVsbCwgbnVsbCwgbmV3IE1hcCgpKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aXNpdG9yID0gbmV3IFN0YXRlbWVudEludGVycHJldGVyKCk7XG4gICAgdmlzaXRvci52aXNpdEFsbFN0YXRlbWVudHMoc3RhdGVtZW50cywgY3R4KTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSB7fTtcbiAgICBjdHguZXhwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uIChleHBvcnROYW1lKSB7IHJlc3VsdFtleHBvcnROYW1lXSA9IGN0eC52YXJzLmdldChleHBvcnROYW1lKTsgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSB2YXJOYW1lc1xuICogQHBhcmFtIHs/fSB2YXJWYWx1ZXNcbiAqIEBwYXJhbSB7P30gc3RhdGVtZW50c1xuICogQHBhcmFtIHs/fSBjdHhcbiAqIEBwYXJhbSB7P30gdmlzaXRvclxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2V4ZWN1dGVGdW5jdGlvblN0YXRlbWVudHModmFyTmFtZXMsIHZhclZhbHVlcywgc3RhdGVtZW50cywgY3R4LCB2aXNpdG9yKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hpbGRDdHggPSBjdHguY3JlYXRlQ2hpbGRXaWh0TG9jYWxWYXJzKCk7XG4gICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHZhck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoaWxkQ3R4LnZhcnMuc2V0KHZhck5hbWVzW2ldLCB2YXJWYWx1ZXNbaV0pO1xuICAgIH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSB2aXNpdG9yLnZpc2l0QWxsU3RhdGVtZW50cyhzdGF0ZW1lbnRzLCBjaGlsZEN0eCk7XG4gICAgcmV0dXJuIHJlc3VsdCA/IHJlc3VsdC52YWx1ZSA6IG51bGw7XG59XG52YXIgX0V4ZWN1dGlvbkNvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHBhcmFtIHs/fSBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7P30gY2xhc3NOYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YXJzXG4gICAgICovXG4gICAgZnVuY3Rpb24gX0V4ZWN1dGlvbkNvbnRleHQocGFyZW50LCBpbnN0YW5jZSwgY2xhc3NOYW1lLCB2YXJzKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgICB0aGlzLnZhcnMgPSB2YXJzO1xuICAgICAgICB0aGlzLmV4cG9ydHMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfRXhlY3V0aW9uQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlQ2hpbGRXaWh0TG9jYWxWYXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IF9FeGVjdXRpb25Db250ZXh0KHRoaXMsIHRoaXMuaW5zdGFuY2UsIHRoaXMuY2xhc3NOYW1lLCBuZXcgTWFwKCkpO1xuICAgIH07XG4gICAgcmV0dXJuIF9FeGVjdXRpb25Db250ZXh0O1xufSgpKTtcbnZhciBSZXR1cm5WYWx1ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJldHVyblZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIFJldHVyblZhbHVlO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBfY2xhc3NTdG10XG4gKiBAcGFyYW0gez99IF9jdHhcbiAqIEBwYXJhbSB7P30gX3Zpc2l0b3JcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUR5bmFtaWNDbGFzcyhfY2xhc3NTdG10LCBfY3R4LCBfdmlzaXRvcikge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb3BlcnR5RGVzY3JpcHRvcnMgPSB7fTtcbiAgICBfY2xhc3NTdG10LmdldHRlcnMuZm9yRWFjaChmdW5jdGlvbiAoZ2V0dGVyKSB7XG4gICAgICAgIC8vIE5vdGU6IHVzZSBgZnVuY3Rpb25gIGluc3RlYWQgb2YgYXJyb3cgZnVuY3Rpb24gdG8gY2FwdHVyZSBgdGhpc2BcbiAgICAgICAgcHJvcGVydHlEZXNjcmlwdG9yc1tnZXR0ZXIubmFtZV0gPSB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5zdGFuY2VDdHggPSBuZXcgX0V4ZWN1dGlvbkNvbnRleHQoX2N0eCwgdGhpcywgX2NsYXNzU3RtdC5uYW1lLCBfY3R4LnZhcnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfZXhlY3V0ZUZ1bmN0aW9uU3RhdGVtZW50cyhbXSwgW10sIGdldHRlci5ib2R5LCBpbnN0YW5jZUN0eCwgX3Zpc2l0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIF9jbGFzc1N0bXQubWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyYW1OYW1lcyA9IG1ldGhvZC5wYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gcGFyYW0ubmFtZTsgfSk7XG4gICAgICAgIC8vIE5vdGU6IHVzZSBgZnVuY3Rpb25gIGluc3RlYWQgb2YgYXJyb3cgZnVuY3Rpb24gdG8gY2FwdHVyZSBgdGhpc2BcbiAgICAgICAgcHJvcGVydHlEZXNjcmlwdG9yc1soKG1ldGhvZC5uYW1lKSldID0ge1xuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluc3RhbmNlQ3R4ID0gbmV3IF9FeGVjdXRpb25Db250ZXh0KF9jdHgsIHRoaXMsIF9jbGFzc1N0bXQubmFtZSwgX2N0eC52YXJzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2V4ZWN1dGVGdW5jdGlvblN0YXRlbWVudHMocGFyYW1OYW1lcywgYXJncywgbWV0aG9kLmJvZHksIGluc3RhbmNlQ3R4LCBfdmlzaXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3RvclBhcmFtTmFtZXMgPSBfY2xhc3NTdG10LmNvbnN0cnVjdG9yTWV0aG9kLnBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBwYXJhbS5uYW1lOyB9KTtcbiAgICAvLyBOb3RlOiB1c2UgYGZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGFycm93IGZ1bmN0aW9uIHRvIGNhcHR1cmUgYHRoaXNgXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnN0YW5jZUN0eCA9IG5ldyBfRXhlY3V0aW9uQ29udGV4dChfY3R4LCB0aGlzLCBfY2xhc3NTdG10Lm5hbWUsIF9jdHgudmFycyk7XG4gICAgICAgIF9jbGFzc1N0bXQuZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7IF90aGlzW2ZpZWxkLm5hbWVdID0gdW5kZWZpbmVkOyB9KTtcbiAgICAgICAgX2V4ZWN1dGVGdW5jdGlvblN0YXRlbWVudHMoY3RvclBhcmFtTmFtZXMsIGFyZ3MsIF9jbGFzc1N0bXQuY29uc3RydWN0b3JNZXRob2QuYm9keSwgaW5zdGFuY2VDdHgsIF92aXNpdG9yKTtcbiAgICB9O1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHN1cGVyQ2xhc3MgPSBfY2xhc3NTdG10LnBhcmVudCA/IF9jbGFzc1N0bXQucGFyZW50LnZpc2l0RXhwcmVzc2lvbihfdmlzaXRvciwgX2N0eCkgOiBPYmplY3Q7XG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlLCBwcm9wZXJ0eURlc2NyaXB0b3JzKTtcbiAgICByZXR1cm4gY3Rvcjtcbn1cbnZhciBTdGF0ZW1lbnRJbnRlcnByZXRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhdGVtZW50SW50ZXJwcmV0ZXIoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUuZGVidWdBc3QgPSBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBkZWJ1Z091dHB1dEFzdEFzVHlwZVNjcmlwdChhc3QpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXREZWNsYXJlVmFyU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgY3R4LnZhcnMuc2V0KHN0bXQubmFtZSwgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KSk7XG4gICAgICAgIGlmIChzdG10Lmhhc01vZGlmaWVyKFN0bXRNb2RpZmllci5FeHBvcnRlZCkpIHtcbiAgICAgICAgICAgIGN0eC5leHBvcnRzLnB1c2goc3RtdC5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwclxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRXcml0ZVZhckV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3VyckN0eCA9IGN0eDtcbiAgICAgICAgd2hpbGUgKGN1cnJDdHggIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN1cnJDdHgudmFycy5oYXMoZXhwci5uYW1lKSkge1xuICAgICAgICAgICAgICAgIGN1cnJDdHgudmFycy5zZXQoZXhwci5uYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyckN0eCA9ICgoY3VyckN0eC5wYXJlbnQpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgZGVjbGFyZWQgdmFyaWFibGUgXCIgKyBleHByLm5hbWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0UmVhZFZhckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFyTmFtZSA9ICgoYXN0Lm5hbWUpKTtcbiAgICAgICAgaWYgKGFzdC5idWlsdGluICE9IG51bGwpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoYXN0LmJ1aWx0aW4pIHtcbiAgICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5WYXIuU3VwZXI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHguaW5zdGFuY2UuX19wcm90b19fO1xuICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5UaGlzOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4Lmluc3RhbmNlO1xuICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5DYXRjaEVycm9yOlxuICAgICAgICAgICAgICAgICAgICB2YXJOYW1lID0gQ0FUQ0hfRVJST1JfVkFSJDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5DYXRjaFN0YWNrOlxuICAgICAgICAgICAgICAgICAgICB2YXJOYW1lID0gQ0FUQ0hfU1RBQ0tfVkFSJDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gYnVpbHRpbiB2YXJpYWJsZSBcIiArIGFzdC5idWlsdGluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdXJyQ3R4ID0gY3R4O1xuICAgICAgICB3aGlsZSAoY3VyckN0eCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY3VyckN0eC52YXJzLmhhcyh2YXJOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyQ3R4LnZhcnMuZ2V0KHZhck5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyckN0eCA9ICgoY3VyckN0eC5wYXJlbnQpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgZGVjbGFyZWQgdmFyaWFibGUgXCIgKyB2YXJOYW1lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwclxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRXcml0ZUtleUV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlY2VpdmVyID0gZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5kZXggPSBleHByLmluZGV4LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIHJlY2VpdmVyW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cHJcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0V3JpdGVQcm9wRXhwciA9IGZ1bmN0aW9uIChleHByLCBjdHgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVjZWl2ZXIgPSBleHByLnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIHJlY2VpdmVyW2V4cHIubmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHByXG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEludm9rZU1ldGhvZEV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlY2VpdmVyID0gZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXJncyA9IHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhleHByLmFyZ3MsIGN0eCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdDtcbiAgICAgICAgaWYgKGV4cHIuYnVpbHRpbiAhPSBudWxsKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGV4cHIuYnVpbHRpbikge1xuICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpbk1ldGhvZC5Db25jYXRBcnJheTpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVjZWl2ZXIuY29uY2F0LmFwcGx5KHJlY2VpdmVyLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBCdWlsdGluTWV0aG9kLlN1YnNjcmliZU9ic2VydmFibGU6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlY2VpdmVyLnN1YnNjcmliZSh7IG5leHQ6IGFyZ3NbMF0gfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpbk1ldGhvZC5CaW5kOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZWNlaXZlci5iaW5kLmFwcGx5KHJlY2VpdmVyLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBidWlsdGluIG1ldGhvZCBcIiArIGV4cHIuYnVpbHRpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZWNlaXZlclsoKGV4cHIubmFtZSkpXS5hcHBseShyZWNlaXZlciwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRJbnZva2VGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFyZ3MgPSB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoc3RtdC5hcmdzLCBjdHgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmbkV4cHIgPSBzdG10LmZuO1xuICAgICAgICBpZiAoZm5FeHByIGluc3RhbmNlb2YgUmVhZFZhckV4cHIgJiYgZm5FeHByLmJ1aWx0aW4gPT09IEJ1aWx0aW5WYXIuU3VwZXIpIHtcbiAgICAgICAgICAgIGN0eC5pbnN0YW5jZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IuYXBwbHkoY3R4Lmluc3RhbmNlLCBhcmdzKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZm4kJDEgPSBzdG10LmZuLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgICAgcmV0dXJuIGZuJCQxLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0UmV0dXJuU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXR1cm5WYWx1ZShzdG10LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXREZWNsYXJlQ2xhc3NTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbGF6eiA9IGNyZWF0ZUR5bmFtaWNDbGFzcyhzdG10LCBjdHgsIHRoaXMpO1xuICAgICAgICBjdHgudmFycy5zZXQoc3RtdC5uYW1lLCBjbGF6eik7XG4gICAgICAgIGlmIChzdG10Lmhhc01vZGlmaWVyKFN0bXRNb2RpZmllci5FeHBvcnRlZCkpIHtcbiAgICAgICAgICAgIGN0eC5leHBvcnRzLnB1c2goc3RtdC5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIHN0bXQuZXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRJZlN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbmRpdGlvbiA9IHN0bXQuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC50cnVlQ2FzZSwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdG10LmZhbHNlQ2FzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5mYWxzZUNhc2UsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0VHJ5Q2F0Y2hTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuYm9keVN0bXRzLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlsZEN0eCA9IGN0eC5jcmVhdGVDaGlsZFdpaHRMb2NhbFZhcnMoKTtcbiAgICAgICAgICAgIGNoaWxkQ3R4LnZhcnMuc2V0KENBVENIX0VSUk9SX1ZBUiQyLCBlKTtcbiAgICAgICAgICAgIGNoaWxkQ3R4LnZhcnMuc2V0KENBVENIX1NUQUNLX1ZBUiQyLCBlLnN0YWNrKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmNhdGNoU3RtdHMsIGNoaWxkQ3R4KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdFRocm93U3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgdGhyb3cgc3RtdC5lcnJvci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdENvbW1lbnRTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0SW5zdGFudGlhdGVFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFyZ3MgPSB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGN0eCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsYXp6ID0gYXN0LmNsYXNzRXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgcmV0dXJuIG5ldyAoY2xhenouYmluZC5hcHBseShjbGF6eiwgW3ZvaWQgMF0uY29uY2F0KGFyZ3MpKSkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7IHJldHVybiBhc3QudmFsdWU7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0RXh0ZXJuYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7IHJldHVybiBhc3QudmFsdWUucnVudGltZTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRDb25kaXRpb25hbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgaWYgKGFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCkpIHtcbiAgICAgICAgICAgIHJldHVybiBhc3QudHJ1ZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXN0LmZhbHNlQ2FzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYXN0LmZhbHNlQ2FzZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdE5vdEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgcmV0dXJuICFhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0QXNzZXJ0Tm90TnVsbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIGFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRDYXN0RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICByZXR1cm4gYXN0LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25FeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmFtTmFtZXMgPSBhc3QucGFyYW1zLm1hcChmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuIHBhcmFtLm5hbWU7IH0pO1xuICAgICAgICByZXR1cm4gX2RlY2xhcmVGbihwYXJhbU5hbWVzLCBhc3Quc3RhdGVtZW50cywgY3R4LCB0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXREZWNsYXJlRnVuY3Rpb25TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJhbU5hbWVzID0gc3RtdC5wYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gcGFyYW0ubmFtZTsgfSk7XG4gICAgICAgIGN0eC52YXJzLnNldChzdG10Lm5hbWUsIF9kZWNsYXJlRm4ocGFyYW1OYW1lcywgc3RtdC5zdGF0ZW1lbnRzLCBjdHgsIHRoaXMpKTtcbiAgICAgICAgaWYgKHN0bXQuaGFzTW9kaWZpZXIoU3RtdE1vZGlmaWVyLkV4cG9ydGVkKSkge1xuICAgICAgICAgICAgY3R4LmV4cG9ydHMucHVzaChzdG10Lm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0QmluYXJ5T3BlcmF0b3JFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxocyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFzdC5saHMudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjdHgpOyB9O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByaHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBhc3QucmhzLnZpc2l0RXhwcmVzc2lvbihfdGhpcywgY3R4KTsgfTtcbiAgICAgICAgc3dpdGNoIChhc3Qub3BlcmF0b3IpIHtcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuRXF1YWxzOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSA9PSByaHMoKTtcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuSWRlbnRpY2FsOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSA9PT0gcmhzKCk7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk5vdEVxdWFsczpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgIT0gcmhzKCk7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk5vdElkZW50aWNhbDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgIT09IHJocygpO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5BbmQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxocygpICYmIHJocygpO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5PcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgfHwgcmhzKCk7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLlBsdXM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxocygpICsgcmhzKCk7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk1pbnVzOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSAtIHJocygpO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5EaXZpZGU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxocygpIC8gcmhzKCk7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk11bHRpcGx5OlxuICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSAqIHJocygpO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Nb2R1bG86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxocygpICUgcmhzKCk7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkxvd2VyOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSA8IHJocygpO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Mb3dlckVxdWFsczpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgPD0gcmhzKCk7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkJpZ2dlcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgPiByaHMoKTtcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuQmlnZ2VyRXF1YWxzOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSA+PSByaHMoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvcGVyYXRvciBcIiArIGFzdC5vcGVyYXRvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdFJlYWRQcm9wRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlY2VpdmVyID0gYXN0LnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICByZXN1bHQgPSByZWNlaXZlclthc3QubmFtZV07XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRSZWFkS2V5RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWNlaXZlciA9IGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvcCA9IGFzdC5pbmRleC52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgcmV0dXJuIHJlY2VpdmVyW3Byb3BdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5lbnRyaWVzLCBjdHgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbE1hcEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0ge307XG4gICAgICAgIGFzdC5lbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiByZXN1bHRbZW50cnkua2V5XSA9IGVudHJ5LnZhbHVlLnZpc2l0RXhwcmVzc2lvbihfdGhpcywgY3R4KTsgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0Q29tbWFFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZXMgPSB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LnBhcnRzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cHJlc3Npb25zXG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEFsbEV4cHJlc3Npb25zID0gZnVuY3Rpb24gKGV4cHJlc3Npb25zLCBjdHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb25zLm1hcChmdW5jdGlvbiAoZXhwcikgeyByZXR1cm4gZXhwci52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGN0eCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGF0ZW1lbnRzXG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEFsbFN0YXRlbWVudHMgPSBmdW5jdGlvbiAoc3RhdGVtZW50cywgY3R4KSB7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBzdGF0ZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdG10ID0gc3RhdGVtZW50c1tpXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbCA9IHN0bXQudmlzaXRTdGF0ZW1lbnQodGhpcywgY3R4KTtcbiAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBSZXR1cm5WYWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGVtZW50SW50ZXJwcmV0ZXI7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IHZhck5hbWVzXG4gKiBAcGFyYW0gez99IHN0YXRlbWVudHNcbiAqIEBwYXJhbSB7P30gY3R4XG4gKiBAcGFyYW0gez99IHZpc2l0b3JcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9kZWNsYXJlRm4odmFyTmFtZXMsIHN0YXRlbWVudHMsIGN0eCwgdmlzaXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9leGVjdXRlRnVuY3Rpb25TdGF0ZW1lbnRzKHZhck5hbWVzLCBhcmdzLCBzdGF0ZW1lbnRzLCBjdHgsIHZpc2l0b3IpO1xuICAgIH07XG59XG52YXIgQ0FUQ0hfRVJST1JfVkFSJDIgPSAnZXJyb3InO1xudmFyIENBVENIX1NUQUNLX1ZBUiQyID0gJ3N0YWNrJztcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQGFic3RyYWN0XG4gKi9cbnZhciBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBmYWxzZSkgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlQ2xhc3NTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBjdHgucHVzaENsYXNzKHN0bXQpO1xuICAgICAgICB0aGlzLl92aXNpdENsYXNzQ29uc3RydWN0b3Ioc3RtdCwgY3R4KTtcbiAgICAgICAgaWYgKHN0bXQucGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChzdG10LCBzdG10Lm5hbWUgKyBcIi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFwiKTtcbiAgICAgICAgICAgIHN0bXQucGFyZW50LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCIucHJvdG90eXBlKTtcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3RtdC5nZXR0ZXJzLmZvckVhY2goZnVuY3Rpb24gKGdldHRlcikgeyByZXR1cm4gX3RoaXMuX3Zpc2l0Q2xhc3NHZXR0ZXIoc3RtdCwgZ2V0dGVyLCBjdHgpOyB9KTtcbiAgICAgICAgc3RtdC5tZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkgeyByZXR1cm4gX3RoaXMuX3Zpc2l0Q2xhc3NNZXRob2Qoc3RtdCwgbWV0aG9kLCBjdHgpOyB9KTtcbiAgICAgICAgY3R4LnBvcENsYXNzKCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0Q2xhc3NDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KHN0bXQsIFwiZnVuY3Rpb24gXCIgKyBzdG10Lm5hbWUgKyBcIihcIik7XG4gICAgICAgIGlmIChzdG10LmNvbnN0cnVjdG9yTWV0aG9kICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKHN0bXQuY29uc3RydWN0b3JNZXRob2QucGFyYW1zLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwiKSB7XCIpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIGlmIChzdG10LmNvbnN0cnVjdG9yTWV0aG9kICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChzdG10LmNvbnN0cnVjdG9yTWV0aG9kLmJvZHkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwidmFyIHNlbGYgPSB0aGlzO1wiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmNvbnN0cnVjdG9yTWV0aG9kLmJvZHksIGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIn1cIik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGdldHRlclxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdENsYXNzR2V0dGVyID0gZnVuY3Rpb24gKHN0bXQsIGdldHRlciwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KFwiICsgc3RtdC5uYW1lICsgXCIucHJvdG90eXBlLCAnXCIgKyBnZXR0ZXIubmFtZSArIFwiJywgeyBnZXQ6IGZ1bmN0aW9uKCkge1wiKTtcbiAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICBpZiAoZ2V0dGVyLmJvZHkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ2YXIgc2VsZiA9IHRoaXM7XCIpO1xuICAgICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoZ2V0dGVyLmJvZHksIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIn19KTtcIik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IG1ldGhvZFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdENsYXNzTWV0aG9kID0gZnVuY3Rpb24gKHN0bXQsIG1ldGhvZCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChzdG10LCBzdG10Lm5hbWUgKyBcIi5wcm90b3R5cGUuXCIgKyBtZXRob2QubmFtZSArIFwiID0gZnVuY3Rpb24oXCIpO1xuICAgICAgICB0aGlzLl92aXNpdFBhcmFtcyhtZXRob2QucGFyYW1zLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIikge1wiKTtcbiAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICBpZiAobWV0aG9kLmJvZHkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ2YXIgc2VsZiA9IHRoaXM7XCIpO1xuICAgICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMobWV0aG9kLmJvZHksIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIn07XCIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlYWRWYXJFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGlmIChhc3QuYnVpbHRpbiA9PT0gQnVpbHRpblZhci5UaGlzKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoYXN0LCAnc2VsZicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFzdC5idWlsdGluID09PSBCdWlsdGluVmFyLlN1cGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCInc3VwZXInIG5lZWRzIHRvIGJlIGhhbmRsZWQgYXQgYSBwYXJlbnQgYXN0IG5vZGUsIG5vdCBhdCB0aGUgdmFyaWFibGUgbGV2ZWwhXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS52aXNpdFJlYWRWYXJFeHByLmNhbGwodGhpcywgYXN0LCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlVmFyU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KHN0bXQsIFwidmFyIFwiICsgc3RtdC5uYW1lICsgXCIgPSBcIik7XG4gICAgICAgIHN0bXQudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwiO1wiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q2FzdEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgYXN0LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwclxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW52b2tlRnVuY3Rpb25FeHByID0gZnVuY3Rpb24gKGV4cHIsIGN0eCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmbkV4cHIgPSBleHByLmZuO1xuICAgICAgICBpZiAoZm5FeHByIGluc3RhbmNlb2YgUmVhZFZhckV4cHIgJiYgZm5FeHByLmJ1aWx0aW4gPT09IEJ1aWx0aW5WYXIuU3VwZXIpIHtcbiAgICAgICAgICAgICgoKChjdHguY3VycmVudENsYXNzKSkucGFyZW50KSkudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgICBjdHgucHJpbnQoZXhwciwgXCIuY2FsbCh0aGlzXCIpO1xuICAgICAgICAgICAgaWYgKGV4cHIuYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY3R4LnByaW50KGV4cHIsIFwiLCBcIik7XG4gICAgICAgICAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGV4cHIuYXJncywgY3R4LCAnLCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnByaW50KGV4cHIsIFwiKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUudmlzaXRJbnZva2VGdW5jdGlvbkV4cHIuY2FsbCh0aGlzLCBleHByLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEZ1bmN0aW9uRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcImZ1bmN0aW9uKFwiKTtcbiAgICAgICAgdGhpcy5fdmlzaXRQYXJhbXMoYXN0LnBhcmFtcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50bG4oYXN0LCBcIikge1wiKTtcbiAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhhc3Quc3RhdGVtZW50cywgY3R4KTtcbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIn1cIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlRnVuY3Rpb25TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCJmdW5jdGlvbiBcIiArIHN0bXQubmFtZSArIFwiKFwiKTtcbiAgICAgICAgdGhpcy5fdmlzaXRQYXJhbXMoc3RtdC5wYXJhbXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwiKSB7XCIpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuc3RhdGVtZW50cywgY3R4KTtcbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIn1cIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUcnlDYXRjaFN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwidHJ5IHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5ib2R5U3RtdHMsIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ9IGNhdGNoIChcIiArIENBVENIX0VSUk9SX1ZBUiQxLm5hbWUgKyBcIikge1wiKTtcbiAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjYXRjaFN0bXRzID0gWy8qKiBAdHlwZSB7P30gKi8gKENBVENIX1NUQUNLX1ZBUiQxLnNldChDQVRDSF9FUlJPUl9WQVIkMS5wcm9wKCdzdGFjaycpKS50b0RlY2xTdG10KG51bGwsIFtcbiAgICAgICAgICAgICAgICBTdG10TW9kaWZpZXIuRmluYWxcbiAgICAgICAgICAgIF0pKV0uY29uY2F0KHN0bXQuY2F0Y2hTdG10cyk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKGNhdGNoU3RtdHMsIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ9XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGFyYW1zXG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0UGFyYW1zID0gZnVuY3Rpb24gKHBhcmFtcywgY3R4KSB7XG4gICAgICAgIHRoaXMudmlzaXRBbGxPYmplY3RzKGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gY3R4LnByaW50KG51bGwsIHBhcmFtLm5hbWUpOyB9LCBwYXJhbXMsIGN0eCwgJywnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWV0aG9kXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLmdldEJ1aWx0aW5NZXRob2ROYW1lID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lO1xuICAgICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBCdWlsdGluTWV0aG9kLkNvbmNhdEFycmF5OlxuICAgICAgICAgICAgICAgIG5hbWUgPSAnY29uY2F0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQnVpbHRpbk1ldGhvZC5TdWJzY3JpYmVPYnNlcnZhYmxlOlxuICAgICAgICAgICAgICAgIG5hbWUgPSAnc3Vic2NyaWJlJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQnVpbHRpbk1ldGhvZC5CaW5kOlxuICAgICAgICAgICAgICAgIG5hbWUgPSAnYmluZCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gYnVpbHRpbiBtZXRob2Q6IFwiICsgbWV0aG9kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9O1xuICAgIHJldHVybiBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3I7XG59KEFic3RyYWN0RW1pdHRlclZpc2l0b3IpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQHBhcmFtIHs/fSBzb3VyY2VVcmxcbiAqIEBwYXJhbSB7P30gY3R4XG4gKiBAcGFyYW0gez99IHZhcnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGV2YWxFeHByZXNzaW9uKHNvdXJjZVVybCQkMSwgY3R4LCB2YXJzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZm5Cb2R5ID0gY3R4LnRvU291cmNlKCkgKyBcIlxcbi8vIyBzb3VyY2VVUkw9XCIgKyBzb3VyY2VVcmwkJDE7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZm5BcmdOYW1lcyA9IFtdO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGZuQXJnVmFsdWVzID0gW107XG4gICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBhcmdOYW1lIGluIHZhcnMpIHtcbiAgICAgICAgZm5BcmdOYW1lcy5wdXNoKGFyZ05hbWUpO1xuICAgICAgICBmbkFyZ1ZhbHVlcy5wdXNoKHZhcnNbYXJnTmFtZV0pO1xuICAgIH1cbiAgICBpZiAoaXNEZXZNb2RlKCkpIHtcbiAgICAgICAgLy8gdXNpbmcgYG5ldyBGdW5jdGlvbiguLi4pYCBnZW5lcmF0ZXMgYSBoZWFkZXIsIDEgbGluZSBvZiBubyBhcmd1bWVudHMsIDIgbGluZXMgb3RoZXJ3aXNlXG4gICAgICAgIC8vIEUuZy4gYGBgXG4gICAgICAgIC8vIGZ1bmN0aW9uIGFub255bW91cyhhLGIsY1xuICAgICAgICAvLyAvKiovKSB7IC4uLiB9YGBgXG4gICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gaGFyZCBjb2RlIHRoaXMgZmFjdCwgc28gd2UgYXV0byBkZXRlY3QgaXQgdmlhIGFuIGVtcHR5IGZ1bmN0aW9uIGZpcnN0LlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbXB0eUZuID0gbmV3IChGdW5jdGlvbi5iaW5kLmFwcGx5KEZ1bmN0aW9uLCBbdm9pZCAwXS5jb25jYXQoZm5BcmdOYW1lcy5jb25jYXQoJ3JldHVybiBudWxsOycpKSkpKCkudG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaGVhZGVyTGluZXMgPSBlbXB0eUZuLnNsaWNlKDAsIGVtcHR5Rm4uaW5kZXhPZigncmV0dXJuIG51bGw7JykpLnNwbGl0KCdcXG4nKS5sZW5ndGggLSAxO1xuICAgICAgICBmbkJvZHkgKz0gXCJcXG5cIiArIGN0eC50b1NvdXJjZU1hcEdlbmVyYXRvcihzb3VyY2VVcmwkJDEsIHNvdXJjZVVybCQkMSwgaGVhZGVyTGluZXMpLnRvSnNDb21tZW50KCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLmJpbmQuYXBwbHkoRnVuY3Rpb24sIFt2b2lkIDBdLmNvbmNhdChmbkFyZ05hbWVzLmNvbmNhdChmbkJvZHkpKSkpKCkuYXBwbHkodm9pZCAwLCBmbkFyZ1ZhbHVlcyk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gc291cmNlVXJsXG4gKiBAcGFyYW0gez99IHN0YXRlbWVudHNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGppdFN0YXRlbWVudHMoc291cmNlVXJsJCQxLCBzdGF0ZW1lbnRzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udmVydGVyID0gbmV3IEppdEVtaXR0ZXJWaXNpdG9yKCk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3R4ID0gRW1pdHRlclZpc2l0b3JDb250ZXh0LmNyZWF0ZVJvb3QoKTtcbiAgICBjb252ZXJ0ZXIudmlzaXRBbGxTdGF0ZW1lbnRzKHN0YXRlbWVudHMsIGN0eCk7XG4gICAgY29udmVydGVyLmNyZWF0ZVJldHVyblN0bXQoY3R4KTtcbiAgICByZXR1cm4gZXZhbEV4cHJlc3Npb24oc291cmNlVXJsJCQxLCBjdHgsIGNvbnZlcnRlci5nZXRBcmdzKCkpO1xufVxudmFyIEppdEVtaXR0ZXJWaXNpdG9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhKaXRFbWl0dGVyVmlzaXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBKaXRFbWl0dGVyVmlzaXRvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2V2YWxBcmdOYW1lcyA9IFtdO1xuICAgICAgICBfdGhpcy5fZXZhbEFyZ1ZhbHVlcyA9IFtdO1xuICAgICAgICBfdGhpcy5fZXZhbEV4cG9ydGVkVmFycyA9IFtdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuY3JlYXRlUmV0dXJuU3RtdCA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RtdCA9IG5ldyBSZXR1cm5TdGF0ZW1lbnQobmV3IExpdGVyYWxNYXBFeHByKHRoaXMuX2V2YWxFeHBvcnRlZFZhcnMubWFwKGZ1bmN0aW9uIChyZXN1bHRWYXIpIHsgcmV0dXJuIG5ldyBMaXRlcmFsTWFwRW50cnkocmVzdWx0VmFyLCB2YXJpYWJsZShyZXN1bHRWYXIpLCBmYWxzZSk7IH0pKSk7XG4gICAgICAgIHN0bXQudmlzaXRTdGF0ZW1lbnQodGhpcywgY3R4KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSml0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLmdldEFyZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgdGhpcy5fZXZhbEFyZ05hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRbdGhpcy5fZXZhbEFyZ05hbWVzW2ldXSA9IHRoaXMuX2V2YWxBcmdWYWx1ZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEppdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4dGVybmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IGFzdC52YWx1ZS5ydW50aW1lO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpZCA9IHRoaXMuX2V2YWxBcmdWYWx1ZXMuaW5kZXhPZih2YWx1ZSk7XG4gICAgICAgIGlmIChpZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGlkID0gdGhpcy5fZXZhbEFyZ1ZhbHVlcy5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLl9ldmFsQXJnVmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZSA9IGlkZW50aWZpZXJOYW1lKHsgcmVmZXJlbmNlOiBhc3QudmFsdWUucnVudGltZSB9KSB8fCAndmFsJztcbiAgICAgICAgICAgIHRoaXMuX2V2YWxBcmdOYW1lcy5wdXNoKFwiaml0X1wiICsgbmFtZSArIFwiX1wiICsgaWQpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChhc3QsIHRoaXMuX2V2YWxBcmdOYW1lc1tpZF0pO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlVmFyU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgaWYgKHN0bXQuaGFzTW9kaWZpZXIoU3RtdE1vZGlmaWVyLkV4cG9ydGVkKSkge1xuICAgICAgICAgICAgdGhpcy5fZXZhbEV4cG9ydGVkVmFycy5wdXNoKHN0bXQubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUudmlzaXREZWNsYXJlVmFyU3RtdC5jYWxsKHRoaXMsIHN0bXQsIGN0eCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSml0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZUZ1bmN0aW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgaWYgKHN0bXQuaGFzTW9kaWZpZXIoU3RtdE1vZGlmaWVyLkV4cG9ydGVkKSkge1xuICAgICAgICAgICAgdGhpcy5fZXZhbEV4cG9ydGVkVmFycy5wdXNoKHN0bXQubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUudmlzaXREZWNsYXJlRnVuY3Rpb25TdG10LmNhbGwodGhpcywgc3RtdCwgY3R4KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlQ2xhc3NTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBpZiAoc3RtdC5oYXNNb2RpZmllcihTdG10TW9kaWZpZXIuRXhwb3J0ZWQpKSB7XG4gICAgICAgICAgICB0aGlzLl9ldmFsRXhwb3J0ZWRWYXJzLnB1c2goc3RtdC5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS52aXNpdERlY2xhcmVDbGFzc1N0bXQuY2FsbCh0aGlzLCBzdG10LCBjdHgpO1xuICAgIH07XG4gICAgcmV0dXJuIEppdEVtaXR0ZXJWaXNpdG9yO1xufShBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQW4gaW50ZXJuYWwgbW9kdWxlIG9mIHRoZSBBbmd1bGFyIGNvbXBpbGVyIHRoYXQgYmVnaW5zIHdpdGggY29tcG9uZW50IHR5cGVzLFxuICogZXh0cmFjdHMgdGVtcGxhdGVzLCBhbmQgZXZlbnR1YWxseSBwcm9kdWNlcyBhIGNvbXBpbGVkIHZlcnNpb24gb2YgdGhlIGNvbXBvbmVudFxuICogcmVhZHkgZm9yIGxpbmtpbmcgaW50byBhbiBhcHBsaWNhdGlvbi5cbiAqXG4gKiBcXEBzZWN1cml0eSBXaGVuIGNvbXBpbGluZyB0ZW1wbGF0ZXMgYXQgcnVudGltZSwgeW91IG11c3QgZW5zdXJlIHRoYXQgdGhlIGVudGlyZSB0ZW1wbGF0ZSBjb21lc1xuICogZnJvbSBhIHRydXN0ZWQgc291cmNlLiBBdHRhY2tlci1jb250cm9sbGVkIGRhdGEgaW50cm9kdWNlZCBieSBhIHRlbXBsYXRlIGNvdWxkIGV4cG9zZSB5b3VyXG4gKiBhcHBsaWNhdGlvbiB0byBYU1Mgcmlza3MuICBGb3IgbW9yZSBkZXRhaWwsIHNlZSB0aGUgW1NlY3VyaXR5IEd1aWRlXShodHRwOi8vZy5jby9uZy9zZWN1cml0eSkuXG4gKi9cbnZhciBKaXRDb21waWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfaW5qZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IF9tZXRhZGF0YVJlc29sdmVyXG4gICAgICogQHBhcmFtIHs/fSBfdGVtcGxhdGVQYXJzZXJcbiAgICAgKiBAcGFyYW0gez99IF9zdHlsZUNvbXBpbGVyXG4gICAgICogQHBhcmFtIHs/fSBfdmlld0NvbXBpbGVyXG4gICAgICogQHBhcmFtIHs/fSBfbmdNb2R1bGVDb21waWxlclxuICAgICAqIEBwYXJhbSB7P30gX3N1bW1hcnlSZXNvbHZlclxuICAgICAqIEBwYXJhbSB7P30gX2NvbXBpbGVyQ29uZmlnXG4gICAgICogQHBhcmFtIHs/fSBfY29uc29sZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEppdENvbXBpbGVyKF9pbmplY3RvciwgX21ldGFkYXRhUmVzb2x2ZXIsIF90ZW1wbGF0ZVBhcnNlciwgX3N0eWxlQ29tcGlsZXIsIF92aWV3Q29tcGlsZXIsIF9uZ01vZHVsZUNvbXBpbGVyLCBfc3VtbWFyeVJlc29sdmVyLCBfY29tcGlsZXJDb25maWcsIF9jb25zb2xlKSB7XG4gICAgICAgIHRoaXMuX2luamVjdG9yID0gX2luamVjdG9yO1xuICAgICAgICB0aGlzLl9tZXRhZGF0YVJlc29sdmVyID0gX21ldGFkYXRhUmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlUGFyc2VyID0gX3RlbXBsYXRlUGFyc2VyO1xuICAgICAgICB0aGlzLl9zdHlsZUNvbXBpbGVyID0gX3N0eWxlQ29tcGlsZXI7XG4gICAgICAgIHRoaXMuX3ZpZXdDb21waWxlciA9IF92aWV3Q29tcGlsZXI7XG4gICAgICAgIHRoaXMuX25nTW9kdWxlQ29tcGlsZXIgPSBfbmdNb2R1bGVDb21waWxlcjtcbiAgICAgICAgdGhpcy5fc3VtbWFyeVJlc29sdmVyID0gX3N1bW1hcnlSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5fY29tcGlsZXJDb25maWcgPSBfY29tcGlsZXJDb25maWc7XG4gICAgICAgIHRoaXMuX2NvbnNvbGUgPSBfY29uc29sZTtcbiAgICAgICAgdGhpcy5fY29tcGlsZWRUZW1wbGF0ZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jb21waWxlZEhvc3RUZW1wbGF0ZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jb21waWxlZERpcmVjdGl2ZVdyYXBwZXJDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fY29tcGlsZWROZ01vZHVsZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9zaGFyZWRTdHlsZXNoZWV0Q291bnQgPSAwO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSml0Q29tcGlsZXIucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2luamVjdG9yOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAdGVtcGxhdGUgVFxuICAgICAqIEBwYXJhbSB7P30gbW9kdWxlVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSml0Q29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVNb2R1bGVTeW5jID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHtcbiAgICAgICAgcmV0dXJuIFN5bmNBc3luYy5hc3NlcnRTeW5jKHRoaXMuX2NvbXBpbGVNb2R1bGVBbmRDb21wb25lbnRzKG1vZHVsZVR5cGUsIHRydWUpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICogQHBhcmFtIHs/fSBtb2R1bGVUeXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUuY29tcGlsZU1vZHVsZUFzeW5jID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9jb21waWxlTW9kdWxlQW5kQ29tcG9uZW50cyhtb2R1bGVUeXBlLCBmYWxzZSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0gez99IG1vZHVsZVR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlTW9kdWxlQW5kQWxsQ29tcG9uZW50c1N5bmMgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSkge1xuICAgICAgICByZXR1cm4gU3luY0FzeW5jLmFzc2VydFN5bmModGhpcy5fY29tcGlsZU1vZHVsZUFuZEFsbENvbXBvbmVudHMobW9kdWxlVHlwZSwgdHJ1ZSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0gez99IG1vZHVsZVR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlTW9kdWxlQW5kQWxsQ29tcG9uZW50c0FzeW5jID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9jb21waWxlTW9kdWxlQW5kQWxsQ29tcG9uZW50cyhtb2R1bGVUeXBlLCBmYWxzZSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb21wb25lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5nZXROZ0NvbnRlbnRTZWxlY3RvcnMgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIHRoaXMuX2NvbnNvbGUud2FybignQ29tcGlsZXIuZ2V0TmdDb250ZW50U2VsZWN0b3JzIGlzIGRlcHJlY2F0ZWQuIFVzZSBDb21wb25lbnRGYWN0b3J5Lm5nQ29udGVudFNlbGVjdG9ycyBpbnN0ZWFkIScpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wbGF0ZSA9IHRoaXMuX2NvbXBpbGVkVGVtcGxhdGVDYWNoZS5nZXQoY29tcG9uZW50KTtcbiAgICAgICAgaWYgKCF0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGNvbXBvbmVudCBcIiArIMm1c3RyaW5naWZ5KGNvbXBvbmVudCkgKyBcIiBpcyBub3QgeWV0IGNvbXBpbGVkIVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCh0ZW1wbGF0ZS5jb21wTWV0YS50ZW1wbGF0ZSkpLm5nQ29udGVudFNlbGVjdG9ycztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICogQHBhcmFtIHs/fSBjb21wb25lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5nZXRDb21wb25lbnRGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdW1tYXJ5ID0gdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXREaXJlY3RpdmVTdW1tYXJ5KGNvbXBvbmVudCk7XG4gICAgICAgIHJldHVybiAoc3VtbWFyeS5jb21wb25lbnRGYWN0b3J5KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3VtbWFyaWVzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUubG9hZEFvdFN1bW1hcmllcyA9IGZ1bmN0aW9uIChzdW1tYXJpZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jbGVhckNhY2hlKCk7XG4gICAgICAgIGZsYXR0ZW5TdW1tYXJpZXMoc3VtbWFyaWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChzdW1tYXJ5KSB7XG4gICAgICAgICAgICBfdGhpcy5fc3VtbWFyeVJlc29sdmVyLmFkZFN1bW1hcnkoeyBzeW1ib2w6IHN1bW1hcnkudHlwZS5yZWZlcmVuY2UsIG1ldGFkYXRhOiBudWxsLCB0eXBlOiBzdW1tYXJ5IH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVmXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUuaGFzQW90U3VtbWFyeSA9IGZ1bmN0aW9uIChyZWYpIHsgcmV0dXJuICEhdGhpcy5fc3VtbWFyeVJlc29sdmVyLnJlc29sdmVTdW1tYXJ5KHJlZik7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpZHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5fZmlsdGVySml0SWRlbnRpZmllcnMgPSBmdW5jdGlvbiAoaWRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBpZHMubWFwKGZ1bmN0aW9uIChtb2QpIHsgcmV0dXJuIG1vZC5yZWZlcmVuY2U7IH0pLmZpbHRlcihmdW5jdGlvbiAocmVmKSB7IHJldHVybiAhX3RoaXMuaGFzQW90U3VtbWFyeShyZWYpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICogQHBhcmFtIHs/fSBtb2R1bGVUeXBlXG4gICAgICogQHBhcmFtIHs/fSBpc1N5bmNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZU1vZHVsZUFuZENvbXBvbmVudHMgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSwgaXNTeW5jKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBTeW5jQXN5bmMudGhlbih0aGlzLl9sb2FkTW9kdWxlcyhtb2R1bGVUeXBlLCBpc1N5bmMpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fY29tcGlsZUNvbXBvbmVudHMobW9kdWxlVHlwZSwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX2NvbXBpbGVNb2R1bGUobW9kdWxlVHlwZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0gez99IG1vZHVsZVR5cGVcbiAgICAgKiBAcGFyYW0gez99IGlzU3luY1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSml0Q29tcGlsZXIucHJvdG90eXBlLl9jb21waWxlTW9kdWxlQW5kQWxsQ29tcG9uZW50cyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlLCBpc1N5bmMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFN5bmNBc3luYy50aGVuKHRoaXMuX2xvYWRNb2R1bGVzKG1vZHVsZVR5cGUsIGlzU3luYyksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBvbmVudEZhY3RvcmllcyA9IFtdO1xuICAgICAgICAgICAgX3RoaXMuX2NvbXBpbGVDb21wb25lbnRzKG1vZHVsZVR5cGUsIGNvbXBvbmVudEZhY3Rvcmllcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vZHVsZVdpdGhDb21wb25lbnRGYWN0b3JpZXMoX3RoaXMuX2NvbXBpbGVNb2R1bGUobW9kdWxlVHlwZSksIGNvbXBvbmVudEZhY3Rvcmllcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtYWluTW9kdWxlXG4gICAgICogQHBhcmFtIHs/fSBpc1N5bmNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5fbG9hZE1vZHVsZXMgPSBmdW5jdGlvbiAobWFpbk1vZHVsZSwgaXNTeW5jKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxvYWRpbmcgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWFpbk5nTW9kdWxlID0gKCh0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldE5nTW9kdWxlTWV0YWRhdGEobWFpbk1vZHVsZSkpKTtcbiAgICAgICAgLy8gTm90ZTogZm9yIHJ1bnRpbWUgY29tcGlsYXRpb24sIHdlIHdhbnQgdG8gdHJhbnNpdGl2ZWx5IGNvbXBpbGUgYWxsIG1vZHVsZXMsXG4gICAgICAgIC8vIHNvIHdlIGFsc28gbmVlZCB0byBsb2FkIHRoZSBkZWNsYXJlZCBkaXJlY3RpdmVzIC8gcGlwZXMgZm9yIGFsbCBuZXN0ZWQgbW9kdWxlcy5cbiAgICAgICAgdGhpcy5fZmlsdGVySml0SWRlbnRpZmllcnMobWFpbk5nTW9kdWxlLnRyYW5zaXRpdmVNb2R1bGUubW9kdWxlcykuZm9yRWFjaChmdW5jdGlvbiAobmVzdGVkTmdNb2R1bGUpIHtcbiAgICAgICAgICAgIC8vIGdldE5nTW9kdWxlTWV0YWRhdGEgb25seSByZXR1cm5zIG51bGwgaWYgdGhlIHZhbHVlIHBhc3NlZCBpbiBpcyBub3QgYW4gTmdNb2R1bGVcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1vZHVsZU1ldGEgPSAoKF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldE5nTW9kdWxlTWV0YWRhdGEobmVzdGVkTmdNb2R1bGUpKSk7XG4gICAgICAgICAgICBfdGhpcy5fZmlsdGVySml0SWRlbnRpZmllcnMobW9kdWxlTWV0YS5kZWNsYXJlZERpcmVjdGl2ZXMpLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb21pc2UgPSBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5sb2FkRGlyZWN0aXZlTWV0YWRhdGEobW9kdWxlTWV0YS50eXBlLnJlZmVyZW5jZSwgcmVmLCBpc1N5bmMpO1xuICAgICAgICAgICAgICAgIGlmIChwcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRpbmcucHVzaChwcm9taXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzLl9maWx0ZXJKaXRJZGVudGlmaWVycyhtb2R1bGVNZXRhLmRlY2xhcmVkUGlwZXMpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKHJlZikgeyByZXR1cm4gX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0T3JMb2FkUGlwZU1ldGFkYXRhKHJlZik7IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFN5bmNBc3luYy5hbGwobG9hZGluZyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAdGVtcGxhdGUgVFxuICAgICAqIEBwYXJhbSB7P30gbW9kdWxlVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSml0Q29tcGlsZXIucHJvdG90eXBlLl9jb21waWxlTW9kdWxlID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmdNb2R1bGVGYWN0b3J5ID0gKCh0aGlzLl9jb21waWxlZE5nTW9kdWxlQ2FjaGUuZ2V0KG1vZHVsZVR5cGUpKSk7XG4gICAgICAgIGlmICghbmdNb2R1bGVGYWN0b3J5KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtb2R1bGVNZXRhXzEgPSAoKHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0TmdNb2R1bGVNZXRhZGF0YShtb2R1bGVUeXBlKSkpO1xuICAgICAgICAgICAgLy8gQWx3YXlzIHByb3ZpZGUgYSBib3VuZCBDb21waWxlclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXh0cmFQcm92aWRlcnMgPSBbdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXRQcm92aWRlck1ldGFkYXRhKG5ldyBQcm92aWRlck1ldGEoQ29tcGlsZXIsIHsgdXNlRmFjdG9yeTogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IE1vZHVsZUJvdW5kQ29tcGlsZXIoX3RoaXMsIG1vZHVsZU1ldGFfMS50eXBlLnJlZmVyZW5jZSk7IH0gfSkpXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG91dHB1dEN0eCA9IGNyZWF0ZU91dHB1dENvbnRleHQoKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBpbGVSZXN1bHQgPSB0aGlzLl9uZ01vZHVsZUNvbXBpbGVyLmNvbXBpbGUob3V0cHV0Q3R4LCBtb2R1bGVNZXRhXzEsIGV4dHJhUHJvdmlkZXJzKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY29tcGlsZXJDb25maWcudXNlSml0KSB7XG4gICAgICAgICAgICAgICAgbmdNb2R1bGVGYWN0b3J5ID1cbiAgICAgICAgICAgICAgICAgICAgaW50ZXJwcmV0U3RhdGVtZW50cyhvdXRwdXRDdHguc3RhdGVtZW50cylbY29tcGlsZVJlc3VsdC5uZ01vZHVsZUZhY3RvcnlWYXJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmdNb2R1bGVGYWN0b3J5ID0gaml0U3RhdGVtZW50cyhuZ01vZHVsZUppdFVybChtb2R1bGVNZXRhXzEpLCBvdXRwdXRDdHguc3RhdGVtZW50cylbY29tcGlsZVJlc3VsdC5uZ01vZHVsZUZhY3RvcnlWYXJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY29tcGlsZWROZ01vZHVsZUNhY2hlLnNldChtb2R1bGVNZXRhXzEudHlwZS5yZWZlcmVuY2UsIG5nTW9kdWxlRmFjdG9yeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5nTW9kdWxlRmFjdG9yeTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFxcQGludGVybmFsXG4gICAgICogQHBhcmFtIHs/fSBtYWluTW9kdWxlXG4gICAgICogQHBhcmFtIHs/fSBhbGxDb21wb25lbnRGYWN0b3JpZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZUNvbXBvbmVudHMgPSBmdW5jdGlvbiAobWFpbk1vZHVsZSwgYWxsQ29tcG9uZW50RmFjdG9yaWVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nTW9kdWxlID0gKCh0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldE5nTW9kdWxlTWV0YWRhdGEobWFpbk1vZHVsZSkpKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbW9kdWxlQnlKaXREaXJlY3RpdmUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlbXBsYXRlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNKaXRNb2R1bGVzID0gdGhpcy5fZmlsdGVySml0SWRlbnRpZmllcnMobmdNb2R1bGUudHJhbnNpdGl2ZU1vZHVsZS5tb2R1bGVzKTtcbiAgICAgICAgdHJhbnNKaXRNb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKGxvY2FsTW9kKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsb2NhbE1vZHVsZU1ldGEgPSAoKF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldE5nTW9kdWxlTWV0YWRhdGEobG9jYWxNb2QpKSk7XG4gICAgICAgICAgICBfdGhpcy5fZmlsdGVySml0SWRlbnRpZmllcnMobG9jYWxNb2R1bGVNZXRhLmRlY2xhcmVkRGlyZWN0aXZlcykuZm9yRWFjaChmdW5jdGlvbiAoZGlyUmVmKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlQnlKaXREaXJlY3RpdmUuc2V0KGRpclJlZiwgbG9jYWxNb2R1bGVNZXRhKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXJNZXRhID0gX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0RGlyZWN0aXZlTWV0YWRhdGEoZGlyUmVmKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyTWV0YS5pc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZXMuYWRkKF90aGlzLl9jcmVhdGVDb21waWxlZFRlbXBsYXRlKGRpck1ldGEsIGxvY2FsTW9kdWxlTWV0YSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWxsQ29tcG9uZW50RmFjdG9yaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wbGF0ZSA9IF90aGlzLl9jcmVhdGVDb21waWxlZEhvc3RUZW1wbGF0ZShkaXJNZXRhLnR5cGUucmVmZXJlbmNlLCBsb2NhbE1vZHVsZU1ldGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVzLmFkZCh0ZW1wbGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxDb21wb25lbnRGYWN0b3JpZXMucHVzaCgvKiogQHR5cGUgez99ICovIChkaXJNZXRhLmNvbXBvbmVudEZhY3RvcnkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdHJhbnNKaXRNb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKGxvY2FsTW9kKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsb2NhbE1vZHVsZU1ldGEgPSAoKF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldE5nTW9kdWxlTWV0YWRhdGEobG9jYWxNb2QpKSk7XG4gICAgICAgICAgICBfdGhpcy5fZmlsdGVySml0SWRlbnRpZmllcnMobG9jYWxNb2R1bGVNZXRhLmRlY2xhcmVkRGlyZWN0aXZlcykuZm9yRWFjaChmdW5jdGlvbiAoZGlyUmVmKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlyTWV0YSA9IF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldERpcmVjdGl2ZU1ldGFkYXRhKGRpclJlZik7XG4gICAgICAgICAgICAgICAgaWYgKGRpck1ldGEuaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlyTWV0YS5lbnRyeUNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnlDb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtb2R1bGVNZXRhID0gKChtb2R1bGVCeUppdERpcmVjdGl2ZS5nZXQoZW50cnlDb21wb25lbnRUeXBlLmNvbXBvbmVudFR5cGUpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZXMuYWRkKF90aGlzLl9jcmVhdGVDb21waWxlZEhvc3RUZW1wbGF0ZShlbnRyeUNvbXBvbmVudFR5cGUuY29tcG9uZW50VHlwZSwgbW9kdWxlTWV0YSkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxvY2FsTW9kdWxlTWV0YS5lbnRyeUNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnlDb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5oYXNBb3RTdW1tYXJ5KGVudHJ5Q29tcG9uZW50VHlwZS5jb21wb25lbnRUeXBlLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbW9kdWxlTWV0YSA9ICgobW9kdWxlQnlKaXREaXJlY3RpdmUuZ2V0KGVudHJ5Q29tcG9uZW50VHlwZS5jb21wb25lbnRUeXBlKSkpO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZXMuYWRkKF90aGlzLl9jcmVhdGVDb21waWxlZEhvc3RUZW1wbGF0ZShlbnRyeUNvbXBvbmVudFR5cGUuY29tcG9uZW50VHlwZSwgbW9kdWxlTWV0YSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGVtcGxhdGVzLmZvckVhY2goZnVuY3Rpb24gKHRlbXBsYXRlKSB7IHJldHVybiBfdGhpcy5fY29tcGlsZVRlbXBsYXRlKHRlbXBsYXRlKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5jbGVhckNhY2hlRm9yID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdGhpcy5fY29tcGlsZWROZ01vZHVsZUNhY2hlLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5jbGVhckNhY2hlRm9yKHR5cGUpO1xuICAgICAgICB0aGlzLl9jb21waWxlZEhvc3RUZW1wbGF0ZUNhY2hlLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcGlsZWRUZW1wbGF0ZSA9IHRoaXMuX2NvbXBpbGVkVGVtcGxhdGVDYWNoZS5nZXQodHlwZSk7XG4gICAgICAgIGlmIChjb21waWxlZFRlbXBsYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9jb21waWxlZFRlbXBsYXRlQ2FjaGUuZGVsZXRlKHR5cGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmNsZWFyQ2FjaGUoKTtcbiAgICAgICAgdGhpcy5fY29tcGlsZWRUZW1wbGF0ZUNhY2hlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX2NvbXBpbGVkSG9zdFRlbXBsYXRlQ2FjaGUuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fY29tcGlsZWROZ01vZHVsZUNhY2hlLmNsZWFyKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbXBUeXBlXG4gICAgICogQHBhcmFtIHs/fSBuZ01vZHVsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSml0Q29tcGlsZXIucHJvdG90eXBlLl9jcmVhdGVDb21waWxlZEhvc3RUZW1wbGF0ZSA9IGZ1bmN0aW9uIChjb21wVHlwZSwgbmdNb2R1bGUpIHtcbiAgICAgICAgaWYgKCFuZ01vZHVsZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29tcG9uZW50IFwiICsgybVzdHJpbmdpZnkoY29tcFR5cGUpICsgXCIgaXMgbm90IHBhcnQgb2YgYW55IE5nTW9kdWxlIG9yIHRoZSBtb2R1bGUgaGFzIG5vdCBiZWVuIGltcG9ydGVkIGludG8geW91ciBtb2R1bGUuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBpbGVkVGVtcGxhdGUgPSB0aGlzLl9jb21waWxlZEhvc3RUZW1wbGF0ZUNhY2hlLmdldChjb21wVHlwZSk7XG4gICAgICAgIGlmICghY29tcGlsZWRUZW1wbGF0ZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcE1ldGEgPSB0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldERpcmVjdGl2ZU1ldGFkYXRhKGNvbXBUeXBlKTtcbiAgICAgICAgICAgIGFzc2VydENvbXBvbmVudChjb21wTWV0YSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wb25lbnRGYWN0b3J5ID0gKGNvbXBNZXRhLmNvbXBvbmVudEZhY3RvcnkpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaG9zdENsYXNzID0gdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXRIb3N0Q29tcG9uZW50VHlwZShjb21wVHlwZSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBob3N0TWV0YSA9IGNyZWF0ZUhvc3RDb21wb25lbnRNZXRhKGhvc3RDbGFzcywgY29tcE1ldGEsIC8qKiBAdHlwZSB7P30gKi8gKMm1Z2V0Q29tcG9uZW50Vmlld0RlZmluaXRpb25GYWN0b3J5KGNvbXBvbmVudEZhY3RvcnkpKSk7XG4gICAgICAgICAgICBjb21waWxlZFRlbXBsYXRlID1cbiAgICAgICAgICAgICAgICBuZXcgQ29tcGlsZWRUZW1wbGF0ZSh0cnVlLCBjb21wTWV0YS50eXBlLCBob3N0TWV0YSwgbmdNb2R1bGUsIFtjb21wTWV0YS50eXBlXSk7XG4gICAgICAgICAgICB0aGlzLl9jb21waWxlZEhvc3RUZW1wbGF0ZUNhY2hlLnNldChjb21wVHlwZSwgY29tcGlsZWRUZW1wbGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBpbGVkVGVtcGxhdGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbXBNZXRhXG4gICAgICogQHBhcmFtIHs/fSBuZ01vZHVsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSml0Q29tcGlsZXIucHJvdG90eXBlLl9jcmVhdGVDb21waWxlZFRlbXBsYXRlID0gZnVuY3Rpb24gKGNvbXBNZXRhLCBuZ01vZHVsZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21waWxlZFRlbXBsYXRlID0gdGhpcy5fY29tcGlsZWRUZW1wbGF0ZUNhY2hlLmdldChjb21wTWV0YS50eXBlLnJlZmVyZW5jZSk7XG4gICAgICAgIGlmICghY29tcGlsZWRUZW1wbGF0ZSkge1xuICAgICAgICAgICAgYXNzZXJ0Q29tcG9uZW50KGNvbXBNZXRhKTtcbiAgICAgICAgICAgIGNvbXBpbGVkVGVtcGxhdGUgPSBuZXcgQ29tcGlsZWRUZW1wbGF0ZShmYWxzZSwgY29tcE1ldGEudHlwZSwgY29tcE1ldGEsIG5nTW9kdWxlLCBuZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLmRpcmVjdGl2ZXMpO1xuICAgICAgICAgICAgdGhpcy5fY29tcGlsZWRUZW1wbGF0ZUNhY2hlLnNldChjb21wTWV0YS50eXBlLnJlZmVyZW5jZSwgY29tcGlsZWRUZW1wbGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBpbGVkVGVtcGxhdGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRlbXBsYXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVUZW1wbGF0ZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGVtcGxhdGUuaXNDb21waWxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBNZXRhID0gdGVtcGxhdGUuY29tcE1ldGE7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4dGVybmFsU3R5bGVzaGVldHNCeU1vZHVsZVVybCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3V0cHV0Q29udGV4dCA9IGNyZWF0ZU91dHB1dENvbnRleHQoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcG9uZW50U3R5bGVzaGVldCA9IHRoaXMuX3N0eWxlQ29tcGlsZXIuY29tcGlsZUNvbXBvbmVudChvdXRwdXRDb250ZXh0LCBjb21wTWV0YSk7IC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgKChjb21wTWV0YS50ZW1wbGF0ZSkpLmV4dGVybmFsU3R5bGVzaGVldHMuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGVzaGVldE1ldGEpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBpbGVkU3R5bGVzaGVldCA9IF90aGlzLl9zdHlsZUNvbXBpbGVyLmNvbXBpbGVTdHlsZXMoY3JlYXRlT3V0cHV0Q29udGV4dCgpLCBjb21wTWV0YSwgc3R5bGVzaGVldE1ldGEpO1xuICAgICAgICAgICAgZXh0ZXJuYWxTdHlsZXNoZWV0c0J5TW9kdWxlVXJsLnNldCgvKiogQHR5cGUgez99ICovICgoc3R5bGVzaGVldE1ldGEubW9kdWxlVXJsKSksIGNvbXBpbGVkU3R5bGVzaGVldCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9yZXNvbHZlU3R5bGVzQ29tcGlsZVJlc3VsdChjb21wb25lbnRTdHlsZXNoZWV0LCBleHRlcm5hbFN0eWxlc2hlZXRzQnlNb2R1bGVVcmwpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXJlY3RpdmVzID0gdGVtcGxhdGUuZGlyZWN0aXZlcy5tYXAoZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0RGlyZWN0aXZlU3VtbWFyeShkaXIucmVmZXJlbmNlKTsgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBpcGVzID0gdGVtcGxhdGUubmdNb2R1bGUudHJhbnNpdGl2ZU1vZHVsZS5waXBlcy5tYXAoZnVuY3Rpb24gKHBpcGUpIHsgcmV0dXJuIF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldFBpcGVTdW1tYXJ5KHBpcGUucmVmZXJlbmNlKTsgfSk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuX3RlbXBsYXRlUGFyc2VyLnBhcnNlKGNvbXBNZXRhLCAvKiogQHR5cGUgez99ICovICgoKChjb21wTWV0YS50ZW1wbGF0ZSkpLnRlbXBsYXRlKSksIGRpcmVjdGl2ZXMsIHBpcGVzLCB0ZW1wbGF0ZS5uZ01vZHVsZS5zY2hlbWFzLCB0ZW1wbGF0ZVNvdXJjZVVybCh0ZW1wbGF0ZS5uZ01vZHVsZS50eXBlLCB0ZW1wbGF0ZS5jb21wTWV0YSwgLyoqIEB0eXBlIHs/fSAqLyAoKHRlbXBsYXRlLmNvbXBNZXRhLnRlbXBsYXRlKSkpKSwgcGFyc2VkVGVtcGxhdGUgPSBfYS50ZW1wbGF0ZSwgdXNlZFBpcGVzID0gX2EucGlwZXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBpbGVSZXN1bHQgPSB0aGlzLl92aWV3Q29tcGlsZXIuY29tcGlsZUNvbXBvbmVudChvdXRwdXRDb250ZXh0LCBjb21wTWV0YSwgcGFyc2VkVGVtcGxhdGUsIHZhcmlhYmxlKGNvbXBvbmVudFN0eWxlc2hlZXQuc3R5bGVzVmFyKSwgdXNlZFBpcGVzKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXZhbFJlc3VsdDtcbiAgICAgICAgaWYgKCF0aGlzLl9jb21waWxlckNvbmZpZy51c2VKaXQpIHtcbiAgICAgICAgICAgIGV2YWxSZXN1bHQgPSBpbnRlcnByZXRTdGF0ZW1lbnRzKG91dHB1dENvbnRleHQuc3RhdGVtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBldmFsUmVzdWx0ID0gaml0U3RhdGVtZW50cyh0ZW1wbGF0ZUppdFVybCh0ZW1wbGF0ZS5uZ01vZHVsZS50eXBlLCB0ZW1wbGF0ZS5jb21wTWV0YSksIG91dHB1dENvbnRleHQuc3RhdGVtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlld0NsYXNzID0gZXZhbFJlc3VsdFtjb21waWxlUmVzdWx0LnZpZXdDbGFzc1Zhcl07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlbmRlcmVyVHlwZSA9IGV2YWxSZXN1bHRbY29tcGlsZVJlc3VsdC5yZW5kZXJlclR5cGVWYXJdO1xuICAgICAgICB0ZW1wbGF0ZS5jb21waWxlZCh2aWV3Q2xhc3MsIHJlbmRlcmVyVHlwZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlc3VsdFxuICAgICAqIEBwYXJhbSB7P30gZXh0ZXJuYWxTdHlsZXNoZWV0c0J5TW9kdWxlVXJsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUuX3Jlc29sdmVTdHlsZXNDb21waWxlUmVzdWx0ID0gZnVuY3Rpb24gKHJlc3VsdCwgZXh0ZXJuYWxTdHlsZXNoZWV0c0J5TW9kdWxlVXJsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJlc3VsdC5kZXBlbmRlbmNpZXMuZm9yRWFjaChmdW5jdGlvbiAoZGVwLCBpKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZXN0ZWRDb21waWxlUmVzdWx0ID0gKChleHRlcm5hbFN0eWxlc2hlZXRzQnlNb2R1bGVVcmwuZ2V0KGRlcC5tb2R1bGVVcmwpKSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZXN0ZWRTdHlsZXNBcnIgPSBfdGhpcy5fcmVzb2x2ZUFuZEV2YWxTdHlsZXNDb21waWxlUmVzdWx0KG5lc3RlZENvbXBpbGVSZXN1bHQsIGV4dGVybmFsU3R5bGVzaGVldHNCeU1vZHVsZVVybCk7XG4gICAgICAgICAgICBkZXAuc2V0VmFsdWUobmVzdGVkU3R5bGVzQXJyKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlc3VsdFxuICAgICAqIEBwYXJhbSB7P30gZXh0ZXJuYWxTdHlsZXNoZWV0c0J5TW9kdWxlVXJsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUuX3Jlc29sdmVBbmRFdmFsU3R5bGVzQ29tcGlsZVJlc3VsdCA9IGZ1bmN0aW9uIChyZXN1bHQsIGV4dGVybmFsU3R5bGVzaGVldHNCeU1vZHVsZVVybCkge1xuICAgICAgICB0aGlzLl9yZXNvbHZlU3R5bGVzQ29tcGlsZVJlc3VsdChyZXN1bHQsIGV4dGVybmFsU3R5bGVzaGVldHNCeU1vZHVsZVVybCk7XG4gICAgICAgIGlmICghdGhpcy5fY29tcGlsZXJDb25maWcudXNlSml0KSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJwcmV0U3RhdGVtZW50cyhyZXN1bHQub3V0cHV0Q3R4LnN0YXRlbWVudHMpW3Jlc3VsdC5zdHlsZXNWYXJdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGppdFN0YXRlbWVudHMoc2hhcmVkU3R5bGVzaGVldEppdFVybChyZXN1bHQubWV0YSwgdGhpcy5fc2hhcmVkU3R5bGVzaGVldENvdW50KyspLCByZXN1bHQub3V0cHV0Q3R4LnN0YXRlbWVudHMpW3Jlc3VsdC5zdHlsZXNWYXJdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gSml0Q29tcGlsZXI7XG59KCkpO1xuSml0Q29tcGlsZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBpbGVySW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuSml0Q29tcGlsZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBJbmplY3RvciwgfSxcbiAgICB7IHR5cGU6IENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLCB9LFxuICAgIHsgdHlwZTogVGVtcGxhdGVQYXJzZXIsIH0sXG4gICAgeyB0eXBlOiBTdHlsZUNvbXBpbGVyLCB9LFxuICAgIHsgdHlwZTogVmlld0NvbXBpbGVyLCB9LFxuICAgIHsgdHlwZTogTmdNb2R1bGVDb21waWxlciwgfSxcbiAgICB7IHR5cGU6IFN1bW1hcnlSZXNvbHZlciwgfSxcbiAgICB7IHR5cGU6IENvbXBpbGVyQ29uZmlnLCB9LFxuICAgIHsgdHlwZTogybVDb25zb2xlLCB9LFxuXTsgfTtcbnZhciBDb21waWxlZFRlbXBsYXRlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlzSG9zdFxuICAgICAqIEBwYXJhbSB7P30gY29tcFR5cGVcbiAgICAgKiBAcGFyYW0gez99IGNvbXBNZXRhXG4gICAgICogQHBhcmFtIHs/fSBuZ01vZHVsZVxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbXBpbGVkVGVtcGxhdGUoaXNIb3N0LCBjb21wVHlwZSwgY29tcE1ldGEsIG5nTW9kdWxlLCBkaXJlY3RpdmVzKSB7XG4gICAgICAgIHRoaXMuaXNIb3N0ID0gaXNIb3N0O1xuICAgICAgICB0aGlzLmNvbXBUeXBlID0gY29tcFR5cGU7XG4gICAgICAgIHRoaXMuY29tcE1ldGEgPSBjb21wTWV0YTtcbiAgICAgICAgdGhpcy5uZ01vZHVsZSA9IG5nTW9kdWxlO1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xuICAgICAgICB0aGlzLl92aWV3Q2xhc3MgPSAoKG51bGwpKTtcbiAgICAgICAgdGhpcy5pc0NvbXBpbGVkID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlld0NsYXNzXG4gICAgICogQHBhcmFtIHs/fSByZW5kZXJlclR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVkVGVtcGxhdGUucHJvdG90eXBlLmNvbXBpbGVkID0gZnVuY3Rpb24gKHZpZXdDbGFzcywgcmVuZGVyZXJUeXBlKSB7XG4gICAgICAgIHRoaXMuX3ZpZXdDbGFzcyA9IHZpZXdDbGFzcztcbiAgICAgICAgKCh0aGlzLmNvbXBNZXRhLmNvbXBvbmVudFZpZXdUeXBlKSkuc2V0RGVsZWdhdGUodmlld0NsYXNzKTtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9wIGluIHJlbmRlcmVyVHlwZSkge1xuICAgICAgICAgICAgKCh0aGlzLmNvbXBNZXRhLnJlbmRlcmVyVHlwZSkpW3Byb3BdID0gcmVuZGVyZXJUeXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNDb21waWxlZCA9IHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gQ29tcGlsZWRUZW1wbGF0ZTtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gbWV0YVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0Q29tcG9uZW50KG1ldGEpIHtcbiAgICBpZiAoIW1ldGEuaXNDb21wb25lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGNvbXBpbGUgJ1wiICsgaWRlbnRpZmllck5hbWUobWV0YS50eXBlKSArIFwiJyBiZWNhdXNlIGl0IGlzIG5vdCBhIGNvbXBvbmVudC5cIik7XG4gICAgfVxufVxuLyoqXG4gKiBJbXBsZW1lbnRzIGBDb21waWxlcmAgYnkgZGVsZWdhdGluZyB0byB0aGUgSml0Q29tcGlsZXIgdXNpbmcgYSBrbm93biBtb2R1bGUuXG4gKi9cbnZhciBNb2R1bGVCb3VuZENvbXBpbGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9kZWxlZ2F0ZVxuICAgICAqIEBwYXJhbSB7P30gX25nTW9kdWxlXG4gICAgICovXG4gICAgZnVuY3Rpb24gTW9kdWxlQm91bmRDb21waWxlcihfZGVsZWdhdGUsIF9uZ01vZHVsZSkge1xuICAgICAgICB0aGlzLl9kZWxlZ2F0ZSA9IF9kZWxlZ2F0ZTtcbiAgICAgICAgdGhpcy5fbmdNb2R1bGUgPSBfbmdNb2R1bGU7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVCb3VuZENvbXBpbGVyLnByb3RvdHlwZSwgXCJfaW5qZWN0b3JcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVsZWdhdGUuaW5qZWN0b3I7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICogQHBhcmFtIHs/fSBtb2R1bGVUeXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNb2R1bGVCb3VuZENvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlTW9kdWxlU3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5jb21waWxlTW9kdWxlU3luYyhtb2R1bGVUeXBlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICogQHBhcmFtIHs/fSBtb2R1bGVUeXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNb2R1bGVCb3VuZENvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlTW9kdWxlQXN5bmMgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUuY29tcGlsZU1vZHVsZUFzeW5jKG1vZHVsZVR5cGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0gez99IG1vZHVsZVR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1vZHVsZUJvdW5kQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVNb2R1bGVBbmRBbGxDb21wb25lbnRzU3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5jb21waWxlTW9kdWxlQW5kQWxsQ29tcG9uZW50c1N5bmMobW9kdWxlVHlwZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAdGVtcGxhdGUgVFxuICAgICAqIEBwYXJhbSB7P30gbW9kdWxlVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTW9kdWxlQm91bmRDb21waWxlci5wcm90b3R5cGUuY29tcGlsZU1vZHVsZUFuZEFsbENvbXBvbmVudHNBc3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5jb21waWxlTW9kdWxlQW5kQWxsQ29tcG9uZW50c0FzeW5jKG1vZHVsZVR5cGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb21wb25lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1vZHVsZUJvdW5kQ29tcGlsZXIucHJvdG90eXBlLmdldE5nQ29udGVudFNlbGVjdG9ycyA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmdldE5nQ29udGVudFNlbGVjdG9ycyhjb21wb25lbnQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGFsbCBjYWNoZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1vZHVsZUJvdW5kQ29tcGlsZXIucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2RlbGVnYXRlLmNsZWFyQ2FjaGUoKTsgfTtcbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGNhY2hlIGZvciB0aGUgZ2l2ZW4gY29tcG9uZW50L25nTW9kdWxlLlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTW9kdWxlQm91bmRDb21waWxlci5wcm90b3R5cGUuY2xlYXJDYWNoZUZvciA9IGZ1bmN0aW9uICh0eXBlKSB7IHRoaXMuX2RlbGVnYXRlLmNsZWFyQ2FjaGVGb3IodHlwZSk7IH07XG4gICAgcmV0dXJuIE1vZHVsZUJvdW5kQ29tcGlsZXI7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IGZuXG4gKiBAcGFyYW0gez89fSBvdXRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5TdW1tYXJpZXMoZm4kJDEsIG91dCkge1xuICAgIGlmIChvdXQgPT09IHZvaWQgMCkgeyBvdXQgPSBbXTsgfVxuICAgIGZuJCQxKCkuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZmxhdHRlblN1bW1hcmllcyhlbnRyeSwgb3V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG91dC5wdXNoKGVudHJ5KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU91dHB1dENvbnRleHQoKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW1wb3J0RXhwciQkMSA9IGZ1bmN0aW9uIChzeW1ib2wpIHsgcmV0dXJuIGltcG9ydEV4cHIoeyBuYW1lOiBpZGVudGlmaWVyTmFtZShzeW1ib2wpLCBtb2R1bGVOYW1lOiBudWxsLCBydW50aW1lOiBzeW1ib2wgfSk7IH07XG4gICAgcmV0dXJuIHsgc3RhdGVtZW50czogW10sIGdlbkZpbGVQYXRoOiAnJywgaW1wb3J0RXhwcjogaW1wb3J0RXhwciQkMSB9O1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBBIGNvbnRhaW5lciBmb3IgbWVzc2FnZSBleHRyYWN0ZWQgZnJvbSB0aGUgdGVtcGxhdGVzLlxuICovXG52YXIgTWVzc2FnZUJ1bmRsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfaHRtbFBhcnNlclxuICAgICAqIEBwYXJhbSB7P30gX2ltcGxpY2l0VGFnc1xuICAgICAqIEBwYXJhbSB7P30gX2ltcGxpY2l0QXR0cnNcbiAgICAgKiBAcGFyYW0gez89fSBfbG9jYWxlXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWVzc2FnZUJ1bmRsZShfaHRtbFBhcnNlciwgX2ltcGxpY2l0VGFncywgX2ltcGxpY2l0QXR0cnMsIF9sb2NhbGUpIHtcbiAgICAgICAgaWYgKF9sb2NhbGUgPT09IHZvaWQgMCkgeyBfbG9jYWxlID0gbnVsbDsgfVxuICAgICAgICB0aGlzLl9odG1sUGFyc2VyID0gX2h0bWxQYXJzZXI7XG4gICAgICAgIHRoaXMuX2ltcGxpY2l0VGFncyA9IF9pbXBsaWNpdFRhZ3M7XG4gICAgICAgIHRoaXMuX2ltcGxpY2l0QXR0cnMgPSBfaW1wbGljaXRBdHRycztcbiAgICAgICAgdGhpcy5fbG9jYWxlID0gX2xvY2FsZTtcbiAgICAgICAgdGhpcy5fbWVzc2FnZXMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBodG1sXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcGFyYW0gez99IGludGVycG9sYXRpb25Db25maWdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1lc3NhZ2VCdW5kbGUucHJvdG90eXBlLnVwZGF0ZUZyb21UZW1wbGF0ZSA9IGZ1bmN0aW9uIChodG1sLCB1cmwsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaHRtbFBhcnNlclJlc3VsdCA9IHRoaXMuX2h0bWxQYXJzZXIucGFyc2UoaHRtbCwgdXJsLCB0cnVlLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgaWYgKGh0bWxQYXJzZXJSZXN1bHQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGh0bWxQYXJzZXJSZXN1bHQuZXJyb3JzO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGkxOG5QYXJzZXJSZXN1bHQgPSBleHRyYWN0TWVzc2FnZXMoaHRtbFBhcnNlclJlc3VsdC5yb290Tm9kZXMsIGludGVycG9sYXRpb25Db25maWcsIHRoaXMuX2ltcGxpY2l0VGFncywgdGhpcy5faW1wbGljaXRBdHRycyk7XG4gICAgICAgIGlmIChpMThuUGFyc2VyUmVzdWx0LmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBpMThuUGFyc2VyUmVzdWx0LmVycm9ycztcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSB0aGlzLl9tZXNzYWdlcykucHVzaC5hcHBseShfYSwgaTE4blBhcnNlclJlc3VsdC5tZXNzYWdlcyk7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgdmFyIF9hO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZXNzYWdlQnVuZGxlLnByb3RvdHlwZS5nZXRNZXNzYWdlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21lc3NhZ2VzOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc2VyaWFsaXplclxuICAgICAqIEBwYXJhbSB7Pz19IGZpbHRlclNvdXJjZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1lc3NhZ2VCdW5kbGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHNlcmlhbGl6ZXIsIGZpbHRlclNvdXJjZXMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWVzc2FnZXMgPSB7fTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWFwcGVyVmlzaXRvciA9IG5ldyBNYXBQbGFjZWhvbGRlck5hbWVzKCk7XG4gICAgICAgIC8vIERlZHVwbGljYXRlIG1lc3NhZ2VzIGJhc2VkIG9uIHRoZWlyIElEXG4gICAgICAgIHRoaXMuX21lc3NhZ2VzLmZvckVhY2goZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlkID0gc2VyaWFsaXplci5kaWdlc3QobWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAoIW1lc3NhZ2VzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VzW2lkXSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAoX2EgPSBtZXNzYWdlc1tpZF0uc291cmNlcykucHVzaC5hcHBseShfYSwgbWVzc2FnZS5zb3VyY2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRyYW5zZm9ybSBwbGFjZWhvbGRlciBuYW1lcyB1c2luZyB0aGUgc2VyaWFsaXplciBtYXBwaW5nXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1zZ0xpc3QgPSBPYmplY3Qua2V5cyhtZXNzYWdlcykubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWFwcGVyID0gc2VyaWFsaXplci5jcmVhdGVOYW1lTWFwcGVyKG1lc3NhZ2VzW2lkXSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzcmMgPSBtZXNzYWdlc1tpZF07XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlcyA9IG1hcHBlciA/IG1hcHBlclZpc2l0b3IuY29udmVydChzcmMubm9kZXMsIG1hcHBlcikgOiBzcmMubm9kZXM7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc2Zvcm1lZE1lc3NhZ2UgPSBuZXcgTWVzc2FnZShub2Rlcywge30sIHt9LCBzcmMubWVhbmluZywgc3JjLmRlc2NyaXB0aW9uLCBpZCk7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZE1lc3NhZ2Uuc291cmNlcyA9IHNyYy5zb3VyY2VzO1xuICAgICAgICAgICAgaWYgKGZpbHRlclNvdXJjZXMpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZE1lc3NhZ2Uuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5maWxlUGF0aCA9IGZpbHRlclNvdXJjZXMoc291cmNlLmZpbGVQYXRoKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRNZXNzYWdlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZXIud3JpdGUobXNnTGlzdCwgdGhpcy5fbG9jYWxlKTtcbiAgICB9O1xuICAgIHJldHVybiBNZXNzYWdlQnVuZGxlO1xufSgpKTtcbnZhciBNYXBQbGFjZWhvbGRlck5hbWVzID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhNYXBQbGFjZWhvbGRlck5hbWVzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1hcFBsYWNlaG9sZGVyTmFtZXMoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2Rlc1xuICAgICAqIEBwYXJhbSB7P30gbWFwcGVyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNYXBQbGFjZWhvbGRlck5hbWVzLnByb3RvdHlwZS5jb252ZXJ0ID0gZnVuY3Rpb24gKG5vZGVzLCBtYXBwZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG1hcHBlciA/IG5vZGVzLm1hcChmdW5jdGlvbiAobikgeyByZXR1cm4gbi52aXNpdChfdGhpcywgbWFwcGVyKTsgfSkgOiBub2RlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGhcbiAgICAgKiBAcGFyYW0gez99IG1hcHBlclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWFwUGxhY2Vob2xkZXJOYW1lcy5wcm90b3R5cGUudmlzaXRUYWdQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgbWFwcGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0TmFtZSA9ICgobWFwcGVyLnRvUHVibGljTmFtZShwaC5zdGFydE5hbWUpKSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsb3NlTmFtZSA9IHBoLmNsb3NlTmFtZSA/ICgobWFwcGVyLnRvUHVibGljTmFtZShwaC5jbG9zZU5hbWUpKSkgOiBwaC5jbG9zZU5hbWU7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNoaWxkcmVuID0gcGguY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLnZpc2l0KF90aGlzLCBtYXBwZXIpOyB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBUYWdQbGFjZWhvbGRlcihwaC50YWcsIHBoLmF0dHJzLCBzdGFydE5hbWUsIGNsb3NlTmFtZSwgY2hpbGRyZW4sIHBoLmlzVm9pZCwgcGguc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBoXG4gICAgICogQHBhcmFtIHs/fSBtYXBwZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1hcFBsYWNlaG9sZGVyTmFtZXMucHJvdG90eXBlLnZpc2l0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIG1hcHBlcikge1xuICAgICAgICByZXR1cm4gbmV3IFBsYWNlaG9sZGVyKHBoLnZhbHVlLCAvKiogQHR5cGUgez99ICovICgobWFwcGVyLnRvUHVibGljTmFtZShwaC5uYW1lKSkpLCBwaC5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGhcbiAgICAgKiBAcGFyYW0gez99IG1hcHBlclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWFwUGxhY2Vob2xkZXJOYW1lcy5wcm90b3R5cGUudmlzaXRJY3VQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgbWFwcGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSWN1UGxhY2Vob2xkZXIocGgudmFsdWUsIC8qKiBAdHlwZSB7P30gKi8gKChtYXBwZXIudG9QdWJsaWNOYW1lKHBoLm5hbWUpKSksIHBoLnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgcmV0dXJuIE1hcFBsYWNlaG9sZGVyTmFtZXM7XG59KENsb25lVmlzaXRvcikpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBFeHRyYWN0IGkxOG4gbWVzc2FnZXMgZnJvbSBzb3VyY2UgY29kZVxuICovXG52YXIgRXh0cmFjdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGhvc3RcbiAgICAgKiBAcGFyYW0gez99IHN0YXRpY1N5bWJvbFJlc29sdmVyXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlQnVuZGxlXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVJlc29sdmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gRXh0cmFjdG9yKGhvc3QsIHN0YXRpY1N5bWJvbFJlc29sdmVyLCBtZXNzYWdlQnVuZGxlLCBtZXRhZGF0YVJlc29sdmVyKSB7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIHRoaXMuc3RhdGljU3ltYm9sUmVzb2x2ZXIgPSBzdGF0aWNTeW1ib2xSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5tZXNzYWdlQnVuZGxlID0gbWVzc2FnZUJ1bmRsZTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YVJlc29sdmVyID0gbWV0YWRhdGFSZXNvbHZlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByb290RmlsZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4dHJhY3Rvci5wcm90b3R5cGUuZXh0cmFjdCA9IGZ1bmN0aW9uIChyb290RmlsZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvZ3JhbVN5bWJvbHMgPSBleHRyYWN0UHJvZ3JhbVN5bWJvbHModGhpcy5zdGF0aWNTeW1ib2xSZXNvbHZlciwgcm9vdEZpbGVzLCB0aGlzLmhvc3QpO1xuICAgICAgICB2YXIgX2EgPSBhbmFseXplQW5kVmFsaWRhdGVOZ01vZHVsZXMocHJvZ3JhbVN5bWJvbHMsIHRoaXMuaG9zdCwgdGhpcy5tZXRhZGF0YVJlc29sdmVyKSwgZmlsZXMgPSBfYS5maWxlcywgbmdNb2R1bGVzID0gX2EubmdNb2R1bGVzO1xuICAgICAgICByZXR1cm4gUHJvbWlzZVxuICAgICAgICAgICAgLmFsbChuZ01vZHVsZXMubWFwKGZ1bmN0aW9uIChuZ01vZHVsZSkgeyByZXR1cm4gX3RoaXMubWV0YWRhdGFSZXNvbHZlci5sb2FkTmdNb2R1bGVEaXJlY3RpdmVBbmRQaXBlTWV0YWRhdGEobmdNb2R1bGUudHlwZS5yZWZlcmVuY2UsIGZhbHNlKTsgfSkpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIGZpbGVzLmZvckVhY2goZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wTWV0YXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmaWxlLmRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXJNZXRhID0gX3RoaXMubWV0YWRhdGFSZXNvbHZlci5nZXREaXJlY3RpdmVNZXRhZGF0YShkaXJlY3RpdmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpck1ldGEgJiYgZGlyTWV0YS5pc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcE1ldGFzLnB1c2goZGlyTWV0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb21wTWV0YXMuZm9yRWFjaChmdW5jdGlvbiAoY29tcE1ldGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaHRtbCA9ICgoKChjb21wTWV0YS50ZW1wbGF0ZSkpLnRlbXBsYXRlKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGludGVycG9sYXRpb25Db25maWcgPSBJbnRlcnBvbGF0aW9uQ29uZmlnLmZyb21BcnJheSgvKiogQHR5cGUgez99ICovICgoY29tcE1ldGEudGVtcGxhdGUpKS5pbnRlcnBvbGF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCAoKF90aGlzLm1lc3NhZ2VCdW5kbGUudXBkYXRlRnJvbVRlbXBsYXRlKGh0bWwsIGZpbGUuc3JjVXJsLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSkpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS50b1N0cmluZygpOyB9KS5qb2luKCdcXG4nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMubWVzc2FnZUJ1bmRsZTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGhvc3RcbiAgICAgKiBAcGFyYW0gez99IGxvY2FsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXh0cmFjdG9yLmNyZWF0ZSA9IGZ1bmN0aW9uIChob3N0LCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaHRtbFBhcnNlciA9IG5ldyBIdG1sUGFyc2VyKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVybFJlc29sdmVyID0gY3JlYXRlT2ZmbGluZUNvbXBpbGVVcmxSZXNvbHZlcigpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzeW1ib2xDYWNoZSA9IG5ldyBTdGF0aWNTeW1ib2xDYWNoZSgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdW1tYXJ5UmVzb2x2ZXIgPSBuZXcgQW90U3VtbWFyeVJlc29sdmVyKGhvc3QsIHN5bWJvbENhY2hlKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhdGljU3ltYm9sUmVzb2x2ZXIgPSBuZXcgU3RhdGljU3ltYm9sUmVzb2x2ZXIoaG9zdCwgc3ltYm9sQ2FjaGUsIHN1bW1hcnlSZXNvbHZlcik7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXRpY1JlZmxlY3RvciA9IG5ldyBTdGF0aWNSZWZsZWN0b3Ioc3VtbWFyeVJlc29sdmVyLCBzdGF0aWNTeW1ib2xSZXNvbHZlcik7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbmZpZyA9IG5ldyBDb21waWxlckNvbmZpZyh7IGRlZmF1bHRFbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZCwgdXNlSml0OiBmYWxzZSB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9ybWFsaXplciA9IG5ldyBEaXJlY3RpdmVOb3JtYWxpemVyKHsgZ2V0OiBmdW5jdGlvbiAodXJsKSB7IHJldHVybiBob3N0LmxvYWRSZXNvdXJjZSh1cmwpOyB9IH0sIHVybFJlc29sdmVyLCBodG1sUGFyc2VyLCBjb25maWcpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50U2NoZW1hUmVnaXN0cnkgPSBuZXcgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc29sdmVyID0gbmV3IENvbXBpbGVNZXRhZGF0YVJlc29sdmVyKGNvbmZpZywgbmV3IE5nTW9kdWxlUmVzb2x2ZXIoc3RhdGljUmVmbGVjdG9yKSwgbmV3IERpcmVjdGl2ZVJlc29sdmVyKHN0YXRpY1JlZmxlY3RvciksIG5ldyBQaXBlUmVzb2x2ZXIoc3RhdGljUmVmbGVjdG9yKSwgc3VtbWFyeVJlc29sdmVyLCBlbGVtZW50U2NoZW1hUmVnaXN0cnksIG5vcm1hbGl6ZXIsIG5ldyDJtUNvbnNvbGUoKSwgc3ltYm9sQ2FjaGUsIHN0YXRpY1JlZmxlY3Rvcik7XG4gICAgICAgIC8vIFRPRE8odmljYik6IGltcGxpY2l0IHRhZ3MgJiBhdHRyaWJ1dGVzXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lc3NhZ2VCdW5kbGUgPSBuZXcgTWVzc2FnZUJ1bmRsZShodG1sUGFyc2VyLCBbXSwge30sIGxvY2FsZSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4dHJhY3RvciA9IG5ldyBFeHRyYWN0b3IoaG9zdCwgc3RhdGljU3ltYm9sUmVzb2x2ZXIsIG1lc3NhZ2VCdW5kbGUsIHJlc29sdmVyKTtcbiAgICAgICAgcmV0dXJuIHsgZXh0cmFjdG9yOiBleHRyYWN0b3IsIHN0YXRpY1JlZmxlY3Rvcjogc3RhdGljUmVmbGVjdG9yIH07XG4gICAgfTtcbiAgICByZXR1cm4gRXh0cmFjdG9yO1xufSgpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBKaXRSZWZsZWN0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEppdFJlZmxlY3RvcigpIHtcbiAgICAgICAgdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzID0gbmV3IMm1UmVmbGVjdGlvbkNhcGFiaWxpdGllcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez99IGNtcE1ldGFkYXRhXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRSZWZsZWN0b3IucHJvdG90eXBlLmNvbXBvbmVudE1vZHVsZVVybCA9IGZ1bmN0aW9uICh0eXBlLCBjbXBNZXRhZGF0YSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtb2R1bGVJZCA9IGNtcE1ldGFkYXRhLm1vZHVsZUlkO1xuICAgICAgICBpZiAodHlwZW9mIG1vZHVsZUlkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2NoZW1lID0gZ2V0VXJsU2NoZW1lKG1vZHVsZUlkKTtcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWUgPyBtb2R1bGVJZCA6IFwicGFja2FnZTpcIiArIG1vZHVsZUlkICsgTU9EVUxFX1NVRkZJWDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtb2R1bGVJZCAhPT0gbnVsbCAmJiBtb2R1bGVJZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBzeW50YXhFcnJvcihcIm1vZHVsZUlkIHNob3VsZCBiZSBhIHN0cmluZyBpbiBcXFwiXCIgKyDJtXN0cmluZ2lmeSh0eXBlKSArIFwiXFxcIi4gU2VlIGh0dHBzOi8vZ29vLmdsL3dJRERpTCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cXG5cIiArXG4gICAgICAgICAgICAgICAgXCJJZiB5b3UncmUgdXNpbmcgV2VicGFjayB5b3Ugc2hvdWxkIGlubGluZSB0aGUgdGVtcGxhdGUgYW5kIHRoZSBzdHlsZXMsIHNlZSBodHRwczovL2dvby5nbC9YMko4emMuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIi4vXCIgKyDJtXN0cmluZ2lmeSh0eXBlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZU9yRnVuY1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSml0UmVmbGVjdG9yLnByb3RvdHlwZS5wYXJhbWV0ZXJzID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wYXJhbWV0ZXJzKHR5cGVPckZ1bmMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlT3JGdW5jXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRSZWZsZWN0b3IucHJvdG90eXBlLmFubm90YXRpb25zID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmbGVjdGlvbkNhcGFiaWxpdGllcy5hbm5vdGF0aW9ucyh0eXBlT3JGdW5jKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZU9yRnVuY1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSml0UmVmbGVjdG9yLnByb3RvdHlwZS5wcm9wTWV0YWRhdGEgPSBmdW5jdGlvbiAodHlwZU9yRnVuYykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3BNZXRhZGF0YSh0eXBlT3JGdW5jKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7P30gbGNQcm9wZXJ0eVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSml0UmVmbGVjdG9yLnByb3RvdHlwZS5oYXNMaWZlY3ljbGVIb29rID0gZnVuY3Rpb24gKHR5cGUsIGxjUHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmbGVjdGlvbkNhcGFiaWxpdGllcy5oYXNMaWZlY3ljbGVIb29rKHR5cGUsIGxjUHJvcGVydHkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByZWZcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEppdFJlZmxlY3Rvci5wcm90b3R5cGUucmVzb2x2ZUV4dGVybmFsUmVmZXJlbmNlID0gZnVuY3Rpb24gKHJlZikgeyByZXR1cm4gcmVmLnJ1bnRpbWU7IH07XG4gICAgcmV0dXJuIEppdFJlZmxlY3Rvcjtcbn0oKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgX05PX1JFU09VUkNFX0xPQURFUiA9IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIFJlc291cmNlTG9hZGVyIGltcGxlbWVudGF0aW9uIGhhcyBiZWVuIHByb3ZpZGVkLiBDYW4ndCByZWFkIHRoZSB1cmwgXFxcIlwiICsgdXJsICsgXCJcXFwiXCIpO1xuICAgIH1cbn07XG52YXIgYmFzZUh0bWxQYXJzZXIgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ0h0bWxQYXJzZXInKTtcbi8qKlxuICogQSBzZXQgb2YgcHJvdmlkZXJzIHRoYXQgcHJvdmlkZSBgSml0Q29tcGlsZXJgIGFuZCBpdHMgZGVwZW5kZW5jaWVzIHRvIHVzZSBmb3JcbiAqIHRlbXBsYXRlIGNvbXBpbGF0aW9uLlxuICovXG52YXIgQ09NUElMRVJfUFJPVklERVJTID0gW1xuICAgIHsgcHJvdmlkZTogQ29tcGlsZVJlZmxlY3RvciwgdXNlVmFsdWU6IG5ldyBKaXRSZWZsZWN0b3IoKSB9LFxuICAgIHsgcHJvdmlkZTogUmVzb3VyY2VMb2FkZXIsIHVzZVZhbHVlOiBfTk9fUkVTT1VSQ0VfTE9BREVSIH0sXG4gICAgSml0U3VtbWFyeVJlc29sdmVyLFxuICAgIHsgcHJvdmlkZTogU3VtbWFyeVJlc29sdmVyLCB1c2VFeGlzdGluZzogSml0U3VtbWFyeVJlc29sdmVyIH0sXG4gICAgybVDb25zb2xlLFxuICAgIExleGVyLFxuICAgIFBhcnNlcixcbiAgICB7XG4gICAgICAgIHByb3ZpZGU6IGJhc2VIdG1sUGFyc2VyLFxuICAgICAgICB1c2VDbGFzczogSHRtbFBhcnNlcixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgcHJvdmlkZTogSTE4Tkh0bWxQYXJzZXIsXG4gICAgICAgIHVzZUZhY3Rvcnk6IGZ1bmN0aW9uIChwYXJzZXIsIHRyYW5zbGF0aW9ucywgZm9ybWF0LCBjb25maWcsIGNvbnNvbGUpIHtcbiAgICAgICAgICAgIHRyYW5zbGF0aW9ucyA9IHRyYW5zbGF0aW9ucyB8fCAnJztcbiAgICAgICAgICAgIHZhciBtaXNzaW5nVHJhbnNsYXRpb24gPSB0cmFuc2xhdGlvbnMgPyBjb25maWcubWlzc2luZ1RyYW5zbGF0aW9uIDogTWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kuSWdub3JlO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJMThOSHRtbFBhcnNlcihwYXJzZXIsIHRyYW5zbGF0aW9ucywgZm9ybWF0LCBtaXNzaW5nVHJhbnNsYXRpb24sIGNvbnNvbGUpO1xuICAgICAgICB9LFxuICAgICAgICBkZXBzOiBbXG4gICAgICAgICAgICBiYXNlSHRtbFBhcnNlcixcbiAgICAgICAgICAgIFtuZXcgT3B0aW9uYWwoKSwgbmV3IEluamVjdChUUkFOU0xBVElPTlMpXSxcbiAgICAgICAgICAgIFtuZXcgT3B0aW9uYWwoKSwgbmV3IEluamVjdChUUkFOU0xBVElPTlNfRk9STUFUKV0sXG4gICAgICAgICAgICBbQ29tcGlsZXJDb25maWddLFxuICAgICAgICAgICAgW8m1Q29uc29sZV0sXG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgcHJvdmlkZTogSHRtbFBhcnNlcixcbiAgICAgICAgdXNlRXhpc3Rpbmc6IEkxOE5IdG1sUGFyc2VyLFxuICAgIH0sXG4gICAgVGVtcGxhdGVQYXJzZXIsXG4gICAgRGlyZWN0aXZlTm9ybWFsaXplcixcbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlcixcbiAgICBERUZBVUxUX1BBQ0tBR0VfVVJMX1BST1ZJREVSLFxuICAgIFN0eWxlQ29tcGlsZXIsXG4gICAgVmlld0NvbXBpbGVyLFxuICAgIE5nTW9kdWxlQ29tcGlsZXIsXG4gICAgeyBwcm92aWRlOiBDb21waWxlckNvbmZpZywgdXNlVmFsdWU6IG5ldyBDb21waWxlckNvbmZpZygpIH0sXG4gICAgSml0Q29tcGlsZXIsXG4gICAgeyBwcm92aWRlOiBDb21waWxlciwgdXNlRXhpc3Rpbmc6IEppdENvbXBpbGVyIH0sXG4gICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LFxuICAgIHsgcHJvdmlkZTogRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LCB1c2VFeGlzdGluZzogRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5IH0sXG4gICAgVXJsUmVzb2x2ZXIsXG4gICAgRGlyZWN0aXZlUmVzb2x2ZXIsXG4gICAgUGlwZVJlc29sdmVyLFxuICAgIE5nTW9kdWxlUmVzb2x2ZXIsXG5dO1xudmFyIEppdENvbXBpbGVyRmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkZWZhdWx0T3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEppdENvbXBpbGVyRmFjdG9yeShkZWZhdWx0T3B0aW9ucykge1xuICAgICAgICB2YXIgY29tcGlsZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgdXNlRGVidWc6IGlzRGV2TW9kZSgpLFxuICAgICAgICAgICAgdXNlSml0OiB0cnVlLFxuICAgICAgICAgICAgZGVmYXVsdEVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLkVtdWxhdGVkLFxuICAgICAgICAgICAgbWlzc2luZ1RyYW5zbGF0aW9uOiBNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneS5XYXJuaW5nLFxuICAgICAgICAgICAgZW5hYmxlTGVnYWN5VGVtcGxhdGU6IHRydWUsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2RlZmF1bHRPcHRpb25zID0gW2NvbXBpbGVyT3B0aW9uc10uY29uY2F0KGRlZmF1bHRPcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSml0Q29tcGlsZXJGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVDb21waWxlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IFtdOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9wdHMgPSBfbWVyZ2VPcHRpb25zKHRoaXMuX2RlZmF1bHRPcHRpb25zLmNvbmNhdChvcHRpb25zKSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluamVjdG9yID0gUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW1xuICAgICAgICAgICAgQ09NUElMRVJfUFJPVklERVJTLCB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogQ29tcGlsZXJDb25maWcsXG4gICAgICAgICAgICAgICAgdXNlRmFjdG9yeTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVyQ29uZmlnKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxldCBleHBsaWNpdCB2YWx1ZXMgZnJvbSB0aGUgY29tcGlsZXIgb3B0aW9ucyBvdmVyd3JpdGUgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnJvbSB0aGUgYXBwIHByb3ZpZGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlSml0OiBvcHRzLnVzZUppdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxldCBleHBsaWNpdCB2YWx1ZXMgZnJvbSB0aGUgY29tcGlsZXIgb3B0aW9ucyBvdmVyd3JpdGUgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnJvbSB0aGUgYXBwIHByb3ZpZGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdEVuY2Fwc3VsYXRpb246IG9wdHMuZGVmYXVsdEVuY2Fwc3VsYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBtaXNzaW5nVHJhbnNsYXRpb246IG9wdHMubWlzc2luZ1RyYW5zbGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlTGVnYWN5VGVtcGxhdGU6IG9wdHMuZW5hYmxlTGVnYWN5VGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVwczogW11cbiAgICAgICAgICAgIH0sIC8qKiBAdHlwZSB7P30gKi8gKChvcHRzLnByb3ZpZGVycykpXG4gICAgICAgIF0pO1xuICAgICAgICByZXR1cm4gaW5qZWN0b3IuZ2V0KENvbXBpbGVyKTtcbiAgICB9O1xuICAgIHJldHVybiBKaXRDb21waWxlckZhY3Rvcnk7XG59KCkpO1xuSml0Q29tcGlsZXJGYWN0b3J5LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21waWxlckluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkppdENvbXBpbGVyRmFjdG9yeS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtDT01QSUxFUl9PUFRJT05TLF0gfSxdIH0sXG5dOyB9O1xuLyoqXG4gKiBBIHBsYXRmb3JtIHRoYXQgaW5jbHVkZWQgY29yZVBsYXRmb3JtIGFuZCB0aGUgY29tcGlsZXIuXG4gKlxuICogXFxAZXhwZXJpbWVudGFsXG4gKi9cbnZhciBwbGF0Zm9ybUNvcmVEeW5hbWljID0gY3JlYXRlUGxhdGZvcm1GYWN0b3J5KHBsYXRmb3JtQ29yZSwgJ2NvcmVEeW5hbWljJywgW1xuICAgIHsgcHJvdmlkZTogQ09NUElMRVJfT1BUSU9OUywgdXNlVmFsdWU6IHt9LCBtdWx0aTogdHJ1ZSB9LFxuICAgIHsgcHJvdmlkZTogQ29tcGlsZXJGYWN0b3J5LCB1c2VDbGFzczogSml0Q29tcGlsZXJGYWN0b3J5IH0sXG5dKTtcbi8qKlxuICogQHBhcmFtIHs/fSBvcHRpb25zQXJyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfbWVyZ2VPcHRpb25zKG9wdGlvbnNBcnIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VKaXQ6IF9sYXN0RGVmaW5lZChvcHRpb25zQXJyLm1hcChmdW5jdGlvbiAob3B0aW9ucykgeyByZXR1cm4gb3B0aW9ucy51c2VKaXQ7IH0pKSxcbiAgICAgICAgZGVmYXVsdEVuY2Fwc3VsYXRpb246IF9sYXN0RGVmaW5lZChvcHRpb25zQXJyLm1hcChmdW5jdGlvbiAob3B0aW9ucykgeyByZXR1cm4gb3B0aW9ucy5kZWZhdWx0RW5jYXBzdWxhdGlvbjsgfSkpLFxuICAgICAgICBwcm92aWRlcnM6IF9tZXJnZUFycmF5cyhvcHRpb25zQXJyLm1hcChmdW5jdGlvbiAob3B0aW9ucykgeyByZXR1cm4gKChvcHRpb25zLnByb3ZpZGVycykpOyB9KSksXG4gICAgICAgIG1pc3NpbmdUcmFuc2xhdGlvbjogX2xhc3REZWZpbmVkKG9wdGlvbnNBcnIubWFwKGZ1bmN0aW9uIChvcHRpb25zKSB7IHJldHVybiBvcHRpb25zLm1pc3NpbmdUcmFuc2xhdGlvbjsgfSkpLFxuICAgICAgICBlbmFibGVMZWdhY3lUZW1wbGF0ZTogX2xhc3REZWZpbmVkKG9wdGlvbnNBcnIubWFwKGZ1bmN0aW9uIChvcHRpb25zKSB7IHJldHVybiBvcHRpb25zLmVuYWJsZUxlZ2FjeVRlbXBsYXRlOyB9KSksXG4gICAgfTtcbn1cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7P30gYXJnc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2xhc3REZWZpbmVkKGFyZ3MpIHtcbiAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSBhcmdzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmIChhcmdzW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmdzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gcGFydHNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9tZXJnZUFycmF5cyhwYXJ0cykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IFtdO1xuICAgIHBhcnRzLmZvckVhY2goZnVuY3Rpb24gKHBhcnQpIHsgcmV0dXJuIHBhcnQgJiYgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBwYXJ0KTsgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQG1vZHVsZVxuICogQGRlc2NyaXB0aW9uXG4gKiBFbnRyeSBwb2ludCBmb3IgYWxsIEFQSXMgb2YgdGhlIGNvbXBpbGVyIHBhY2thZ2UuXG4gKlxuICogPGRpdiBjbGFzcz1cImNhbGxvdXQgaXMtY3JpdGljYWxcIj5cbiAqICAgPGhlYWRlcj5VbnN0YWJsZSBBUElzPC9oZWFkZXI+XG4gKiAgIDxwPlxuICogICAgIEFsbCBjb21waWxlciBhcGlzIGFyZSBjdXJyZW50bHkgY29uc2lkZXJlZCBleHBlcmltZW50YWwgYW5kIHByaXZhdGUhXG4gKiAgIDwvcD5cbiAqICAgPHA+XG4gKiAgICAgV2UgZXhwZWN0IHRoZSBBUElzIGluIHRoaXMgcGFja2FnZSB0byBrZWVwIG9uIGNoYW5naW5nLiBEbyBub3QgcmVseSBvbiB0aGVtLlxuICogICA8L3A+XG4gKiA8L2Rpdj5cbiAqL1xuLy8gVGhpcyBmaWxlIG9ubHkgcmVleHBvcnRzIGNvbnRlbnQgb2YgdGhlIGBzcmNgIGZvbGRlci4gS2VlcCBpdCB0aGF0IHdheS5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQG1vZHVsZVxuICogQGRlc2NyaXB0aW9uXG4gKiBFbnRyeSBwb2ludCBmb3IgYWxsIHB1YmxpYyBBUElzIG9mIHRoZSBjb21waWxlciBwYWNrYWdlLlxuICovXG4vLyBUaGlzIGZpbGUgb25seSByZWV4cG9ydHMgY29udGVudCBvZiB0aGUgYHNyY2AgZm9sZGVyLiBLZWVwIGl0IHRoYXQgd2F5LlxuZXhwb3J0IHsgVkVSU0lPTiwgVEVNUExBVEVfVFJBTlNGT1JNUywgQ29tcGlsZXJDb25maWcsIEppdENvbXBpbGVyLCBEaXJlY3RpdmVSZXNvbHZlciwgUGlwZVJlc29sdmVyLCBOZ01vZHVsZVJlc29sdmVyLCBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHLCBJbnRlcnBvbGF0aW9uQ29uZmlnLCBOZ01vZHVsZUNvbXBpbGVyLCBBc3NlcnROb3ROdWxsLCBCaW5hcnlPcGVyYXRvciwgQmluYXJ5T3BlcmF0b3JFeHByLCBCdWlsdGluTWV0aG9kLCBCdWlsdGluVmFyLCBDYXN0RXhwciwgQ2xhc3NTdG10LCBDb21tYUV4cHIsIENvbW1lbnRTdG10LCBDb25kaXRpb25hbEV4cHIsIERlY2xhcmVGdW5jdGlvblN0bXQsIERlY2xhcmVWYXJTdG10LCBFeHByZXNzaW9uU3RhdGVtZW50LCBFeHRlcm5hbEV4cHIsIEV4dGVybmFsUmVmZXJlbmNlLCBGdW5jdGlvbkV4cHIsIElmU3RtdCwgSW5zdGFudGlhdGVFeHByLCBJbnZva2VGdW5jdGlvbkV4cHIsIEludm9rZU1ldGhvZEV4cHIsIExpdGVyYWxBcnJheUV4cHIsIExpdGVyYWxFeHByLCBMaXRlcmFsTWFwRXhwciwgTm90RXhwciwgUmVhZEtleUV4cHIsIFJlYWRQcm9wRXhwciwgUmVhZFZhckV4cHIsIFJldHVyblN0YXRlbWVudCwgVGhyb3dTdG10LCBUcnlDYXRjaFN0bXQsIFdyaXRlS2V5RXhwciwgV3JpdGVQcm9wRXhwciwgV3JpdGVWYXJFeHByLCBTdG10TW9kaWZpZXIsIFN0YXRlbWVudCwgRW1pdHRlclZpc2l0b3JDb250ZXh0LCBWaWV3Q29tcGlsZXIsIGdldFBhcnNlRXJyb3JzLCBpc1N5bnRheEVycm9yLCBzeW50YXhFcnJvciwgVGV4dEFzdCwgQm91bmRUZXh0QXN0LCBBdHRyQXN0LCBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdCwgQm91bmRFdmVudEFzdCwgUmVmZXJlbmNlQXN0LCBWYXJpYWJsZUFzdCwgRWxlbWVudEFzdCwgRW1iZWRkZWRUZW1wbGF0ZUFzdCwgQm91bmREaXJlY3RpdmVQcm9wZXJ0eUFzdCwgRGlyZWN0aXZlQXN0LCBQcm92aWRlckFzdCwgUHJvdmlkZXJBc3RUeXBlLCBOZ0NvbnRlbnRBc3QsIFByb3BlcnR5QmluZGluZ1R5cGUsIE51bGxUZW1wbGF0ZVZpc2l0b3IsIFJlY3Vyc2l2ZVRlbXBsYXRlQXN0VmlzaXRvciwgdGVtcGxhdGVWaXNpdEFsbCwgQ29tcGlsZUFuaW1hdGlvbkVudHJ5TWV0YWRhdGEsIENvbXBpbGVBbmltYXRpb25TdGF0ZU1ldGFkYXRhLCBDb21waWxlQW5pbWF0aW9uU3RhdGVEZWNsYXJhdGlvbk1ldGFkYXRhLCBDb21waWxlQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uTWV0YWRhdGEsIENvbXBpbGVBbmltYXRpb25NZXRhZGF0YSwgQ29tcGlsZUFuaW1hdGlvbktleWZyYW1lc1NlcXVlbmNlTWV0YWRhdGEsIENvbXBpbGVBbmltYXRpb25TdHlsZU1ldGFkYXRhLCBDb21waWxlQW5pbWF0aW9uQW5pbWF0ZU1ldGFkYXRhLCBDb21waWxlQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGEsIENvbXBpbGVBbmltYXRpb25TZXF1ZW5jZU1ldGFkYXRhLCBDb21waWxlQW5pbWF0aW9uR3JvdXBNZXRhZGF0YSwgaWRlbnRpZmllck5hbWUsIGlkZW50aWZpZXJNb2R1bGVVcmwsIHZpZXdDbGFzc05hbWUsIHJlbmRlcmVyVHlwZU5hbWUsIGhvc3RWaWV3Q2xhc3NOYW1lLCBjb21wb25lbnRGYWN0b3J5TmFtZSwgQ29tcGlsZVN1bW1hcnlLaW5kLCB0b2tlbk5hbWUsIHRva2VuUmVmZXJlbmNlLCBDb21waWxlU3R5bGVzaGVldE1ldGFkYXRhLCBDb21waWxlVGVtcGxhdGVNZXRhZGF0YSwgQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhLCBjcmVhdGVIb3N0Q29tcG9uZW50TWV0YSwgQ29tcGlsZVBpcGVNZXRhZGF0YSwgQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEsIFRyYW5zaXRpdmVDb21waWxlTmdNb2R1bGVNZXRhZGF0YSwgUHJvdmlkZXJNZXRhLCBmbGF0dGVuLCBzb3VyY2VVcmwsIHRlbXBsYXRlU291cmNlVXJsLCBzaGFyZWRTdHlsZXNoZWV0Sml0VXJsLCBuZ01vZHVsZUppdFVybCwgdGVtcGxhdGVKaXRVcmwsIGNyZWF0ZUFvdENvbXBpbGVyLCBBb3RDb21waWxlciwgYW5hbHl6ZU5nTW9kdWxlcywgYW5hbHl6ZUFuZFZhbGlkYXRlTmdNb2R1bGVzLCBleHRyYWN0UHJvZ3JhbVN5bWJvbHMsIEdlbmVyYXRlZEZpbGUsIHRvVHlwZVNjcmlwdCwgU3RhdGljUmVmbGVjdG9yLCBTdGF0aWNTeW1ib2wsIFN0YXRpY1N5bWJvbENhY2hlLCBSZXNvbHZlZFN0YXRpY1N5bWJvbCwgU3RhdGljU3ltYm9sUmVzb2x2ZXIsIHVuZXNjYXBlSWRlbnRpZmllciwgQW90U3VtbWFyeVJlc29sdmVyLCBBc3RQYXRoLCBTdW1tYXJ5UmVzb2x2ZXIsIEppdFN1bW1hcnlSZXNvbHZlciwgQ09NUElMRVJfUFJPVklERVJTLCBKaXRDb21waWxlckZhY3RvcnksIHBsYXRmb3JtQ29yZUR5bmFtaWMsIEppdFJlZmxlY3RvciwgQ29tcGlsZVJlZmxlY3RvciwgY3JlYXRlVXJsUmVzb2x2ZXJXaXRob3V0UGFja2FnZVByZWZpeCwgY3JlYXRlT2ZmbGluZUNvbXBpbGVVcmxSZXNvbHZlciwgREVGQVVMVF9QQUNLQUdFX1VSTF9QUk9WSURFUiwgVXJsUmVzb2x2ZXIsIGdldFVybFNjaGVtZSwgUmVzb3VyY2VMb2FkZXIsIEVsZW1lbnRTY2hlbWFSZWdpc3RyeSwgRXh0cmFjdG9yLCBJMThOSHRtbFBhcnNlciwgTWVzc2FnZUJ1bmRsZSwgU2VyaWFsaXplciwgWGxpZmYsIFhsaWZmMiwgWG1iLCBYdGIsIERpcmVjdGl2ZU5vcm1hbGl6ZXIsIFBhcnNlckVycm9yLCBQYXJzZVNwYW4sIEFTVCwgUXVvdGUsIEVtcHR5RXhwciwgSW1wbGljaXRSZWNlaXZlciwgQ2hhaW4sIENvbmRpdGlvbmFsLCBQcm9wZXJ0eVJlYWQsIFByb3BlcnR5V3JpdGUsIFNhZmVQcm9wZXJ0eVJlYWQsIEtleWVkUmVhZCwgS2V5ZWRXcml0ZSwgQmluZGluZ1BpcGUsIExpdGVyYWxQcmltaXRpdmUsIExpdGVyYWxBcnJheSwgTGl0ZXJhbE1hcCwgSW50ZXJwb2xhdGlvbiwgQmluYXJ5LCBQcmVmaXhOb3QsIE5vbk51bGxBc3NlcnQsIE1ldGhvZENhbGwsIFNhZmVNZXRob2RDYWxsLCBGdW5jdGlvbkNhbGwsIEFTVFdpdGhTb3VyY2UsIFRlbXBsYXRlQmluZGluZywgTnVsbEFzdFZpc2l0b3IsIFJlY3Vyc2l2ZUFzdFZpc2l0b3IsIEFzdFRyYW5zZm9ybWVyLCB2aXNpdEFzdENoaWxkcmVuLCBUb2tlblR5cGUsIExleGVyLCBUb2tlbiwgRU9GLCBpc0lkZW50aWZpZXIsIGlzUXVvdGUsIFNwbGl0SW50ZXJwb2xhdGlvbiwgVGVtcGxhdGVCaW5kaW5nUGFyc2VSZXN1bHQsIFBhcnNlciwgX1BhcnNlQVNULCBFUlJPUl9DT0xMRUNUT1JfVE9LRU4sIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLCBUZXh0LCBFeHBhbnNpb24sIEV4cGFuc2lvbkNhc2UsIEF0dHJpYnV0ZSQxIGFzIEF0dHJpYnV0ZSwgRWxlbWVudCwgQ29tbWVudCwgdmlzaXRBbGwsIFJlY3Vyc2l2ZVZpc2l0b3IsIGZpbmROb2RlLCBQYXJzZVRyZWVSZXN1bHQsIFRyZWVFcnJvciwgSHRtbFBhcnNlciwgSHRtbFRhZ0RlZmluaXRpb24sIGdldEh0bWxUYWdEZWZpbml0aW9uLCBUYWdDb250ZW50VHlwZSwgc3BsaXROc05hbWUsIGlzTmdDb250YWluZXIsIGlzTmdDb250ZW50LCBpc05nVGVtcGxhdGUsIGdldE5zUHJlZml4LCBtZXJnZU5zQW5kTmFtZSwgTkFNRURfRU5USVRJRVMsIGRlYnVnT3V0cHV0QXN0QXNUeXBlU2NyaXB0LCBUeXBlU2NyaXB0RW1pdHRlciwgUGFyc2VMb2NhdGlvbiwgUGFyc2VTb3VyY2VGaWxlLCBQYXJzZVNvdXJjZVNwYW4sIFBhcnNlRXJyb3JMZXZlbCwgUGFyc2VFcnJvciwgdHlwZVNvdXJjZVNwYW4sIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeSwgQ3NzU2VsZWN0b3IsIFNlbGVjdG9yTWF0Y2hlciwgU2VsZWN0b3JMaXN0Q29udGV4dCwgU2VsZWN0b3JDb250ZXh0LCBTdHlsZXNDb21waWxlRGVwZW5kZW5jeSwgQ29tcGlsZWRTdHlsZXNoZWV0LCBTdHlsZUNvbXBpbGVyLCBUZW1wbGF0ZVBhcnNlRXJyb3IsIFRlbXBsYXRlUGFyc2VSZXN1bHQsIFRlbXBsYXRlUGFyc2VyLCBzcGxpdENsYXNzZXMsIGNyZWF0ZUVsZW1lbnRDc3NTZWxlY3RvciwgcmVtb3ZlU3VtbWFyeUR1cGxpY2F0ZXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBpbGVyLmpzLm1hcFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcGlsZXIuZXM1LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbXBpbGVyL0Bhbmd1bGFyL2NvbXBpbGVyLmVzNS5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsImltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XG4vKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXIgdjQuMy4zXG4gKiAoYykgMjAxMC0yMDE3IEdvb2dsZSwgSW5jLiBodHRwczovL2FuZ3VsYXIuaW8vXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuaW1wb3J0IHsgUmVzb3VyY2VMb2FkZXIsIHBsYXRmb3JtQ29yZUR5bmFtaWMgfSBmcm9tICdAYW5ndWxhci9jb21waWxlcic7XG5pbXBvcnQgeyBDT01QSUxFUl9PUFRJT05TLCBJbmplY3RhYmxlLCBQTEFURk9STV9JRCwgVmVyc2lvbiwgY3JlYXRlUGxhdGZvcm1GYWN0b3J5LCDJtWdsb2JhbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgybVQTEFURk9STV9CUk9XU0VSX0lEIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IMm1SU5URVJOQUxfQlJPV1NFUl9QTEFURk9STV9QUk9WSURFUlMgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBSZXNvdXJjZUxvYWRlckltcGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFJlc291cmNlTG9hZGVySW1wbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZXNvdXJjZUxvYWRlckltcGwoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgUmVzb3VyY2VMb2FkZXJJbXBsLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHZhciByZXNvbHZlO1xuICAgICAgICB2YXIgcmVqZWN0O1xuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXMsIHJlaikge1xuICAgICAgICAgICAgcmVzb2x2ZSA9IHJlcztcbiAgICAgICAgICAgIHJlamVjdCA9IHJlajtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAndGV4dCc7XG4gICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyByZXNwb25zZVRleHQgaXMgdGhlIG9sZC1zY2hvb2wgd2F5IG9mIHJldHJpZXZpbmcgcmVzcG9uc2UgKHN1cHBvcnRlZCBieSBJRTggJiA5KVxuICAgICAgICAgICAgLy8gcmVzcG9uc2UvcmVzcG9uc2VUeXBlIHByb3BlcnRpZXMgd2VyZSBpbnRyb2R1Y2VkIGluIFJlc291cmNlTG9hZGVyIExldmVsMiBzcGVjIChzdXBwb3J0ZWRcbiAgICAgICAgICAgIC8vIGJ5IElFMTApXG4gICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSB4aHIucmVzcG9uc2UgfHwgeGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSBJRTkgYnVnIChodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xNDUwKVxuICAgICAgICAgICAgdmFyIHN0YXR1cyA9IHhoci5zdGF0dXMgPT09IDEyMjMgPyAyMDQgOiB4aHIuc3RhdHVzO1xuICAgICAgICAgICAgLy8gZml4IHN0YXR1cyBjb2RlIHdoZW4gaXQgaXMgMCAoMCBzdGF0dXMgaXMgdW5kb2N1bWVudGVkKS5cbiAgICAgICAgICAgIC8vIE9jY3VycyB3aGVuIGFjY2Vzc2luZyBmaWxlIHJlc291cmNlcyBvciBvbiBBbmRyb2lkIDQuMSBzdG9jayBicm93c2VyXG4gICAgICAgICAgICAvLyB3aGlsZSByZXRyaWV2aW5nIGZpbGVzIGZyb20gYXBwbGljYXRpb24gY2FjaGUuXG4gICAgICAgICAgICBpZiAoc3RhdHVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gcmVzcG9uc2UgPyAyMDAgOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKDIwMCA8PSBzdGF0dXMgJiYgc3RhdHVzIDw9IDMwMCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KFwiRmFpbGVkIHRvIGxvYWQgXCIgKyB1cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uICgpIHsgcmVqZWN0KFwiRmFpbGVkIHRvIGxvYWQgXCIgKyB1cmwpOyB9O1xuICAgICAgICB4aHIuc2VuZCgpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuICAgIHJldHVybiBSZXNvdXJjZUxvYWRlckltcGw7XG59KFJlc291cmNlTG9hZGVyKSk7XG5SZXNvdXJjZUxvYWRlckltcGwuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblJlc291cmNlTG9hZGVySW1wbC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIElOVEVSTkFMX0JST1dTRVJfRFlOQU1JQ19QTEFURk9STV9QUk9WSURFUlMgPSBbXG4gICAgybVJTlRFUk5BTF9CUk9XU0VSX1BMQVRGT1JNX1BST1ZJREVSUyxcbiAgICB7XG4gICAgICAgIHByb3ZpZGU6IENPTVBJTEVSX09QVElPTlMsXG4gICAgICAgIHVzZVZhbHVlOiB7IHByb3ZpZGVyczogW3sgcHJvdmlkZTogUmVzb3VyY2VMb2FkZXIsIHVzZUNsYXNzOiBSZXNvdXJjZUxvYWRlckltcGwgfV0gfSxcbiAgICAgICAgbXVsdGk6IHRydWVcbiAgICB9LFxuICAgIHsgcHJvdmlkZTogUExBVEZPUk1fSUQsIHVzZVZhbHVlOiDJtVBMQVRGT1JNX0JST1dTRVJfSUQgfSxcbl07XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIFJlc291cmNlTG9hZGVyIHRoYXQgdXNlcyBhIHRlbXBsYXRlIGNhY2hlIHRvIGF2b2lkIGRvaW5nIGFuIGFjdHVhbFxuICogUmVzb3VyY2VMb2FkZXIuXG4gKlxuICogVGhlIHRlbXBsYXRlIGNhY2hlIG5lZWRzIHRvIGJlIGJ1aWx0IGFuZCBsb2FkZWQgaW50byB3aW5kb3cuJHRlbXBsYXRlQ2FjaGVcbiAqIHZpYSBhIHNlcGFyYXRlIG1lY2hhbmlzbS5cbiAqL1xudmFyIENhY2hlZFJlc291cmNlTG9hZGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhDYWNoZWRSZXNvdXJjZUxvYWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYWNoZWRSZXNvdXJjZUxvYWRlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2NhY2hlID0gybVnbG9iYWwuJHRlbXBsYXRlQ2FjaGU7XG4gICAgICAgIGlmIChfdGhpcy5fY2FjaGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWNoZWRSZXNvdXJjZUxvYWRlcjogVGVtcGxhdGUgY2FjaGUgd2FzIG5vdCBmb3VuZCBpbiAkdGVtcGxhdGVDYWNoZS4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENhY2hlZFJlc291cmNlTG9hZGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWNoZS5oYXNPd25Qcm9wZXJ0eSh1cmwpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2NhY2hlW3VybF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYWNoZWRSZXNvdXJjZUxvYWRlcjogRGlkIG5vdCBmaW5kIGNhY2hlZCB0ZW1wbGF0ZSBmb3IgJyArIHVybCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDYWNoZWRSZXNvdXJjZUxvYWRlcjtcbn0oUmVzb3VyY2VMb2FkZXIpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQG1vZHVsZVxuICogQGRlc2NyaXB0aW9uXG4gKiBFbnRyeSBwb2ludCBmb3IgYWxsIHB1YmxpYyBBUElzIG9mIHRoZSBjb21tb24gcGFja2FnZS5cbiAqL1xuLyoqXG4gKiBAc3RhYmxlXG4gKi9cbnZhciBWRVJTSU9OID0gbmV3IFZlcnNpb24oJzQuMy4zJyk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEBleHBlcmltZW50YWxcbiAqL1xudmFyIFJFU09VUkNFX0NBQ0hFX1BST1ZJREVSID0gW3sgcHJvdmlkZTogUmVzb3VyY2VMb2FkZXIsIHVzZUNsYXNzOiBDYWNoZWRSZXNvdXJjZUxvYWRlciB9XTtcbi8qKlxuICogQHN0YWJsZVxuICovXG52YXIgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyA9IGNyZWF0ZVBsYXRmb3JtRmFjdG9yeShwbGF0Zm9ybUNvcmVEeW5hbWljLCAnYnJvd3NlckR5bmFtaWMnLCBJTlRFUk5BTF9CUk9XU0VSX0RZTkFNSUNfUExBVEZPUk1fUFJPVklERVJTKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQG1vZHVsZVxuICogQGRlc2NyaXB0aW9uXG4gKiBFbnRyeSBwb2ludCBmb3IgYWxsIHB1YmxpYyBBUElzIG9mIHRoZSBwbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMgcGFja2FnZS5cbiAqL1xuLy8gVGhpcyBmaWxlIG9ubHkgcmVleHBvcnRzIGNvbnRlbnQgb2YgdGhlIGBzcmNgIGZvbGRlci4gS2VlcCBpdCB0aGF0IHdheS5cbmV4cG9ydCB7IFJFU09VUkNFX0NBQ0hFX1BST1ZJREVSLCBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljLCBWRVJTSU9OLCBJTlRFUk5BTF9CUk9XU0VSX0RZTkFNSUNfUExBVEZPUk1fUFJPVklERVJTIGFzIMm1SU5URVJOQUxfQlJPV1NFUl9EWU5BTUlDX1BMQVRGT1JNX1BST1ZJREVSUywgUmVzb3VyY2VMb2FkZXJJbXBsIGFzIMm1UmVzb3VyY2VMb2FkZXJJbXBsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMuZXM1LmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljL0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYy5lczUuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiXSwibWFwcGluZ3MiOiI7OztBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwLzFCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///132\n");

/***/ }),

/***/ 153:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar core_1 = __webpack_require__(9);\r\nvar platform_browser_1 = __webpack_require__(65);\r\nvar app_component_1 = __webpack_require__(154);\r\nvar index_1 = __webpack_require__(156);\r\nvar index_2 = __webpack_require__(157);\r\nvar index_3 = __webpack_require__(158);\r\nvar AppModule = (function () {\r\n    function AppModule() {\r\n    }\r\n    AppModule = __decorate([\r\n        core_1.NgModule({\r\n            imports: [platform_browser_1.BrowserModule],\r\n            declarations: [\r\n                app_component_1.AppComponent,\r\n                index_1.StartPageComponent,\r\n                index_2.HeaderComponent,\r\n                index_3.FooterComponent\r\n            ],\r\n            bootstrap: [\r\n                app_component_1.AppComponent\r\n            ]\r\n        })\r\n    ], AppModule);\r\n    return AppModule;\r\n}());\r\nexports.AppModule = AppModule;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9hcHAubW9kdWxlLnRzPzlhOGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmdNb2R1bGUgfSAgICAgIGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQnJvd3Nlck1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xuaW1wb3J0IHsgQXBwQ29tcG9uZW50IH0gIGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTdGFydFBhZ2VDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvc3RhcnRwYWdlL2luZGV4JztcbmltcG9ydCB7IEhlYWRlckNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9oZWFkZXIvaW5kZXgnO1xuaW1wb3J0IHsgRm9vdGVyQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL2Zvb3Rlci9pbmRleCc7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6ICAgICAgWyBCcm93c2VyTW9kdWxlIF0sXG4gIGRlY2xhcmF0aW9uczogW1xuICAgICAgQXBwQ29tcG9uZW50LFxuICAgICAgU3RhcnRQYWdlQ29tcG9uZW50LFxuICAgICAgSGVhZGVyQ29tcG9uZW50LFxuICAgICAgRm9vdGVyQ29tcG9uZW50XG5cbiAgXSxcbiAgYm9vdHN0cmFwOiBbXG4gICAgICBBcHBDb21wb25lbnRcbiAgXVxufSlcblxuZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7IH1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBub2RlX21vZHVsZXMvYW5ndWxhci1yb3V0ZXItbG9hZGVyL3NyYyEuL25vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC1sb2FkZXIhLi9ub2RlX21vZHVsZXMvdHNsaW50LWxvYWRlciEuL3NyYy9hcHAvYXBwLm1vZHVsZS50cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFnQkE7QUFBQTtBQUFBO0FBQUE7QUFkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///153\n");

/***/ }),

/***/ 154:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar core_1 = __webpack_require__(9);\r\nvar app_service_1 = __webpack_require__(155);\r\n//this metadata of angular which template to used \r\nvar AppComponent = (function () {\r\n    function AppComponent($appService) {\r\n        this.$appService = $appService;\r\n        this.name = 'Angular';\r\n        this.getName();\r\n    }\r\n    AppComponent.prototype.getName = function () {\r\n        this.name = this.$appService.getName();\r\n    };\r\n    AppComponent = __decorate([\r\n        core_1.Component({\r\n            selector: 'vizob-app',\r\n            template: \"\\n            <vizob-header></vizob-header>\\n            <div>This is root page {{name}}</div>\\n            <vizob-footer></vizob-footer>\\n\",\r\n            providers: [app_service_1.AppService]\r\n        }),\r\n        __metadata(\"design:paramtypes\", [app_service_1.AppService])\r\n    ], AppComponent);\r\n    return AppComponent;\r\n}());\r\nexports.AppComponent = AppComponent;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9hcHAuY29tcG9uZW50LnRzP2QyMDUiXSwic291cmNlc0NvbnRlbnQiOlsiXHJcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBBcHBTZXJ2aWNlIH0gZnJvbSAnLi9zZXJ2aWNlcy9hcHAuc2VydmljZSc7XHJcbi8vdGhpcyBtZXRhZGF0YSBvZiBhbmd1bGFyIHdoaWNoIHRlbXBsYXRlIHRvIHVzZWQgXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICd2aXpvYi1hcHAnLFxyXG4gICAgdGVtcGxhdGU6IGBcclxuICAgICAgICAgICAgPHZpem9iLWhlYWRlcj48L3Zpem9iLWhlYWRlcj5cclxuICAgICAgICAgICAgPGRpdj5UaGlzIGlzIHJvb3QgcGFnZSB7e25hbWV9fTwvZGl2PlxyXG4gICAgICAgICAgICA8dml6b2ItZm9vdGVyPjwvdml6b2ItZm9vdGVyPlxyXG5gLFxyXG4gICAgcHJvdmlkZXJzOiBbQXBwU2VydmljZV1cclxufSlcclxuZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XHJcbiAgICBuYW1lID0gJ0FuZ3VsYXInO1xyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSAkYXBwU2VydmljZTogQXBwU2VydmljZSkge1xyXG4gICAgICAgIHRoaXMuZ2V0TmFtZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldE5hbWUoKSB7XHJcbiAgICAgICB0aGlzLm5hbWUgPSB0aGlzLiRhcHBTZXJ2aWNlLmdldE5hbWUoKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL2FuZ3VsYXItcm91dGVyLWxvYWRlci9zcmMhLi9ub2RlX21vZHVsZXMvYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAtbG9hZGVyIS4vbm9kZV9tb2R1bGVzL3RzbGludC1sb2FkZXIhLi9zcmMvYXBwL2FwcC5jb21wb25lbnQudHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBVUE7QUFFQTtBQUFBO0FBREE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBUkE7QUFUQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBR0E7QUFGQTtBQVNBO0FBQUE7QUFUQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///154\n");

/***/ }),

/***/ 155:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar AppService = (function () {\r\n    function AppService() {\r\n    }\r\n    AppService.prototype.getName = function () {\r\n        return 'EPiserver Name';\r\n    };\r\n    return AppService;\r\n}());\r\nexports.AppService = AppService;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9zZXJ2aWNlcy9hcHAuc2VydmljZS50cz9hMWUyIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjbGFzcyBBcHBTZXJ2aWNlIHtcclxuICAgIGdldE5hbWUoKXtcclxuICAgICByZXR1cm4gJ0VQaXNlcnZlciBOYW1lJ1xyXG4gICAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9hbmd1bGFyLXJvdXRlci1sb2FkZXIvc3JjIS4vbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwLWxvYWRlciEuL25vZGVfbW9kdWxlcy90c2xpbnQtbG9hZGVyIS4vc3JjL2FwcC9zZXJ2aWNlcy9hcHAuc2VydmljZS50cyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUFBO0FBSUE7QUFIQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBSkE7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///155\n");

/***/ }),

/***/ 156:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar core_1 = __webpack_require__(9);\r\nvar StartPageComponent = (function () {\r\n    function StartPageComponent() {\r\n        this.name = 'Angular';\r\n        this.getName();\r\n    }\r\n    StartPageComponent.prototype.getName = function () {\r\n        this.name = 'Start page component';\r\n    };\r\n    StartPageComponent = __decorate([\r\n        core_1.Component({\r\n            selector: 'start-page',\r\n            template: \"\\n        <div>Start Page {{name}}</div>\\n    \"\r\n        }),\r\n        __metadata(\"design:paramtypes\", [])\r\n    ], StartPageComponent);\r\n    return StartPageComponent;\r\n}());\r\nexports.StartPageComponent = StartPageComponent;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9jb21wb25lbnRzL3N0YXJ0cGFnZS9pbmRleC50cz83MWJjIl0sInNvdXJjZXNDb250ZW50IjpbIlxyXG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcblxyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAnc3RhcnQtcGFnZScsXHJcbiAgICB0ZW1wbGF0ZTogYFxyXG4gICAgICAgIDxkaXY+U3RhcnQgUGFnZSB7e25hbWV9fTwvZGl2PlxyXG4gICAgYFxyXG59KVxyXG5leHBvcnQgY2xhc3MgU3RhcnRQYWdlQ29tcG9uZW50IHtcclxuICAgIG5hbWUgPSAnQW5ndWxhcic7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmdldE5hbWUoKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXROYW1lKCkge1xyXG4gICAgICAgIHRoaXMubmFtZSA9ICdTdGFydCBwYWdlIGNvbXBvbmVudCc7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9hbmd1bGFyLXJvdXRlci1sb2FkZXIvc3JjIS4vbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwLWxvYWRlciEuL25vZGVfbW9kdWxlcy90c2xpbnQtbG9hZGVyIS4vc3JjL2FwcC9jb21wb25lbnRzL3N0YXJ0cGFnZS9pbmRleC50cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFDQTtBQVNBO0FBRUE7QUFEQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFSQTtBQU5BO0FBQ0E7QUFDQTtBQUdBOztBQUNBO0FBU0E7QUFBQTtBQVRBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///156\n");

/***/ }),

/***/ 157:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar core_1 = __webpack_require__(9);\r\nvar HeaderComponent = (function () {\r\n    function HeaderComponent() {\r\n        this.name = 'Angular';\r\n        this.getName();\r\n    }\r\n    HeaderComponent.prototype.getName = function () {\r\n        this.name = 'Header';\r\n    };\r\n    HeaderComponent = __decorate([\r\n        core_1.Component({\r\n            selector: 'vizob-header',\r\n            template: \"\\n        <div>This is {{name}}</div>\\n    \"\r\n        }),\r\n        __metadata(\"design:paramtypes\", [])\r\n    ], HeaderComponent);\r\n    return HeaderComponent;\r\n}());\r\nexports.HeaderComponent = HeaderComponent;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9jb21wb25lbnRzL2hlYWRlci9pbmRleC50cz8xNTQ0Il0sInNvdXJjZXNDb250ZW50IjpbIlxyXG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcblxyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAndml6b2ItaGVhZGVyJyxcclxuICAgIHRlbXBsYXRlOiBgXHJcbiAgICAgICAgPGRpdj5UaGlzIGlzIHt7bmFtZX19PC9kaXY+XHJcbiAgICBgXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBIZWFkZXJDb21wb25lbnQge1xyXG4gICAgbmFtZSA9ICdBbmd1bGFyJztcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuZ2V0TmFtZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldE5hbWUoKSB7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJ0hlYWRlcic7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9hbmd1bGFyLXJvdXRlci1sb2FkZXIvc3JjIS4vbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwLWxvYWRlciEuL25vZGVfbW9kdWxlcy90c2xpbnQtbG9hZGVyIS4vc3JjL2FwcC9jb21wb25lbnRzL2hlYWRlci9pbmRleC50cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFDQTtBQVNBO0FBRUE7QUFEQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFSQTtBQU5BO0FBQ0E7QUFDQTtBQUdBOztBQUNBO0FBU0E7QUFBQTtBQVRBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///157\n");

/***/ }),

/***/ 158:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar core_1 = __webpack_require__(9);\r\nvar FooterComponent = (function () {\r\n    function FooterComponent() {\r\n        this.name = 'Angular';\r\n        this.getName();\r\n    }\r\n    FooterComponent.prototype.getName = function () {\r\n        this.name = 'Footer';\r\n    };\r\n    FooterComponent = __decorate([\r\n        core_1.Component({\r\n            selector: 'vizob-footer',\r\n            template: \"\\n            <div>This is {{name}}</div>\\n\"\r\n        }),\r\n        __metadata(\"design:paramtypes\", [])\r\n    ], FooterComponent);\r\n    return FooterComponent;\r\n}());\r\nexports.FooterComponent = FooterComponent;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9jb21wb25lbnRzL2Zvb3Rlci9pbmRleC50cz8zMGFmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ3Zpem9iLWZvb3RlcicsXHJcbiAgICB0ZW1wbGF0ZTogYFxyXG4gICAgICAgICAgICA8ZGl2PlRoaXMgaXMge3tuYW1lfX08L2Rpdj5cclxuYFxyXG59KVxyXG5leHBvcnQgY2xhc3MgRm9vdGVyQ29tcG9uZW50IHtcclxuICAgIG5hbWUgPSAnQW5ndWxhcic7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmdldE5hbWUoKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXROYW1lKCkge1xyXG4gICAgICAgIHRoaXMubmFtZSA9ICdGb290ZXInO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBub2RlX21vZHVsZXMvYW5ndWxhci1yb3V0ZXItbG9hZGVyL3NyYyEuL25vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC1sb2FkZXIhLi9ub2RlX21vZHVsZXMvdHNsaW50LWxvYWRlciEuL3NyYy9hcHAvY29tcG9uZW50cy9mb290ZXIvaW5kZXgudHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFRQTtBQUVBO0FBREE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBUkE7QUFOQTtBQUNBO0FBQ0E7QUFHQTs7QUFDQTtBQVNBO0FBQUE7QUFUQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///158\n");

/***/ })

},[131]);